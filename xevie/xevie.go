// Package xevie is the X client API for the XEVIE extension.
package xevie

/*
	This file was generated by xevie.xml on May 10 2012 8:04:32pm EDT.
	This file is automatically generated. Edit at your peril!
*/

import (
	"github.com/BurntSushi/xgb"

	"github.com/BurntSushi/xgb/xproto"
)

// Init must be called before using the XEVIE extension.
func Init(c *xgb.Conn) error {
	reply, err := xproto.QueryExtension(c, 5, "XEVIE").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return xgb.Errorf("No extension named XEVIE could be found on on the server.")
	}

	xgb.ExtLock.Lock()
	c.Extensions["XEVIE"] = reply.MajorOpcode
	for evNum, fun := range xgb.NewExtEventFuncs["XEVIE"] {
		xgb.NewEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range xgb.NewExtErrorFuncs["XEVIE"] {
		xgb.NewErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	xgb.ExtLock.Unlock()

	return nil
}

func init() {
	xgb.NewExtEventFuncs["XEVIE"] = make(map[int]xgb.NewEventFun)
	xgb.NewExtErrorFuncs["XEVIE"] = make(map[int]xgb.NewErrorFun)
}

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Float'

const (
	DatatypeUnmodified = 0
	DatatypeModified   = 1
)

// 'Event' struct definition
// Size: 32
type Event struct {
	// padding: 32 bytes
}

// Struct read Event
func EventRead(buf []byte, v *Event) int {
	b := 0

	b += 32 // padding

	return b
}

// Struct list read Event
func EventReadList(buf []byte, dest []Event) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Event{}
		b += EventRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Event
func (v Event) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	b += 32 // padding

	return buf
}

// Write struct list Event
func EventListBytes(buf []byte, list []Event) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Request QueryVersion
// size: 8
type QueryVersionCookie struct {
	*xgb.Cookie
}

func QueryVersion(c *xgb.Conn, ClientMajorVersion uint16, ClientMinorVersion uint16) QueryVersionCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryVersionRequest(c, ClientMajorVersion, ClientMinorVersion), cookie)
	return QueryVersionCookie{cookie}
}

func QueryVersionUnchecked(c *xgb.Conn, ClientMajorVersion uint16, ClientMinorVersion uint16) QueryVersionCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryVersionRequest(c, ClientMajorVersion, ClientMinorVersion), cookie)
	return QueryVersionCookie{cookie}
}

// Request reply for QueryVersion
// size: 32
type QueryVersionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ServerMajorVersion uint16
	ServerMinorVersion uint16
	// padding: 20 bytes
}

// Waits and reads reply data from request QueryVersion
func (cook QueryVersionCookie) Reply() (*QueryVersionReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryVersionReply(buf), nil
}

// Read reply into structure from buffer for QueryVersion
func queryVersionReply(buf []byte) *QueryVersionReply {
	v := new(QueryVersionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ServerMajorVersion = xgb.Get16(buf[b:])
	b += 2

	v.ServerMinorVersion = xgb.Get16(buf[b:])
	b += 2

	b += 20 // padding

	return v
}

// Write request to wire for QueryVersion
func queryVersionRequest(c *xgb.Conn, ClientMajorVersion uint16, ClientMinorVersion uint16) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XEVIE"]
	b += 1

	buf[b] = 0 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], ClientMajorVersion)
	b += 2

	xgb.Put16(buf[b:], ClientMinorVersion)
	b += 2

	return buf
}

// Request Start
// size: 8
type StartCookie struct {
	*xgb.Cookie
}

func Start(c *xgb.Conn, Screen uint32) StartCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(startRequest(c, Screen), cookie)
	return StartCookie{cookie}
}

func StartUnchecked(c *xgb.Conn, Screen uint32) StartCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(startRequest(c, Screen), cookie)
	return StartCookie{cookie}
}

// Request reply for Start
// size: 32
type StartReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
}

// Waits and reads reply data from request Start
func (cook StartCookie) Reply() (*StartReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return startReply(buf), nil
}

// Read reply into structure from buffer for Start
func startReply(buf []byte) *StartReply {
	v := new(StartReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	return v
}

// Write request to wire for Start
func startRequest(c *xgb.Conn, Screen uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XEVIE"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	return buf
}

// Request End
// size: 8
type EndCookie struct {
	*xgb.Cookie
}

func End(c *xgb.Conn, Cmap uint32) EndCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(endRequest(c, Cmap), cookie)
	return EndCookie{cookie}
}

func EndUnchecked(c *xgb.Conn, Cmap uint32) EndCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(endRequest(c, Cmap), cookie)
	return EndCookie{cookie}
}

// Request reply for End
// size: 32
type EndReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
}

// Waits and reads reply data from request End
func (cook EndCookie) Reply() (*EndReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return endReply(buf), nil
}

// Read reply into structure from buffer for End
func endReply(buf []byte) *EndReply {
	v := new(EndReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	return v
}

// Write request to wire for End
func endRequest(c *xgb.Conn, Cmap uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XEVIE"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Cmap)
	b += 4

	return buf
}

// Request Send
// size: 104
type SendCookie struct {
	*xgb.Cookie
}

func Send(c *xgb.Conn, Event Event, DataType uint32) SendCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(sendRequest(c, Event, DataType), cookie)
	return SendCookie{cookie}
}

func SendUnchecked(c *xgb.Conn, Event Event, DataType uint32) SendCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(sendRequest(c, Event, DataType), cookie)
	return SendCookie{cookie}
}

// Request reply for Send
// size: 32
type SendReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
}

// Waits and reads reply data from request Send
func (cook SendCookie) Reply() (*SendReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return sendReply(buf), nil
}

// Read reply into structure from buffer for Send
func sendReply(buf []byte) *SendReply {
	v := new(SendReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	return v
}

// Write request to wire for Send
func sendRequest(c *xgb.Conn, Event Event, DataType uint32) []byte {
	size := 104
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XEVIE"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	{
		structBytes := Event.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	xgb.Put32(buf[b:], DataType)
	b += 4

	b += 64 // padding

	return buf
}

// Request SelectInput
// size: 8
type SelectInputCookie struct {
	*xgb.Cookie
}

func SelectInput(c *xgb.Conn, EventMask uint32) SelectInputCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(selectInputRequest(c, EventMask), cookie)
	return SelectInputCookie{cookie}
}

func SelectInputUnchecked(c *xgb.Conn, EventMask uint32) SelectInputCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(selectInputRequest(c, EventMask), cookie)
	return SelectInputCookie{cookie}
}

// Request reply for SelectInput
// size: 32
type SelectInputReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
}

// Waits and reads reply data from request SelectInput
func (cook SelectInputCookie) Reply() (*SelectInputReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return selectInputReply(buf), nil
}

// Read reply into structure from buffer for SelectInput
func selectInputReply(buf []byte) *SelectInputReply {
	v := new(SelectInputReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	return v
}

// Write request to wire for SelectInput
func selectInputRequest(c *xgb.Conn, EventMask uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XEVIE"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], EventMask)
	b += 4

	return buf
}
