// Package xv is the X client API for the XVideo extension.
package xv

/*
	This file was generated by xv.xml on May 10 2012 8:04:33pm EDT.
	This file is automatically generated. Edit at your peril!
*/

import (
	"github.com/BurntSushi/xgb"

	"github.com/BurntSushi/xgb/shm"
	"github.com/BurntSushi/xgb/xproto"
)

// Init must be called before using the XVideo extension.
func Init(c *xgb.Conn) error {
	reply, err := xproto.QueryExtension(c, 6, "XVideo").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return xgb.Errorf("No extension named XVideo could be found on on the server.")
	}

	xgb.ExtLock.Lock()
	c.Extensions["XVideo"] = reply.MajorOpcode
	for evNum, fun := range xgb.NewExtEventFuncs["XVideo"] {
		xgb.NewEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range xgb.NewExtErrorFuncs["XVideo"] {
		xgb.NewErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	xgb.ExtLock.Unlock()

	return nil
}

func init() {
	xgb.NewExtEventFuncs["XVideo"] = make(map[int]xgb.NewEventFun)
	xgb.NewExtErrorFuncs["XVideo"] = make(map[int]xgb.NewErrorFun)
}

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

const (
	TypeInputMask  = 1
	TypeOutputMask = 2
	TypeVideoMask  = 4
	TypeStillMask  = 8
	TypeImageMask  = 16
)

const (
	ImageFormatInfoTypeRgb = 0
	ImageFormatInfoTypeYuv = 1
)

const (
	ImageFormatInfoFormatPacked = 0
	ImageFormatInfoFormatPlanar = 1
)

const (
	AttributeFlagGettable = 1
	AttributeFlagSettable = 2
)

const (
	VideoNotifyReasonStarted   = 0
	VideoNotifyReasonStopped   = 1
	VideoNotifyReasonBusy      = 2
	VideoNotifyReasonPreempted = 3
	VideoNotifyReasonHardError = 4
)

const (
	ScanlineOrderTopToBottom = 0
	ScanlineOrderBottomToTop = 1
)

const (
	GrabPortStatusSuccess        = 0
	GrabPortStatusBadExtension   = 1
	GrabPortStatusAlreadyGrabbed = 2
	GrabPortStatusInvalidTime    = 3
	GrabPortStatusBadReply       = 4
	GrabPortStatusBadAlloc       = 5
)

type Port uint32

func NewPortId(c *xgb.Conn) (Port, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Port(id), nil
}

type Encoding uint32

func NewEncodingId(c *xgb.Conn) (Encoding, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Encoding(id), nil
}

// 'Rational' struct definition
// Size: 8
type Rational struct {
	Numerator   int32
	Denominator int32
}

// Struct read Rational
func RationalRead(buf []byte, v *Rational) int {
	b := 0

	v.Numerator = int32(xgb.Get32(buf[b:]))
	b += 4

	v.Denominator = int32(xgb.Get32(buf[b:]))
	b += 4

	return b
}

// Struct list read Rational
func RationalReadList(buf []byte, dest []Rational) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Rational{}
		b += RationalRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Rational
func (v Rational) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Numerator))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Denominator))
	b += 4

	return buf
}

// Write struct list Rational
func RationalListBytes(buf []byte, list []Rational) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Format' struct definition
// Size: 8
type Format struct {
	Visual xproto.Visualid
	Depth  byte
	// padding: 3 bytes
}

// Struct read Format
func FormatRead(buf []byte, v *Format) int {
	b := 0

	v.Visual = xproto.Visualid(xgb.Get32(buf[b:]))
	b += 4

	v.Depth = buf[b]
	b += 1

	b += 3 // padding

	return b
}

// Struct list read Format
func FormatReadList(buf []byte, dest []Format) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Format{}
		b += FormatRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Format
func (v Format) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Visual))
	b += 4

	buf[b] = v.Depth
	b += 1

	b += 3 // padding

	return buf
}

// Write struct list Format
func FormatListBytes(buf []byte, list []Format) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'AdaptorInfo' struct definition
// Size: ((12 + xgb.Pad((int(NameSize) * 1))) + xgb.Pad((int(NumFormats) * 8)))
type AdaptorInfo struct {
	BaseId     Port
	NameSize   uint16
	NumPorts   uint16
	NumFormats uint16
	Type       byte
	// padding: 1 bytes
	Name    string   // size: xgb.Pad((int(NameSize) * 1))
	Formats []Format // size: xgb.Pad((int(NumFormats) * 8))
}

// Struct read AdaptorInfo
func AdaptorInfoRead(buf []byte, v *AdaptorInfo) int {
	b := 0

	v.BaseId = Port(xgb.Get32(buf[b:]))
	b += 4

	v.NameSize = xgb.Get16(buf[b:])
	b += 2

	v.NumPorts = xgb.Get16(buf[b:])
	b += 2

	v.NumFormats = xgb.Get16(buf[b:])
	b += 2

	v.Type = buf[b]
	b += 1

	b += 1 // padding

	{
		byteString := make([]byte, v.NameSize)
		copy(byteString[:v.NameSize], buf[b:])
		v.Name = string(byteString)
		b += xgb.Pad(int(v.NameSize))
	}

	v.Formats = make([]Format, v.NumFormats)
	b += FormatReadList(buf[b:], v.Formats)

	return b
}

// Struct list read AdaptorInfo
func AdaptorInfoReadList(buf []byte, dest []AdaptorInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = AdaptorInfo{}
		b += AdaptorInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write AdaptorInfo
func (v AdaptorInfo) Bytes() []byte {
	buf := make([]byte, ((12 + xgb.Pad((int(v.NameSize) * 1))) + xgb.Pad((int(v.NumFormats) * 8))))
	b := 0

	xgb.Put32(buf[b:], uint32(v.BaseId))
	b += 4

	xgb.Put16(buf[b:], v.NameSize)
	b += 2

	xgb.Put16(buf[b:], v.NumPorts)
	b += 2

	xgb.Put16(buf[b:], v.NumFormats)
	b += 2

	buf[b] = v.Type
	b += 1

	b += 1 // padding

	copy(buf[b:], v.Name[:v.NameSize])
	b += xgb.Pad(int(v.NameSize))

	b += FormatListBytes(buf[b:], v.Formats)

	return buf
}

// Write struct list AdaptorInfo
func AdaptorInfoListBytes(buf []byte, list []AdaptorInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size AdaptorInfo
func AdaptorInfoListSize(list []AdaptorInfo) int {
	size := 0
	for _, item := range list {
		size += ((12 + xgb.Pad((int(item.NameSize) * 1))) + xgb.Pad((int(item.NumFormats) * 8)))
	}
	return size
}

// 'EncodingInfo' struct definition
// Size: (20 + xgb.Pad((int(NameSize) * 1)))
type EncodingInfo struct {
	Encoding Encoding
	NameSize uint16
	Width    uint16
	Height   uint16
	// padding: 2 bytes
	Rate Rational
	Name string // size: xgb.Pad((int(NameSize) * 1))
}

// Struct read EncodingInfo
func EncodingInfoRead(buf []byte, v *EncodingInfo) int {
	b := 0

	v.Encoding = Encoding(xgb.Get32(buf[b:]))
	b += 4

	v.NameSize = xgb.Get16(buf[b:])
	b += 2

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.Rate = Rational{}
	b += RationalRead(buf[b:], &v.Rate)

	{
		byteString := make([]byte, v.NameSize)
		copy(byteString[:v.NameSize], buf[b:])
		v.Name = string(byteString)
		b += xgb.Pad(int(v.NameSize))
	}

	return b
}

// Struct list read EncodingInfo
func EncodingInfoReadList(buf []byte, dest []EncodingInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = EncodingInfo{}
		b += EncodingInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write EncodingInfo
func (v EncodingInfo) Bytes() []byte {
	buf := make([]byte, (20 + xgb.Pad((int(v.NameSize) * 1))))
	b := 0

	xgb.Put32(buf[b:], uint32(v.Encoding))
	b += 4

	xgb.Put16(buf[b:], v.NameSize)
	b += 2

	xgb.Put16(buf[b:], v.Width)
	b += 2

	xgb.Put16(buf[b:], v.Height)
	b += 2

	b += 2 // padding

	{
		structBytes := v.Rate.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	copy(buf[b:], v.Name[:v.NameSize])
	b += xgb.Pad(int(v.NameSize))

	return buf
}

// Write struct list EncodingInfo
func EncodingInfoListBytes(buf []byte, list []EncodingInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size EncodingInfo
func EncodingInfoListSize(list []EncodingInfo) int {
	size := 0
	for _, item := range list {
		size += (20 + xgb.Pad((int(item.NameSize) * 1)))
	}
	return size
}

// 'Image' struct definition
// Size: (((16 + xgb.Pad((int(NumPlanes) * 4))) + xgb.Pad((int(NumPlanes) * 4))) + xgb.Pad((int(DataSize) * 1)))
type Image struct {
	Id        uint32
	Width     uint16
	Height    uint16
	DataSize  uint32
	NumPlanes uint32
	Pitches   []uint32 // size: xgb.Pad((int(NumPlanes) * 4))
	Offsets   []uint32 // size: xgb.Pad((int(NumPlanes) * 4))
	Data      []byte   // size: xgb.Pad((int(DataSize) * 1))
}

// Struct read Image
func ImageRead(buf []byte, v *Image) int {
	b := 0

	v.Id = xgb.Get32(buf[b:])
	b += 4

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	v.DataSize = xgb.Get32(buf[b:])
	b += 4

	v.NumPlanes = xgb.Get32(buf[b:])
	b += 4

	v.Pitches = make([]uint32, v.NumPlanes)
	for i := 0; i < int(v.NumPlanes); i++ {
		v.Pitches[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	v.Offsets = make([]uint32, v.NumPlanes)
	for i := 0; i < int(v.NumPlanes); i++ {
		v.Offsets[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	v.Data = make([]byte, v.DataSize)
	copy(v.Data[:v.DataSize], buf[b:])
	b += xgb.Pad(int(v.DataSize))

	return b
}

// Struct list read Image
func ImageReadList(buf []byte, dest []Image) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Image{}
		b += ImageRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Image
func (v Image) Bytes() []byte {
	buf := make([]byte, (((16 + xgb.Pad((int(v.NumPlanes) * 4))) + xgb.Pad((int(v.NumPlanes) * 4))) + xgb.Pad((int(v.DataSize) * 1))))
	b := 0

	xgb.Put32(buf[b:], v.Id)
	b += 4

	xgb.Put16(buf[b:], v.Width)
	b += 2

	xgb.Put16(buf[b:], v.Height)
	b += 2

	xgb.Put32(buf[b:], v.DataSize)
	b += 4

	xgb.Put32(buf[b:], v.NumPlanes)
	b += 4

	for i := 0; i < int(v.NumPlanes); i++ {
		xgb.Put32(buf[b:], v.Pitches[i])
		b += 4
	}
	b = xgb.Pad(b)

	for i := 0; i < int(v.NumPlanes); i++ {
		xgb.Put32(buf[b:], v.Offsets[i])
		b += 4
	}
	b = xgb.Pad(b)

	copy(buf[b:], v.Data[:v.DataSize])
	b += xgb.Pad(int(v.DataSize))

	return buf
}

// Write struct list Image
func ImageListBytes(buf []byte, list []Image) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size Image
func ImageListSize(list []Image) int {
	size := 0
	for _, item := range list {
		size += (((16 + xgb.Pad((int(item.NumPlanes) * 4))) + xgb.Pad((int(item.NumPlanes) * 4))) + xgb.Pad((int(item.DataSize) * 1)))
	}
	return size
}

// 'AttributeInfo' struct definition
// Size: (16 + xgb.Pad((int(Size) * 1)))
type AttributeInfo struct {
	Flags uint32
	Min   int32
	Max   int32
	Size  uint32
	Name  string // size: xgb.Pad((int(Size) * 1))
}

// Struct read AttributeInfo
func AttributeInfoRead(buf []byte, v *AttributeInfo) int {
	b := 0

	v.Flags = xgb.Get32(buf[b:])
	b += 4

	v.Min = int32(xgb.Get32(buf[b:]))
	b += 4

	v.Max = int32(xgb.Get32(buf[b:]))
	b += 4

	v.Size = xgb.Get32(buf[b:])
	b += 4

	{
		byteString := make([]byte, v.Size)
		copy(byteString[:v.Size], buf[b:])
		v.Name = string(byteString)
		b += xgb.Pad(int(v.Size))
	}

	return b
}

// Struct list read AttributeInfo
func AttributeInfoReadList(buf []byte, dest []AttributeInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = AttributeInfo{}
		b += AttributeInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write AttributeInfo
func (v AttributeInfo) Bytes() []byte {
	buf := make([]byte, (16 + xgb.Pad((int(v.Size) * 1))))
	b := 0

	xgb.Put32(buf[b:], v.Flags)
	b += 4

	xgb.Put32(buf[b:], uint32(v.Min))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Max))
	b += 4

	xgb.Put32(buf[b:], v.Size)
	b += 4

	copy(buf[b:], v.Name[:v.Size])
	b += xgb.Pad(int(v.Size))

	return buf
}

// Write struct list AttributeInfo
func AttributeInfoListBytes(buf []byte, list []AttributeInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size AttributeInfo
func AttributeInfoListSize(list []AttributeInfo) int {
	size := 0
	for _, item := range list {
		size += (16 + xgb.Pad((int(item.Size) * 1)))
	}
	return size
}

// 'ImageFormatInfo' struct definition
// Size: 128
type ImageFormatInfo struct {
	Id        uint32
	Type      byte
	ByteOrder byte
	// padding: 2 bytes
	Guid      []byte // size: 16
	Bpp       byte
	NumPlanes byte
	// padding: 2 bytes
	Depth byte
	// padding: 3 bytes
	RedMask   uint32
	GreenMask uint32
	BlueMask  uint32
	Format    byte
	// padding: 3 bytes
	YSampleBits    uint32
	USampleBits    uint32
	VSampleBits    uint32
	VhorzYPeriod   uint32
	VhorzUPeriod   uint32
	VhorzVPeriod   uint32
	VvertYPeriod   uint32
	VvertUPeriod   uint32
	VvertVPeriod   uint32
	VcompOrder     []byte // size: 32
	VscanlineOrder byte
	// padding: 11 bytes
}

// Struct read ImageFormatInfo
func ImageFormatInfoRead(buf []byte, v *ImageFormatInfo) int {
	b := 0

	v.Id = xgb.Get32(buf[b:])
	b += 4

	v.Type = buf[b]
	b += 1

	v.ByteOrder = buf[b]
	b += 1

	b += 2 // padding

	v.Guid = make([]byte, 16)
	copy(v.Guid[:16], buf[b:])
	b += xgb.Pad(int(16))

	v.Bpp = buf[b]
	b += 1

	v.NumPlanes = buf[b]
	b += 1

	b += 2 // padding

	v.Depth = buf[b]
	b += 1

	b += 3 // padding

	v.RedMask = xgb.Get32(buf[b:])
	b += 4

	v.GreenMask = xgb.Get32(buf[b:])
	b += 4

	v.BlueMask = xgb.Get32(buf[b:])
	b += 4

	v.Format = buf[b]
	b += 1

	b += 3 // padding

	v.YSampleBits = xgb.Get32(buf[b:])
	b += 4

	v.USampleBits = xgb.Get32(buf[b:])
	b += 4

	v.VSampleBits = xgb.Get32(buf[b:])
	b += 4

	v.VhorzYPeriod = xgb.Get32(buf[b:])
	b += 4

	v.VhorzUPeriod = xgb.Get32(buf[b:])
	b += 4

	v.VhorzVPeriod = xgb.Get32(buf[b:])
	b += 4

	v.VvertYPeriod = xgb.Get32(buf[b:])
	b += 4

	v.VvertUPeriod = xgb.Get32(buf[b:])
	b += 4

	v.VvertVPeriod = xgb.Get32(buf[b:])
	b += 4

	v.VcompOrder = make([]byte, 32)
	copy(v.VcompOrder[:32], buf[b:])
	b += xgb.Pad(int(32))

	v.VscanlineOrder = buf[b]
	b += 1

	b += 11 // padding

	return b
}

// Struct list read ImageFormatInfo
func ImageFormatInfoReadList(buf []byte, dest []ImageFormatInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ImageFormatInfo{}
		b += ImageFormatInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write ImageFormatInfo
func (v ImageFormatInfo) Bytes() []byte {
	buf := make([]byte, 128)
	b := 0

	xgb.Put32(buf[b:], v.Id)
	b += 4

	buf[b] = v.Type
	b += 1

	buf[b] = v.ByteOrder
	b += 1

	b += 2 // padding

	copy(buf[b:], v.Guid[:16])
	b += xgb.Pad(int(16))

	buf[b] = v.Bpp
	b += 1

	buf[b] = v.NumPlanes
	b += 1

	b += 2 // padding

	buf[b] = v.Depth
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], v.RedMask)
	b += 4

	xgb.Put32(buf[b:], v.GreenMask)
	b += 4

	xgb.Put32(buf[b:], v.BlueMask)
	b += 4

	buf[b] = v.Format
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], v.YSampleBits)
	b += 4

	xgb.Put32(buf[b:], v.USampleBits)
	b += 4

	xgb.Put32(buf[b:], v.VSampleBits)
	b += 4

	xgb.Put32(buf[b:], v.VhorzYPeriod)
	b += 4

	xgb.Put32(buf[b:], v.VhorzUPeriod)
	b += 4

	xgb.Put32(buf[b:], v.VhorzVPeriod)
	b += 4

	xgb.Put32(buf[b:], v.VvertYPeriod)
	b += 4

	xgb.Put32(buf[b:], v.VvertUPeriod)
	b += 4

	xgb.Put32(buf[b:], v.VvertVPeriod)
	b += 4

	copy(buf[b:], v.VcompOrder[:32])
	b += xgb.Pad(int(32))

	buf[b] = v.VscanlineOrder
	b += 1

	b += 11 // padding

	return buf
}

// Write struct list ImageFormatInfo
func ImageFormatInfoListBytes(buf []byte, list []ImageFormatInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size ImageFormatInfo
func ImageFormatInfoListSize(list []ImageFormatInfo) int {
	size := 0
	for _ = range list {
		size += 128
	}
	return size
}

// Event definition VideoNotify (0)
// Size: 32

const VideoNotify = 0

type VideoNotifyEvent struct {
	Sequence uint16
	Reason   byte
	Time     xproto.Timestamp
	Drawable xproto.Drawable
	Port     Port
}

// Event read VideoNotify
func VideoNotifyEventNew(buf []byte) xgb.Event {
	v := VideoNotifyEvent{}
	b := 1 // don't read event number

	v.Reason = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Drawable = xproto.Drawable(xgb.Get32(buf[b:]))
	b += 4

	v.Port = Port(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Event write VideoNotify
func (v VideoNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 0
	b += 1

	buf[b] = v.Reason
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Port))
	b += 4

	return buf
}

func (v VideoNotifyEvent) ImplementsEvent() {}

func (v VideoNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v VideoNotifyEvent) String() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Reason: %d", v.Reason))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Drawable: %d", v.Drawable))
	fieldVals = append(fieldVals, xgb.Sprintf("Port: %d", v.Port))
	return "VideoNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XVideo"][0] = VideoNotifyEventNew
}

// Event definition PortNotify (1)
// Size: 32

const PortNotify = 1

type PortNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Time      xproto.Timestamp
	Port      Port
	Attribute xproto.Atom
	Value     int32
}

// Event read PortNotify
func PortNotifyEventNew(buf []byte) xgb.Event {
	v := PortNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Port = Port(xgb.Get32(buf[b:]))
	b += 4

	v.Attribute = xproto.Atom(xgb.Get32(buf[b:]))
	b += 4

	v.Value = int32(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Event write PortNotify
func (v PortNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 1
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Port))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Attribute))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Value))
	b += 4

	return buf
}

func (v PortNotifyEvent) ImplementsEvent() {}

func (v PortNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v PortNotifyEvent) String() string {
	fieldVals := make([]string, 0, 5)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Port: %d", v.Port))
	fieldVals = append(fieldVals, xgb.Sprintf("Attribute: %d", v.Attribute))
	fieldVals = append(fieldVals, xgb.Sprintf("Value: %d", v.Value))
	return "PortNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XVideo"][1] = PortNotifyEventNew
}

// Error definition BadPort (0)
// Size: 32

const BadBadPort = 0

type BadPortError struct {
	Sequence uint16
	NiceName string
}

// Error read BadPort
func BadPortErrorNew(buf []byte) xgb.Error {
	v := BadPortError{}
	v.NiceName = "BadPort"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

func (err BadPortError) ImplementsError() {}

func (err BadPortError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadPortError) BadId() uint32 {
	return 0
}

func (err BadPortError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadBadPort {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["XVideo"][0] = BadPortErrorNew
}

// Error definition BadEncoding (1)
// Size: 32

const BadBadEncoding = 1

type BadEncodingError struct {
	Sequence uint16
	NiceName string
}

// Error read BadEncoding
func BadEncodingErrorNew(buf []byte) xgb.Error {
	v := BadEncodingError{}
	v.NiceName = "BadEncoding"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

func (err BadEncodingError) ImplementsError() {}

func (err BadEncodingError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadEncodingError) BadId() uint32 {
	return 0
}

func (err BadEncodingError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadBadEncoding {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["XVideo"][1] = BadEncodingErrorNew
}

// Error definition BadControl (2)
// Size: 32

const BadBadControl = 2

type BadControlError struct {
	Sequence uint16
	NiceName string
}

// Error read BadControl
func BadControlErrorNew(buf []byte) xgb.Error {
	v := BadControlError{}
	v.NiceName = "BadControl"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

func (err BadControlError) ImplementsError() {}

func (err BadControlError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadControlError) BadId() uint32 {
	return 0
}

func (err BadControlError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadBadControl {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["XVideo"][2] = BadControlErrorNew
}

// Request QueryExtension
// size: 4
type QueryExtensionCookie struct {
	*xgb.Cookie
}

func QueryExtension(c *xgb.Conn) QueryExtensionCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryExtensionRequest(c), cookie)
	return QueryExtensionCookie{cookie}
}

func QueryExtensionUnchecked(c *xgb.Conn) QueryExtensionCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryExtensionRequest(c), cookie)
	return QueryExtensionCookie{cookie}
}

// Request reply for QueryExtension
// size: 12
type QueryExtensionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Major uint16
	Minor uint16
}

// Waits and reads reply data from request QueryExtension
func (cook QueryExtensionCookie) Reply() (*QueryExtensionReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryExtensionReply(buf), nil
}

// Read reply into structure from buffer for QueryExtension
func queryExtensionReply(buf []byte) *QueryExtensionReply {
	v := new(QueryExtensionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Major = xgb.Get16(buf[b:])
	b += 2

	v.Minor = xgb.Get16(buf[b:])
	b += 2

	return v
}

// Write request to wire for QueryExtension
func queryExtensionRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 0 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request QueryAdaptors
// size: 8
type QueryAdaptorsCookie struct {
	*xgb.Cookie
}

func QueryAdaptors(c *xgb.Conn, Window xproto.Window) QueryAdaptorsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryAdaptorsRequest(c, Window), cookie)
	return QueryAdaptorsCookie{cookie}
}

func QueryAdaptorsUnchecked(c *xgb.Conn, Window xproto.Window) QueryAdaptorsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryAdaptorsRequest(c, Window), cookie)
	return QueryAdaptorsCookie{cookie}
}

// Request reply for QueryAdaptors
// size: (32 + AdaptorInfoListSize(Info))
type QueryAdaptorsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumAdaptors uint16
	// padding: 22 bytes
	Info []AdaptorInfo // size: AdaptorInfoListSize(Info)
}

// Waits and reads reply data from request QueryAdaptors
func (cook QueryAdaptorsCookie) Reply() (*QueryAdaptorsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryAdaptorsReply(buf), nil
}

// Read reply into structure from buffer for QueryAdaptors
func queryAdaptorsReply(buf []byte) *QueryAdaptorsReply {
	v := new(QueryAdaptorsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumAdaptors = xgb.Get16(buf[b:])
	b += 2

	b += 22 // padding

	v.Info = make([]AdaptorInfo, v.NumAdaptors)
	b += AdaptorInfoReadList(buf[b:], v.Info)

	return v
}

// Write request to wire for QueryAdaptors
func queryAdaptorsRequest(c *xgb.Conn, Window xproto.Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request QueryEncodings
// size: 8
type QueryEncodingsCookie struct {
	*xgb.Cookie
}

func QueryEncodings(c *xgb.Conn, Port Port) QueryEncodingsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryEncodingsRequest(c, Port), cookie)
	return QueryEncodingsCookie{cookie}
}

func QueryEncodingsUnchecked(c *xgb.Conn, Port Port) QueryEncodingsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryEncodingsRequest(c, Port), cookie)
	return QueryEncodingsCookie{cookie}
}

// Request reply for QueryEncodings
// size: (32 + EncodingInfoListSize(Info))
type QueryEncodingsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumEncodings uint16
	// padding: 22 bytes
	Info []EncodingInfo // size: EncodingInfoListSize(Info)
}

// Waits and reads reply data from request QueryEncodings
func (cook QueryEncodingsCookie) Reply() (*QueryEncodingsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryEncodingsReply(buf), nil
}

// Read reply into structure from buffer for QueryEncodings
func queryEncodingsReply(buf []byte) *QueryEncodingsReply {
	v := new(QueryEncodingsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumEncodings = xgb.Get16(buf[b:])
	b += 2

	b += 22 // padding

	v.Info = make([]EncodingInfo, v.NumEncodings)
	b += EncodingInfoReadList(buf[b:], v.Info)

	return v
}

// Write request to wire for QueryEncodings
func queryEncodingsRequest(c *xgb.Conn, Port Port) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	return buf
}

// Request GrabPort
// size: 12
type GrabPortCookie struct {
	*xgb.Cookie
}

func GrabPort(c *xgb.Conn, Port Port, Time xproto.Timestamp) GrabPortCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(grabPortRequest(c, Port, Time), cookie)
	return GrabPortCookie{cookie}
}

func GrabPortUnchecked(c *xgb.Conn, Port Port, Time xproto.Timestamp) GrabPortCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(grabPortRequest(c, Port, Time), cookie)
	return GrabPortCookie{cookie}
}

// Request reply for GrabPort
// size: 8
type GrabPortReply struct {
	Sequence uint16
	Length   uint32
	Result   byte
}

// Waits and reads reply data from request GrabPort
func (cook GrabPortCookie) Reply() (*GrabPortReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return grabPortReply(buf), nil
}

// Read reply into structure from buffer for GrabPort
func grabPortReply(buf []byte) *GrabPortReply {
	v := new(GrabPortReply)
	b := 1 // skip reply determinant

	v.Result = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	return v
}

// Write request to wire for GrabPort
func grabPortRequest(c *xgb.Conn, Port Port, Time xproto.Timestamp) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	return buf
}

// Request UngrabPort
// size: 12
type UngrabPortCookie struct {
	*xgb.Cookie
}

// Write request to wire for UngrabPort
func UngrabPort(c *xgb.Conn, Port Port, Time xproto.Timestamp) UngrabPortCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(ungrabPortRequest(c, Port, Time), cookie)
	return UngrabPortCookie{cookie}
}

func UngrabPortChecked(c *xgb.Conn, Port Port, Time xproto.Timestamp) UngrabPortCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(ungrabPortRequest(c, Port, Time), cookie)
	return UngrabPortCookie{cookie}
}

func (cook UngrabPortCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UngrabPort
func ungrabPortRequest(c *xgb.Conn, Port Port, Time xproto.Timestamp) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	return buf
}

// Request PutVideo
// size: 32
type PutVideoCookie struct {
	*xgb.Cookie
}

// Write request to wire for PutVideo
func PutVideo(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) PutVideoCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(putVideoRequest(c, Port, Drawable, Gc, VidX, VidY, VidW, VidH, DrwX, DrwY, DrwW, DrwH), cookie)
	return PutVideoCookie{cookie}
}

func PutVideoChecked(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) PutVideoCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(putVideoRequest(c, Port, Drawable, Gc, VidX, VidY, VidW, VidH, DrwX, DrwY, DrwW, DrwH), cookie)
	return PutVideoCookie{cookie}
}

func (cook PutVideoCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for PutVideo
func putVideoRequest(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) []byte {
	size := 32
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put16(buf[b:], uint16(VidX))
	b += 2

	xgb.Put16(buf[b:], uint16(VidY))
	b += 2

	xgb.Put16(buf[b:], VidW)
	b += 2

	xgb.Put16(buf[b:], VidH)
	b += 2

	xgb.Put16(buf[b:], uint16(DrwX))
	b += 2

	xgb.Put16(buf[b:], uint16(DrwY))
	b += 2

	xgb.Put16(buf[b:], DrwW)
	b += 2

	xgb.Put16(buf[b:], DrwH)
	b += 2

	return buf
}

// Request PutStill
// size: 32
type PutStillCookie struct {
	*xgb.Cookie
}

// Write request to wire for PutStill
func PutStill(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) PutStillCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(putStillRequest(c, Port, Drawable, Gc, VidX, VidY, VidW, VidH, DrwX, DrwY, DrwW, DrwH), cookie)
	return PutStillCookie{cookie}
}

func PutStillChecked(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) PutStillCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(putStillRequest(c, Port, Drawable, Gc, VidX, VidY, VidW, VidH, DrwX, DrwY, DrwW, DrwH), cookie)
	return PutStillCookie{cookie}
}

func (cook PutStillCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for PutStill
func putStillRequest(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) []byte {
	size := 32
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put16(buf[b:], uint16(VidX))
	b += 2

	xgb.Put16(buf[b:], uint16(VidY))
	b += 2

	xgb.Put16(buf[b:], VidW)
	b += 2

	xgb.Put16(buf[b:], VidH)
	b += 2

	xgb.Put16(buf[b:], uint16(DrwX))
	b += 2

	xgb.Put16(buf[b:], uint16(DrwY))
	b += 2

	xgb.Put16(buf[b:], DrwW)
	b += 2

	xgb.Put16(buf[b:], DrwH)
	b += 2

	return buf
}

// Request GetVideo
// size: 32
type GetVideoCookie struct {
	*xgb.Cookie
}

// Write request to wire for GetVideo
func GetVideo(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) GetVideoCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(getVideoRequest(c, Port, Drawable, Gc, VidX, VidY, VidW, VidH, DrwX, DrwY, DrwW, DrwH), cookie)
	return GetVideoCookie{cookie}
}

func GetVideoChecked(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) GetVideoCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(getVideoRequest(c, Port, Drawable, Gc, VidX, VidY, VidW, VidH, DrwX, DrwY, DrwW, DrwH), cookie)
	return GetVideoCookie{cookie}
}

func (cook GetVideoCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for GetVideo
func getVideoRequest(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) []byte {
	size := 32
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put16(buf[b:], uint16(VidX))
	b += 2

	xgb.Put16(buf[b:], uint16(VidY))
	b += 2

	xgb.Put16(buf[b:], VidW)
	b += 2

	xgb.Put16(buf[b:], VidH)
	b += 2

	xgb.Put16(buf[b:], uint16(DrwX))
	b += 2

	xgb.Put16(buf[b:], uint16(DrwY))
	b += 2

	xgb.Put16(buf[b:], DrwW)
	b += 2

	xgb.Put16(buf[b:], DrwH)
	b += 2

	return buf
}

// Request GetStill
// size: 32
type GetStillCookie struct {
	*xgb.Cookie
}

// Write request to wire for GetStill
func GetStill(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) GetStillCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(getStillRequest(c, Port, Drawable, Gc, VidX, VidY, VidW, VidH, DrwX, DrwY, DrwW, DrwH), cookie)
	return GetStillCookie{cookie}
}

func GetStillChecked(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) GetStillCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(getStillRequest(c, Port, Drawable, Gc, VidX, VidY, VidW, VidH, DrwX, DrwY, DrwW, DrwH), cookie)
	return GetStillCookie{cookie}
}

func (cook GetStillCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for GetStill
func getStillRequest(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) []byte {
	size := 32
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 8 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put16(buf[b:], uint16(VidX))
	b += 2

	xgb.Put16(buf[b:], uint16(VidY))
	b += 2

	xgb.Put16(buf[b:], VidW)
	b += 2

	xgb.Put16(buf[b:], VidH)
	b += 2

	xgb.Put16(buf[b:], uint16(DrwX))
	b += 2

	xgb.Put16(buf[b:], uint16(DrwY))
	b += 2

	xgb.Put16(buf[b:], DrwW)
	b += 2

	xgb.Put16(buf[b:], DrwH)
	b += 2

	return buf
}

// Request StopVideo
// size: 12
type StopVideoCookie struct {
	*xgb.Cookie
}

// Write request to wire for StopVideo
func StopVideo(c *xgb.Conn, Port Port, Drawable xproto.Drawable) StopVideoCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(stopVideoRequest(c, Port, Drawable), cookie)
	return StopVideoCookie{cookie}
}

func StopVideoChecked(c *xgb.Conn, Port Port, Drawable xproto.Drawable) StopVideoCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(stopVideoRequest(c, Port, Drawable), cookie)
	return StopVideoCookie{cookie}
}

func (cook StopVideoCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for StopVideo
func stopVideoRequest(c *xgb.Conn, Port Port, Drawable xproto.Drawable) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 9 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	return buf
}

// Request SelectVideoNotify
// size: 12
type SelectVideoNotifyCookie struct {
	*xgb.Cookie
}

// Write request to wire for SelectVideoNotify
func SelectVideoNotify(c *xgb.Conn, Drawable xproto.Drawable, Onoff bool) SelectVideoNotifyCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(selectVideoNotifyRequest(c, Drawable, Onoff), cookie)
	return SelectVideoNotifyCookie{cookie}
}

func SelectVideoNotifyChecked(c *xgb.Conn, Drawable xproto.Drawable, Onoff bool) SelectVideoNotifyCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(selectVideoNotifyRequest(c, Drawable, Onoff), cookie)
	return SelectVideoNotifyCookie{cookie}
}

func (cook SelectVideoNotifyCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SelectVideoNotify
func selectVideoNotifyRequest(c *xgb.Conn, Drawable xproto.Drawable, Onoff bool) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 10 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	if Onoff {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 3 // padding

	return buf
}

// Request SelectPortNotify
// size: 12
type SelectPortNotifyCookie struct {
	*xgb.Cookie
}

// Write request to wire for SelectPortNotify
func SelectPortNotify(c *xgb.Conn, Port Port, Onoff bool) SelectPortNotifyCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(selectPortNotifyRequest(c, Port, Onoff), cookie)
	return SelectPortNotifyCookie{cookie}
}

func SelectPortNotifyChecked(c *xgb.Conn, Port Port, Onoff bool) SelectPortNotifyCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(selectPortNotifyRequest(c, Port, Onoff), cookie)
	return SelectPortNotifyCookie{cookie}
}

func (cook SelectPortNotifyCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SelectPortNotify
func selectPortNotifyRequest(c *xgb.Conn, Port Port, Onoff bool) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 11 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	if Onoff {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 3 // padding

	return buf
}

// Request QueryBestSize
// size: 20
type QueryBestSizeCookie struct {
	*xgb.Cookie
}

func QueryBestSize(c *xgb.Conn, Port Port, VidW uint16, VidH uint16, DrwW uint16, DrwH uint16, Motion bool) QueryBestSizeCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryBestSizeRequest(c, Port, VidW, VidH, DrwW, DrwH, Motion), cookie)
	return QueryBestSizeCookie{cookie}
}

func QueryBestSizeUnchecked(c *xgb.Conn, Port Port, VidW uint16, VidH uint16, DrwW uint16, DrwH uint16, Motion bool) QueryBestSizeCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryBestSizeRequest(c, Port, VidW, VidH, DrwW, DrwH, Motion), cookie)
	return QueryBestSizeCookie{cookie}
}

// Request reply for QueryBestSize
// size: 12
type QueryBestSizeReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ActualWidth  uint16
	ActualHeight uint16
}

// Waits and reads reply data from request QueryBestSize
func (cook QueryBestSizeCookie) Reply() (*QueryBestSizeReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryBestSizeReply(buf), nil
}

// Read reply into structure from buffer for QueryBestSize
func queryBestSizeReply(buf []byte) *QueryBestSizeReply {
	v := new(QueryBestSizeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ActualWidth = xgb.Get16(buf[b:])
	b += 2

	v.ActualHeight = xgb.Get16(buf[b:])
	b += 2

	return v
}

// Write request to wire for QueryBestSize
func queryBestSizeRequest(c *xgb.Conn, Port Port, VidW uint16, VidH uint16, DrwW uint16, DrwH uint16, Motion bool) []byte {
	size := 20
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 12 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	xgb.Put16(buf[b:], VidW)
	b += 2

	xgb.Put16(buf[b:], VidH)
	b += 2

	xgb.Put16(buf[b:], DrwW)
	b += 2

	xgb.Put16(buf[b:], DrwH)
	b += 2

	if Motion {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 3 // padding

	return buf
}

// Request SetPortAttribute
// size: 16
type SetPortAttributeCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetPortAttribute
func SetPortAttribute(c *xgb.Conn, Port Port, Attribute xproto.Atom, Value int32) SetPortAttributeCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setPortAttributeRequest(c, Port, Attribute, Value), cookie)
	return SetPortAttributeCookie{cookie}
}

func SetPortAttributeChecked(c *xgb.Conn, Port Port, Attribute xproto.Atom, Value int32) SetPortAttributeCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setPortAttributeRequest(c, Port, Attribute, Value), cookie)
	return SetPortAttributeCookie{cookie}
}

func (cook SetPortAttributeCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetPortAttribute
func setPortAttributeRequest(c *xgb.Conn, Port Port, Attribute xproto.Atom, Value int32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 13 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	xgb.Put32(buf[b:], uint32(Attribute))
	b += 4

	xgb.Put32(buf[b:], uint32(Value))
	b += 4

	return buf
}

// Request GetPortAttribute
// size: 12
type GetPortAttributeCookie struct {
	*xgb.Cookie
}

func GetPortAttribute(c *xgb.Conn, Port Port, Attribute xproto.Atom) GetPortAttributeCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getPortAttributeRequest(c, Port, Attribute), cookie)
	return GetPortAttributeCookie{cookie}
}

func GetPortAttributeUnchecked(c *xgb.Conn, Port Port, Attribute xproto.Atom) GetPortAttributeCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getPortAttributeRequest(c, Port, Attribute), cookie)
	return GetPortAttributeCookie{cookie}
}

// Request reply for GetPortAttribute
// size: 12
type GetPortAttributeReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Value int32
}

// Waits and reads reply data from request GetPortAttribute
func (cook GetPortAttributeCookie) Reply() (*GetPortAttributeReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getPortAttributeReply(buf), nil
}

// Read reply into structure from buffer for GetPortAttribute
func getPortAttributeReply(buf []byte) *GetPortAttributeReply {
	v := new(GetPortAttributeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Value = int32(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Write request to wire for GetPortAttribute
func getPortAttributeRequest(c *xgb.Conn, Port Port, Attribute xproto.Atom) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 14 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	xgb.Put32(buf[b:], uint32(Attribute))
	b += 4

	return buf
}

// Request QueryPortAttributes
// size: 8
type QueryPortAttributesCookie struct {
	*xgb.Cookie
}

func QueryPortAttributes(c *xgb.Conn, Port Port) QueryPortAttributesCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryPortAttributesRequest(c, Port), cookie)
	return QueryPortAttributesCookie{cookie}
}

func QueryPortAttributesUnchecked(c *xgb.Conn, Port Port) QueryPortAttributesCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryPortAttributesRequest(c, Port), cookie)
	return QueryPortAttributesCookie{cookie}
}

// Request reply for QueryPortAttributes
// size: (32 + AttributeInfoListSize(Attributes))
type QueryPortAttributesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumAttributes uint32
	TextSize      uint32
	// padding: 16 bytes
	Attributes []AttributeInfo // size: AttributeInfoListSize(Attributes)
}

// Waits and reads reply data from request QueryPortAttributes
func (cook QueryPortAttributesCookie) Reply() (*QueryPortAttributesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryPortAttributesReply(buf), nil
}

// Read reply into structure from buffer for QueryPortAttributes
func queryPortAttributesReply(buf []byte) *QueryPortAttributesReply {
	v := new(QueryPortAttributesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumAttributes = xgb.Get32(buf[b:])
	b += 4

	v.TextSize = xgb.Get32(buf[b:])
	b += 4

	b += 16 // padding

	v.Attributes = make([]AttributeInfo, v.NumAttributes)
	b += AttributeInfoReadList(buf[b:], v.Attributes)

	return v
}

// Write request to wire for QueryPortAttributes
func queryPortAttributesRequest(c *xgb.Conn, Port Port) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 15 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	return buf
}

// Request ListImageFormats
// size: 8
type ListImageFormatsCookie struct {
	*xgb.Cookie
}

func ListImageFormats(c *xgb.Conn, Port Port) ListImageFormatsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(listImageFormatsRequest(c, Port), cookie)
	return ListImageFormatsCookie{cookie}
}

func ListImageFormatsUnchecked(c *xgb.Conn, Port Port) ListImageFormatsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(listImageFormatsRequest(c, Port), cookie)
	return ListImageFormatsCookie{cookie}
}

// Request reply for ListImageFormats
// size: (32 + ImageFormatInfoListSize(Format))
type ListImageFormatsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumFormats uint32
	// padding: 20 bytes
	Format []ImageFormatInfo // size: ImageFormatInfoListSize(Format)
}

// Waits and reads reply data from request ListImageFormats
func (cook ListImageFormatsCookie) Reply() (*ListImageFormatsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listImageFormatsReply(buf), nil
}

// Read reply into structure from buffer for ListImageFormats
func listImageFormatsReply(buf []byte) *ListImageFormatsReply {
	v := new(ListImageFormatsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumFormats = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.Format = make([]ImageFormatInfo, v.NumFormats)
	b += ImageFormatInfoReadList(buf[b:], v.Format)

	return v
}

// Write request to wire for ListImageFormats
func listImageFormatsRequest(c *xgb.Conn, Port Port) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 16 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	return buf
}

// Request QueryImageAttributes
// size: 16
type QueryImageAttributesCookie struct {
	*xgb.Cookie
}

func QueryImageAttributes(c *xgb.Conn, Port Port, Id uint32, Width uint16, Height uint16) QueryImageAttributesCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryImageAttributesRequest(c, Port, Id, Width, Height), cookie)
	return QueryImageAttributesCookie{cookie}
}

func QueryImageAttributesUnchecked(c *xgb.Conn, Port Port, Id uint32, Width uint16, Height uint16) QueryImageAttributesCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryImageAttributesRequest(c, Port, Id, Width, Height), cookie)
	return QueryImageAttributesCookie{cookie}
}

// Request reply for QueryImageAttributes
// size: ((32 + xgb.Pad((int(NumPlanes) * 4))) + xgb.Pad((int(NumPlanes) * 4)))
type QueryImageAttributesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumPlanes uint32
	DataSize  uint32
	Width     uint16
	Height    uint16
	// padding: 12 bytes
	Pitches []uint32 // size: xgb.Pad((int(NumPlanes) * 4))
	Offsets []uint32 // size: xgb.Pad((int(NumPlanes) * 4))
}

// Waits and reads reply data from request QueryImageAttributes
func (cook QueryImageAttributesCookie) Reply() (*QueryImageAttributesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryImageAttributesReply(buf), nil
}

// Read reply into structure from buffer for QueryImageAttributes
func queryImageAttributesReply(buf []byte) *QueryImageAttributesReply {
	v := new(QueryImageAttributesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumPlanes = xgb.Get32(buf[b:])
	b += 4

	v.DataSize = xgb.Get32(buf[b:])
	b += 4

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	b += 12 // padding

	v.Pitches = make([]uint32, v.NumPlanes)
	for i := 0; i < int(v.NumPlanes); i++ {
		v.Pitches[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	v.Offsets = make([]uint32, v.NumPlanes)
	for i := 0; i < int(v.NumPlanes); i++ {
		v.Offsets[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for QueryImageAttributes
func queryImageAttributesRequest(c *xgb.Conn, Port Port, Id uint32, Width uint16, Height uint16) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 17 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	xgb.Put32(buf[b:], Id)
	b += 4

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	return buf
}

// Request PutImage
// size: xgb.Pad((40 + xgb.Pad((len(Data) * 1))))
type PutImageCookie struct {
	*xgb.Cookie
}

// Write request to wire for PutImage
func PutImage(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, Id uint32, SrcX int16, SrcY int16, SrcW uint16, SrcH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16, Width uint16, Height uint16, Data []byte) PutImageCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(putImageRequest(c, Port, Drawable, Gc, Id, SrcX, SrcY, SrcW, SrcH, DrwX, DrwY, DrwW, DrwH, Width, Height, Data), cookie)
	return PutImageCookie{cookie}
}

func PutImageChecked(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, Id uint32, SrcX int16, SrcY int16, SrcW uint16, SrcH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16, Width uint16, Height uint16, Data []byte) PutImageCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(putImageRequest(c, Port, Drawable, Gc, Id, SrcX, SrcY, SrcW, SrcH, DrwX, DrwY, DrwW, DrwH, Width, Height, Data), cookie)
	return PutImageCookie{cookie}
}

func (cook PutImageCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for PutImage
func putImageRequest(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, Id uint32, SrcX int16, SrcY int16, SrcW uint16, SrcH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16, Width uint16, Height uint16, Data []byte) []byte {
	size := xgb.Pad((40 + xgb.Pad((len(Data) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 18 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put32(buf[b:], Id)
	b += 4

	xgb.Put16(buf[b:], uint16(SrcX))
	b += 2

	xgb.Put16(buf[b:], uint16(SrcY))
	b += 2

	xgb.Put16(buf[b:], SrcW)
	b += 2

	xgb.Put16(buf[b:], SrcH)
	b += 2

	xgb.Put16(buf[b:], uint16(DrwX))
	b += 2

	xgb.Put16(buf[b:], uint16(DrwY))
	b += 2

	xgb.Put16(buf[b:], DrwW)
	b += 2

	xgb.Put16(buf[b:], DrwH)
	b += 2

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	copy(buf[b:], Data[:len(Data)])
	b += xgb.Pad(int(len(Data)))

	return buf
}

// Request ShmPutImage
// size: 52
type ShmPutImageCookie struct {
	*xgb.Cookie
}

// Write request to wire for ShmPutImage
func ShmPutImage(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, Shmseg shm.Seg, Id uint32, Offset uint32, SrcX int16, SrcY int16, SrcW uint16, SrcH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16, Width uint16, Height uint16, SendEvent byte) ShmPutImageCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(shmPutImageRequest(c, Port, Drawable, Gc, Shmseg, Id, Offset, SrcX, SrcY, SrcW, SrcH, DrwX, DrwY, DrwW, DrwH, Width, Height, SendEvent), cookie)
	return ShmPutImageCookie{cookie}
}

func ShmPutImageChecked(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, Shmseg shm.Seg, Id uint32, Offset uint32, SrcX int16, SrcY int16, SrcW uint16, SrcH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16, Width uint16, Height uint16, SendEvent byte) ShmPutImageCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(shmPutImageRequest(c, Port, Drawable, Gc, Shmseg, Id, Offset, SrcX, SrcY, SrcW, SrcH, DrwX, DrwY, DrwW, DrwH, Width, Height, SendEvent), cookie)
	return ShmPutImageCookie{cookie}
}

func (cook ShmPutImageCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ShmPutImage
func shmPutImageRequest(c *xgb.Conn, Port Port, Drawable xproto.Drawable, Gc xproto.Gcontext, Shmseg shm.Seg, Id uint32, Offset uint32, SrcX int16, SrcY int16, SrcW uint16, SrcH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16, Width uint16, Height uint16, SendEvent byte) []byte {
	size := 52
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO"]
	b += 1

	buf[b] = 19 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Port))
	b += 4

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put32(buf[b:], uint32(Shmseg))
	b += 4

	xgb.Put32(buf[b:], Id)
	b += 4

	xgb.Put32(buf[b:], Offset)
	b += 4

	xgb.Put16(buf[b:], uint16(SrcX))
	b += 2

	xgb.Put16(buf[b:], uint16(SrcY))
	b += 2

	xgb.Put16(buf[b:], SrcW)
	b += 2

	xgb.Put16(buf[b:], SrcH)
	b += 2

	xgb.Put16(buf[b:], uint16(DrwX))
	b += 2

	xgb.Put16(buf[b:], uint16(DrwY))
	b += 2

	xgb.Put16(buf[b:], DrwW)
	b += 2

	xgb.Put16(buf[b:], DrwH)
	b += 2

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	buf[b] = SendEvent
	b += 1

	b += 3 // padding

	return buf
}
