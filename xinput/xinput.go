package xinput

/*
	This file was generated by xinput.xml on May 10 2012 4:20:28pm EDT.
	This file is automatically generated. Edit at your peril!
*/

import (
	"github.com/BurntSushi/xgb"

	"github.com/BurntSushi/xgb/xproto"
)

// Init must be called before using the XInputExtension extension.
func Init(c *xgb.Conn) error {
	reply, err := xproto.QueryExtension(c, 15, "XInputExtension").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return xgb.Errorf("No extension named XInputExtension could be found on on the server.")
	}

	xgb.ExtLock.Lock()
	c.Extensions["XInputExtension"] = reply.MajorOpcode
	for evNum, fun := range xgb.NewExtEventFuncs["XInputExtension"] {
		xgb.NewEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range xgb.NewExtErrorFuncs["XInputExtension"] {
		xgb.NewErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	xgb.ExtLock.Unlock()

	return nil
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"] = make(map[int]xgb.NewEventFun)
	xgb.NewExtErrorFuncs["XInputExtension"] = make(map[int]xgb.NewErrorFun)
}

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

const (
	ValuatorModeRelative = 0
	ValuatorModeAbsolute = 1
)

const (
	PropagateModeAddToList      = 0
	PropagateModeDeleteFromList = 1
)

const (
	DeviceUseIsXPointer           = 0
	DeviceUseIsXKeyboard          = 1
	DeviceUseIsXExtensionDevice   = 2
	DeviceUseIsXExtensionKeyboard = 3
	DeviceUseIsXExtensionPointer  = 4
)

const (
	InputClassKey       = 0
	InputClassButton    = 1
	InputClassValuator  = 2
	InputClassFeedback  = 3
	InputClassProximity = 4
	InputClassFocus     = 5
	InputClassOther     = 6
)

const (
	DeviceInputModeAsyncThisDevice   = 0
	DeviceInputModeSyncThisDevice    = 1
	DeviceInputModeReplayThisDevice  = 2
	DeviceInputModeAsyncOtherDevices = 3
	DeviceInputModeAsyncAll          = 4
	DeviceInputModeSyncAll           = 5
)

const (
	FeedbackClassKeyboard = 0
	FeedbackClassPointer  = 1
	FeedbackClassString   = 2
	FeedbackClassInteger  = 3
	FeedbackClassLed      = 4
	FeedbackClassBell     = 5
)

type KeyCode byte

type EventClass uint32

// 'DeviceInfo' struct definition
// Size: 8
type DeviceInfo struct {
	DeviceType   xproto.Atom
	DeviceId     byte
	NumClassInfo byte
	DeviceUse    byte
	// padding: 1 bytes
}

// Struct read DeviceInfo
func DeviceInfoRead(buf []byte, v *DeviceInfo) int {
	b := 0

	v.DeviceType = xproto.Atom(xgb.Get32(buf[b:]))
	b += 4

	v.DeviceId = buf[b]
	b += 1

	v.NumClassInfo = buf[b]
	b += 1

	v.DeviceUse = buf[b]
	b += 1

	b += 1 // padding

	return b
}

// Struct list read DeviceInfo
func DeviceInfoReadList(buf []byte, dest []DeviceInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceInfo{}
		b += DeviceInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write DeviceInfo
func (v DeviceInfo) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put32(buf[b:], uint32(v.DeviceType))
	b += 4

	buf[b] = v.DeviceId
	b += 1

	buf[b] = v.NumClassInfo
	b += 1

	buf[b] = v.DeviceUse
	b += 1

	b += 1 // padding

	return buf
}

// Write struct list DeviceInfo
func DeviceInfoListBytes(buf []byte, list []DeviceInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'InputInfo' struct definition
// Size: 2
type InputInfo struct {
	ClassId byte
	Len     byte
}

// Struct read InputInfo
func InputInfoRead(buf []byte, v *InputInfo) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	return b
}

// Struct list read InputInfo
func InputInfoReadList(buf []byte, dest []InputInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = InputInfo{}
		b += InputInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write InputInfo
func (v InputInfo) Bytes() []byte {
	buf := make([]byte, 2)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	return buf
}

// Write struct list InputInfo
func InputInfoListBytes(buf []byte, list []InputInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'KeyInfo' struct definition
// Size: 8
type KeyInfo struct {
	ClassId    byte
	Len        byte
	MinKeycode KeyCode
	MaxKeycode KeyCode
	NumKeys    uint16
	// padding: 2 bytes
}

// Struct read KeyInfo
func KeyInfoRead(buf []byte, v *KeyInfo) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.MinKeycode = KeyCode(buf[b])
	b += 1

	v.MaxKeycode = KeyCode(buf[b])
	b += 1

	v.NumKeys = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	return b
}

// Struct list read KeyInfo
func KeyInfoReadList(buf []byte, dest []KeyInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = KeyInfo{}
		b += KeyInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write KeyInfo
func (v KeyInfo) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = byte(v.MinKeycode)
	b += 1

	buf[b] = byte(v.MaxKeycode)
	b += 1

	xgb.Put16(buf[b:], v.NumKeys)
	b += 2

	b += 2 // padding

	return buf
}

// Write struct list KeyInfo
func KeyInfoListBytes(buf []byte, list []KeyInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'ButtonInfo' struct definition
// Size: 4
type ButtonInfo struct {
	ClassId    byte
	Len        byte
	NumButtons uint16
}

// Struct read ButtonInfo
func ButtonInfoRead(buf []byte, v *ButtonInfo) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.NumButtons = xgb.Get16(buf[b:])
	b += 2

	return b
}

// Struct list read ButtonInfo
func ButtonInfoReadList(buf []byte, dest []ButtonInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ButtonInfo{}
		b += ButtonInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write ButtonInfo
func (v ButtonInfo) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	xgb.Put16(buf[b:], v.NumButtons)
	b += 2

	return buf
}

// Write struct list ButtonInfo
func ButtonInfoListBytes(buf []byte, list []ButtonInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'AxisInfo' struct definition
// Size: 12
type AxisInfo struct {
	Resolution uint32
	Minimum    int32
	Maximum    int32
}

// Struct read AxisInfo
func AxisInfoRead(buf []byte, v *AxisInfo) int {
	b := 0

	v.Resolution = xgb.Get32(buf[b:])
	b += 4

	v.Minimum = int32(xgb.Get32(buf[b:]))
	b += 4

	v.Maximum = int32(xgb.Get32(buf[b:]))
	b += 4

	return b
}

// Struct list read AxisInfo
func AxisInfoReadList(buf []byte, dest []AxisInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = AxisInfo{}
		b += AxisInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write AxisInfo
func (v AxisInfo) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	xgb.Put32(buf[b:], v.Resolution)
	b += 4

	xgb.Put32(buf[b:], uint32(v.Minimum))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Maximum))
	b += 4

	return buf
}

// Write struct list AxisInfo
func AxisInfoListBytes(buf []byte, list []AxisInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'ValuatorInfo' struct definition
// Size: (8 + xgb.Pad((int(AxesLen) * 12)))
type ValuatorInfo struct {
	ClassId    byte
	Len        byte
	AxesLen    byte
	Mode       byte
	MotionSize uint32
	Axes       []AxisInfo // size: xgb.Pad((int(AxesLen) * 12))
}

// Struct read ValuatorInfo
func ValuatorInfoRead(buf []byte, v *ValuatorInfo) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.AxesLen = buf[b]
	b += 1

	v.Mode = buf[b]
	b += 1

	v.MotionSize = xgb.Get32(buf[b:])
	b += 4

	v.Axes = make([]AxisInfo, v.AxesLen)
	b += AxisInfoReadList(buf[b:], v.Axes)

	return b
}

// Struct list read ValuatorInfo
func ValuatorInfoReadList(buf []byte, dest []ValuatorInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ValuatorInfo{}
		b += ValuatorInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write ValuatorInfo
func (v ValuatorInfo) Bytes() []byte {
	buf := make([]byte, (8 + xgb.Pad((int(v.AxesLen) * 12))))
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = v.AxesLen
	b += 1

	buf[b] = v.Mode
	b += 1

	xgb.Put32(buf[b:], v.MotionSize)
	b += 4

	b += AxisInfoListBytes(buf[b:], v.Axes)

	return buf
}

// Write struct list ValuatorInfo
func ValuatorInfoListBytes(buf []byte, list []ValuatorInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size ValuatorInfo
func ValuatorInfoListSize(list []ValuatorInfo) int {
	size := 0
	for _, item := range list {
		size += (8 + xgb.Pad((int(item.AxesLen) * 12)))
	}
	return size
}

// 'InputClassInfo' struct definition
// Size: 2
type InputClassInfo struct {
	ClassId       byte
	EventTypeBase byte
}

// Struct read InputClassInfo
func InputClassInfoRead(buf []byte, v *InputClassInfo) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.EventTypeBase = buf[b]
	b += 1

	return b
}

// Struct list read InputClassInfo
func InputClassInfoReadList(buf []byte, dest []InputClassInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = InputClassInfo{}
		b += InputClassInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write InputClassInfo
func (v InputClassInfo) Bytes() []byte {
	buf := make([]byte, 2)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.EventTypeBase
	b += 1

	return buf
}

// Write struct list InputClassInfo
func InputClassInfoListBytes(buf []byte, list []InputClassInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'DeviceTimeCoord' struct definition
// Size: 4
type DeviceTimeCoord struct {
	Time xproto.Timestamp
}

// Struct read DeviceTimeCoord
func DeviceTimeCoordRead(buf []byte, v *DeviceTimeCoord) int {
	b := 0

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	return b
}

// Struct list read DeviceTimeCoord
func DeviceTimeCoordReadList(buf []byte, dest []DeviceTimeCoord) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceTimeCoord{}
		b += DeviceTimeCoordRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write DeviceTimeCoord
func (v DeviceTimeCoord) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	return buf
}

// Write struct list DeviceTimeCoord
func DeviceTimeCoordListBytes(buf []byte, list []DeviceTimeCoord) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'FeedbackState' struct definition
// Size: 4
type FeedbackState struct {
	ClassId byte
	Id      byte
	Len     uint16
}

// Struct read FeedbackState
func FeedbackStateRead(buf []byte, v *FeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	return b
}

// Struct list read FeedbackState
func FeedbackStateReadList(buf []byte, dest []FeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = FeedbackState{}
		b += FeedbackStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write FeedbackState
func (v FeedbackState) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	return buf
}

// Write struct list FeedbackState
func FeedbackStateListBytes(buf []byte, list []FeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'KbdFeedbackState' struct definition
// Size: 52
type KbdFeedbackState struct {
	ClassId          byte
	Id               byte
	Len              uint16
	Pitch            uint16
	Duration         uint16
	LedMask          uint32
	LedValues        uint32
	GlobalAutoRepeat bool
	Click            byte
	Percent          byte
	// padding: 1 bytes
	AutoRepeats []byte // size: 32
}

// Struct read KbdFeedbackState
func KbdFeedbackStateRead(buf []byte, v *KbdFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Pitch = xgb.Get16(buf[b:])
	b += 2

	v.Duration = xgb.Get16(buf[b:])
	b += 2

	v.LedMask = xgb.Get32(buf[b:])
	b += 4

	v.LedValues = xgb.Get32(buf[b:])
	b += 4

	if buf[b] == 1 {
		v.GlobalAutoRepeat = true
	} else {
		v.GlobalAutoRepeat = false
	}
	b += 1

	v.Click = buf[b]
	b += 1

	v.Percent = buf[b]
	b += 1

	b += 1 // padding

	v.AutoRepeats = make([]byte, 32)
	copy(v.AutoRepeats[:32], buf[b:])
	b += xgb.Pad(int(32))

	return b
}

// Struct list read KbdFeedbackState
func KbdFeedbackStateReadList(buf []byte, dest []KbdFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = KbdFeedbackState{}
		b += KbdFeedbackStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write KbdFeedbackState
func (v KbdFeedbackState) Bytes() []byte {
	buf := make([]byte, 52)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put16(buf[b:], v.Pitch)
	b += 2

	xgb.Put16(buf[b:], v.Duration)
	b += 2

	xgb.Put32(buf[b:], v.LedMask)
	b += 4

	xgb.Put32(buf[b:], v.LedValues)
	b += 4

	if v.GlobalAutoRepeat {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	buf[b] = v.Click
	b += 1

	buf[b] = v.Percent
	b += 1

	b += 1 // padding

	copy(buf[b:], v.AutoRepeats[:32])
	b += xgb.Pad(int(32))

	return buf
}

// Write struct list KbdFeedbackState
func KbdFeedbackStateListBytes(buf []byte, list []KbdFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size KbdFeedbackState
func KbdFeedbackStateListSize(list []KbdFeedbackState) int {
	size := 0
	for _ = range list {
		size += 52
	}
	return size
}

// 'PtrFeedbackState' struct definition
// Size: 12
type PtrFeedbackState struct {
	ClassId byte
	Id      byte
	Len     uint16
	// padding: 2 bytes
	AccelNum   uint16
	AccelDenom uint16
	Threshold  uint16
}

// Struct read PtrFeedbackState
func PtrFeedbackStateRead(buf []byte, v *PtrFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.AccelNum = xgb.Get16(buf[b:])
	b += 2

	v.AccelDenom = xgb.Get16(buf[b:])
	b += 2

	v.Threshold = xgb.Get16(buf[b:])
	b += 2

	return b
}

// Struct list read PtrFeedbackState
func PtrFeedbackStateReadList(buf []byte, dest []PtrFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = PtrFeedbackState{}
		b += PtrFeedbackStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write PtrFeedbackState
func (v PtrFeedbackState) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	b += 2 // padding

	xgb.Put16(buf[b:], v.AccelNum)
	b += 2

	xgb.Put16(buf[b:], v.AccelDenom)
	b += 2

	xgb.Put16(buf[b:], v.Threshold)
	b += 2

	return buf
}

// Write struct list PtrFeedbackState
func PtrFeedbackStateListBytes(buf []byte, list []PtrFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'IntegerFeedbackState' struct definition
// Size: 16
type IntegerFeedbackState struct {
	ClassId    byte
	Id         byte
	Len        uint16
	Resolution uint32
	MinValue   int32
	MaxValue   int32
}

// Struct read IntegerFeedbackState
func IntegerFeedbackStateRead(buf []byte, v *IntegerFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Resolution = xgb.Get32(buf[b:])
	b += 4

	v.MinValue = int32(xgb.Get32(buf[b:]))
	b += 4

	v.MaxValue = int32(xgb.Get32(buf[b:]))
	b += 4

	return b
}

// Struct list read IntegerFeedbackState
func IntegerFeedbackStateReadList(buf []byte, dest []IntegerFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = IntegerFeedbackState{}
		b += IntegerFeedbackStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write IntegerFeedbackState
func (v IntegerFeedbackState) Bytes() []byte {
	buf := make([]byte, 16)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], v.Resolution)
	b += 4

	xgb.Put32(buf[b:], uint32(v.MinValue))
	b += 4

	xgb.Put32(buf[b:], uint32(v.MaxValue))
	b += 4

	return buf
}

// Write struct list IntegerFeedbackState
func IntegerFeedbackStateListBytes(buf []byte, list []IntegerFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'StringFeedbackState' struct definition
// Size: (8 + xgb.Pad((int(NumKeysyms) * 4)))
type StringFeedbackState struct {
	ClassId    byte
	Id         byte
	Len        uint16
	MaxSymbols uint16
	NumKeysyms uint16
	Keysyms    []xproto.Keysym // size: xgb.Pad((int(NumKeysyms) * 4))
}

// Struct read StringFeedbackState
func StringFeedbackStateRead(buf []byte, v *StringFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.MaxSymbols = xgb.Get16(buf[b:])
	b += 2

	v.NumKeysyms = xgb.Get16(buf[b:])
	b += 2

	v.Keysyms = make([]xproto.Keysym, v.NumKeysyms)
	for i := 0; i < int(v.NumKeysyms); i++ {
		v.Keysyms[i] = xproto.Keysym(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return b
}

// Struct list read StringFeedbackState
func StringFeedbackStateReadList(buf []byte, dest []StringFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = StringFeedbackState{}
		b += StringFeedbackStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write StringFeedbackState
func (v StringFeedbackState) Bytes() []byte {
	buf := make([]byte, (8 + xgb.Pad((int(v.NumKeysyms) * 4))))
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put16(buf[b:], v.MaxSymbols)
	b += 2

	xgb.Put16(buf[b:], v.NumKeysyms)
	b += 2

	for i := 0; i < int(v.NumKeysyms); i++ {
		xgb.Put32(buf[b:], uint32(v.Keysyms[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Write struct list StringFeedbackState
func StringFeedbackStateListBytes(buf []byte, list []StringFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size StringFeedbackState
func StringFeedbackStateListSize(list []StringFeedbackState) int {
	size := 0
	for _, item := range list {
		size += (8 + xgb.Pad((int(item.NumKeysyms) * 4)))
	}
	return size
}

// 'BellFeedbackState' struct definition
// Size: 12
type BellFeedbackState struct {
	ClassId byte
	Id      byte
	Len     uint16
	Percent byte
	// padding: 3 bytes
	Pitch    uint16
	Duration uint16
}

// Struct read BellFeedbackState
func BellFeedbackStateRead(buf []byte, v *BellFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Percent = buf[b]
	b += 1

	b += 3 // padding

	v.Pitch = xgb.Get16(buf[b:])
	b += 2

	v.Duration = xgb.Get16(buf[b:])
	b += 2

	return b
}

// Struct list read BellFeedbackState
func BellFeedbackStateReadList(buf []byte, dest []BellFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = BellFeedbackState{}
		b += BellFeedbackStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write BellFeedbackState
func (v BellFeedbackState) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.Percent
	b += 1

	b += 3 // padding

	xgb.Put16(buf[b:], v.Pitch)
	b += 2

	xgb.Put16(buf[b:], v.Duration)
	b += 2

	return buf
}

// Write struct list BellFeedbackState
func BellFeedbackStateListBytes(buf []byte, list []BellFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'LedFeedbackState' struct definition
// Size: 12
type LedFeedbackState struct {
	ClassId   byte
	Id        byte
	Len       uint16
	LedMask   uint32
	LedValues uint32
}

// Struct read LedFeedbackState
func LedFeedbackStateRead(buf []byte, v *LedFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.LedMask = xgb.Get32(buf[b:])
	b += 4

	v.LedValues = xgb.Get32(buf[b:])
	b += 4

	return b
}

// Struct list read LedFeedbackState
func LedFeedbackStateReadList(buf []byte, dest []LedFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = LedFeedbackState{}
		b += LedFeedbackStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write LedFeedbackState
func (v LedFeedbackState) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], v.LedMask)
	b += 4

	xgb.Put32(buf[b:], v.LedValues)
	b += 4

	return buf
}

// Write struct list LedFeedbackState
func LedFeedbackStateListBytes(buf []byte, list []LedFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'FeedbackCtl' struct definition
// Size: 4
type FeedbackCtl struct {
	ClassId byte
	Id      byte
	Len     uint16
}

// Struct read FeedbackCtl
func FeedbackCtlRead(buf []byte, v *FeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	return b
}

// Struct list read FeedbackCtl
func FeedbackCtlReadList(buf []byte, dest []FeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = FeedbackCtl{}
		b += FeedbackCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write FeedbackCtl
func (v FeedbackCtl) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	return buf
}

// Write struct list FeedbackCtl
func FeedbackCtlListBytes(buf []byte, list []FeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'KbdFeedbackCtl' struct definition
// Size: 20
type KbdFeedbackCtl struct {
	ClassId         byte
	Id              byte
	Len             uint16
	Key             KeyCode
	AutoRepeatMode  byte
	KeyClickPercent int8
	BellPercent     int8
	BellPitch       int16
	BellDuration    int16
	LedMask         uint32
	LedValues       uint32
}

// Struct read KbdFeedbackCtl
func KbdFeedbackCtlRead(buf []byte, v *KbdFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Key = KeyCode(buf[b])
	b += 1

	v.AutoRepeatMode = buf[b]
	b += 1

	v.KeyClickPercent = int8(buf[b])
	b += 1

	v.BellPercent = int8(buf[b])
	b += 1

	v.BellPitch = int16(xgb.Get16(buf[b:]))
	b += 2

	v.BellDuration = int16(xgb.Get16(buf[b:]))
	b += 2

	v.LedMask = xgb.Get32(buf[b:])
	b += 4

	v.LedValues = xgb.Get32(buf[b:])
	b += 4

	return b
}

// Struct list read KbdFeedbackCtl
func KbdFeedbackCtlReadList(buf []byte, dest []KbdFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = KbdFeedbackCtl{}
		b += KbdFeedbackCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write KbdFeedbackCtl
func (v KbdFeedbackCtl) Bytes() []byte {
	buf := make([]byte, 20)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	buf[b] = byte(v.Key)
	b += 1

	buf[b] = v.AutoRepeatMode
	b += 1

	buf[b] = byte(v.KeyClickPercent)
	b += 1

	buf[b] = byte(v.BellPercent)
	b += 1

	xgb.Put16(buf[b:], uint16(v.BellPitch))
	b += 2

	xgb.Put16(buf[b:], uint16(v.BellDuration))
	b += 2

	xgb.Put32(buf[b:], v.LedMask)
	b += 4

	xgb.Put32(buf[b:], v.LedValues)
	b += 4

	return buf
}

// Write struct list KbdFeedbackCtl
func KbdFeedbackCtlListBytes(buf []byte, list []KbdFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'PtrFeedbackCtl' struct definition
// Size: 12
type PtrFeedbackCtl struct {
	ClassId byte
	Id      byte
	Len     uint16
	// padding: 2 bytes
	Num       int16
	Denom     int16
	Threshold int16
}

// Struct read PtrFeedbackCtl
func PtrFeedbackCtlRead(buf []byte, v *PtrFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.Num = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Denom = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Threshold = int16(xgb.Get16(buf[b:]))
	b += 2

	return b
}

// Struct list read PtrFeedbackCtl
func PtrFeedbackCtlReadList(buf []byte, dest []PtrFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = PtrFeedbackCtl{}
		b += PtrFeedbackCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write PtrFeedbackCtl
func (v PtrFeedbackCtl) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	b += 2 // padding

	xgb.Put16(buf[b:], uint16(v.Num))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Denom))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Threshold))
	b += 2

	return buf
}

// Write struct list PtrFeedbackCtl
func PtrFeedbackCtlListBytes(buf []byte, list []PtrFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'IntegerFeedbackCtl' struct definition
// Size: 8
type IntegerFeedbackCtl struct {
	ClassId      byte
	Id           byte
	Len          uint16
	IntToDisplay int32
}

// Struct read IntegerFeedbackCtl
func IntegerFeedbackCtlRead(buf []byte, v *IntegerFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.IntToDisplay = int32(xgb.Get32(buf[b:]))
	b += 4

	return b
}

// Struct list read IntegerFeedbackCtl
func IntegerFeedbackCtlReadList(buf []byte, dest []IntegerFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = IntegerFeedbackCtl{}
		b += IntegerFeedbackCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write IntegerFeedbackCtl
func (v IntegerFeedbackCtl) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], uint32(v.IntToDisplay))
	b += 4

	return buf
}

// Write struct list IntegerFeedbackCtl
func IntegerFeedbackCtlListBytes(buf []byte, list []IntegerFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'StringFeedbackCtl' struct definition
// Size: (8 + xgb.Pad((int(NumKeysyms) * 4)))
type StringFeedbackCtl struct {
	ClassId byte
	Id      byte
	Len     uint16
	// padding: 2 bytes
	NumKeysyms uint16
	Keysyms    []xproto.Keysym // size: xgb.Pad((int(NumKeysyms) * 4))
}

// Struct read StringFeedbackCtl
func StringFeedbackCtlRead(buf []byte, v *StringFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.NumKeysyms = xgb.Get16(buf[b:])
	b += 2

	v.Keysyms = make([]xproto.Keysym, v.NumKeysyms)
	for i := 0; i < int(v.NumKeysyms); i++ {
		v.Keysyms[i] = xproto.Keysym(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return b
}

// Struct list read StringFeedbackCtl
func StringFeedbackCtlReadList(buf []byte, dest []StringFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = StringFeedbackCtl{}
		b += StringFeedbackCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write StringFeedbackCtl
func (v StringFeedbackCtl) Bytes() []byte {
	buf := make([]byte, (8 + xgb.Pad((int(v.NumKeysyms) * 4))))
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	b += 2 // padding

	xgb.Put16(buf[b:], v.NumKeysyms)
	b += 2

	for i := 0; i < int(v.NumKeysyms); i++ {
		xgb.Put32(buf[b:], uint32(v.Keysyms[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Write struct list StringFeedbackCtl
func StringFeedbackCtlListBytes(buf []byte, list []StringFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size StringFeedbackCtl
func StringFeedbackCtlListSize(list []StringFeedbackCtl) int {
	size := 0
	for _, item := range list {
		size += (8 + xgb.Pad((int(item.NumKeysyms) * 4)))
	}
	return size
}

// 'BellFeedbackCtl' struct definition
// Size: 12
type BellFeedbackCtl struct {
	ClassId byte
	Id      byte
	Len     uint16
	Percent int8
	// padding: 3 bytes
	Pitch    int16
	Duration int16
}

// Struct read BellFeedbackCtl
func BellFeedbackCtlRead(buf []byte, v *BellFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Percent = int8(buf[b])
	b += 1

	b += 3 // padding

	v.Pitch = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Duration = int16(xgb.Get16(buf[b:]))
	b += 2

	return b
}

// Struct list read BellFeedbackCtl
func BellFeedbackCtlReadList(buf []byte, dest []BellFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = BellFeedbackCtl{}
		b += BellFeedbackCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write BellFeedbackCtl
func (v BellFeedbackCtl) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	buf[b] = byte(v.Percent)
	b += 1

	b += 3 // padding

	xgb.Put16(buf[b:], uint16(v.Pitch))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Duration))
	b += 2

	return buf
}

// Write struct list BellFeedbackCtl
func BellFeedbackCtlListBytes(buf []byte, list []BellFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'LedFeedbackCtl' struct definition
// Size: 12
type LedFeedbackCtl struct {
	ClassId   byte
	Id        byte
	Len       uint16
	LedMask   uint32
	LedValues uint32
}

// Struct read LedFeedbackCtl
func LedFeedbackCtlRead(buf []byte, v *LedFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.LedMask = xgb.Get32(buf[b:])
	b += 4

	v.LedValues = xgb.Get32(buf[b:])
	b += 4

	return b
}

// Struct list read LedFeedbackCtl
func LedFeedbackCtlReadList(buf []byte, dest []LedFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = LedFeedbackCtl{}
		b += LedFeedbackCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write LedFeedbackCtl
func (v LedFeedbackCtl) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], v.LedMask)
	b += 4

	xgb.Put32(buf[b:], v.LedValues)
	b += 4

	return buf
}

// Write struct list LedFeedbackCtl
func LedFeedbackCtlListBytes(buf []byte, list []LedFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'InputState' struct definition
// Size: 3
type InputState struct {
	ClassId  byte
	Len      byte
	NumItems byte
}

// Struct read InputState
func InputStateRead(buf []byte, v *InputState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.NumItems = buf[b]
	b += 1

	return b
}

// Struct list read InputState
func InputStateReadList(buf []byte, dest []InputState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = InputState{}
		b += InputStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write InputState
func (v InputState) Bytes() []byte {
	buf := make([]byte, 3)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = v.NumItems
	b += 1

	return buf
}

// Write struct list InputState
func InputStateListBytes(buf []byte, list []InputState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'KeyState' struct definition
// Size: 36
type KeyState struct {
	ClassId byte
	Len     byte
	NumKeys byte
	// padding: 1 bytes
	Keys []byte // size: 32
}

// Struct read KeyState
func KeyStateRead(buf []byte, v *KeyState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.NumKeys = buf[b]
	b += 1

	b += 1 // padding

	v.Keys = make([]byte, 32)
	copy(v.Keys[:32], buf[b:])
	b += xgb.Pad(int(32))

	return b
}

// Struct list read KeyState
func KeyStateReadList(buf []byte, dest []KeyState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = KeyState{}
		b += KeyStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write KeyState
func (v KeyState) Bytes() []byte {
	buf := make([]byte, 36)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = v.NumKeys
	b += 1

	b += 1 // padding

	copy(buf[b:], v.Keys[:32])
	b += xgb.Pad(int(32))

	return buf
}

// Write struct list KeyState
func KeyStateListBytes(buf []byte, list []KeyState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size KeyState
func KeyStateListSize(list []KeyState) int {
	size := 0
	for _ = range list {
		size += 36
	}
	return size
}

// 'ButtonState' struct definition
// Size: 36
type ButtonState struct {
	ClassId    byte
	Len        byte
	NumButtons byte
	// padding: 1 bytes
	Buttons []byte // size: 32
}

// Struct read ButtonState
func ButtonStateRead(buf []byte, v *ButtonState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.NumButtons = buf[b]
	b += 1

	b += 1 // padding

	v.Buttons = make([]byte, 32)
	copy(v.Buttons[:32], buf[b:])
	b += xgb.Pad(int(32))

	return b
}

// Struct list read ButtonState
func ButtonStateReadList(buf []byte, dest []ButtonState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ButtonState{}
		b += ButtonStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write ButtonState
func (v ButtonState) Bytes() []byte {
	buf := make([]byte, 36)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = v.NumButtons
	b += 1

	b += 1 // padding

	copy(buf[b:], v.Buttons[:32])
	b += xgb.Pad(int(32))

	return buf
}

// Write struct list ButtonState
func ButtonStateListBytes(buf []byte, list []ButtonState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size ButtonState
func ButtonStateListSize(list []ButtonState) int {
	size := 0
	for _ = range list {
		size += 36
	}
	return size
}

// 'ValuatorState' struct definition
// Size: (4 + xgb.Pad((int(NumValuators) * 4)))
type ValuatorState struct {
	ClassId      byte
	Len          byte
	NumValuators byte
	Mode         byte
	Valuators    []uint32 // size: xgb.Pad((int(NumValuators) * 4))
}

// Struct read ValuatorState
func ValuatorStateRead(buf []byte, v *ValuatorState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.NumValuators = buf[b]
	b += 1

	v.Mode = buf[b]
	b += 1

	v.Valuators = make([]uint32, v.NumValuators)
	for i := 0; i < int(v.NumValuators); i++ {
		v.Valuators[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return b
}

// Struct list read ValuatorState
func ValuatorStateReadList(buf []byte, dest []ValuatorState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ValuatorState{}
		b += ValuatorStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write ValuatorState
func (v ValuatorState) Bytes() []byte {
	buf := make([]byte, (4 + xgb.Pad((int(v.NumValuators) * 4))))
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = v.NumValuators
	b += 1

	buf[b] = v.Mode
	b += 1

	for i := 0; i < int(v.NumValuators); i++ {
		xgb.Put32(buf[b:], v.Valuators[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Write struct list ValuatorState
func ValuatorStateListBytes(buf []byte, list []ValuatorState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size ValuatorState
func ValuatorStateListSize(list []ValuatorState) int {
	size := 0
	for _, item := range list {
		size += (4 + xgb.Pad((int(item.NumValuators) * 4)))
	}
	return size
}

// 'DeviceState' struct definition
// Size: 4
type DeviceState struct {
	ControlId uint16
	Len       uint16
}

// Struct read DeviceState
func DeviceStateRead(buf []byte, v *DeviceState) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	return b
}

// Struct list read DeviceState
func DeviceStateReadList(buf []byte, dest []DeviceState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceState{}
		b += DeviceStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write DeviceState
func (v DeviceState) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	return buf
}

// Write struct list DeviceState
func DeviceStateListBytes(buf []byte, list []DeviceState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'DeviceResolutionState' struct definition
// Size: (((8 + xgb.Pad((int(NumValuators) * 4))) + xgb.Pad((int(NumValuators) * 4))) + xgb.Pad((int(NumValuators) * 4)))
type DeviceResolutionState struct {
	ControlId        uint16
	Len              uint16
	NumValuators     uint32
	ResolutionValues []uint32 // size: xgb.Pad((int(NumValuators) * 4))
	ResolutionMin    []uint32 // size: xgb.Pad((int(NumValuators) * 4))
	ResolutionMax    []uint32 // size: xgb.Pad((int(NumValuators) * 4))
}

// Struct read DeviceResolutionState
func DeviceResolutionStateRead(buf []byte, v *DeviceResolutionState) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.NumValuators = xgb.Get32(buf[b:])
	b += 4

	v.ResolutionValues = make([]uint32, v.NumValuators)
	for i := 0; i < int(v.NumValuators); i++ {
		v.ResolutionValues[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	v.ResolutionMin = make([]uint32, v.NumValuators)
	for i := 0; i < int(v.NumValuators); i++ {
		v.ResolutionMin[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	v.ResolutionMax = make([]uint32, v.NumValuators)
	for i := 0; i < int(v.NumValuators); i++ {
		v.ResolutionMax[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return b
}

// Struct list read DeviceResolutionState
func DeviceResolutionStateReadList(buf []byte, dest []DeviceResolutionState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceResolutionState{}
		b += DeviceResolutionStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write DeviceResolutionState
func (v DeviceResolutionState) Bytes() []byte {
	buf := make([]byte, (((8 + xgb.Pad((int(v.NumValuators) * 4))) + xgb.Pad((int(v.NumValuators) * 4))) + xgb.Pad((int(v.NumValuators) * 4))))
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], v.NumValuators)
	b += 4

	for i := 0; i < int(v.NumValuators); i++ {
		xgb.Put32(buf[b:], v.ResolutionValues[i])
		b += 4
	}
	b = xgb.Pad(b)

	for i := 0; i < int(v.NumValuators); i++ {
		xgb.Put32(buf[b:], v.ResolutionMin[i])
		b += 4
	}
	b = xgb.Pad(b)

	for i := 0; i < int(v.NumValuators); i++ {
		xgb.Put32(buf[b:], v.ResolutionMax[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Write struct list DeviceResolutionState
func DeviceResolutionStateListBytes(buf []byte, list []DeviceResolutionState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size DeviceResolutionState
func DeviceResolutionStateListSize(list []DeviceResolutionState) int {
	size := 0
	for _, item := range list {
		size += (((8 + xgb.Pad((int(item.NumValuators) * 4))) + xgb.Pad((int(item.NumValuators) * 4))) + xgb.Pad((int(item.NumValuators) * 4)))
	}
	return size
}

// 'DeviceAbsCalibState' struct definition
// Size: 36
type DeviceAbsCalibState struct {
	ControlId       uint16
	Len             uint16
	MinX            int32
	MaxX            int32
	MinY            int32
	MaxY            int32
	FlipX           uint32
	FlipY           uint32
	Rotation        uint32
	ButtonThreshold uint32
}

// Struct read DeviceAbsCalibState
func DeviceAbsCalibStateRead(buf []byte, v *DeviceAbsCalibState) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.MinX = int32(xgb.Get32(buf[b:]))
	b += 4

	v.MaxX = int32(xgb.Get32(buf[b:]))
	b += 4

	v.MinY = int32(xgb.Get32(buf[b:]))
	b += 4

	v.MaxY = int32(xgb.Get32(buf[b:]))
	b += 4

	v.FlipX = xgb.Get32(buf[b:])
	b += 4

	v.FlipY = xgb.Get32(buf[b:])
	b += 4

	v.Rotation = xgb.Get32(buf[b:])
	b += 4

	v.ButtonThreshold = xgb.Get32(buf[b:])
	b += 4

	return b
}

// Struct list read DeviceAbsCalibState
func DeviceAbsCalibStateReadList(buf []byte, dest []DeviceAbsCalibState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceAbsCalibState{}
		b += DeviceAbsCalibStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write DeviceAbsCalibState
func (v DeviceAbsCalibState) Bytes() []byte {
	buf := make([]byte, 36)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], uint32(v.MinX))
	b += 4

	xgb.Put32(buf[b:], uint32(v.MaxX))
	b += 4

	xgb.Put32(buf[b:], uint32(v.MinY))
	b += 4

	xgb.Put32(buf[b:], uint32(v.MaxY))
	b += 4

	xgb.Put32(buf[b:], v.FlipX)
	b += 4

	xgb.Put32(buf[b:], v.FlipY)
	b += 4

	xgb.Put32(buf[b:], v.Rotation)
	b += 4

	xgb.Put32(buf[b:], v.ButtonThreshold)
	b += 4

	return buf
}

// Write struct list DeviceAbsCalibState
func DeviceAbsCalibStateListBytes(buf []byte, list []DeviceAbsCalibState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'DeviceAbsAreaState' struct definition
// Size: 28
type DeviceAbsAreaState struct {
	ControlId uint16
	Len       uint16
	OffsetX   uint32
	OffsetY   uint32
	Width     uint32
	Height    uint32
	Screen    uint32
	Following uint32
}

// Struct read DeviceAbsAreaState
func DeviceAbsAreaStateRead(buf []byte, v *DeviceAbsAreaState) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.OffsetX = xgb.Get32(buf[b:])
	b += 4

	v.OffsetY = xgb.Get32(buf[b:])
	b += 4

	v.Width = xgb.Get32(buf[b:])
	b += 4

	v.Height = xgb.Get32(buf[b:])
	b += 4

	v.Screen = xgb.Get32(buf[b:])
	b += 4

	v.Following = xgb.Get32(buf[b:])
	b += 4

	return b
}

// Struct list read DeviceAbsAreaState
func DeviceAbsAreaStateReadList(buf []byte, dest []DeviceAbsAreaState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceAbsAreaState{}
		b += DeviceAbsAreaStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write DeviceAbsAreaState
func (v DeviceAbsAreaState) Bytes() []byte {
	buf := make([]byte, 28)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], v.OffsetX)
	b += 4

	xgb.Put32(buf[b:], v.OffsetY)
	b += 4

	xgb.Put32(buf[b:], v.Width)
	b += 4

	xgb.Put32(buf[b:], v.Height)
	b += 4

	xgb.Put32(buf[b:], v.Screen)
	b += 4

	xgb.Put32(buf[b:], v.Following)
	b += 4

	return buf
}

// Write struct list DeviceAbsAreaState
func DeviceAbsAreaStateListBytes(buf []byte, list []DeviceAbsAreaState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'DeviceCoreState' struct definition
// Size: 8
type DeviceCoreState struct {
	ControlId uint16
	Len       uint16
	Status    byte
	Iscore    byte
	// padding: 2 bytes
}

// Struct read DeviceCoreState
func DeviceCoreStateRead(buf []byte, v *DeviceCoreState) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Status = buf[b]
	b += 1

	v.Iscore = buf[b]
	b += 1

	b += 2 // padding

	return b
}

// Struct list read DeviceCoreState
func DeviceCoreStateReadList(buf []byte, dest []DeviceCoreState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceCoreState{}
		b += DeviceCoreStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write DeviceCoreState
func (v DeviceCoreState) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.Status
	b += 1

	buf[b] = v.Iscore
	b += 1

	b += 2 // padding

	return buf
}

// Write struct list DeviceCoreState
func DeviceCoreStateListBytes(buf []byte, list []DeviceCoreState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'DeviceEnableState' struct definition
// Size: 8
type DeviceEnableState struct {
	ControlId uint16
	Len       uint16
	Enable    byte
	// padding: 3 bytes
}

// Struct read DeviceEnableState
func DeviceEnableStateRead(buf []byte, v *DeviceEnableState) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Enable = buf[b]
	b += 1

	b += 3 // padding

	return b
}

// Struct list read DeviceEnableState
func DeviceEnableStateReadList(buf []byte, dest []DeviceEnableState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceEnableState{}
		b += DeviceEnableStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write DeviceEnableState
func (v DeviceEnableState) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.Enable
	b += 1

	b += 3 // padding

	return buf
}

// Write struct list DeviceEnableState
func DeviceEnableStateListBytes(buf []byte, list []DeviceEnableState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'DeviceCtl' struct definition
// Size: 4
type DeviceCtl struct {
	ControlId uint16
	Len       uint16
}

// Struct read DeviceCtl
func DeviceCtlRead(buf []byte, v *DeviceCtl) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	return b
}

// Struct list read DeviceCtl
func DeviceCtlReadList(buf []byte, dest []DeviceCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceCtl{}
		b += DeviceCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write DeviceCtl
func (v DeviceCtl) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	return buf
}

// Write struct list DeviceCtl
func DeviceCtlListBytes(buf []byte, list []DeviceCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'DeviceResolutionCtl' struct definition
// Size: (6 + xgb.Pad((int(NumValuators) * 4)))
type DeviceResolutionCtl struct {
	ControlId        uint16
	Len              uint16
	FirstValuator    byte
	NumValuators     byte
	ResolutionValues []uint32 // size: xgb.Pad((int(NumValuators) * 4))
}

// Struct read DeviceResolutionCtl
func DeviceResolutionCtlRead(buf []byte, v *DeviceResolutionCtl) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.FirstValuator = buf[b]
	b += 1

	v.NumValuators = buf[b]
	b += 1

	v.ResolutionValues = make([]uint32, v.NumValuators)
	for i := 0; i < int(v.NumValuators); i++ {
		v.ResolutionValues[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return b
}

// Struct list read DeviceResolutionCtl
func DeviceResolutionCtlReadList(buf []byte, dest []DeviceResolutionCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceResolutionCtl{}
		b += DeviceResolutionCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write DeviceResolutionCtl
func (v DeviceResolutionCtl) Bytes() []byte {
	buf := make([]byte, (6 + xgb.Pad((int(v.NumValuators) * 4))))
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.FirstValuator
	b += 1

	buf[b] = v.NumValuators
	b += 1

	for i := 0; i < int(v.NumValuators); i++ {
		xgb.Put32(buf[b:], v.ResolutionValues[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Write struct list DeviceResolutionCtl
func DeviceResolutionCtlListBytes(buf []byte, list []DeviceResolutionCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size DeviceResolutionCtl
func DeviceResolutionCtlListSize(list []DeviceResolutionCtl) int {
	size := 0
	for _, item := range list {
		size += (6 + xgb.Pad((int(item.NumValuators) * 4)))
	}
	return size
}

// 'DeviceAbsCalibCtl' struct definition
// Size: 36
type DeviceAbsCalibCtl struct {
	ControlId       uint16
	Len             uint16
	MinX            int32
	MaxX            int32
	MinY            int32
	MaxY            int32
	FlipX           uint32
	FlipY           uint32
	Rotation        uint32
	ButtonThreshold uint32
}

// Struct read DeviceAbsCalibCtl
func DeviceAbsCalibCtlRead(buf []byte, v *DeviceAbsCalibCtl) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.MinX = int32(xgb.Get32(buf[b:]))
	b += 4

	v.MaxX = int32(xgb.Get32(buf[b:]))
	b += 4

	v.MinY = int32(xgb.Get32(buf[b:]))
	b += 4

	v.MaxY = int32(xgb.Get32(buf[b:]))
	b += 4

	v.FlipX = xgb.Get32(buf[b:])
	b += 4

	v.FlipY = xgb.Get32(buf[b:])
	b += 4

	v.Rotation = xgb.Get32(buf[b:])
	b += 4

	v.ButtonThreshold = xgb.Get32(buf[b:])
	b += 4

	return b
}

// Struct list read DeviceAbsCalibCtl
func DeviceAbsCalibCtlReadList(buf []byte, dest []DeviceAbsCalibCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceAbsCalibCtl{}
		b += DeviceAbsCalibCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write DeviceAbsCalibCtl
func (v DeviceAbsCalibCtl) Bytes() []byte {
	buf := make([]byte, 36)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], uint32(v.MinX))
	b += 4

	xgb.Put32(buf[b:], uint32(v.MaxX))
	b += 4

	xgb.Put32(buf[b:], uint32(v.MinY))
	b += 4

	xgb.Put32(buf[b:], uint32(v.MaxY))
	b += 4

	xgb.Put32(buf[b:], v.FlipX)
	b += 4

	xgb.Put32(buf[b:], v.FlipY)
	b += 4

	xgb.Put32(buf[b:], v.Rotation)
	b += 4

	xgb.Put32(buf[b:], v.ButtonThreshold)
	b += 4

	return buf
}

// Write struct list DeviceAbsCalibCtl
func DeviceAbsCalibCtlListBytes(buf []byte, list []DeviceAbsCalibCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'DeviceAbsAreaCtrl' struct definition
// Size: 28
type DeviceAbsAreaCtrl struct {
	ControlId uint16
	Len       uint16
	OffsetX   uint32
	OffsetY   uint32
	Width     int32
	Height    int32
	Screen    int32
	Following uint32
}

// Struct read DeviceAbsAreaCtrl
func DeviceAbsAreaCtrlRead(buf []byte, v *DeviceAbsAreaCtrl) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.OffsetX = xgb.Get32(buf[b:])
	b += 4

	v.OffsetY = xgb.Get32(buf[b:])
	b += 4

	v.Width = int32(xgb.Get32(buf[b:]))
	b += 4

	v.Height = int32(xgb.Get32(buf[b:]))
	b += 4

	v.Screen = int32(xgb.Get32(buf[b:]))
	b += 4

	v.Following = xgb.Get32(buf[b:])
	b += 4

	return b
}

// Struct list read DeviceAbsAreaCtrl
func DeviceAbsAreaCtrlReadList(buf []byte, dest []DeviceAbsAreaCtrl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceAbsAreaCtrl{}
		b += DeviceAbsAreaCtrlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write DeviceAbsAreaCtrl
func (v DeviceAbsAreaCtrl) Bytes() []byte {
	buf := make([]byte, 28)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], v.OffsetX)
	b += 4

	xgb.Put32(buf[b:], v.OffsetY)
	b += 4

	xgb.Put32(buf[b:], uint32(v.Width))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Height))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Screen))
	b += 4

	xgb.Put32(buf[b:], v.Following)
	b += 4

	return buf
}

// Write struct list DeviceAbsAreaCtrl
func DeviceAbsAreaCtrlListBytes(buf []byte, list []DeviceAbsAreaCtrl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'DeviceCoreCtrl' struct definition
// Size: 8
type DeviceCoreCtrl struct {
	ControlId uint16
	Len       uint16
	Status    byte
	// padding: 3 bytes
}

// Struct read DeviceCoreCtrl
func DeviceCoreCtrlRead(buf []byte, v *DeviceCoreCtrl) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Status = buf[b]
	b += 1

	b += 3 // padding

	return b
}

// Struct list read DeviceCoreCtrl
func DeviceCoreCtrlReadList(buf []byte, dest []DeviceCoreCtrl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceCoreCtrl{}
		b += DeviceCoreCtrlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write DeviceCoreCtrl
func (v DeviceCoreCtrl) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.Status
	b += 1

	b += 3 // padding

	return buf
}

// Write struct list DeviceCoreCtrl
func DeviceCoreCtrlListBytes(buf []byte, list []DeviceCoreCtrl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'DeviceEnableCtrl' struct definition
// Size: 8
type DeviceEnableCtrl struct {
	ControlId uint16
	Len       uint16
	Enable    byte
	// padding: 3 bytes
}

// Struct read DeviceEnableCtrl
func DeviceEnableCtrlRead(buf []byte, v *DeviceEnableCtrl) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Enable = buf[b]
	b += 1

	b += 3 // padding

	return b
}

// Struct list read DeviceEnableCtrl
func DeviceEnableCtrlReadList(buf []byte, dest []DeviceEnableCtrl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceEnableCtrl{}
		b += DeviceEnableCtrlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write DeviceEnableCtrl
func (v DeviceEnableCtrl) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.Enable
	b += 1

	b += 3 // padding

	return buf
}

// Write struct list DeviceEnableCtrl
func DeviceEnableCtrlListBytes(buf []byte, list []DeviceEnableCtrl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Event definition DeviceValuator (0)
// Size: 32

const DeviceValuator = 0

type DeviceValuatorEvent struct {
	Sequence      uint16
	DeviceId      byte
	DeviceState   uint16
	NumValuators  byte
	FirstValuator byte
	Valuators     []int32 // size: 24
}

// Event read DeviceValuator
func DeviceValuatorEventNew(buf []byte) xgb.Event {
	v := DeviceValuatorEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.DeviceState = xgb.Get16(buf[b:])
	b += 2

	v.NumValuators = buf[b]
	b += 1

	v.FirstValuator = buf[b]
	b += 1

	v.Valuators = make([]int32, 6)
	for i := 0; i < int(6); i++ {
		v.Valuators[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Event write DeviceValuator
func (v DeviceValuatorEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 0
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	xgb.Put16(buf[b:], v.DeviceState)
	b += 2

	buf[b] = v.NumValuators
	b += 1

	buf[b] = v.FirstValuator
	b += 1

	for i := 0; i < int(6); i++ {
		xgb.Put32(buf[b:], uint32(v.Valuators[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

func (v DeviceValuatorEvent) ImplementsEvent() {}

func (v DeviceValuatorEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v DeviceValuatorEvent) String() string {
	fieldVals := make([]string, 0, 5)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceState: %d", v.DeviceState))
	fieldVals = append(fieldVals, xgb.Sprintf("NumValuators: %d", v.NumValuators))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstValuator: %d", v.FirstValuator))
	return "DeviceValuator {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][0] = DeviceValuatorEventNew
}

// Event definition DeviceKeyPress (1)
// Size: 32

const DeviceKeyPress = 1

type DeviceKeyPressEvent struct {
	Sequence   uint16
	Detail     byte
	Time       xproto.Timestamp
	Root       xproto.Window
	Event      xproto.Window
	Child      xproto.Window
	RootX      int16
	RootY      int16
	EventX     int16
	EventY     int16
	State      uint16
	SameScreen bool
	DeviceId   byte
}

// Event read DeviceKeyPress
func DeviceKeyPressEventNew(buf []byte) xgb.Event {
	v := DeviceKeyPressEvent{}
	b := 1 // don't read event number

	v.Detail = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Root = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.Event = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.Child = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.RootX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.RootY = int16(xgb.Get16(buf[b:]))
	b += 2

	v.EventX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.EventY = int16(xgb.Get16(buf[b:]))
	b += 2

	v.State = xgb.Get16(buf[b:])
	b += 2

	if buf[b] == 1 {
		v.SameScreen = true
	} else {
		v.SameScreen = false
	}
	b += 1

	v.DeviceId = buf[b]
	b += 1

	return v
}

// Event write DeviceKeyPress
func (v DeviceKeyPressEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 1
	b += 1

	buf[b] = v.Detail
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Root))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Event))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Child))
	b += 4

	xgb.Put16(buf[b:], uint16(v.RootX))
	b += 2

	xgb.Put16(buf[b:], uint16(v.RootY))
	b += 2

	xgb.Put16(buf[b:], uint16(v.EventX))
	b += 2

	xgb.Put16(buf[b:], uint16(v.EventY))
	b += 2

	xgb.Put16(buf[b:], v.State)
	b += 2

	if v.SameScreen {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	buf[b] = v.DeviceId
	b += 1

	return buf
}

func (v DeviceKeyPressEvent) ImplementsEvent() {}

func (v DeviceKeyPressEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v DeviceKeyPressEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "DeviceKeyPress {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][1] = DeviceKeyPressEventNew
}

// Event definition FocusIn (6)
// Size: 32

const FocusIn = 6

type FocusInEvent struct {
	Sequence uint16
	Detail   byte
	Time     xproto.Timestamp
	Window   xproto.Window
	Mode     byte
	DeviceId byte
	// padding: 18 bytes
}

// Event read FocusIn
func FocusInEventNew(buf []byte) xgb.Event {
	v := FocusInEvent{}
	b := 1 // don't read event number

	v.Detail = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Window = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.Mode = buf[b]
	b += 1

	v.DeviceId = buf[b]
	b += 1

	b += 18 // padding

	return v
}

// Event write FocusIn
func (v FocusInEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 6
	b += 1

	buf[b] = v.Detail
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	buf[b] = v.Mode
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 18 // padding

	return buf
}

func (v FocusInEvent) ImplementsEvent() {}

func (v FocusInEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v FocusInEvent) String() string {
	fieldVals := make([]string, 0, 6)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("Mode: %d", v.Mode))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "FocusIn {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][6] = FocusInEventNew
}

// Event definition DeviceStateNotify (10)
// Size: 32

const DeviceStateNotify = 10

type DeviceStateNotifyEvent struct {
	Sequence        uint16
	DeviceId        byte
	Time            xproto.Timestamp
	NumKeys         byte
	NumButtons      byte
	NumValuators    byte
	ClassesReported byte
	Buttons         []byte   // size: 4
	Keys            []byte   // size: 4
	Valuators       []uint32 // size: 12
}

// Event read DeviceStateNotify
func DeviceStateNotifyEventNew(buf []byte) xgb.Event {
	v := DeviceStateNotifyEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.NumKeys = buf[b]
	b += 1

	v.NumButtons = buf[b]
	b += 1

	v.NumValuators = buf[b]
	b += 1

	v.ClassesReported = buf[b]
	b += 1

	v.Buttons = make([]byte, 4)
	copy(v.Buttons[:4], buf[b:])
	b += xgb.Pad(int(4))

	v.Keys = make([]byte, 4)
	copy(v.Keys[:4], buf[b:])
	b += xgb.Pad(int(4))

	v.Valuators = make([]uint32, 3)
	for i := 0; i < int(3); i++ {
		v.Valuators[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Event write DeviceStateNotify
func (v DeviceStateNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 10
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.NumKeys
	b += 1

	buf[b] = v.NumButtons
	b += 1

	buf[b] = v.NumValuators
	b += 1

	buf[b] = v.ClassesReported
	b += 1

	copy(buf[b:], v.Buttons[:4])
	b += xgb.Pad(int(4))

	copy(buf[b:], v.Keys[:4])
	b += xgb.Pad(int(4))

	for i := 0; i < int(3); i++ {
		xgb.Put32(buf[b:], v.Valuators[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

func (v DeviceStateNotifyEvent) ImplementsEvent() {}

func (v DeviceStateNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v DeviceStateNotifyEvent) String() string {
	fieldVals := make([]string, 0, 9)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("NumKeys: %d", v.NumKeys))
	fieldVals = append(fieldVals, xgb.Sprintf("NumButtons: %d", v.NumButtons))
	fieldVals = append(fieldVals, xgb.Sprintf("NumValuators: %d", v.NumValuators))
	fieldVals = append(fieldVals, xgb.Sprintf("ClassesReported: %d", v.ClassesReported))
	return "DeviceStateNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][10] = DeviceStateNotifyEventNew
}

// Event definition DeviceMappingNotify (11)
// Size: 32

const DeviceMappingNotify = 11

type DeviceMappingNotifyEvent struct {
	Sequence     uint16
	DeviceId     byte
	Request      byte
	FirstKeycode KeyCode
	Count        byte
	// padding: 1 bytes
	Time xproto.Timestamp
	// padding: 20 bytes
}

// Event read DeviceMappingNotify
func DeviceMappingNotifyEventNew(buf []byte) xgb.Event {
	v := DeviceMappingNotifyEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Request = buf[b]
	b += 1

	v.FirstKeycode = KeyCode(buf[b])
	b += 1

	v.Count = buf[b]
	b += 1

	b += 1 // padding

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	b += 20 // padding

	return v
}

// Event write DeviceMappingNotify
func (v DeviceMappingNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 11
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	buf[b] = v.Request
	b += 1

	buf[b] = byte(v.FirstKeycode)
	b += 1

	buf[b] = v.Count
	b += 1

	b += 1 // padding

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	b += 20 // padding

	return buf
}

func (v DeviceMappingNotifyEvent) ImplementsEvent() {}

func (v DeviceMappingNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v DeviceMappingNotifyEvent) String() string {
	fieldVals := make([]string, 0, 7)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	fieldVals = append(fieldVals, xgb.Sprintf("Request: %d", v.Request))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstKeycode: %d", v.FirstKeycode))
	fieldVals = append(fieldVals, xgb.Sprintf("Count: %d", v.Count))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	return "DeviceMappingNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][11] = DeviceMappingNotifyEventNew
}

// Event definition ChangeDeviceNotify (12)
// Size: 32

const ChangeDeviceNotify = 12

type ChangeDeviceNotifyEvent struct {
	Sequence uint16
	DeviceId byte
	Time     xproto.Timestamp
	Request  byte
	// padding: 23 bytes
}

// Event read ChangeDeviceNotify
func ChangeDeviceNotifyEventNew(buf []byte) xgb.Event {
	v := ChangeDeviceNotifyEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Request = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Event write ChangeDeviceNotify
func (v ChangeDeviceNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 12
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.Request
	b += 1

	b += 23 // padding

	return buf
}

func (v ChangeDeviceNotifyEvent) ImplementsEvent() {}

func (v ChangeDeviceNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v ChangeDeviceNotifyEvent) String() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Request: %d", v.Request))
	return "ChangeDeviceNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][12] = ChangeDeviceNotifyEventNew
}

// Event definition DeviceKeyStateNotify (13)
// Size: 32

const DeviceKeyStateNotify = 13

type DeviceKeyStateNotifyEvent struct {
	Sequence uint16
	DeviceId byte
	Keys     []byte // size: 28
}

// Event read DeviceKeyStateNotify
func DeviceKeyStateNotifyEventNew(buf []byte) xgb.Event {
	v := DeviceKeyStateNotifyEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Keys = make([]byte, 28)
	copy(v.Keys[:28], buf[b:])
	b += xgb.Pad(int(28))

	return v
}

// Event write DeviceKeyStateNotify
func (v DeviceKeyStateNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 13
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	copy(buf[b:], v.Keys[:28])
	b += xgb.Pad(int(28))

	return buf
}

func (v DeviceKeyStateNotifyEvent) ImplementsEvent() {}

func (v DeviceKeyStateNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v DeviceKeyStateNotifyEvent) String() string {
	fieldVals := make([]string, 0, 2)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "DeviceKeyStateNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][13] = DeviceKeyStateNotifyEventNew
}

// Event definition DeviceButtonStateNotify (14)
// Size: 32

const DeviceButtonStateNotify = 14

type DeviceButtonStateNotifyEvent struct {
	Sequence uint16
	DeviceId byte
	Buttons  []byte // size: 28
}

// Event read DeviceButtonStateNotify
func DeviceButtonStateNotifyEventNew(buf []byte) xgb.Event {
	v := DeviceButtonStateNotifyEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Buttons = make([]byte, 28)
	copy(v.Buttons[:28], buf[b:])
	b += xgb.Pad(int(28))

	return v
}

// Event write DeviceButtonStateNotify
func (v DeviceButtonStateNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 14
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	copy(buf[b:], v.Buttons[:28])
	b += xgb.Pad(int(28))

	return buf
}

func (v DeviceButtonStateNotifyEvent) ImplementsEvent() {}

func (v DeviceButtonStateNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v DeviceButtonStateNotifyEvent) String() string {
	fieldVals := make([]string, 0, 2)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "DeviceButtonStateNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][14] = DeviceButtonStateNotifyEventNew
}

// Event definition DevicePresenceNotify (15)
// Size: 32

const DevicePresenceNotify = 15

type DevicePresenceNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Time      xproto.Timestamp
	Devchange byte
	DeviceId  byte
	Control   uint16
	// padding: 20 bytes
}

// Event read DevicePresenceNotify
func DevicePresenceNotifyEventNew(buf []byte) xgb.Event {
	v := DevicePresenceNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Devchange = buf[b]
	b += 1

	v.DeviceId = buf[b]
	b += 1

	v.Control = xgb.Get16(buf[b:])
	b += 2

	b += 20 // padding

	return v
}

// Event write DevicePresenceNotify
func (v DevicePresenceNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 15
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.Devchange
	b += 1

	buf[b] = v.DeviceId
	b += 1

	xgb.Put16(buf[b:], v.Control)
	b += 2

	b += 20 // padding

	return buf
}

func (v DevicePresenceNotifyEvent) ImplementsEvent() {}

func (v DevicePresenceNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v DevicePresenceNotifyEvent) String() string {
	fieldVals := make([]string, 0, 6)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Devchange: %d", v.Devchange))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	fieldVals = append(fieldVals, xgb.Sprintf("Control: %d", v.Control))
	return "DevicePresenceNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][15] = DevicePresenceNotifyEventNew
}

// EventCopy definition DeviceKeyRelease (2)

const DeviceKeyRelease = 2

type DeviceKeyReleaseEvent DeviceKeyPressEvent

func DeviceKeyReleaseEventNew(buf []byte) xgb.Event {
	return DeviceKeyReleaseEvent(DeviceKeyPressEventNew(buf).(DeviceKeyPressEvent))
}

func (v DeviceKeyReleaseEvent) Bytes() []byte {
	return DeviceKeyPressEvent(v).Bytes()
}

func (v DeviceKeyReleaseEvent) ImplementsEvent() {}

func (v DeviceKeyReleaseEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v DeviceKeyReleaseEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "DeviceKeyRelease {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][2] = DeviceKeyReleaseEventNew
}

// EventCopy definition DeviceButtonPress (3)

const DeviceButtonPress = 3

type DeviceButtonPressEvent DeviceKeyPressEvent

func DeviceButtonPressEventNew(buf []byte) xgb.Event {
	return DeviceButtonPressEvent(DeviceKeyPressEventNew(buf).(DeviceKeyPressEvent))
}

func (v DeviceButtonPressEvent) Bytes() []byte {
	return DeviceKeyPressEvent(v).Bytes()
}

func (v DeviceButtonPressEvent) ImplementsEvent() {}

func (v DeviceButtonPressEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v DeviceButtonPressEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "DeviceButtonPress {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][3] = DeviceButtonPressEventNew
}

// EventCopy definition DeviceButtonRelease (4)

const DeviceButtonRelease = 4

type DeviceButtonReleaseEvent DeviceKeyPressEvent

func DeviceButtonReleaseEventNew(buf []byte) xgb.Event {
	return DeviceButtonReleaseEvent(DeviceKeyPressEventNew(buf).(DeviceKeyPressEvent))
}

func (v DeviceButtonReleaseEvent) Bytes() []byte {
	return DeviceKeyPressEvent(v).Bytes()
}

func (v DeviceButtonReleaseEvent) ImplementsEvent() {}

func (v DeviceButtonReleaseEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v DeviceButtonReleaseEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "DeviceButtonRelease {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][4] = DeviceButtonReleaseEventNew
}

// EventCopy definition DeviceMotionNotify (5)

const DeviceMotionNotify = 5

type DeviceMotionNotifyEvent DeviceKeyPressEvent

func DeviceMotionNotifyEventNew(buf []byte) xgb.Event {
	return DeviceMotionNotifyEvent(DeviceKeyPressEventNew(buf).(DeviceKeyPressEvent))
}

func (v DeviceMotionNotifyEvent) Bytes() []byte {
	return DeviceKeyPressEvent(v).Bytes()
}

func (v DeviceMotionNotifyEvent) ImplementsEvent() {}

func (v DeviceMotionNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v DeviceMotionNotifyEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "DeviceMotionNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][5] = DeviceMotionNotifyEventNew
}

// EventCopy definition ProximityIn (8)

const ProximityIn = 8

type ProximityInEvent DeviceKeyPressEvent

func ProximityInEventNew(buf []byte) xgb.Event {
	return ProximityInEvent(DeviceKeyPressEventNew(buf).(DeviceKeyPressEvent))
}

func (v ProximityInEvent) Bytes() []byte {
	return DeviceKeyPressEvent(v).Bytes()
}

func (v ProximityInEvent) ImplementsEvent() {}

func (v ProximityInEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v ProximityInEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "ProximityIn {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][8] = ProximityInEventNew
}

// EventCopy definition ProximityOut (9)

const ProximityOut = 9

type ProximityOutEvent DeviceKeyPressEvent

func ProximityOutEventNew(buf []byte) xgb.Event {
	return ProximityOutEvent(DeviceKeyPressEventNew(buf).(DeviceKeyPressEvent))
}

func (v ProximityOutEvent) Bytes() []byte {
	return DeviceKeyPressEvent(v).Bytes()
}

func (v ProximityOutEvent) ImplementsEvent() {}

func (v ProximityOutEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v ProximityOutEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "ProximityOut {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][9] = ProximityOutEventNew
}

// EventCopy definition FocusOut (7)

const FocusOut = 7

type FocusOutEvent FocusInEvent

func FocusOutEventNew(buf []byte) xgb.Event {
	return FocusOutEvent(FocusInEventNew(buf).(FocusInEvent))
}

func (v FocusOutEvent) Bytes() []byte {
	return FocusInEvent(v).Bytes()
}

func (v FocusOutEvent) ImplementsEvent() {}

func (v FocusOutEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v FocusOutEvent) String() string {
	fieldVals := make([]string, 0, 6)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("Mode: %d", v.Mode))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "FocusOut {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][7] = FocusOutEventNew
}

// Error definition Device (0)
// Size: 32

const BadDevice = 0

type DeviceError struct {
	Sequence uint16
	NiceName string
}

// Error read Device
func DeviceErrorNew(buf []byte) xgb.Error {
	v := DeviceError{}
	v.NiceName = "Device"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

func (err DeviceError) ImplementsError() {}

func (err DeviceError) SequenceId() uint16 {
	return err.Sequence
}

func (err DeviceError) BadId() uint32 {
	return 0
}

func (err DeviceError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadDevice {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["XInputExtension"][0] = DeviceErrorNew
}

// Error definition Event (1)
// Size: 32

const BadEvent = 1

type EventError struct {
	Sequence uint16
	NiceName string
}

// Error read Event
func EventErrorNew(buf []byte) xgb.Error {
	v := EventError{}
	v.NiceName = "Event"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

func (err EventError) ImplementsError() {}

func (err EventError) SequenceId() uint16 {
	return err.Sequence
}

func (err EventError) BadId() uint32 {
	return 0
}

func (err EventError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadEvent {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["XInputExtension"][1] = EventErrorNew
}

// Error definition Mode (2)
// Size: 32

const BadMode = 2

type ModeError struct {
	Sequence uint16
	NiceName string
}

// Error read Mode
func ModeErrorNew(buf []byte) xgb.Error {
	v := ModeError{}
	v.NiceName = "Mode"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

func (err ModeError) ImplementsError() {}

func (err ModeError) SequenceId() uint16 {
	return err.Sequence
}

func (err ModeError) BadId() uint32 {
	return 0
}

func (err ModeError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadMode {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["XInputExtension"][2] = ModeErrorNew
}

// Error definition DeviceBusy (3)
// Size: 32

const BadDeviceBusy = 3

type DeviceBusyError struct {
	Sequence uint16
	NiceName string
}

// Error read DeviceBusy
func DeviceBusyErrorNew(buf []byte) xgb.Error {
	v := DeviceBusyError{}
	v.NiceName = "DeviceBusy"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

func (err DeviceBusyError) ImplementsError() {}

func (err DeviceBusyError) SequenceId() uint16 {
	return err.Sequence
}

func (err DeviceBusyError) BadId() uint32 {
	return 0
}

func (err DeviceBusyError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadDeviceBusy {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["XInputExtension"][3] = DeviceBusyErrorNew
}

// Error definition Class (4)
// Size: 32

const BadClass = 4

type ClassError struct {
	Sequence uint16
	NiceName string
}

// Error read Class
func ClassErrorNew(buf []byte) xgb.Error {
	v := ClassError{}
	v.NiceName = "Class"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

func (err ClassError) ImplementsError() {}

func (err ClassError) SequenceId() uint16 {
	return err.Sequence
}

func (err ClassError) BadId() uint32 {
	return 0
}

func (err ClassError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadClass {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["XInputExtension"][4] = ClassErrorNew
}

// Request GetExtensionVersion
// size: xgb.Pad((8 + xgb.Pad((int(NameLen) * 1))))
type GetExtensionVersionCookie struct {
	*xgb.Cookie
}

func GetExtensionVersion(c *xgb.Conn, NameLen uint16, Name string) GetExtensionVersionCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getExtensionVersionRequest(c, NameLen, Name), cookie)
	return GetExtensionVersionCookie{cookie}
}

func GetExtensionVersionUnchecked(c *xgb.Conn, NameLen uint16, Name string) GetExtensionVersionCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getExtensionVersionRequest(c, NameLen, Name), cookie)
	return GetExtensionVersionCookie{cookie}
}

// Request reply for GetExtensionVersion
// size: 32
type GetExtensionVersionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ServerMajor uint16
	ServerMinor uint16
	Present     bool
	// padding: 19 bytes
}

// Waits and reads reply data from request GetExtensionVersion
func (cook GetExtensionVersionCookie) Reply() (*GetExtensionVersionReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getExtensionVersionReply(buf), nil
}

// Read reply into structure from buffer for GetExtensionVersion
func getExtensionVersionReply(buf []byte) *GetExtensionVersionReply {
	v := new(GetExtensionVersionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ServerMajor = xgb.Get16(buf[b:])
	b += 2

	v.ServerMinor = xgb.Get16(buf[b:])
	b += 2

	if buf[b] == 1 {
		v.Present = true
	} else {
		v.Present = false
	}
	b += 1

	b += 19 // padding

	return v
}

// Write request to wire for GetExtensionVersion
func getExtensionVersionRequest(c *xgb.Conn, NameLen uint16, Name string) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(NameLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], NameLen)
	b += 2

	b += 2 // padding

	copy(buf[b:], Name[:NameLen])
	b += xgb.Pad(int(NameLen))

	return buf
}

// Request ListInputDevices
// size: 4
type ListInputDevicesCookie struct {
	*xgb.Cookie
}

func ListInputDevices(c *xgb.Conn) ListInputDevicesCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(listInputDevicesRequest(c), cookie)
	return ListInputDevicesCookie{cookie}
}

func ListInputDevicesUnchecked(c *xgb.Conn) ListInputDevicesCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(listInputDevicesRequest(c), cookie)
	return ListInputDevicesCookie{cookie}
}

// Request reply for ListInputDevices
// size: (32 + xgb.Pad((int(DevicesLen) * 8)))
type ListInputDevicesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	DevicesLen byte
	// padding: 23 bytes
	Devices []DeviceInfo // size: xgb.Pad((int(DevicesLen) * 8))
}

// Waits and reads reply data from request ListInputDevices
func (cook ListInputDevicesCookie) Reply() (*ListInputDevicesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listInputDevicesReply(buf), nil
}

// Read reply into structure from buffer for ListInputDevices
func listInputDevicesReply(buf []byte) *ListInputDevicesReply {
	v := new(ListInputDevicesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.DevicesLen = buf[b]
	b += 1

	b += 23 // padding

	v.Devices = make([]DeviceInfo, v.DevicesLen)
	b += DeviceInfoReadList(buf[b:], v.Devices)

	return v
}

// Write request to wire for ListInputDevices
func listInputDevicesRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request OpenDevice
// size: 8
type OpenDeviceCookie struct {
	*xgb.Cookie
}

func OpenDevice(c *xgb.Conn, DeviceId byte) OpenDeviceCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(openDeviceRequest(c, DeviceId), cookie)
	return OpenDeviceCookie{cookie}
}

func OpenDeviceUnchecked(c *xgb.Conn, DeviceId byte) OpenDeviceCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(openDeviceRequest(c, DeviceId), cookie)
	return OpenDeviceCookie{cookie}
}

// Request reply for OpenDevice
// size: (32 + xgb.Pad((int(NumClasses) * 2)))
type OpenDeviceReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumClasses byte
	// padding: 23 bytes
	ClassInfo []InputClassInfo // size: xgb.Pad((int(NumClasses) * 2))
}

// Waits and reads reply data from request OpenDevice
func (cook OpenDeviceCookie) Reply() (*OpenDeviceReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return openDeviceReply(buf), nil
}

// Read reply into structure from buffer for OpenDevice
func openDeviceReply(buf []byte) *OpenDeviceReply {
	v := new(OpenDeviceReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumClasses = buf[b]
	b += 1

	b += 23 // padding

	v.ClassInfo = make([]InputClassInfo, v.NumClasses)
	b += InputClassInfoReadList(buf[b:], v.ClassInfo)

	return v
}

// Write request to wire for OpenDevice
func openDeviceRequest(c *xgb.Conn, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// Request CloseDevice
// size: 8
type CloseDeviceCookie struct {
	*xgb.Cookie
}

// Write request to wire for CloseDevice
func CloseDevice(c *xgb.Conn, DeviceId byte) CloseDeviceCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(closeDeviceRequest(c, DeviceId), cookie)
	return CloseDeviceCookie{cookie}
}

func CloseDeviceChecked(c *xgb.Conn, DeviceId byte) CloseDeviceCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(closeDeviceRequest(c, DeviceId), cookie)
	return CloseDeviceCookie{cookie}
}

func (cook CloseDeviceCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CloseDevice
func closeDeviceRequest(c *xgb.Conn, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// Request SetDeviceMode
// size: 8
type SetDeviceModeCookie struct {
	*xgb.Cookie
}

func SetDeviceMode(c *xgb.Conn, DeviceId byte, Mode byte) SetDeviceModeCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(setDeviceModeRequest(c, DeviceId, Mode), cookie)
	return SetDeviceModeCookie{cookie}
}

func SetDeviceModeUnchecked(c *xgb.Conn, DeviceId byte, Mode byte) SetDeviceModeCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(setDeviceModeRequest(c, DeviceId, Mode), cookie)
	return SetDeviceModeCookie{cookie}
}

// Request reply for SetDeviceMode
// size: 32
type SetDeviceModeReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Waits and reads reply data from request SetDeviceMode
func (cook SetDeviceModeCookie) Reply() (*SetDeviceModeReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return setDeviceModeReply(buf), nil
}

// Read reply into structure from buffer for SetDeviceMode
func setDeviceModeReply(buf []byte) *SetDeviceModeReply {
	v := new(SetDeviceModeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for SetDeviceMode
func setDeviceModeRequest(c *xgb.Conn, DeviceId byte, Mode byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = Mode
	b += 1

	b += 2 // padding

	return buf
}

// Request SelectExtensionEvent
// size: xgb.Pad((12 + xgb.Pad((int(NumClasses) * 4))))
type SelectExtensionEventCookie struct {
	*xgb.Cookie
}

// Write request to wire for SelectExtensionEvent
func SelectExtensionEvent(c *xgb.Conn, Window xproto.Window, NumClasses uint16, Classes []EventClass) SelectExtensionEventCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(selectExtensionEventRequest(c, Window, NumClasses, Classes), cookie)
	return SelectExtensionEventCookie{cookie}
}

func SelectExtensionEventChecked(c *xgb.Conn, Window xproto.Window, NumClasses uint16, Classes []EventClass) SelectExtensionEventCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(selectExtensionEventRequest(c, Window, NumClasses, Classes), cookie)
	return SelectExtensionEventCookie{cookie}
}

func (cook SelectExtensionEventCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SelectExtensionEvent
func selectExtensionEventRequest(c *xgb.Conn, Window xproto.Window, NumClasses uint16, Classes []EventClass) []byte {
	size := xgb.Pad((12 + xgb.Pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put16(buf[b:], NumClasses)
	b += 2

	b += 2 // padding

	for i := 0; i < int(NumClasses); i++ {
		xgb.Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request GetSelectedExtensionEvents
// size: 8
type GetSelectedExtensionEventsCookie struct {
	*xgb.Cookie
}

func GetSelectedExtensionEvents(c *xgb.Conn, Window xproto.Window) GetSelectedExtensionEventsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getSelectedExtensionEventsRequest(c, Window), cookie)
	return GetSelectedExtensionEventsCookie{cookie}
}

func GetSelectedExtensionEventsUnchecked(c *xgb.Conn, Window xproto.Window) GetSelectedExtensionEventsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getSelectedExtensionEventsRequest(c, Window), cookie)
	return GetSelectedExtensionEventsCookie{cookie}
}

// Request reply for GetSelectedExtensionEvents
// size: ((32 + xgb.Pad((int(NumThisClasses) * 4))) + xgb.Pad((int(NumAllClasses) * 4)))
type GetSelectedExtensionEventsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumThisClasses uint16
	NumAllClasses  uint16
	// padding: 20 bytes
	ThisClasses []EventClass // size: xgb.Pad((int(NumThisClasses) * 4))
	AllClasses  []EventClass // size: xgb.Pad((int(NumAllClasses) * 4))
}

// Waits and reads reply data from request GetSelectedExtensionEvents
func (cook GetSelectedExtensionEventsCookie) Reply() (*GetSelectedExtensionEventsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getSelectedExtensionEventsReply(buf), nil
}

// Read reply into structure from buffer for GetSelectedExtensionEvents
func getSelectedExtensionEventsReply(buf []byte) *GetSelectedExtensionEventsReply {
	v := new(GetSelectedExtensionEventsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumThisClasses = xgb.Get16(buf[b:])
	b += 2

	v.NumAllClasses = xgb.Get16(buf[b:])
	b += 2

	b += 20 // padding

	v.ThisClasses = make([]EventClass, v.NumThisClasses)
	for i := 0; i < int(v.NumThisClasses); i++ {
		v.ThisClasses[i] = EventClass(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	v.AllClasses = make([]EventClass, v.NumAllClasses)
	for i := 0; i < int(v.NumAllClasses); i++ {
		v.AllClasses[i] = EventClass(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetSelectedExtensionEvents
func getSelectedExtensionEventsRequest(c *xgb.Conn, Window xproto.Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request ChangeDeviceDontPropagateList
// size: xgb.Pad((12 + xgb.Pad((int(NumClasses) * 4))))
type ChangeDeviceDontPropagateListCookie struct {
	*xgb.Cookie
}

// Write request to wire for ChangeDeviceDontPropagateList
func ChangeDeviceDontPropagateList(c *xgb.Conn, Window xproto.Window, NumClasses uint16, Mode byte, Classes []EventClass) ChangeDeviceDontPropagateListCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeDeviceDontPropagateListRequest(c, Window, NumClasses, Mode, Classes), cookie)
	return ChangeDeviceDontPropagateListCookie{cookie}
}

func ChangeDeviceDontPropagateListChecked(c *xgb.Conn, Window xproto.Window, NumClasses uint16, Mode byte, Classes []EventClass) ChangeDeviceDontPropagateListCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeDeviceDontPropagateListRequest(c, Window, NumClasses, Mode, Classes), cookie)
	return ChangeDeviceDontPropagateListCookie{cookie}
}

func (cook ChangeDeviceDontPropagateListCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeDeviceDontPropagateList
func changeDeviceDontPropagateListRequest(c *xgb.Conn, Window xproto.Window, NumClasses uint16, Mode byte, Classes []EventClass) []byte {
	size := xgb.Pad((12 + xgb.Pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 8 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put16(buf[b:], NumClasses)
	b += 2

	buf[b] = Mode
	b += 1

	b += 1 // padding

	for i := 0; i < int(NumClasses); i++ {
		xgb.Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request GetDeviceDontPropagateList
// size: 8
type GetDeviceDontPropagateListCookie struct {
	*xgb.Cookie
}

func GetDeviceDontPropagateList(c *xgb.Conn, Window xproto.Window) GetDeviceDontPropagateListCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceDontPropagateListRequest(c, Window), cookie)
	return GetDeviceDontPropagateListCookie{cookie}
}

func GetDeviceDontPropagateListUnchecked(c *xgb.Conn, Window xproto.Window) GetDeviceDontPropagateListCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceDontPropagateListRequest(c, Window), cookie)
	return GetDeviceDontPropagateListCookie{cookie}
}

// Request reply for GetDeviceDontPropagateList
// size: (32 + xgb.Pad((int(NumClasses) * 4)))
type GetDeviceDontPropagateListReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumClasses uint16
	// padding: 22 bytes
	Classes []EventClass // size: xgb.Pad((int(NumClasses) * 4))
}

// Waits and reads reply data from request GetDeviceDontPropagateList
func (cook GetDeviceDontPropagateListCookie) Reply() (*GetDeviceDontPropagateListReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceDontPropagateListReply(buf), nil
}

// Read reply into structure from buffer for GetDeviceDontPropagateList
func getDeviceDontPropagateListReply(buf []byte) *GetDeviceDontPropagateListReply {
	v := new(GetDeviceDontPropagateListReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumClasses = xgb.Get16(buf[b:])
	b += 2

	b += 22 // padding

	v.Classes = make([]EventClass, v.NumClasses)
	for i := 0; i < int(v.NumClasses); i++ {
		v.Classes[i] = EventClass(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetDeviceDontPropagateList
func getDeviceDontPropagateListRequest(c *xgb.Conn, Window xproto.Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 9 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request GetDeviceMotionEvents
// size: 16
type GetDeviceMotionEventsCookie struct {
	*xgb.Cookie
}

func GetDeviceMotionEvents(c *xgb.Conn, Start xproto.Timestamp, Stop xproto.Timestamp, DeviceId byte) GetDeviceMotionEventsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceMotionEventsRequest(c, Start, Stop, DeviceId), cookie)
	return GetDeviceMotionEventsCookie{cookie}
}

func GetDeviceMotionEventsUnchecked(c *xgb.Conn, Start xproto.Timestamp, Stop xproto.Timestamp, DeviceId byte) GetDeviceMotionEventsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceMotionEventsRequest(c, Start, Stop, DeviceId), cookie)
	return GetDeviceMotionEventsCookie{cookie}
}

// Request reply for GetDeviceMotionEvents
// size: 32
type GetDeviceMotionEventsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumCoords  uint32
	NumAxes    byte
	DeviceMode byte
	// padding: 18 bytes
}

// Waits and reads reply data from request GetDeviceMotionEvents
func (cook GetDeviceMotionEventsCookie) Reply() (*GetDeviceMotionEventsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceMotionEventsReply(buf), nil
}

// Read reply into structure from buffer for GetDeviceMotionEvents
func getDeviceMotionEventsReply(buf []byte) *GetDeviceMotionEventsReply {
	v := new(GetDeviceMotionEventsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumCoords = xgb.Get32(buf[b:])
	b += 4

	v.NumAxes = buf[b]
	b += 1

	v.DeviceMode = buf[b]
	b += 1

	b += 18 // padding

	return v
}

// Write request to wire for GetDeviceMotionEvents
func getDeviceMotionEventsRequest(c *xgb.Conn, Start xproto.Timestamp, Stop xproto.Timestamp, DeviceId byte) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 10 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Start))
	b += 4

	xgb.Put32(buf[b:], uint32(Stop))
	b += 4

	buf[b] = DeviceId
	b += 1

	return buf
}

// Request ChangeKeyboardDevice
// size: 8
type ChangeKeyboardDeviceCookie struct {
	*xgb.Cookie
}

func ChangeKeyboardDevice(c *xgb.Conn, DeviceId byte) ChangeKeyboardDeviceCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(changeKeyboardDeviceRequest(c, DeviceId), cookie)
	return ChangeKeyboardDeviceCookie{cookie}
}

func ChangeKeyboardDeviceUnchecked(c *xgb.Conn, DeviceId byte) ChangeKeyboardDeviceCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(changeKeyboardDeviceRequest(c, DeviceId), cookie)
	return ChangeKeyboardDeviceCookie{cookie}
}

// Request reply for ChangeKeyboardDevice
// size: 32
type ChangeKeyboardDeviceReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Waits and reads reply data from request ChangeKeyboardDevice
func (cook ChangeKeyboardDeviceCookie) Reply() (*ChangeKeyboardDeviceReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return changeKeyboardDeviceReply(buf), nil
}

// Read reply into structure from buffer for ChangeKeyboardDevice
func changeKeyboardDeviceReply(buf []byte) *ChangeKeyboardDeviceReply {
	v := new(ChangeKeyboardDeviceReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for ChangeKeyboardDevice
func changeKeyboardDeviceRequest(c *xgb.Conn, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 11 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// Request ChangePointerDevice
// size: 8
type ChangePointerDeviceCookie struct {
	*xgb.Cookie
}

func ChangePointerDevice(c *xgb.Conn, XAxis byte, YAxis byte, DeviceId byte) ChangePointerDeviceCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(changePointerDeviceRequest(c, XAxis, YAxis, DeviceId), cookie)
	return ChangePointerDeviceCookie{cookie}
}

func ChangePointerDeviceUnchecked(c *xgb.Conn, XAxis byte, YAxis byte, DeviceId byte) ChangePointerDeviceCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(changePointerDeviceRequest(c, XAxis, YAxis, DeviceId), cookie)
	return ChangePointerDeviceCookie{cookie}
}

// Request reply for ChangePointerDevice
// size: 32
type ChangePointerDeviceReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Waits and reads reply data from request ChangePointerDevice
func (cook ChangePointerDeviceCookie) Reply() (*ChangePointerDeviceReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return changePointerDeviceReply(buf), nil
}

// Read reply into structure from buffer for ChangePointerDevice
func changePointerDeviceReply(buf []byte) *ChangePointerDeviceReply {
	v := new(ChangePointerDeviceReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for ChangePointerDevice
func changePointerDeviceRequest(c *xgb.Conn, XAxis byte, YAxis byte, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 12 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = XAxis
	b += 1

	buf[b] = YAxis
	b += 1

	buf[b] = DeviceId
	b += 1

	b += 1 // padding

	return buf
}

// Request GrabDevice
// size: xgb.Pad((20 + xgb.Pad((int(NumClasses) * 4))))
type GrabDeviceCookie struct {
	*xgb.Cookie
}

func GrabDevice(c *xgb.Conn, GrabWindow xproto.Window, Time xproto.Timestamp, NumClasses uint16, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, DeviceId byte, Classes []EventClass) GrabDeviceCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(grabDeviceRequest(c, GrabWindow, Time, NumClasses, ThisDeviceMode, OtherDeviceMode, OwnerEvents, DeviceId, Classes), cookie)
	return GrabDeviceCookie{cookie}
}

func GrabDeviceUnchecked(c *xgb.Conn, GrabWindow xproto.Window, Time xproto.Timestamp, NumClasses uint16, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, DeviceId byte, Classes []EventClass) GrabDeviceCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(grabDeviceRequest(c, GrabWindow, Time, NumClasses, ThisDeviceMode, OtherDeviceMode, OwnerEvents, DeviceId, Classes), cookie)
	return GrabDeviceCookie{cookie}
}

// Request reply for GrabDevice
// size: 32
type GrabDeviceReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Waits and reads reply data from request GrabDevice
func (cook GrabDeviceCookie) Reply() (*GrabDeviceReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return grabDeviceReply(buf), nil
}

// Read reply into structure from buffer for GrabDevice
func grabDeviceReply(buf []byte) *GrabDeviceReply {
	v := new(GrabDeviceReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for GrabDevice
func grabDeviceRequest(c *xgb.Conn, GrabWindow xproto.Window, Time xproto.Timestamp, NumClasses uint16, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, DeviceId byte, Classes []EventClass) []byte {
	size := xgb.Pad((20 + xgb.Pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 13 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GrabWindow))
	b += 4

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	xgb.Put16(buf[b:], NumClasses)
	b += 2

	buf[b] = ThisDeviceMode
	b += 1

	buf[b] = OtherDeviceMode
	b += 1

	if OwnerEvents {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	buf[b] = DeviceId
	b += 1

	b += 2 // padding

	for i := 0; i < int(NumClasses); i++ {
		xgb.Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request UngrabDevice
// size: 12
type UngrabDeviceCookie struct {
	*xgb.Cookie
}

// Write request to wire for UngrabDevice
func UngrabDevice(c *xgb.Conn, Time xproto.Timestamp, DeviceId byte) UngrabDeviceCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(ungrabDeviceRequest(c, Time, DeviceId), cookie)
	return UngrabDeviceCookie{cookie}
}

func UngrabDeviceChecked(c *xgb.Conn, Time xproto.Timestamp, DeviceId byte) UngrabDeviceCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(ungrabDeviceRequest(c, Time, DeviceId), cookie)
	return UngrabDeviceCookie{cookie}
}

func (cook UngrabDeviceCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UngrabDevice
func ungrabDeviceRequest(c *xgb.Conn, Time xproto.Timestamp, DeviceId byte) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 14 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	buf[b] = DeviceId
	b += 1

	return buf
}

// Request GrabDeviceKey
// size: xgb.Pad((20 + xgb.Pad((int(NumClasses) * 4))))
type GrabDeviceKeyCookie struct {
	*xgb.Cookie
}

// Write request to wire for GrabDeviceKey
func GrabDeviceKey(c *xgb.Conn, GrabWindow xproto.Window, NumClasses uint16, Modifiers uint16, ModifierDevice byte, GrabbedDevice byte, Key byte, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, Classes []EventClass) GrabDeviceKeyCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(grabDeviceKeyRequest(c, GrabWindow, NumClasses, Modifiers, ModifierDevice, GrabbedDevice, Key, ThisDeviceMode, OtherDeviceMode, OwnerEvents, Classes), cookie)
	return GrabDeviceKeyCookie{cookie}
}

func GrabDeviceKeyChecked(c *xgb.Conn, GrabWindow xproto.Window, NumClasses uint16, Modifiers uint16, ModifierDevice byte, GrabbedDevice byte, Key byte, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, Classes []EventClass) GrabDeviceKeyCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(grabDeviceKeyRequest(c, GrabWindow, NumClasses, Modifiers, ModifierDevice, GrabbedDevice, Key, ThisDeviceMode, OtherDeviceMode, OwnerEvents, Classes), cookie)
	return GrabDeviceKeyCookie{cookie}
}

func (cook GrabDeviceKeyCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for GrabDeviceKey
func grabDeviceKeyRequest(c *xgb.Conn, GrabWindow xproto.Window, NumClasses uint16, Modifiers uint16, ModifierDevice byte, GrabbedDevice byte, Key byte, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, Classes []EventClass) []byte {
	size := xgb.Pad((20 + xgb.Pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 15 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GrabWindow))
	b += 4

	xgb.Put16(buf[b:], NumClasses)
	b += 2

	xgb.Put16(buf[b:], Modifiers)
	b += 2

	buf[b] = ModifierDevice
	b += 1

	buf[b] = GrabbedDevice
	b += 1

	buf[b] = Key
	b += 1

	buf[b] = ThisDeviceMode
	b += 1

	buf[b] = OtherDeviceMode
	b += 1

	if OwnerEvents {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 2 // padding

	for i := 0; i < int(NumClasses); i++ {
		xgb.Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request UngrabDeviceKey
// size: 16
type UngrabDeviceKeyCookie struct {
	*xgb.Cookie
}

// Write request to wire for UngrabDeviceKey
func UngrabDeviceKey(c *xgb.Conn, GrabWindow xproto.Window, Modifiers uint16, ModifierDevice byte, Key byte, GrabbedDevice byte) UngrabDeviceKeyCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(ungrabDeviceKeyRequest(c, GrabWindow, Modifiers, ModifierDevice, Key, GrabbedDevice), cookie)
	return UngrabDeviceKeyCookie{cookie}
}

func UngrabDeviceKeyChecked(c *xgb.Conn, GrabWindow xproto.Window, Modifiers uint16, ModifierDevice byte, Key byte, GrabbedDevice byte) UngrabDeviceKeyCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(ungrabDeviceKeyRequest(c, GrabWindow, Modifiers, ModifierDevice, Key, GrabbedDevice), cookie)
	return UngrabDeviceKeyCookie{cookie}
}

func (cook UngrabDeviceKeyCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UngrabDeviceKey
func ungrabDeviceKeyRequest(c *xgb.Conn, GrabWindow xproto.Window, Modifiers uint16, ModifierDevice byte, Key byte, GrabbedDevice byte) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 16 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GrabWindow))
	b += 4

	xgb.Put16(buf[b:], Modifiers)
	b += 2

	buf[b] = ModifierDevice
	b += 1

	buf[b] = Key
	b += 1

	buf[b] = GrabbedDevice
	b += 1

	return buf
}

// Request GrabDeviceButton
// size: xgb.Pad((20 + xgb.Pad((int(NumClasses) * 4))))
type GrabDeviceButtonCookie struct {
	*xgb.Cookie
}

// Write request to wire for GrabDeviceButton
func GrabDeviceButton(c *xgb.Conn, GrabWindow xproto.Window, GrabbedDevice byte, ModifierDevice byte, NumClasses uint16, Modifiers uint16, ThisDeviceMode byte, OtherDeviceMode byte, Button byte, OwnerEvents byte, Classes []EventClass) GrabDeviceButtonCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(grabDeviceButtonRequest(c, GrabWindow, GrabbedDevice, ModifierDevice, NumClasses, Modifiers, ThisDeviceMode, OtherDeviceMode, Button, OwnerEvents, Classes), cookie)
	return GrabDeviceButtonCookie{cookie}
}

func GrabDeviceButtonChecked(c *xgb.Conn, GrabWindow xproto.Window, GrabbedDevice byte, ModifierDevice byte, NumClasses uint16, Modifiers uint16, ThisDeviceMode byte, OtherDeviceMode byte, Button byte, OwnerEvents byte, Classes []EventClass) GrabDeviceButtonCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(grabDeviceButtonRequest(c, GrabWindow, GrabbedDevice, ModifierDevice, NumClasses, Modifiers, ThisDeviceMode, OtherDeviceMode, Button, OwnerEvents, Classes), cookie)
	return GrabDeviceButtonCookie{cookie}
}

func (cook GrabDeviceButtonCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for GrabDeviceButton
func grabDeviceButtonRequest(c *xgb.Conn, GrabWindow xproto.Window, GrabbedDevice byte, ModifierDevice byte, NumClasses uint16, Modifiers uint16, ThisDeviceMode byte, OtherDeviceMode byte, Button byte, OwnerEvents byte, Classes []EventClass) []byte {
	size := xgb.Pad((20 + xgb.Pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 17 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GrabWindow))
	b += 4

	buf[b] = GrabbedDevice
	b += 1

	buf[b] = ModifierDevice
	b += 1

	xgb.Put16(buf[b:], NumClasses)
	b += 2

	xgb.Put16(buf[b:], Modifiers)
	b += 2

	buf[b] = ThisDeviceMode
	b += 1

	buf[b] = OtherDeviceMode
	b += 1

	buf[b] = Button
	b += 1

	buf[b] = OwnerEvents
	b += 1

	b += 2 // padding

	for i := 0; i < int(NumClasses); i++ {
		xgb.Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request UngrabDeviceButton
// size: 16
type UngrabDeviceButtonCookie struct {
	*xgb.Cookie
}

// Write request to wire for UngrabDeviceButton
func UngrabDeviceButton(c *xgb.Conn, GrabWindow xproto.Window, Modifiers uint16, ModifierDevice byte, Button byte, GrabbedDevice byte) UngrabDeviceButtonCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(ungrabDeviceButtonRequest(c, GrabWindow, Modifiers, ModifierDevice, Button, GrabbedDevice), cookie)
	return UngrabDeviceButtonCookie{cookie}
}

func UngrabDeviceButtonChecked(c *xgb.Conn, GrabWindow xproto.Window, Modifiers uint16, ModifierDevice byte, Button byte, GrabbedDevice byte) UngrabDeviceButtonCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(ungrabDeviceButtonRequest(c, GrabWindow, Modifiers, ModifierDevice, Button, GrabbedDevice), cookie)
	return UngrabDeviceButtonCookie{cookie}
}

func (cook UngrabDeviceButtonCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UngrabDeviceButton
func ungrabDeviceButtonRequest(c *xgb.Conn, GrabWindow xproto.Window, Modifiers uint16, ModifierDevice byte, Button byte, GrabbedDevice byte) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 18 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GrabWindow))
	b += 4

	xgb.Put16(buf[b:], Modifiers)
	b += 2

	buf[b] = ModifierDevice
	b += 1

	buf[b] = Button
	b += 1

	buf[b] = GrabbedDevice
	b += 1

	return buf
}

// Request AllowDeviceEvents
// size: 12
type AllowDeviceEventsCookie struct {
	*xgb.Cookie
}

// Write request to wire for AllowDeviceEvents
func AllowDeviceEvents(c *xgb.Conn, Time xproto.Timestamp, Mode byte, DeviceId byte) AllowDeviceEventsCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(allowDeviceEventsRequest(c, Time, Mode, DeviceId), cookie)
	return AllowDeviceEventsCookie{cookie}
}

func AllowDeviceEventsChecked(c *xgb.Conn, Time xproto.Timestamp, Mode byte, DeviceId byte) AllowDeviceEventsCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(allowDeviceEventsRequest(c, Time, Mode, DeviceId), cookie)
	return AllowDeviceEventsCookie{cookie}
}

func (cook AllowDeviceEventsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for AllowDeviceEvents
func allowDeviceEventsRequest(c *xgb.Conn, Time xproto.Timestamp, Mode byte, DeviceId byte) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 19 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	buf[b] = Mode
	b += 1

	buf[b] = DeviceId
	b += 1

	return buf
}

// Request GetDeviceFocus
// size: 8
type GetDeviceFocusCookie struct {
	*xgb.Cookie
}

func GetDeviceFocus(c *xgb.Conn, DeviceId byte) GetDeviceFocusCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceFocusRequest(c, DeviceId), cookie)
	return GetDeviceFocusCookie{cookie}
}

func GetDeviceFocusUnchecked(c *xgb.Conn, DeviceId byte) GetDeviceFocusCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceFocusRequest(c, DeviceId), cookie)
	return GetDeviceFocusCookie{cookie}
}

// Request reply for GetDeviceFocus
// size: 32
type GetDeviceFocusReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Focus    xproto.Window
	Time     xproto.Timestamp
	RevertTo byte
	// padding: 15 bytes
}

// Waits and reads reply data from request GetDeviceFocus
func (cook GetDeviceFocusCookie) Reply() (*GetDeviceFocusReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceFocusReply(buf), nil
}

// Read reply into structure from buffer for GetDeviceFocus
func getDeviceFocusReply(buf []byte) *GetDeviceFocusReply {
	v := new(GetDeviceFocusReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Focus = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.RevertTo = buf[b]
	b += 1

	b += 15 // padding

	return v
}

// Write request to wire for GetDeviceFocus
func getDeviceFocusRequest(c *xgb.Conn, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 20 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// Request SetDeviceFocus
// size: 16
type SetDeviceFocusCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetDeviceFocus
func SetDeviceFocus(c *xgb.Conn, Focus xproto.Window, Time xproto.Timestamp, RevertTo byte, DeviceId byte) SetDeviceFocusCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setDeviceFocusRequest(c, Focus, Time, RevertTo, DeviceId), cookie)
	return SetDeviceFocusCookie{cookie}
}

func SetDeviceFocusChecked(c *xgb.Conn, Focus xproto.Window, Time xproto.Timestamp, RevertTo byte, DeviceId byte) SetDeviceFocusCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setDeviceFocusRequest(c, Focus, Time, RevertTo, DeviceId), cookie)
	return SetDeviceFocusCookie{cookie}
}

func (cook SetDeviceFocusCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetDeviceFocus
func setDeviceFocusRequest(c *xgb.Conn, Focus xproto.Window, Time xproto.Timestamp, RevertTo byte, DeviceId byte) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 21 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Focus))
	b += 4

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	buf[b] = RevertTo
	b += 1

	buf[b] = DeviceId
	b += 1

	return buf
}

// Request GetFeedbackControl
// size: 8
type GetFeedbackControlCookie struct {
	*xgb.Cookie
}

func GetFeedbackControl(c *xgb.Conn, DeviceId byte) GetFeedbackControlCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getFeedbackControlRequest(c, DeviceId), cookie)
	return GetFeedbackControlCookie{cookie}
}

func GetFeedbackControlUnchecked(c *xgb.Conn, DeviceId byte) GetFeedbackControlCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getFeedbackControlRequest(c, DeviceId), cookie)
	return GetFeedbackControlCookie{cookie}
}

// Request reply for GetFeedbackControl
// size: 32
type GetFeedbackControlReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumFeedback uint16
	// padding: 22 bytes
}

// Waits and reads reply data from request GetFeedbackControl
func (cook GetFeedbackControlCookie) Reply() (*GetFeedbackControlReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getFeedbackControlReply(buf), nil
}

// Read reply into structure from buffer for GetFeedbackControl
func getFeedbackControlReply(buf []byte) *GetFeedbackControlReply {
	v := new(GetFeedbackControlReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumFeedback = xgb.Get16(buf[b:])
	b += 2

	b += 22 // padding

	return v
}

// Write request to wire for GetFeedbackControl
func getFeedbackControlRequest(c *xgb.Conn, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 22 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// Request GetDeviceKeyMapping
// size: 8
type GetDeviceKeyMappingCookie struct {
	*xgb.Cookie
}

func GetDeviceKeyMapping(c *xgb.Conn, DeviceId byte, FirstKeycode KeyCode, Count byte) GetDeviceKeyMappingCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceKeyMappingRequest(c, DeviceId, FirstKeycode, Count), cookie)
	return GetDeviceKeyMappingCookie{cookie}
}

func GetDeviceKeyMappingUnchecked(c *xgb.Conn, DeviceId byte, FirstKeycode KeyCode, Count byte) GetDeviceKeyMappingCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceKeyMappingRequest(c, DeviceId, FirstKeycode, Count), cookie)
	return GetDeviceKeyMappingCookie{cookie}
}

// Request reply for GetDeviceKeyMapping
// size: (32 + xgb.Pad((int(Length) * 4)))
type GetDeviceKeyMappingReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	KeysymsPerKeycode byte
	// padding: 23 bytes
	Keysyms []xproto.Keysym // size: xgb.Pad((int(Length) * 4))
}

// Waits and reads reply data from request GetDeviceKeyMapping
func (cook GetDeviceKeyMappingCookie) Reply() (*GetDeviceKeyMappingReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceKeyMappingReply(buf), nil
}

// Read reply into structure from buffer for GetDeviceKeyMapping
func getDeviceKeyMappingReply(buf []byte) *GetDeviceKeyMappingReply {
	v := new(GetDeviceKeyMappingReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.KeysymsPerKeycode = buf[b]
	b += 1

	b += 23 // padding

	v.Keysyms = make([]xproto.Keysym, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.Keysyms[i] = xproto.Keysym(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetDeviceKeyMapping
func getDeviceKeyMappingRequest(c *xgb.Conn, DeviceId byte, FirstKeycode KeyCode, Count byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 24 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = byte(FirstKeycode)
	b += 1

	buf[b] = Count
	b += 1

	return buf
}

// Request ChangeDeviceKeyMapping
// size: xgb.Pad((8 + xgb.Pad(((int(KeycodeCount) * int(KeysymsPerKeycode)) * 4))))
type ChangeDeviceKeyMappingCookie struct {
	*xgb.Cookie
}

// Write request to wire for ChangeDeviceKeyMapping
func ChangeDeviceKeyMapping(c *xgb.Conn, DeviceId byte, FirstKeycode KeyCode, KeysymsPerKeycode byte, KeycodeCount byte, Keysyms []xproto.Keysym) ChangeDeviceKeyMappingCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeDeviceKeyMappingRequest(c, DeviceId, FirstKeycode, KeysymsPerKeycode, KeycodeCount, Keysyms), cookie)
	return ChangeDeviceKeyMappingCookie{cookie}
}

func ChangeDeviceKeyMappingChecked(c *xgb.Conn, DeviceId byte, FirstKeycode KeyCode, KeysymsPerKeycode byte, KeycodeCount byte, Keysyms []xproto.Keysym) ChangeDeviceKeyMappingCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeDeviceKeyMappingRequest(c, DeviceId, FirstKeycode, KeysymsPerKeycode, KeycodeCount, Keysyms), cookie)
	return ChangeDeviceKeyMappingCookie{cookie}
}

func (cook ChangeDeviceKeyMappingCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeDeviceKeyMapping
func changeDeviceKeyMappingRequest(c *xgb.Conn, DeviceId byte, FirstKeycode KeyCode, KeysymsPerKeycode byte, KeycodeCount byte, Keysyms []xproto.Keysym) []byte {
	size := xgb.Pad((8 + xgb.Pad(((int(KeycodeCount) * int(KeysymsPerKeycode)) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 25 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = byte(FirstKeycode)
	b += 1

	buf[b] = KeysymsPerKeycode
	b += 1

	buf[b] = KeycodeCount
	b += 1

	for i := 0; i < int((int(KeycodeCount) * int(KeysymsPerKeycode))); i++ {
		xgb.Put32(buf[b:], uint32(Keysyms[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request GetDeviceModifierMapping
// size: 8
type GetDeviceModifierMappingCookie struct {
	*xgb.Cookie
}

func GetDeviceModifierMapping(c *xgb.Conn, DeviceId byte) GetDeviceModifierMappingCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceModifierMappingRequest(c, DeviceId), cookie)
	return GetDeviceModifierMappingCookie{cookie}
}

func GetDeviceModifierMappingUnchecked(c *xgb.Conn, DeviceId byte) GetDeviceModifierMappingCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceModifierMappingRequest(c, DeviceId), cookie)
	return GetDeviceModifierMappingCookie{cookie}
}

// Request reply for GetDeviceModifierMapping
// size: (32 + xgb.Pad(((int(KeycodesPerModifier) * 8) * 1)))
type GetDeviceModifierMappingReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	KeycodesPerModifier byte
	// padding: 23 bytes
	Keymaps []byte // size: xgb.Pad(((int(KeycodesPerModifier) * 8) * 1))
}

// Waits and reads reply data from request GetDeviceModifierMapping
func (cook GetDeviceModifierMappingCookie) Reply() (*GetDeviceModifierMappingReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceModifierMappingReply(buf), nil
}

// Read reply into structure from buffer for GetDeviceModifierMapping
func getDeviceModifierMappingReply(buf []byte) *GetDeviceModifierMappingReply {
	v := new(GetDeviceModifierMappingReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.KeycodesPerModifier = buf[b]
	b += 1

	b += 23 // padding

	v.Keymaps = make([]byte, (int(v.KeycodesPerModifier) * 8))
	copy(v.Keymaps[:(int(v.KeycodesPerModifier)*8)], buf[b:])
	b += xgb.Pad(int((int(v.KeycodesPerModifier) * 8)))

	return v
}

// Write request to wire for GetDeviceModifierMapping
func getDeviceModifierMappingRequest(c *xgb.Conn, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 26 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// Request SetDeviceModifierMapping
// size: xgb.Pad((7 + xgb.Pad(((int(KeycodesPerModifier) * 8) * 1))))
type SetDeviceModifierMappingCookie struct {
	*xgb.Cookie
}

func SetDeviceModifierMapping(c *xgb.Conn, DeviceId byte, KeycodesPerModifier byte, Keymaps []byte) SetDeviceModifierMappingCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(setDeviceModifierMappingRequest(c, DeviceId, KeycodesPerModifier, Keymaps), cookie)
	return SetDeviceModifierMappingCookie{cookie}
}

func SetDeviceModifierMappingUnchecked(c *xgb.Conn, DeviceId byte, KeycodesPerModifier byte, Keymaps []byte) SetDeviceModifierMappingCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(setDeviceModifierMappingRequest(c, DeviceId, KeycodesPerModifier, Keymaps), cookie)
	return SetDeviceModifierMappingCookie{cookie}
}

// Request reply for SetDeviceModifierMapping
// size: 32
type SetDeviceModifierMappingReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Waits and reads reply data from request SetDeviceModifierMapping
func (cook SetDeviceModifierMappingCookie) Reply() (*SetDeviceModifierMappingReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return setDeviceModifierMappingReply(buf), nil
}

// Read reply into structure from buffer for SetDeviceModifierMapping
func setDeviceModifierMappingReply(buf []byte) *SetDeviceModifierMappingReply {
	v := new(SetDeviceModifierMappingReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for SetDeviceModifierMapping
func setDeviceModifierMappingRequest(c *xgb.Conn, DeviceId byte, KeycodesPerModifier byte, Keymaps []byte) []byte {
	size := xgb.Pad((7 + xgb.Pad(((int(KeycodesPerModifier) * 8) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 27 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = KeycodesPerModifier
	b += 1

	b += 1 // padding

	copy(buf[b:], Keymaps[:(int(KeycodesPerModifier)*8)])
	b += xgb.Pad(int((int(KeycodesPerModifier) * 8)))

	return buf
}

// Request GetDeviceButtonMapping
// size: 8
type GetDeviceButtonMappingCookie struct {
	*xgb.Cookie
}

func GetDeviceButtonMapping(c *xgb.Conn, DeviceId byte) GetDeviceButtonMappingCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceButtonMappingRequest(c, DeviceId), cookie)
	return GetDeviceButtonMappingCookie{cookie}
}

func GetDeviceButtonMappingUnchecked(c *xgb.Conn, DeviceId byte) GetDeviceButtonMappingCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceButtonMappingRequest(c, DeviceId), cookie)
	return GetDeviceButtonMappingCookie{cookie}
}

// Request reply for GetDeviceButtonMapping
// size: (32 + xgb.Pad((int(MapSize) * 1)))
type GetDeviceButtonMappingReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	MapSize byte
	// padding: 23 bytes
	Map []byte // size: xgb.Pad((int(MapSize) * 1))
}

// Waits and reads reply data from request GetDeviceButtonMapping
func (cook GetDeviceButtonMappingCookie) Reply() (*GetDeviceButtonMappingReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceButtonMappingReply(buf), nil
}

// Read reply into structure from buffer for GetDeviceButtonMapping
func getDeviceButtonMappingReply(buf []byte) *GetDeviceButtonMappingReply {
	v := new(GetDeviceButtonMappingReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.MapSize = buf[b]
	b += 1

	b += 23 // padding

	v.Map = make([]byte, v.MapSize)
	copy(v.Map[:v.MapSize], buf[b:])
	b += xgb.Pad(int(v.MapSize))

	return v
}

// Write request to wire for GetDeviceButtonMapping
func getDeviceButtonMappingRequest(c *xgb.Conn, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 28 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// Request SetDeviceButtonMapping
// size: xgb.Pad((8 + xgb.Pad((int(MapSize) * 1))))
type SetDeviceButtonMappingCookie struct {
	*xgb.Cookie
}

func SetDeviceButtonMapping(c *xgb.Conn, DeviceId byte, MapSize byte, Map []byte) SetDeviceButtonMappingCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(setDeviceButtonMappingRequest(c, DeviceId, MapSize, Map), cookie)
	return SetDeviceButtonMappingCookie{cookie}
}

func SetDeviceButtonMappingUnchecked(c *xgb.Conn, DeviceId byte, MapSize byte, Map []byte) SetDeviceButtonMappingCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(setDeviceButtonMappingRequest(c, DeviceId, MapSize, Map), cookie)
	return SetDeviceButtonMappingCookie{cookie}
}

// Request reply for SetDeviceButtonMapping
// size: 32
type SetDeviceButtonMappingReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Waits and reads reply data from request SetDeviceButtonMapping
func (cook SetDeviceButtonMappingCookie) Reply() (*SetDeviceButtonMappingReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return setDeviceButtonMappingReply(buf), nil
}

// Read reply into structure from buffer for SetDeviceButtonMapping
func setDeviceButtonMappingReply(buf []byte) *SetDeviceButtonMappingReply {
	v := new(SetDeviceButtonMappingReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for SetDeviceButtonMapping
func setDeviceButtonMappingRequest(c *xgb.Conn, DeviceId byte, MapSize byte, Map []byte) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(MapSize) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 29 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = MapSize
	b += 1

	b += 2 // padding

	copy(buf[b:], Map[:MapSize])
	b += xgb.Pad(int(MapSize))

	return buf
}

// Request QueryDeviceState
// size: 8
type QueryDeviceStateCookie struct {
	*xgb.Cookie
}

func QueryDeviceState(c *xgb.Conn, DeviceId byte) QueryDeviceStateCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryDeviceStateRequest(c, DeviceId), cookie)
	return QueryDeviceStateCookie{cookie}
}

func QueryDeviceStateUnchecked(c *xgb.Conn, DeviceId byte) QueryDeviceStateCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryDeviceStateRequest(c, DeviceId), cookie)
	return QueryDeviceStateCookie{cookie}
}

// Request reply for QueryDeviceState
// size: 32
type QueryDeviceStateReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumClasses byte
	// padding: 23 bytes
}

// Waits and reads reply data from request QueryDeviceState
func (cook QueryDeviceStateCookie) Reply() (*QueryDeviceStateReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryDeviceStateReply(buf), nil
}

// Read reply into structure from buffer for QueryDeviceState
func queryDeviceStateReply(buf []byte) *QueryDeviceStateReply {
	v := new(QueryDeviceStateReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumClasses = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for QueryDeviceState
func queryDeviceStateRequest(c *xgb.Conn, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 30 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// Request SendExtensionEvent
// size: xgb.Pad(((16 + xgb.Pad(((int(NumEvents) * 32) * 1))) + xgb.Pad((int(NumClasses) * 4))))
type SendExtensionEventCookie struct {
	*xgb.Cookie
}

// Write request to wire for SendExtensionEvent
func SendExtensionEvent(c *xgb.Conn, Destination xproto.Window, DeviceId byte, Propagate bool, NumClasses uint16, NumEvents byte, Events string, Classes []EventClass) SendExtensionEventCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(sendExtensionEventRequest(c, Destination, DeviceId, Propagate, NumClasses, NumEvents, Events, Classes), cookie)
	return SendExtensionEventCookie{cookie}
}

func SendExtensionEventChecked(c *xgb.Conn, Destination xproto.Window, DeviceId byte, Propagate bool, NumClasses uint16, NumEvents byte, Events string, Classes []EventClass) SendExtensionEventCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(sendExtensionEventRequest(c, Destination, DeviceId, Propagate, NumClasses, NumEvents, Events, Classes), cookie)
	return SendExtensionEventCookie{cookie}
}

func (cook SendExtensionEventCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SendExtensionEvent
func sendExtensionEventRequest(c *xgb.Conn, Destination xproto.Window, DeviceId byte, Propagate bool, NumClasses uint16, NumEvents byte, Events string, Classes []EventClass) []byte {
	size := xgb.Pad(((16 + xgb.Pad(((int(NumEvents) * 32) * 1))) + xgb.Pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 31 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Destination))
	b += 4

	buf[b] = DeviceId
	b += 1

	if Propagate {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	xgb.Put16(buf[b:], NumClasses)
	b += 2

	buf[b] = NumEvents
	b += 1

	b += 3 // padding

	copy(buf[b:], Events[:(int(NumEvents)*32)])
	b += xgb.Pad(int((int(NumEvents) * 32)))

	for i := 0; i < int(NumClasses); i++ {
		xgb.Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request DeviceBell
// size: 8
type DeviceBellCookie struct {
	*xgb.Cookie
}

// Write request to wire for DeviceBell
func DeviceBell(c *xgb.Conn, DeviceId byte, FeedbackId byte, FeedbackClass byte, Percent int8) DeviceBellCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(deviceBellRequest(c, DeviceId, FeedbackId, FeedbackClass, Percent), cookie)
	return DeviceBellCookie{cookie}
}

func DeviceBellChecked(c *xgb.Conn, DeviceId byte, FeedbackId byte, FeedbackClass byte, Percent int8) DeviceBellCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(deviceBellRequest(c, DeviceId, FeedbackId, FeedbackClass, Percent), cookie)
	return DeviceBellCookie{cookie}
}

func (cook DeviceBellCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DeviceBell
func deviceBellRequest(c *xgb.Conn, DeviceId byte, FeedbackId byte, FeedbackClass byte, Percent int8) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 32 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = FeedbackId
	b += 1

	buf[b] = FeedbackClass
	b += 1

	buf[b] = byte(Percent)
	b += 1

	return buf
}

// Request SetDeviceValuators
// size: xgb.Pad((8 + xgb.Pad((int(NumValuators) * 4))))
type SetDeviceValuatorsCookie struct {
	*xgb.Cookie
}

func SetDeviceValuators(c *xgb.Conn, DeviceId byte, FirstValuator byte, NumValuators byte, Valuators []int32) SetDeviceValuatorsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(setDeviceValuatorsRequest(c, DeviceId, FirstValuator, NumValuators, Valuators), cookie)
	return SetDeviceValuatorsCookie{cookie}
}

func SetDeviceValuatorsUnchecked(c *xgb.Conn, DeviceId byte, FirstValuator byte, NumValuators byte, Valuators []int32) SetDeviceValuatorsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(setDeviceValuatorsRequest(c, DeviceId, FirstValuator, NumValuators, Valuators), cookie)
	return SetDeviceValuatorsCookie{cookie}
}

// Request reply for SetDeviceValuators
// size: 32
type SetDeviceValuatorsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Waits and reads reply data from request SetDeviceValuators
func (cook SetDeviceValuatorsCookie) Reply() (*SetDeviceValuatorsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return setDeviceValuatorsReply(buf), nil
}

// Read reply into structure from buffer for SetDeviceValuators
func setDeviceValuatorsReply(buf []byte) *SetDeviceValuatorsReply {
	v := new(SetDeviceValuatorsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for SetDeviceValuators
func setDeviceValuatorsRequest(c *xgb.Conn, DeviceId byte, FirstValuator byte, NumValuators byte, Valuators []int32) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(NumValuators) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 33 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = FirstValuator
	b += 1

	buf[b] = NumValuators
	b += 1

	b += 1 // padding

	for i := 0; i < int(NumValuators); i++ {
		xgb.Put32(buf[b:], uint32(Valuators[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request GetDeviceControl
// size: 8
type GetDeviceControlCookie struct {
	*xgb.Cookie
}

func GetDeviceControl(c *xgb.Conn, ControlId uint16, DeviceId byte) GetDeviceControlCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceControlRequest(c, ControlId, DeviceId), cookie)
	return GetDeviceControlCookie{cookie}
}

func GetDeviceControlUnchecked(c *xgb.Conn, ControlId uint16, DeviceId byte) GetDeviceControlCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceControlRequest(c, ControlId, DeviceId), cookie)
	return GetDeviceControlCookie{cookie}
}

// Request reply for GetDeviceControl
// size: 32
type GetDeviceControlReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Waits and reads reply data from request GetDeviceControl
func (cook GetDeviceControlCookie) Reply() (*GetDeviceControlReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceControlReply(buf), nil
}

// Read reply into structure from buffer for GetDeviceControl
func getDeviceControlReply(buf []byte) *GetDeviceControlReply {
	v := new(GetDeviceControlReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for GetDeviceControl
func getDeviceControlRequest(c *xgb.Conn, ControlId uint16, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 34 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], ControlId)
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 1 // padding

	return buf
}
