// Package xinput is the X client API for the XInputExtension extension.
package xinput

/*
	This file was generated by xinput.xml on May 26 2012 6:23:14pm EDT.
	This file is automatically generated. Edit at your peril!
*/

import (
	"github.com/BurntSushi/xgb"

	"github.com/BurntSushi/xgb/xproto"
)

// Init must be called before using the XInputExtension extension.
func Init(c *xgb.Conn) error {
	reply, err := xproto.QueryExtension(c, 15, "XInputExtension").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return xgb.Errorf("No extension named XInputExtension could be found on on the server.")
	}

	xgb.ExtLock.Lock()
	c.Extensions["XInputExtension"] = reply.MajorOpcode
	for evNum, fun := range xgb.NewExtEventFuncs["XInputExtension"] {
		xgb.NewEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range xgb.NewExtErrorFuncs["XInputExtension"] {
		xgb.NewErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	xgb.ExtLock.Unlock()

	return nil
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"] = make(map[int]xgb.NewEventFun)
	xgb.NewExtErrorFuncs["XInputExtension"] = make(map[int]xgb.NewErrorFun)
}

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

const (
	ValuatorModeRelative = 0
	ValuatorModeAbsolute = 1
)

const (
	PropagateModeAddToList      = 0
	PropagateModeDeleteFromList = 1
)

const (
	DeviceUseIsXPointer           = 0
	DeviceUseIsXKeyboard          = 1
	DeviceUseIsXExtensionDevice   = 2
	DeviceUseIsXExtensionKeyboard = 3
	DeviceUseIsXExtensionPointer  = 4
)

const (
	InputClassKey       = 0
	InputClassButton    = 1
	InputClassValuator  = 2
	InputClassFeedback  = 3
	InputClassProximity = 4
	InputClassFocus     = 5
	InputClassOther     = 6
)

const (
	DeviceInputModeAsyncThisDevice   = 0
	DeviceInputModeSyncThisDevice    = 1
	DeviceInputModeReplayThisDevice  = 2
	DeviceInputModeAsyncOtherDevices = 3
	DeviceInputModeAsyncAll          = 4
	DeviceInputModeSyncAll           = 5
)

const (
	FeedbackClassKeyboard = 0
	FeedbackClassPointer  = 1
	FeedbackClassString   = 2
	FeedbackClassInteger  = 3
	FeedbackClassLed      = 4
	FeedbackClassBell     = 5
)

type KeyCode byte

type EventClass uint32

type DeviceInfo struct {
	DeviceType   xproto.Atom
	DeviceId     byte
	NumClassInfo byte
	DeviceUse    byte
	// padding: 1 bytes
}

// DeviceInfoRead reads a byte slice into a DeviceInfo value.
func DeviceInfoRead(buf []byte, v *DeviceInfo) int {
	b := 0

	v.DeviceType = xproto.Atom(xgb.Get32(buf[b:]))
	b += 4

	v.DeviceId = buf[b]
	b += 1

	v.NumClassInfo = buf[b]
	b += 1

	v.DeviceUse = buf[b]
	b += 1

	b += 1 // padding

	return b
}

// DeviceInfoReadList reads a byte slice into a list of DeviceInfo values.
func DeviceInfoReadList(buf []byte, dest []DeviceInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceInfo{}
		b += DeviceInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a DeviceInfo value to a byte slice.
func (v DeviceInfo) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put32(buf[b:], uint32(v.DeviceType))
	b += 4

	buf[b] = v.DeviceId
	b += 1

	buf[b] = v.NumClassInfo
	b += 1

	buf[b] = v.DeviceUse
	b += 1

	b += 1 // padding

	return buf
}

// DeviceInfoListBytes writes a list of DeviceInfo values to a byte slice.
func DeviceInfoListBytes(buf []byte, list []DeviceInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type InputInfo struct {
	ClassId byte
	Len     byte
}

// InputInfoRead reads a byte slice into a InputInfo value.
func InputInfoRead(buf []byte, v *InputInfo) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	return b
}

// InputInfoReadList reads a byte slice into a list of InputInfo values.
func InputInfoReadList(buf []byte, dest []InputInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = InputInfo{}
		b += InputInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a InputInfo value to a byte slice.
func (v InputInfo) Bytes() []byte {
	buf := make([]byte, 2)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	return buf
}

// InputInfoListBytes writes a list of InputInfo values to a byte slice.
func InputInfoListBytes(buf []byte, list []InputInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type KeyInfo struct {
	ClassId    byte
	Len        byte
	MinKeycode KeyCode
	MaxKeycode KeyCode
	NumKeys    uint16
	// padding: 2 bytes
}

// KeyInfoRead reads a byte slice into a KeyInfo value.
func KeyInfoRead(buf []byte, v *KeyInfo) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.MinKeycode = KeyCode(buf[b])
	b += 1

	v.MaxKeycode = KeyCode(buf[b])
	b += 1

	v.NumKeys = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	return b
}

// KeyInfoReadList reads a byte slice into a list of KeyInfo values.
func KeyInfoReadList(buf []byte, dest []KeyInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = KeyInfo{}
		b += KeyInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a KeyInfo value to a byte slice.
func (v KeyInfo) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = byte(v.MinKeycode)
	b += 1

	buf[b] = byte(v.MaxKeycode)
	b += 1

	xgb.Put16(buf[b:], v.NumKeys)
	b += 2

	b += 2 // padding

	return buf
}

// KeyInfoListBytes writes a list of KeyInfo values to a byte slice.
func KeyInfoListBytes(buf []byte, list []KeyInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type ButtonInfo struct {
	ClassId    byte
	Len        byte
	NumButtons uint16
}

// ButtonInfoRead reads a byte slice into a ButtonInfo value.
func ButtonInfoRead(buf []byte, v *ButtonInfo) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.NumButtons = xgb.Get16(buf[b:])
	b += 2

	return b
}

// ButtonInfoReadList reads a byte slice into a list of ButtonInfo values.
func ButtonInfoReadList(buf []byte, dest []ButtonInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ButtonInfo{}
		b += ButtonInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a ButtonInfo value to a byte slice.
func (v ButtonInfo) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	xgb.Put16(buf[b:], v.NumButtons)
	b += 2

	return buf
}

// ButtonInfoListBytes writes a list of ButtonInfo values to a byte slice.
func ButtonInfoListBytes(buf []byte, list []ButtonInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type AxisInfo struct {
	Resolution uint32
	Minimum    int32
	Maximum    int32
}

// AxisInfoRead reads a byte slice into a AxisInfo value.
func AxisInfoRead(buf []byte, v *AxisInfo) int {
	b := 0

	v.Resolution = xgb.Get32(buf[b:])
	b += 4

	v.Minimum = int32(xgb.Get32(buf[b:]))
	b += 4

	v.Maximum = int32(xgb.Get32(buf[b:]))
	b += 4

	return b
}

// AxisInfoReadList reads a byte slice into a list of AxisInfo values.
func AxisInfoReadList(buf []byte, dest []AxisInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = AxisInfo{}
		b += AxisInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a AxisInfo value to a byte slice.
func (v AxisInfo) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	xgb.Put32(buf[b:], v.Resolution)
	b += 4

	xgb.Put32(buf[b:], uint32(v.Minimum))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Maximum))
	b += 4

	return buf
}

// AxisInfoListBytes writes a list of AxisInfo values to a byte slice.
func AxisInfoListBytes(buf []byte, list []AxisInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type ValuatorInfo struct {
	ClassId    byte
	Len        byte
	AxesLen    byte
	Mode       byte
	MotionSize uint32
	Axes       []AxisInfo // size: xgb.Pad((int(AxesLen) * 12))
}

// ValuatorInfoRead reads a byte slice into a ValuatorInfo value.
func ValuatorInfoRead(buf []byte, v *ValuatorInfo) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.AxesLen = buf[b]
	b += 1

	v.Mode = buf[b]
	b += 1

	v.MotionSize = xgb.Get32(buf[b:])
	b += 4

	v.Axes = make([]AxisInfo, v.AxesLen)
	b += AxisInfoReadList(buf[b:], v.Axes)

	return b
}

// ValuatorInfoReadList reads a byte slice into a list of ValuatorInfo values.
func ValuatorInfoReadList(buf []byte, dest []ValuatorInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ValuatorInfo{}
		b += ValuatorInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a ValuatorInfo value to a byte slice.
func (v ValuatorInfo) Bytes() []byte {
	buf := make([]byte, (8 + xgb.Pad((int(v.AxesLen) * 12))))
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = v.AxesLen
	b += 1

	buf[b] = v.Mode
	b += 1

	xgb.Put32(buf[b:], v.MotionSize)
	b += 4

	b += AxisInfoListBytes(buf[b:], v.Axes)

	return buf
}

// ValuatorInfoListBytes writes a list of ValuatorInfo values to a byte slice.
func ValuatorInfoListBytes(buf []byte, list []ValuatorInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// ValuatorInfoListSize computes the size (bytes) of a list of ValuatorInfo values.
func ValuatorInfoListSize(list []ValuatorInfo) int {
	size := 0
	for _, item := range list {
		size += (8 + xgb.Pad((int(item.AxesLen) * 12)))
	}
	return size
}

type InputClassInfo struct {
	ClassId       byte
	EventTypeBase byte
}

// InputClassInfoRead reads a byte slice into a InputClassInfo value.
func InputClassInfoRead(buf []byte, v *InputClassInfo) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.EventTypeBase = buf[b]
	b += 1

	return b
}

// InputClassInfoReadList reads a byte slice into a list of InputClassInfo values.
func InputClassInfoReadList(buf []byte, dest []InputClassInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = InputClassInfo{}
		b += InputClassInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a InputClassInfo value to a byte slice.
func (v InputClassInfo) Bytes() []byte {
	buf := make([]byte, 2)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.EventTypeBase
	b += 1

	return buf
}

// InputClassInfoListBytes writes a list of InputClassInfo values to a byte slice.
func InputClassInfoListBytes(buf []byte, list []InputClassInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type DeviceTimeCoord struct {
	Time xproto.Timestamp
}

// DeviceTimeCoordRead reads a byte slice into a DeviceTimeCoord value.
func DeviceTimeCoordRead(buf []byte, v *DeviceTimeCoord) int {
	b := 0

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	return b
}

// DeviceTimeCoordReadList reads a byte slice into a list of DeviceTimeCoord values.
func DeviceTimeCoordReadList(buf []byte, dest []DeviceTimeCoord) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceTimeCoord{}
		b += DeviceTimeCoordRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a DeviceTimeCoord value to a byte slice.
func (v DeviceTimeCoord) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	return buf
}

// DeviceTimeCoordListBytes writes a list of DeviceTimeCoord values to a byte slice.
func DeviceTimeCoordListBytes(buf []byte, list []DeviceTimeCoord) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type FeedbackState struct {
	ClassId byte
	Id      byte
	Len     uint16
}

// FeedbackStateRead reads a byte slice into a FeedbackState value.
func FeedbackStateRead(buf []byte, v *FeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	return b
}

// FeedbackStateReadList reads a byte slice into a list of FeedbackState values.
func FeedbackStateReadList(buf []byte, dest []FeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = FeedbackState{}
		b += FeedbackStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a FeedbackState value to a byte slice.
func (v FeedbackState) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	return buf
}

// FeedbackStateListBytes writes a list of FeedbackState values to a byte slice.
func FeedbackStateListBytes(buf []byte, list []FeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type KbdFeedbackState struct {
	ClassId          byte
	Id               byte
	Len              uint16
	Pitch            uint16
	Duration         uint16
	LedMask          uint32
	LedValues        uint32
	GlobalAutoRepeat bool
	Click            byte
	Percent          byte
	// padding: 1 bytes
	AutoRepeats []byte // size: 32
}

// KbdFeedbackStateRead reads a byte slice into a KbdFeedbackState value.
func KbdFeedbackStateRead(buf []byte, v *KbdFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Pitch = xgb.Get16(buf[b:])
	b += 2

	v.Duration = xgb.Get16(buf[b:])
	b += 2

	v.LedMask = xgb.Get32(buf[b:])
	b += 4

	v.LedValues = xgb.Get32(buf[b:])
	b += 4

	if buf[b] == 1 {
		v.GlobalAutoRepeat = true
	} else {
		v.GlobalAutoRepeat = false
	}
	b += 1

	v.Click = buf[b]
	b += 1

	v.Percent = buf[b]
	b += 1

	b += 1 // padding

	v.AutoRepeats = make([]byte, 32)
	copy(v.AutoRepeats[:32], buf[b:])
	b += xgb.Pad(int(32))

	return b
}

// KbdFeedbackStateReadList reads a byte slice into a list of KbdFeedbackState values.
func KbdFeedbackStateReadList(buf []byte, dest []KbdFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = KbdFeedbackState{}
		b += KbdFeedbackStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a KbdFeedbackState value to a byte slice.
func (v KbdFeedbackState) Bytes() []byte {
	buf := make([]byte, 52)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put16(buf[b:], v.Pitch)
	b += 2

	xgb.Put16(buf[b:], v.Duration)
	b += 2

	xgb.Put32(buf[b:], v.LedMask)
	b += 4

	xgb.Put32(buf[b:], v.LedValues)
	b += 4

	if v.GlobalAutoRepeat {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	buf[b] = v.Click
	b += 1

	buf[b] = v.Percent
	b += 1

	b += 1 // padding

	copy(buf[b:], v.AutoRepeats[:32])
	b += xgb.Pad(int(32))

	return buf
}

// KbdFeedbackStateListBytes writes a list of KbdFeedbackState values to a byte slice.
func KbdFeedbackStateListBytes(buf []byte, list []KbdFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// KbdFeedbackStateListSize computes the size (bytes) of a list of KbdFeedbackState values.
func KbdFeedbackStateListSize(list []KbdFeedbackState) int {
	size := 0
	for _ = range list {
		size += 52
	}
	return size
}

type PtrFeedbackState struct {
	ClassId byte
	Id      byte
	Len     uint16
	// padding: 2 bytes
	AccelNum   uint16
	AccelDenom uint16
	Threshold  uint16
}

// PtrFeedbackStateRead reads a byte slice into a PtrFeedbackState value.
func PtrFeedbackStateRead(buf []byte, v *PtrFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.AccelNum = xgb.Get16(buf[b:])
	b += 2

	v.AccelDenom = xgb.Get16(buf[b:])
	b += 2

	v.Threshold = xgb.Get16(buf[b:])
	b += 2

	return b
}

// PtrFeedbackStateReadList reads a byte slice into a list of PtrFeedbackState values.
func PtrFeedbackStateReadList(buf []byte, dest []PtrFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = PtrFeedbackState{}
		b += PtrFeedbackStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a PtrFeedbackState value to a byte slice.
func (v PtrFeedbackState) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	b += 2 // padding

	xgb.Put16(buf[b:], v.AccelNum)
	b += 2

	xgb.Put16(buf[b:], v.AccelDenom)
	b += 2

	xgb.Put16(buf[b:], v.Threshold)
	b += 2

	return buf
}

// PtrFeedbackStateListBytes writes a list of PtrFeedbackState values to a byte slice.
func PtrFeedbackStateListBytes(buf []byte, list []PtrFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type IntegerFeedbackState struct {
	ClassId    byte
	Id         byte
	Len        uint16
	Resolution uint32
	MinValue   int32
	MaxValue   int32
}

// IntegerFeedbackStateRead reads a byte slice into a IntegerFeedbackState value.
func IntegerFeedbackStateRead(buf []byte, v *IntegerFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Resolution = xgb.Get32(buf[b:])
	b += 4

	v.MinValue = int32(xgb.Get32(buf[b:]))
	b += 4

	v.MaxValue = int32(xgb.Get32(buf[b:]))
	b += 4

	return b
}

// IntegerFeedbackStateReadList reads a byte slice into a list of IntegerFeedbackState values.
func IntegerFeedbackStateReadList(buf []byte, dest []IntegerFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = IntegerFeedbackState{}
		b += IntegerFeedbackStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a IntegerFeedbackState value to a byte slice.
func (v IntegerFeedbackState) Bytes() []byte {
	buf := make([]byte, 16)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], v.Resolution)
	b += 4

	xgb.Put32(buf[b:], uint32(v.MinValue))
	b += 4

	xgb.Put32(buf[b:], uint32(v.MaxValue))
	b += 4

	return buf
}

// IntegerFeedbackStateListBytes writes a list of IntegerFeedbackState values to a byte slice.
func IntegerFeedbackStateListBytes(buf []byte, list []IntegerFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type StringFeedbackState struct {
	ClassId    byte
	Id         byte
	Len        uint16
	MaxSymbols uint16
	NumKeysyms uint16
	Keysyms    []xproto.Keysym // size: xgb.Pad((int(NumKeysyms) * 4))
}

// StringFeedbackStateRead reads a byte slice into a StringFeedbackState value.
func StringFeedbackStateRead(buf []byte, v *StringFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.MaxSymbols = xgb.Get16(buf[b:])
	b += 2

	v.NumKeysyms = xgb.Get16(buf[b:])
	b += 2

	v.Keysyms = make([]xproto.Keysym, v.NumKeysyms)
	for i := 0; i < int(v.NumKeysyms); i++ {
		v.Keysyms[i] = xproto.Keysym(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return b
}

// StringFeedbackStateReadList reads a byte slice into a list of StringFeedbackState values.
func StringFeedbackStateReadList(buf []byte, dest []StringFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = StringFeedbackState{}
		b += StringFeedbackStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a StringFeedbackState value to a byte slice.
func (v StringFeedbackState) Bytes() []byte {
	buf := make([]byte, (8 + xgb.Pad((int(v.NumKeysyms) * 4))))
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put16(buf[b:], v.MaxSymbols)
	b += 2

	xgb.Put16(buf[b:], v.NumKeysyms)
	b += 2

	for i := 0; i < int(v.NumKeysyms); i++ {
		xgb.Put32(buf[b:], uint32(v.Keysyms[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// StringFeedbackStateListBytes writes a list of StringFeedbackState values to a byte slice.
func StringFeedbackStateListBytes(buf []byte, list []StringFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// StringFeedbackStateListSize computes the size (bytes) of a list of StringFeedbackState values.
func StringFeedbackStateListSize(list []StringFeedbackState) int {
	size := 0
	for _, item := range list {
		size += (8 + xgb.Pad((int(item.NumKeysyms) * 4)))
	}
	return size
}

type BellFeedbackState struct {
	ClassId byte
	Id      byte
	Len     uint16
	Percent byte
	// padding: 3 bytes
	Pitch    uint16
	Duration uint16
}

// BellFeedbackStateRead reads a byte slice into a BellFeedbackState value.
func BellFeedbackStateRead(buf []byte, v *BellFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Percent = buf[b]
	b += 1

	b += 3 // padding

	v.Pitch = xgb.Get16(buf[b:])
	b += 2

	v.Duration = xgb.Get16(buf[b:])
	b += 2

	return b
}

// BellFeedbackStateReadList reads a byte slice into a list of BellFeedbackState values.
func BellFeedbackStateReadList(buf []byte, dest []BellFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = BellFeedbackState{}
		b += BellFeedbackStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a BellFeedbackState value to a byte slice.
func (v BellFeedbackState) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.Percent
	b += 1

	b += 3 // padding

	xgb.Put16(buf[b:], v.Pitch)
	b += 2

	xgb.Put16(buf[b:], v.Duration)
	b += 2

	return buf
}

// BellFeedbackStateListBytes writes a list of BellFeedbackState values to a byte slice.
func BellFeedbackStateListBytes(buf []byte, list []BellFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type LedFeedbackState struct {
	ClassId   byte
	Id        byte
	Len       uint16
	LedMask   uint32
	LedValues uint32
}

// LedFeedbackStateRead reads a byte slice into a LedFeedbackState value.
func LedFeedbackStateRead(buf []byte, v *LedFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.LedMask = xgb.Get32(buf[b:])
	b += 4

	v.LedValues = xgb.Get32(buf[b:])
	b += 4

	return b
}

// LedFeedbackStateReadList reads a byte slice into a list of LedFeedbackState values.
func LedFeedbackStateReadList(buf []byte, dest []LedFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = LedFeedbackState{}
		b += LedFeedbackStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a LedFeedbackState value to a byte slice.
func (v LedFeedbackState) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], v.LedMask)
	b += 4

	xgb.Put32(buf[b:], v.LedValues)
	b += 4

	return buf
}

// LedFeedbackStateListBytes writes a list of LedFeedbackState values to a byte slice.
func LedFeedbackStateListBytes(buf []byte, list []LedFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type FeedbackCtl struct {
	ClassId byte
	Id      byte
	Len     uint16
}

// FeedbackCtlRead reads a byte slice into a FeedbackCtl value.
func FeedbackCtlRead(buf []byte, v *FeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	return b
}

// FeedbackCtlReadList reads a byte slice into a list of FeedbackCtl values.
func FeedbackCtlReadList(buf []byte, dest []FeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = FeedbackCtl{}
		b += FeedbackCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a FeedbackCtl value to a byte slice.
func (v FeedbackCtl) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	return buf
}

// FeedbackCtlListBytes writes a list of FeedbackCtl values to a byte slice.
func FeedbackCtlListBytes(buf []byte, list []FeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type KbdFeedbackCtl struct {
	ClassId         byte
	Id              byte
	Len             uint16
	Key             KeyCode
	AutoRepeatMode  byte
	KeyClickPercent int8
	BellPercent     int8
	BellPitch       int16
	BellDuration    int16
	LedMask         uint32
	LedValues       uint32
}

// KbdFeedbackCtlRead reads a byte slice into a KbdFeedbackCtl value.
func KbdFeedbackCtlRead(buf []byte, v *KbdFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Key = KeyCode(buf[b])
	b += 1

	v.AutoRepeatMode = buf[b]
	b += 1

	v.KeyClickPercent = int8(buf[b])
	b += 1

	v.BellPercent = int8(buf[b])
	b += 1

	v.BellPitch = int16(xgb.Get16(buf[b:]))
	b += 2

	v.BellDuration = int16(xgb.Get16(buf[b:]))
	b += 2

	v.LedMask = xgb.Get32(buf[b:])
	b += 4

	v.LedValues = xgb.Get32(buf[b:])
	b += 4

	return b
}

// KbdFeedbackCtlReadList reads a byte slice into a list of KbdFeedbackCtl values.
func KbdFeedbackCtlReadList(buf []byte, dest []KbdFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = KbdFeedbackCtl{}
		b += KbdFeedbackCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a KbdFeedbackCtl value to a byte slice.
func (v KbdFeedbackCtl) Bytes() []byte {
	buf := make([]byte, 20)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	buf[b] = byte(v.Key)
	b += 1

	buf[b] = v.AutoRepeatMode
	b += 1

	buf[b] = byte(v.KeyClickPercent)
	b += 1

	buf[b] = byte(v.BellPercent)
	b += 1

	xgb.Put16(buf[b:], uint16(v.BellPitch))
	b += 2

	xgb.Put16(buf[b:], uint16(v.BellDuration))
	b += 2

	xgb.Put32(buf[b:], v.LedMask)
	b += 4

	xgb.Put32(buf[b:], v.LedValues)
	b += 4

	return buf
}

// KbdFeedbackCtlListBytes writes a list of KbdFeedbackCtl values to a byte slice.
func KbdFeedbackCtlListBytes(buf []byte, list []KbdFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type PtrFeedbackCtl struct {
	ClassId byte
	Id      byte
	Len     uint16
	// padding: 2 bytes
	Num       int16
	Denom     int16
	Threshold int16
}

// PtrFeedbackCtlRead reads a byte slice into a PtrFeedbackCtl value.
func PtrFeedbackCtlRead(buf []byte, v *PtrFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.Num = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Denom = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Threshold = int16(xgb.Get16(buf[b:]))
	b += 2

	return b
}

// PtrFeedbackCtlReadList reads a byte slice into a list of PtrFeedbackCtl values.
func PtrFeedbackCtlReadList(buf []byte, dest []PtrFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = PtrFeedbackCtl{}
		b += PtrFeedbackCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a PtrFeedbackCtl value to a byte slice.
func (v PtrFeedbackCtl) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	b += 2 // padding

	xgb.Put16(buf[b:], uint16(v.Num))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Denom))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Threshold))
	b += 2

	return buf
}

// PtrFeedbackCtlListBytes writes a list of PtrFeedbackCtl values to a byte slice.
func PtrFeedbackCtlListBytes(buf []byte, list []PtrFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type IntegerFeedbackCtl struct {
	ClassId      byte
	Id           byte
	Len          uint16
	IntToDisplay int32
}

// IntegerFeedbackCtlRead reads a byte slice into a IntegerFeedbackCtl value.
func IntegerFeedbackCtlRead(buf []byte, v *IntegerFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.IntToDisplay = int32(xgb.Get32(buf[b:]))
	b += 4

	return b
}

// IntegerFeedbackCtlReadList reads a byte slice into a list of IntegerFeedbackCtl values.
func IntegerFeedbackCtlReadList(buf []byte, dest []IntegerFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = IntegerFeedbackCtl{}
		b += IntegerFeedbackCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a IntegerFeedbackCtl value to a byte slice.
func (v IntegerFeedbackCtl) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], uint32(v.IntToDisplay))
	b += 4

	return buf
}

// IntegerFeedbackCtlListBytes writes a list of IntegerFeedbackCtl values to a byte slice.
func IntegerFeedbackCtlListBytes(buf []byte, list []IntegerFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type StringFeedbackCtl struct {
	ClassId byte
	Id      byte
	Len     uint16
	// padding: 2 bytes
	NumKeysyms uint16
	Keysyms    []xproto.Keysym // size: xgb.Pad((int(NumKeysyms) * 4))
}

// StringFeedbackCtlRead reads a byte slice into a StringFeedbackCtl value.
func StringFeedbackCtlRead(buf []byte, v *StringFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.NumKeysyms = xgb.Get16(buf[b:])
	b += 2

	v.Keysyms = make([]xproto.Keysym, v.NumKeysyms)
	for i := 0; i < int(v.NumKeysyms); i++ {
		v.Keysyms[i] = xproto.Keysym(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return b
}

// StringFeedbackCtlReadList reads a byte slice into a list of StringFeedbackCtl values.
func StringFeedbackCtlReadList(buf []byte, dest []StringFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = StringFeedbackCtl{}
		b += StringFeedbackCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a StringFeedbackCtl value to a byte slice.
func (v StringFeedbackCtl) Bytes() []byte {
	buf := make([]byte, (8 + xgb.Pad((int(v.NumKeysyms) * 4))))
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	b += 2 // padding

	xgb.Put16(buf[b:], v.NumKeysyms)
	b += 2

	for i := 0; i < int(v.NumKeysyms); i++ {
		xgb.Put32(buf[b:], uint32(v.Keysyms[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// StringFeedbackCtlListBytes writes a list of StringFeedbackCtl values to a byte slice.
func StringFeedbackCtlListBytes(buf []byte, list []StringFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// StringFeedbackCtlListSize computes the size (bytes) of a list of StringFeedbackCtl values.
func StringFeedbackCtlListSize(list []StringFeedbackCtl) int {
	size := 0
	for _, item := range list {
		size += (8 + xgb.Pad((int(item.NumKeysyms) * 4)))
	}
	return size
}

type BellFeedbackCtl struct {
	ClassId byte
	Id      byte
	Len     uint16
	Percent int8
	// padding: 3 bytes
	Pitch    int16
	Duration int16
}

// BellFeedbackCtlRead reads a byte slice into a BellFeedbackCtl value.
func BellFeedbackCtlRead(buf []byte, v *BellFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Percent = int8(buf[b])
	b += 1

	b += 3 // padding

	v.Pitch = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Duration = int16(xgb.Get16(buf[b:]))
	b += 2

	return b
}

// BellFeedbackCtlReadList reads a byte slice into a list of BellFeedbackCtl values.
func BellFeedbackCtlReadList(buf []byte, dest []BellFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = BellFeedbackCtl{}
		b += BellFeedbackCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a BellFeedbackCtl value to a byte slice.
func (v BellFeedbackCtl) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	buf[b] = byte(v.Percent)
	b += 1

	b += 3 // padding

	xgb.Put16(buf[b:], uint16(v.Pitch))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Duration))
	b += 2

	return buf
}

// BellFeedbackCtlListBytes writes a list of BellFeedbackCtl values to a byte slice.
func BellFeedbackCtlListBytes(buf []byte, list []BellFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type LedFeedbackCtl struct {
	ClassId   byte
	Id        byte
	Len       uint16
	LedMask   uint32
	LedValues uint32
}

// LedFeedbackCtlRead reads a byte slice into a LedFeedbackCtl value.
func LedFeedbackCtlRead(buf []byte, v *LedFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.LedMask = xgb.Get32(buf[b:])
	b += 4

	v.LedValues = xgb.Get32(buf[b:])
	b += 4

	return b
}

// LedFeedbackCtlReadList reads a byte slice into a list of LedFeedbackCtl values.
func LedFeedbackCtlReadList(buf []byte, dest []LedFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = LedFeedbackCtl{}
		b += LedFeedbackCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a LedFeedbackCtl value to a byte slice.
func (v LedFeedbackCtl) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], v.LedMask)
	b += 4

	xgb.Put32(buf[b:], v.LedValues)
	b += 4

	return buf
}

// LedFeedbackCtlListBytes writes a list of LedFeedbackCtl values to a byte slice.
func LedFeedbackCtlListBytes(buf []byte, list []LedFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type InputState struct {
	ClassId  byte
	Len      byte
	NumItems byte
}

// InputStateRead reads a byte slice into a InputState value.
func InputStateRead(buf []byte, v *InputState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.NumItems = buf[b]
	b += 1

	return b
}

// InputStateReadList reads a byte slice into a list of InputState values.
func InputStateReadList(buf []byte, dest []InputState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = InputState{}
		b += InputStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a InputState value to a byte slice.
func (v InputState) Bytes() []byte {
	buf := make([]byte, 3)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = v.NumItems
	b += 1

	return buf
}

// InputStateListBytes writes a list of InputState values to a byte slice.
func InputStateListBytes(buf []byte, list []InputState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type KeyState struct {
	ClassId byte
	Len     byte
	NumKeys byte
	// padding: 1 bytes
	Keys []byte // size: 32
}

// KeyStateRead reads a byte slice into a KeyState value.
func KeyStateRead(buf []byte, v *KeyState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.NumKeys = buf[b]
	b += 1

	b += 1 // padding

	v.Keys = make([]byte, 32)
	copy(v.Keys[:32], buf[b:])
	b += xgb.Pad(int(32))

	return b
}

// KeyStateReadList reads a byte slice into a list of KeyState values.
func KeyStateReadList(buf []byte, dest []KeyState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = KeyState{}
		b += KeyStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a KeyState value to a byte slice.
func (v KeyState) Bytes() []byte {
	buf := make([]byte, 36)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = v.NumKeys
	b += 1

	b += 1 // padding

	copy(buf[b:], v.Keys[:32])
	b += xgb.Pad(int(32))

	return buf
}

// KeyStateListBytes writes a list of KeyState values to a byte slice.
func KeyStateListBytes(buf []byte, list []KeyState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// KeyStateListSize computes the size (bytes) of a list of KeyState values.
func KeyStateListSize(list []KeyState) int {
	size := 0
	for _ = range list {
		size += 36
	}
	return size
}

type ButtonState struct {
	ClassId    byte
	Len        byte
	NumButtons byte
	// padding: 1 bytes
	Buttons []byte // size: 32
}

// ButtonStateRead reads a byte slice into a ButtonState value.
func ButtonStateRead(buf []byte, v *ButtonState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.NumButtons = buf[b]
	b += 1

	b += 1 // padding

	v.Buttons = make([]byte, 32)
	copy(v.Buttons[:32], buf[b:])
	b += xgb.Pad(int(32))

	return b
}

// ButtonStateReadList reads a byte slice into a list of ButtonState values.
func ButtonStateReadList(buf []byte, dest []ButtonState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ButtonState{}
		b += ButtonStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a ButtonState value to a byte slice.
func (v ButtonState) Bytes() []byte {
	buf := make([]byte, 36)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = v.NumButtons
	b += 1

	b += 1 // padding

	copy(buf[b:], v.Buttons[:32])
	b += xgb.Pad(int(32))

	return buf
}

// ButtonStateListBytes writes a list of ButtonState values to a byte slice.
func ButtonStateListBytes(buf []byte, list []ButtonState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// ButtonStateListSize computes the size (bytes) of a list of ButtonState values.
func ButtonStateListSize(list []ButtonState) int {
	size := 0
	for _ = range list {
		size += 36
	}
	return size
}

type ValuatorState struct {
	ClassId      byte
	Len          byte
	NumValuators byte
	Mode         byte
	Valuators    []uint32 // size: xgb.Pad((int(NumValuators) * 4))
}

// ValuatorStateRead reads a byte slice into a ValuatorState value.
func ValuatorStateRead(buf []byte, v *ValuatorState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.NumValuators = buf[b]
	b += 1

	v.Mode = buf[b]
	b += 1

	v.Valuators = make([]uint32, v.NumValuators)
	for i := 0; i < int(v.NumValuators); i++ {
		v.Valuators[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return b
}

// ValuatorStateReadList reads a byte slice into a list of ValuatorState values.
func ValuatorStateReadList(buf []byte, dest []ValuatorState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ValuatorState{}
		b += ValuatorStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a ValuatorState value to a byte slice.
func (v ValuatorState) Bytes() []byte {
	buf := make([]byte, (4 + xgb.Pad((int(v.NumValuators) * 4))))
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = v.NumValuators
	b += 1

	buf[b] = v.Mode
	b += 1

	for i := 0; i < int(v.NumValuators); i++ {
		xgb.Put32(buf[b:], v.Valuators[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// ValuatorStateListBytes writes a list of ValuatorState values to a byte slice.
func ValuatorStateListBytes(buf []byte, list []ValuatorState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// ValuatorStateListSize computes the size (bytes) of a list of ValuatorState values.
func ValuatorStateListSize(list []ValuatorState) int {
	size := 0
	for _, item := range list {
		size += (4 + xgb.Pad((int(item.NumValuators) * 4)))
	}
	return size
}

type DeviceState struct {
	ControlId uint16
	Len       uint16
}

// DeviceStateRead reads a byte slice into a DeviceState value.
func DeviceStateRead(buf []byte, v *DeviceState) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	return b
}

// DeviceStateReadList reads a byte slice into a list of DeviceState values.
func DeviceStateReadList(buf []byte, dest []DeviceState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceState{}
		b += DeviceStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a DeviceState value to a byte slice.
func (v DeviceState) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	return buf
}

// DeviceStateListBytes writes a list of DeviceState values to a byte slice.
func DeviceStateListBytes(buf []byte, list []DeviceState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type DeviceResolutionState struct {
	ControlId        uint16
	Len              uint16
	NumValuators     uint32
	ResolutionValues []uint32 // size: xgb.Pad((int(NumValuators) * 4))
	ResolutionMin    []uint32 // size: xgb.Pad((int(NumValuators) * 4))
	ResolutionMax    []uint32 // size: xgb.Pad((int(NumValuators) * 4))
}

// DeviceResolutionStateRead reads a byte slice into a DeviceResolutionState value.
func DeviceResolutionStateRead(buf []byte, v *DeviceResolutionState) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.NumValuators = xgb.Get32(buf[b:])
	b += 4

	v.ResolutionValues = make([]uint32, v.NumValuators)
	for i := 0; i < int(v.NumValuators); i++ {
		v.ResolutionValues[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	v.ResolutionMin = make([]uint32, v.NumValuators)
	for i := 0; i < int(v.NumValuators); i++ {
		v.ResolutionMin[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	v.ResolutionMax = make([]uint32, v.NumValuators)
	for i := 0; i < int(v.NumValuators); i++ {
		v.ResolutionMax[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return b
}

// DeviceResolutionStateReadList reads a byte slice into a list of DeviceResolutionState values.
func DeviceResolutionStateReadList(buf []byte, dest []DeviceResolutionState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceResolutionState{}
		b += DeviceResolutionStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a DeviceResolutionState value to a byte slice.
func (v DeviceResolutionState) Bytes() []byte {
	buf := make([]byte, (((8 + xgb.Pad((int(v.NumValuators) * 4))) + xgb.Pad((int(v.NumValuators) * 4))) + xgb.Pad((int(v.NumValuators) * 4))))
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], v.NumValuators)
	b += 4

	for i := 0; i < int(v.NumValuators); i++ {
		xgb.Put32(buf[b:], v.ResolutionValues[i])
		b += 4
	}
	b = xgb.Pad(b)

	for i := 0; i < int(v.NumValuators); i++ {
		xgb.Put32(buf[b:], v.ResolutionMin[i])
		b += 4
	}
	b = xgb.Pad(b)

	for i := 0; i < int(v.NumValuators); i++ {
		xgb.Put32(buf[b:], v.ResolutionMax[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// DeviceResolutionStateListBytes writes a list of DeviceResolutionState values to a byte slice.
func DeviceResolutionStateListBytes(buf []byte, list []DeviceResolutionState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// DeviceResolutionStateListSize computes the size (bytes) of a list of DeviceResolutionState values.
func DeviceResolutionStateListSize(list []DeviceResolutionState) int {
	size := 0
	for _, item := range list {
		size += (((8 + xgb.Pad((int(item.NumValuators) * 4))) + xgb.Pad((int(item.NumValuators) * 4))) + xgb.Pad((int(item.NumValuators) * 4)))
	}
	return size
}

type DeviceAbsCalibState struct {
	ControlId       uint16
	Len             uint16
	MinX            int32
	MaxX            int32
	MinY            int32
	MaxY            int32
	FlipX           uint32
	FlipY           uint32
	Rotation        uint32
	ButtonThreshold uint32
}

// DeviceAbsCalibStateRead reads a byte slice into a DeviceAbsCalibState value.
func DeviceAbsCalibStateRead(buf []byte, v *DeviceAbsCalibState) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.MinX = int32(xgb.Get32(buf[b:]))
	b += 4

	v.MaxX = int32(xgb.Get32(buf[b:]))
	b += 4

	v.MinY = int32(xgb.Get32(buf[b:]))
	b += 4

	v.MaxY = int32(xgb.Get32(buf[b:]))
	b += 4

	v.FlipX = xgb.Get32(buf[b:])
	b += 4

	v.FlipY = xgb.Get32(buf[b:])
	b += 4

	v.Rotation = xgb.Get32(buf[b:])
	b += 4

	v.ButtonThreshold = xgb.Get32(buf[b:])
	b += 4

	return b
}

// DeviceAbsCalibStateReadList reads a byte slice into a list of DeviceAbsCalibState values.
func DeviceAbsCalibStateReadList(buf []byte, dest []DeviceAbsCalibState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceAbsCalibState{}
		b += DeviceAbsCalibStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a DeviceAbsCalibState value to a byte slice.
func (v DeviceAbsCalibState) Bytes() []byte {
	buf := make([]byte, 36)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], uint32(v.MinX))
	b += 4

	xgb.Put32(buf[b:], uint32(v.MaxX))
	b += 4

	xgb.Put32(buf[b:], uint32(v.MinY))
	b += 4

	xgb.Put32(buf[b:], uint32(v.MaxY))
	b += 4

	xgb.Put32(buf[b:], v.FlipX)
	b += 4

	xgb.Put32(buf[b:], v.FlipY)
	b += 4

	xgb.Put32(buf[b:], v.Rotation)
	b += 4

	xgb.Put32(buf[b:], v.ButtonThreshold)
	b += 4

	return buf
}

// DeviceAbsCalibStateListBytes writes a list of DeviceAbsCalibState values to a byte slice.
func DeviceAbsCalibStateListBytes(buf []byte, list []DeviceAbsCalibState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type DeviceAbsAreaState struct {
	ControlId uint16
	Len       uint16
	OffsetX   uint32
	OffsetY   uint32
	Width     uint32
	Height    uint32
	Screen    uint32
	Following uint32
}

// DeviceAbsAreaStateRead reads a byte slice into a DeviceAbsAreaState value.
func DeviceAbsAreaStateRead(buf []byte, v *DeviceAbsAreaState) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.OffsetX = xgb.Get32(buf[b:])
	b += 4

	v.OffsetY = xgb.Get32(buf[b:])
	b += 4

	v.Width = xgb.Get32(buf[b:])
	b += 4

	v.Height = xgb.Get32(buf[b:])
	b += 4

	v.Screen = xgb.Get32(buf[b:])
	b += 4

	v.Following = xgb.Get32(buf[b:])
	b += 4

	return b
}

// DeviceAbsAreaStateReadList reads a byte slice into a list of DeviceAbsAreaState values.
func DeviceAbsAreaStateReadList(buf []byte, dest []DeviceAbsAreaState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceAbsAreaState{}
		b += DeviceAbsAreaStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a DeviceAbsAreaState value to a byte slice.
func (v DeviceAbsAreaState) Bytes() []byte {
	buf := make([]byte, 28)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], v.OffsetX)
	b += 4

	xgb.Put32(buf[b:], v.OffsetY)
	b += 4

	xgb.Put32(buf[b:], v.Width)
	b += 4

	xgb.Put32(buf[b:], v.Height)
	b += 4

	xgb.Put32(buf[b:], v.Screen)
	b += 4

	xgb.Put32(buf[b:], v.Following)
	b += 4

	return buf
}

// DeviceAbsAreaStateListBytes writes a list of DeviceAbsAreaState values to a byte slice.
func DeviceAbsAreaStateListBytes(buf []byte, list []DeviceAbsAreaState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type DeviceCoreState struct {
	ControlId uint16
	Len       uint16
	Status    byte
	Iscore    byte
	// padding: 2 bytes
}

// DeviceCoreStateRead reads a byte slice into a DeviceCoreState value.
func DeviceCoreStateRead(buf []byte, v *DeviceCoreState) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Status = buf[b]
	b += 1

	v.Iscore = buf[b]
	b += 1

	b += 2 // padding

	return b
}

// DeviceCoreStateReadList reads a byte slice into a list of DeviceCoreState values.
func DeviceCoreStateReadList(buf []byte, dest []DeviceCoreState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceCoreState{}
		b += DeviceCoreStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a DeviceCoreState value to a byte slice.
func (v DeviceCoreState) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.Status
	b += 1

	buf[b] = v.Iscore
	b += 1

	b += 2 // padding

	return buf
}

// DeviceCoreStateListBytes writes a list of DeviceCoreState values to a byte slice.
func DeviceCoreStateListBytes(buf []byte, list []DeviceCoreState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type DeviceEnableState struct {
	ControlId uint16
	Len       uint16
	Enable    byte
	// padding: 3 bytes
}

// DeviceEnableStateRead reads a byte slice into a DeviceEnableState value.
func DeviceEnableStateRead(buf []byte, v *DeviceEnableState) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Enable = buf[b]
	b += 1

	b += 3 // padding

	return b
}

// DeviceEnableStateReadList reads a byte slice into a list of DeviceEnableState values.
func DeviceEnableStateReadList(buf []byte, dest []DeviceEnableState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceEnableState{}
		b += DeviceEnableStateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a DeviceEnableState value to a byte slice.
func (v DeviceEnableState) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.Enable
	b += 1

	b += 3 // padding

	return buf
}

// DeviceEnableStateListBytes writes a list of DeviceEnableState values to a byte slice.
func DeviceEnableStateListBytes(buf []byte, list []DeviceEnableState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type DeviceCtl struct {
	ControlId uint16
	Len       uint16
}

// DeviceCtlRead reads a byte slice into a DeviceCtl value.
func DeviceCtlRead(buf []byte, v *DeviceCtl) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	return b
}

// DeviceCtlReadList reads a byte slice into a list of DeviceCtl values.
func DeviceCtlReadList(buf []byte, dest []DeviceCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceCtl{}
		b += DeviceCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a DeviceCtl value to a byte slice.
func (v DeviceCtl) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	return buf
}

// DeviceCtlListBytes writes a list of DeviceCtl values to a byte slice.
func DeviceCtlListBytes(buf []byte, list []DeviceCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type DeviceResolutionCtl struct {
	ControlId        uint16
	Len              uint16
	FirstValuator    byte
	NumValuators     byte
	ResolutionValues []uint32 // size: xgb.Pad((int(NumValuators) * 4))
}

// DeviceResolutionCtlRead reads a byte slice into a DeviceResolutionCtl value.
func DeviceResolutionCtlRead(buf []byte, v *DeviceResolutionCtl) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.FirstValuator = buf[b]
	b += 1

	v.NumValuators = buf[b]
	b += 1

	v.ResolutionValues = make([]uint32, v.NumValuators)
	for i := 0; i < int(v.NumValuators); i++ {
		v.ResolutionValues[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return b
}

// DeviceResolutionCtlReadList reads a byte slice into a list of DeviceResolutionCtl values.
func DeviceResolutionCtlReadList(buf []byte, dest []DeviceResolutionCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceResolutionCtl{}
		b += DeviceResolutionCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a DeviceResolutionCtl value to a byte slice.
func (v DeviceResolutionCtl) Bytes() []byte {
	buf := make([]byte, (6 + xgb.Pad((int(v.NumValuators) * 4))))
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.FirstValuator
	b += 1

	buf[b] = v.NumValuators
	b += 1

	for i := 0; i < int(v.NumValuators); i++ {
		xgb.Put32(buf[b:], v.ResolutionValues[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// DeviceResolutionCtlListBytes writes a list of DeviceResolutionCtl values to a byte slice.
func DeviceResolutionCtlListBytes(buf []byte, list []DeviceResolutionCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// DeviceResolutionCtlListSize computes the size (bytes) of a list of DeviceResolutionCtl values.
func DeviceResolutionCtlListSize(list []DeviceResolutionCtl) int {
	size := 0
	for _, item := range list {
		size += (6 + xgb.Pad((int(item.NumValuators) * 4)))
	}
	return size
}

type DeviceAbsCalibCtl struct {
	ControlId       uint16
	Len             uint16
	MinX            int32
	MaxX            int32
	MinY            int32
	MaxY            int32
	FlipX           uint32
	FlipY           uint32
	Rotation        uint32
	ButtonThreshold uint32
}

// DeviceAbsCalibCtlRead reads a byte slice into a DeviceAbsCalibCtl value.
func DeviceAbsCalibCtlRead(buf []byte, v *DeviceAbsCalibCtl) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.MinX = int32(xgb.Get32(buf[b:]))
	b += 4

	v.MaxX = int32(xgb.Get32(buf[b:]))
	b += 4

	v.MinY = int32(xgb.Get32(buf[b:]))
	b += 4

	v.MaxY = int32(xgb.Get32(buf[b:]))
	b += 4

	v.FlipX = xgb.Get32(buf[b:])
	b += 4

	v.FlipY = xgb.Get32(buf[b:])
	b += 4

	v.Rotation = xgb.Get32(buf[b:])
	b += 4

	v.ButtonThreshold = xgb.Get32(buf[b:])
	b += 4

	return b
}

// DeviceAbsCalibCtlReadList reads a byte slice into a list of DeviceAbsCalibCtl values.
func DeviceAbsCalibCtlReadList(buf []byte, dest []DeviceAbsCalibCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceAbsCalibCtl{}
		b += DeviceAbsCalibCtlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a DeviceAbsCalibCtl value to a byte slice.
func (v DeviceAbsCalibCtl) Bytes() []byte {
	buf := make([]byte, 36)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], uint32(v.MinX))
	b += 4

	xgb.Put32(buf[b:], uint32(v.MaxX))
	b += 4

	xgb.Put32(buf[b:], uint32(v.MinY))
	b += 4

	xgb.Put32(buf[b:], uint32(v.MaxY))
	b += 4

	xgb.Put32(buf[b:], v.FlipX)
	b += 4

	xgb.Put32(buf[b:], v.FlipY)
	b += 4

	xgb.Put32(buf[b:], v.Rotation)
	b += 4

	xgb.Put32(buf[b:], v.ButtonThreshold)
	b += 4

	return buf
}

// DeviceAbsCalibCtlListBytes writes a list of DeviceAbsCalibCtl values to a byte slice.
func DeviceAbsCalibCtlListBytes(buf []byte, list []DeviceAbsCalibCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type DeviceAbsAreaCtrl struct {
	ControlId uint16
	Len       uint16
	OffsetX   uint32
	OffsetY   uint32
	Width     int32
	Height    int32
	Screen    int32
	Following uint32
}

// DeviceAbsAreaCtrlRead reads a byte slice into a DeviceAbsAreaCtrl value.
func DeviceAbsAreaCtrlRead(buf []byte, v *DeviceAbsAreaCtrl) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.OffsetX = xgb.Get32(buf[b:])
	b += 4

	v.OffsetY = xgb.Get32(buf[b:])
	b += 4

	v.Width = int32(xgb.Get32(buf[b:]))
	b += 4

	v.Height = int32(xgb.Get32(buf[b:]))
	b += 4

	v.Screen = int32(xgb.Get32(buf[b:]))
	b += 4

	v.Following = xgb.Get32(buf[b:])
	b += 4

	return b
}

// DeviceAbsAreaCtrlReadList reads a byte slice into a list of DeviceAbsAreaCtrl values.
func DeviceAbsAreaCtrlReadList(buf []byte, dest []DeviceAbsAreaCtrl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceAbsAreaCtrl{}
		b += DeviceAbsAreaCtrlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a DeviceAbsAreaCtrl value to a byte slice.
func (v DeviceAbsAreaCtrl) Bytes() []byte {
	buf := make([]byte, 28)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	xgb.Put32(buf[b:], v.OffsetX)
	b += 4

	xgb.Put32(buf[b:], v.OffsetY)
	b += 4

	xgb.Put32(buf[b:], uint32(v.Width))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Height))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Screen))
	b += 4

	xgb.Put32(buf[b:], v.Following)
	b += 4

	return buf
}

// DeviceAbsAreaCtrlListBytes writes a list of DeviceAbsAreaCtrl values to a byte slice.
func DeviceAbsAreaCtrlListBytes(buf []byte, list []DeviceAbsAreaCtrl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type DeviceCoreCtrl struct {
	ControlId uint16
	Len       uint16
	Status    byte
	// padding: 3 bytes
}

// DeviceCoreCtrlRead reads a byte slice into a DeviceCoreCtrl value.
func DeviceCoreCtrlRead(buf []byte, v *DeviceCoreCtrl) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Status = buf[b]
	b += 1

	b += 3 // padding

	return b
}

// DeviceCoreCtrlReadList reads a byte slice into a list of DeviceCoreCtrl values.
func DeviceCoreCtrlReadList(buf []byte, dest []DeviceCoreCtrl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceCoreCtrl{}
		b += DeviceCoreCtrlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a DeviceCoreCtrl value to a byte slice.
func (v DeviceCoreCtrl) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.Status
	b += 1

	b += 3 // padding

	return buf
}

// DeviceCoreCtrlListBytes writes a list of DeviceCoreCtrl values to a byte slice.
func DeviceCoreCtrlListBytes(buf []byte, list []DeviceCoreCtrl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type DeviceEnableCtrl struct {
	ControlId uint16
	Len       uint16
	Enable    byte
	// padding: 3 bytes
}

// DeviceEnableCtrlRead reads a byte slice into a DeviceEnableCtrl value.
func DeviceEnableCtrlRead(buf []byte, v *DeviceEnableCtrl) int {
	b := 0

	v.ControlId = xgb.Get16(buf[b:])
	b += 2

	v.Len = xgb.Get16(buf[b:])
	b += 2

	v.Enable = buf[b]
	b += 1

	b += 3 // padding

	return b
}

// DeviceEnableCtrlReadList reads a byte slice into a list of DeviceEnableCtrl values.
func DeviceEnableCtrlReadList(buf []byte, dest []DeviceEnableCtrl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DeviceEnableCtrl{}
		b += DeviceEnableCtrlRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a DeviceEnableCtrl value to a byte slice.
func (v DeviceEnableCtrl) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put16(buf[b:], v.ControlId)
	b += 2

	xgb.Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.Enable
	b += 1

	b += 3 // padding

	return buf
}

// DeviceEnableCtrlListBytes writes a list of DeviceEnableCtrl values to a byte slice.
func DeviceEnableCtrlListBytes(buf []byte, list []DeviceEnableCtrl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// DeviceValuator is the event number for a DeviceValuatorEvent.
const DeviceValuator = 0

type DeviceValuatorEvent struct {
	Sequence      uint16
	DeviceId      byte
	DeviceState   uint16
	NumValuators  byte
	FirstValuator byte
	Valuators     []int32 // size: 24
}

// DeviceValuatorEventNew constructs a DeviceValuatorEvent value that implements xgb.Event from a byte slice.
func DeviceValuatorEventNew(buf []byte) xgb.Event {
	v := DeviceValuatorEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.DeviceState = xgb.Get16(buf[b:])
	b += 2

	v.NumValuators = buf[b]
	b += 1

	v.FirstValuator = buf[b]
	b += 1

	v.Valuators = make([]int32, 6)
	for i := 0; i < int(6); i++ {
		v.Valuators[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Bytes writes a DeviceValuatorEvent value to a byte slice.
func (v DeviceValuatorEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 0
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	xgb.Put16(buf[b:], v.DeviceState)
	b += 2

	buf[b] = v.NumValuators
	b += 1

	buf[b] = v.FirstValuator
	b += 1

	for i := 0; i < int(6); i++ {
		xgb.Put32(buf[b:], uint32(v.Valuators[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// SequenceId returns the sequence id attached to the DeviceValuator event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v DeviceValuatorEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of DeviceValuatorEvent.
func (v DeviceValuatorEvent) String() string {
	fieldVals := make([]string, 0, 5)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceState: %d", v.DeviceState))
	fieldVals = append(fieldVals, xgb.Sprintf("NumValuators: %d", v.NumValuators))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstValuator: %d", v.FirstValuator))
	return "DeviceValuator {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][0] = DeviceValuatorEventNew
}

// DeviceKeyPress is the event number for a DeviceKeyPressEvent.
const DeviceKeyPress = 1

type DeviceKeyPressEvent struct {
	Sequence   uint16
	Detail     byte
	Time       xproto.Timestamp
	Root       xproto.Window
	Event      xproto.Window
	Child      xproto.Window
	RootX      int16
	RootY      int16
	EventX     int16
	EventY     int16
	State      uint16
	SameScreen bool
	DeviceId   byte
}

// DeviceKeyPressEventNew constructs a DeviceKeyPressEvent value that implements xgb.Event from a byte slice.
func DeviceKeyPressEventNew(buf []byte) xgb.Event {
	v := DeviceKeyPressEvent{}
	b := 1 // don't read event number

	v.Detail = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Root = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.Event = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.Child = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.RootX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.RootY = int16(xgb.Get16(buf[b:]))
	b += 2

	v.EventX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.EventY = int16(xgb.Get16(buf[b:]))
	b += 2

	v.State = xgb.Get16(buf[b:])
	b += 2

	if buf[b] == 1 {
		v.SameScreen = true
	} else {
		v.SameScreen = false
	}
	b += 1

	v.DeviceId = buf[b]
	b += 1

	return v
}

// Bytes writes a DeviceKeyPressEvent value to a byte slice.
func (v DeviceKeyPressEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 1
	b += 1

	buf[b] = v.Detail
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Root))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Event))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Child))
	b += 4

	xgb.Put16(buf[b:], uint16(v.RootX))
	b += 2

	xgb.Put16(buf[b:], uint16(v.RootY))
	b += 2

	xgb.Put16(buf[b:], uint16(v.EventX))
	b += 2

	xgb.Put16(buf[b:], uint16(v.EventY))
	b += 2

	xgb.Put16(buf[b:], v.State)
	b += 2

	if v.SameScreen {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	buf[b] = v.DeviceId
	b += 1

	return buf
}

// SequenceId returns the sequence id attached to the DeviceKeyPress event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v DeviceKeyPressEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of DeviceKeyPressEvent.
func (v DeviceKeyPressEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "DeviceKeyPress {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][1] = DeviceKeyPressEventNew
}

// FocusIn is the event number for a FocusInEvent.
const FocusIn = 6

type FocusInEvent struct {
	Sequence uint16
	Detail   byte
	Time     xproto.Timestamp
	Window   xproto.Window
	Mode     byte
	DeviceId byte
	// padding: 18 bytes
}

// FocusInEventNew constructs a FocusInEvent value that implements xgb.Event from a byte slice.
func FocusInEventNew(buf []byte) xgb.Event {
	v := FocusInEvent{}
	b := 1 // don't read event number

	v.Detail = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Window = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.Mode = buf[b]
	b += 1

	v.DeviceId = buf[b]
	b += 1

	b += 18 // padding

	return v
}

// Bytes writes a FocusInEvent value to a byte slice.
func (v FocusInEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 6
	b += 1

	buf[b] = v.Detail
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	buf[b] = v.Mode
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 18 // padding

	return buf
}

// SequenceId returns the sequence id attached to the FocusIn event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v FocusInEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of FocusInEvent.
func (v FocusInEvent) String() string {
	fieldVals := make([]string, 0, 6)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("Mode: %d", v.Mode))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "FocusIn {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][6] = FocusInEventNew
}

// DeviceStateNotify is the event number for a DeviceStateNotifyEvent.
const DeviceStateNotify = 10

type DeviceStateNotifyEvent struct {
	Sequence        uint16
	DeviceId        byte
	Time            xproto.Timestamp
	NumKeys         byte
	NumButtons      byte
	NumValuators    byte
	ClassesReported byte
	Buttons         []byte   // size: 4
	Keys            []byte   // size: 4
	Valuators       []uint32 // size: 12
}

// DeviceStateNotifyEventNew constructs a DeviceStateNotifyEvent value that implements xgb.Event from a byte slice.
func DeviceStateNotifyEventNew(buf []byte) xgb.Event {
	v := DeviceStateNotifyEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.NumKeys = buf[b]
	b += 1

	v.NumButtons = buf[b]
	b += 1

	v.NumValuators = buf[b]
	b += 1

	v.ClassesReported = buf[b]
	b += 1

	v.Buttons = make([]byte, 4)
	copy(v.Buttons[:4], buf[b:])
	b += xgb.Pad(int(4))

	v.Keys = make([]byte, 4)
	copy(v.Keys[:4], buf[b:])
	b += xgb.Pad(int(4))

	v.Valuators = make([]uint32, 3)
	for i := 0; i < int(3); i++ {
		v.Valuators[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Bytes writes a DeviceStateNotifyEvent value to a byte slice.
func (v DeviceStateNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 10
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.NumKeys
	b += 1

	buf[b] = v.NumButtons
	b += 1

	buf[b] = v.NumValuators
	b += 1

	buf[b] = v.ClassesReported
	b += 1

	copy(buf[b:], v.Buttons[:4])
	b += xgb.Pad(int(4))

	copy(buf[b:], v.Keys[:4])
	b += xgb.Pad(int(4))

	for i := 0; i < int(3); i++ {
		xgb.Put32(buf[b:], v.Valuators[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// SequenceId returns the sequence id attached to the DeviceStateNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v DeviceStateNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of DeviceStateNotifyEvent.
func (v DeviceStateNotifyEvent) String() string {
	fieldVals := make([]string, 0, 9)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("NumKeys: %d", v.NumKeys))
	fieldVals = append(fieldVals, xgb.Sprintf("NumButtons: %d", v.NumButtons))
	fieldVals = append(fieldVals, xgb.Sprintf("NumValuators: %d", v.NumValuators))
	fieldVals = append(fieldVals, xgb.Sprintf("ClassesReported: %d", v.ClassesReported))
	return "DeviceStateNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][10] = DeviceStateNotifyEventNew
}

// DeviceMappingNotify is the event number for a DeviceMappingNotifyEvent.
const DeviceMappingNotify = 11

type DeviceMappingNotifyEvent struct {
	Sequence     uint16
	DeviceId     byte
	Request      byte
	FirstKeycode KeyCode
	Count        byte
	// padding: 1 bytes
	Time xproto.Timestamp
	// padding: 20 bytes
}

// DeviceMappingNotifyEventNew constructs a DeviceMappingNotifyEvent value that implements xgb.Event from a byte slice.
func DeviceMappingNotifyEventNew(buf []byte) xgb.Event {
	v := DeviceMappingNotifyEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Request = buf[b]
	b += 1

	v.FirstKeycode = KeyCode(buf[b])
	b += 1

	v.Count = buf[b]
	b += 1

	b += 1 // padding

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	b += 20 // padding

	return v
}

// Bytes writes a DeviceMappingNotifyEvent value to a byte slice.
func (v DeviceMappingNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 11
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	buf[b] = v.Request
	b += 1

	buf[b] = byte(v.FirstKeycode)
	b += 1

	buf[b] = v.Count
	b += 1

	b += 1 // padding

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	b += 20 // padding

	return buf
}

// SequenceId returns the sequence id attached to the DeviceMappingNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v DeviceMappingNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of DeviceMappingNotifyEvent.
func (v DeviceMappingNotifyEvent) String() string {
	fieldVals := make([]string, 0, 7)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	fieldVals = append(fieldVals, xgb.Sprintf("Request: %d", v.Request))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstKeycode: %d", v.FirstKeycode))
	fieldVals = append(fieldVals, xgb.Sprintf("Count: %d", v.Count))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	return "DeviceMappingNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][11] = DeviceMappingNotifyEventNew
}

// ChangeDeviceNotify is the event number for a ChangeDeviceNotifyEvent.
const ChangeDeviceNotify = 12

type ChangeDeviceNotifyEvent struct {
	Sequence uint16
	DeviceId byte
	Time     xproto.Timestamp
	Request  byte
	// padding: 23 bytes
}

// ChangeDeviceNotifyEventNew constructs a ChangeDeviceNotifyEvent value that implements xgb.Event from a byte slice.
func ChangeDeviceNotifyEventNew(buf []byte) xgb.Event {
	v := ChangeDeviceNotifyEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Request = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Bytes writes a ChangeDeviceNotifyEvent value to a byte slice.
func (v ChangeDeviceNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 12
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.Request
	b += 1

	b += 23 // padding

	return buf
}

// SequenceId returns the sequence id attached to the ChangeDeviceNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v ChangeDeviceNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of ChangeDeviceNotifyEvent.
func (v ChangeDeviceNotifyEvent) String() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Request: %d", v.Request))
	return "ChangeDeviceNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][12] = ChangeDeviceNotifyEventNew
}

// DeviceKeyStateNotify is the event number for a DeviceKeyStateNotifyEvent.
const DeviceKeyStateNotify = 13

type DeviceKeyStateNotifyEvent struct {
	Sequence uint16
	DeviceId byte
	Keys     []byte // size: 28
}

// DeviceKeyStateNotifyEventNew constructs a DeviceKeyStateNotifyEvent value that implements xgb.Event from a byte slice.
func DeviceKeyStateNotifyEventNew(buf []byte) xgb.Event {
	v := DeviceKeyStateNotifyEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Keys = make([]byte, 28)
	copy(v.Keys[:28], buf[b:])
	b += xgb.Pad(int(28))

	return v
}

// Bytes writes a DeviceKeyStateNotifyEvent value to a byte slice.
func (v DeviceKeyStateNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 13
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	copy(buf[b:], v.Keys[:28])
	b += xgb.Pad(int(28))

	return buf
}

// SequenceId returns the sequence id attached to the DeviceKeyStateNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v DeviceKeyStateNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of DeviceKeyStateNotifyEvent.
func (v DeviceKeyStateNotifyEvent) String() string {
	fieldVals := make([]string, 0, 2)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "DeviceKeyStateNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][13] = DeviceKeyStateNotifyEventNew
}

// DeviceButtonStateNotify is the event number for a DeviceButtonStateNotifyEvent.
const DeviceButtonStateNotify = 14

type DeviceButtonStateNotifyEvent struct {
	Sequence uint16
	DeviceId byte
	Buttons  []byte // size: 28
}

// DeviceButtonStateNotifyEventNew constructs a DeviceButtonStateNotifyEvent value that implements xgb.Event from a byte slice.
func DeviceButtonStateNotifyEventNew(buf []byte) xgb.Event {
	v := DeviceButtonStateNotifyEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Buttons = make([]byte, 28)
	copy(v.Buttons[:28], buf[b:])
	b += xgb.Pad(int(28))

	return v
}

// Bytes writes a DeviceButtonStateNotifyEvent value to a byte slice.
func (v DeviceButtonStateNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 14
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	copy(buf[b:], v.Buttons[:28])
	b += xgb.Pad(int(28))

	return buf
}

// SequenceId returns the sequence id attached to the DeviceButtonStateNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v DeviceButtonStateNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of DeviceButtonStateNotifyEvent.
func (v DeviceButtonStateNotifyEvent) String() string {
	fieldVals := make([]string, 0, 2)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "DeviceButtonStateNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][14] = DeviceButtonStateNotifyEventNew
}

// DevicePresenceNotify is the event number for a DevicePresenceNotifyEvent.
const DevicePresenceNotify = 15

type DevicePresenceNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Time      xproto.Timestamp
	Devchange byte
	DeviceId  byte
	Control   uint16
	// padding: 20 bytes
}

// DevicePresenceNotifyEventNew constructs a DevicePresenceNotifyEvent value that implements xgb.Event from a byte slice.
func DevicePresenceNotifyEventNew(buf []byte) xgb.Event {
	v := DevicePresenceNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Devchange = buf[b]
	b += 1

	v.DeviceId = buf[b]
	b += 1

	v.Control = xgb.Get16(buf[b:])
	b += 2

	b += 20 // padding

	return v
}

// Bytes writes a DevicePresenceNotifyEvent value to a byte slice.
func (v DevicePresenceNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 15
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.Devchange
	b += 1

	buf[b] = v.DeviceId
	b += 1

	xgb.Put16(buf[b:], v.Control)
	b += 2

	b += 20 // padding

	return buf
}

// SequenceId returns the sequence id attached to the DevicePresenceNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v DevicePresenceNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of DevicePresenceNotifyEvent.
func (v DevicePresenceNotifyEvent) String() string {
	fieldVals := make([]string, 0, 6)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Devchange: %d", v.Devchange))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	fieldVals = append(fieldVals, xgb.Sprintf("Control: %d", v.Control))
	return "DevicePresenceNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][15] = DevicePresenceNotifyEventNew
}

// DeviceKeyRelease is the event number for a DeviceKeyReleaseEvent.
const DeviceKeyRelease = 2

type DeviceKeyReleaseEvent DeviceKeyPressEvent

// DeviceKeyReleaseEventNew constructs a DeviceKeyReleaseEvent value that implements xgb.Event from a byte slice.
func DeviceKeyReleaseEventNew(buf []byte) xgb.Event {
	return DeviceKeyReleaseEvent(DeviceKeyPressEventNew(buf).(DeviceKeyPressEvent))
}

// Bytes writes a DeviceKeyReleaseEvent value to a byte slice.
func (v DeviceKeyReleaseEvent) Bytes() []byte {
	return DeviceKeyPressEvent(v).Bytes()
}

// SequenceId returns the sequence id attached to the DeviceKeyRelease event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v DeviceKeyReleaseEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v DeviceKeyReleaseEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "DeviceKeyRelease {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][2] = DeviceKeyReleaseEventNew
}

// DeviceButtonPress is the event number for a DeviceButtonPressEvent.
const DeviceButtonPress = 3

type DeviceButtonPressEvent DeviceKeyPressEvent

// DeviceButtonPressEventNew constructs a DeviceButtonPressEvent value that implements xgb.Event from a byte slice.
func DeviceButtonPressEventNew(buf []byte) xgb.Event {
	return DeviceButtonPressEvent(DeviceKeyPressEventNew(buf).(DeviceKeyPressEvent))
}

// Bytes writes a DeviceButtonPressEvent value to a byte slice.
func (v DeviceButtonPressEvent) Bytes() []byte {
	return DeviceKeyPressEvent(v).Bytes()
}

// SequenceId returns the sequence id attached to the DeviceButtonPress event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v DeviceButtonPressEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v DeviceButtonPressEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "DeviceButtonPress {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][3] = DeviceButtonPressEventNew
}

// DeviceButtonRelease is the event number for a DeviceButtonReleaseEvent.
const DeviceButtonRelease = 4

type DeviceButtonReleaseEvent DeviceKeyPressEvent

// DeviceButtonReleaseEventNew constructs a DeviceButtonReleaseEvent value that implements xgb.Event from a byte slice.
func DeviceButtonReleaseEventNew(buf []byte) xgb.Event {
	return DeviceButtonReleaseEvent(DeviceKeyPressEventNew(buf).(DeviceKeyPressEvent))
}

// Bytes writes a DeviceButtonReleaseEvent value to a byte slice.
func (v DeviceButtonReleaseEvent) Bytes() []byte {
	return DeviceKeyPressEvent(v).Bytes()
}

// SequenceId returns the sequence id attached to the DeviceButtonRelease event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v DeviceButtonReleaseEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v DeviceButtonReleaseEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "DeviceButtonRelease {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][4] = DeviceButtonReleaseEventNew
}

// DeviceMotionNotify is the event number for a DeviceMotionNotifyEvent.
const DeviceMotionNotify = 5

type DeviceMotionNotifyEvent DeviceKeyPressEvent

// DeviceMotionNotifyEventNew constructs a DeviceMotionNotifyEvent value that implements xgb.Event from a byte slice.
func DeviceMotionNotifyEventNew(buf []byte) xgb.Event {
	return DeviceMotionNotifyEvent(DeviceKeyPressEventNew(buf).(DeviceKeyPressEvent))
}

// Bytes writes a DeviceMotionNotifyEvent value to a byte slice.
func (v DeviceMotionNotifyEvent) Bytes() []byte {
	return DeviceKeyPressEvent(v).Bytes()
}

// SequenceId returns the sequence id attached to the DeviceMotionNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v DeviceMotionNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v DeviceMotionNotifyEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "DeviceMotionNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][5] = DeviceMotionNotifyEventNew
}

// ProximityIn is the event number for a ProximityInEvent.
const ProximityIn = 8

type ProximityInEvent DeviceKeyPressEvent

// ProximityInEventNew constructs a ProximityInEvent value that implements xgb.Event from a byte slice.
func ProximityInEventNew(buf []byte) xgb.Event {
	return ProximityInEvent(DeviceKeyPressEventNew(buf).(DeviceKeyPressEvent))
}

// Bytes writes a ProximityInEvent value to a byte slice.
func (v ProximityInEvent) Bytes() []byte {
	return DeviceKeyPressEvent(v).Bytes()
}

// SequenceId returns the sequence id attached to the ProximityIn event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v ProximityInEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v ProximityInEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "ProximityIn {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][8] = ProximityInEventNew
}

// ProximityOut is the event number for a ProximityOutEvent.
const ProximityOut = 9

type ProximityOutEvent DeviceKeyPressEvent

// ProximityOutEventNew constructs a ProximityOutEvent value that implements xgb.Event from a byte slice.
func ProximityOutEventNew(buf []byte) xgb.Event {
	return ProximityOutEvent(DeviceKeyPressEventNew(buf).(DeviceKeyPressEvent))
}

// Bytes writes a ProximityOutEvent value to a byte slice.
func (v ProximityOutEvent) Bytes() []byte {
	return DeviceKeyPressEvent(v).Bytes()
}

// SequenceId returns the sequence id attached to the ProximityOut event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v ProximityOutEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v ProximityOutEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "ProximityOut {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][9] = ProximityOutEventNew
}

// FocusOut is the event number for a FocusOutEvent.
const FocusOut = 7

type FocusOutEvent FocusInEvent

// FocusOutEventNew constructs a FocusOutEvent value that implements xgb.Event from a byte slice.
func FocusOutEventNew(buf []byte) xgb.Event {
	return FocusOutEvent(FocusInEventNew(buf).(FocusInEvent))
}

// Bytes writes a FocusOutEvent value to a byte slice.
func (v FocusOutEvent) Bytes() []byte {
	return FocusInEvent(v).Bytes()
}

// SequenceId returns the sequence id attached to the FocusOut event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v FocusOutEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v FocusOutEvent) String() string {
	fieldVals := make([]string, 0, 6)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("Mode: %d", v.Mode))
	fieldVals = append(fieldVals, xgb.Sprintf("DeviceId: %d", v.DeviceId))
	return "FocusOut {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["XInputExtension"][7] = FocusOutEventNew
}

// BadDevice is the error number for a BadDevice.
const BadDevice = 0

type DeviceError struct {
	Sequence uint16
	NiceName string
}

// DeviceErrorNew constructs a DeviceError value that implements xgb.Error from a byte slice.
func DeviceErrorNew(buf []byte) xgb.Error {
	v := DeviceError{}
	v.NiceName = "Device"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

// SequenceId returns the sequence id attached to the BadDevice error.
// This is mostly used internally.
func (err DeviceError) SequenceId() uint16 {
	return err.Sequence
}

// BadId returns the 'BadValue' number if one exists for the BadDevice error. If no bad value exists, 0 is returned.
func (err DeviceError) BadId() uint32 {
	return 0
}

// Error returns a rudimentary string representation of the BadDevice error.

func (err DeviceError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadDevice {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["XInputExtension"][0] = DeviceErrorNew
}

// BadEvent is the error number for a BadEvent.
const BadEvent = 1

type EventError struct {
	Sequence uint16
	NiceName string
}

// EventErrorNew constructs a EventError value that implements xgb.Error from a byte slice.
func EventErrorNew(buf []byte) xgb.Error {
	v := EventError{}
	v.NiceName = "Event"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

// SequenceId returns the sequence id attached to the BadEvent error.
// This is mostly used internally.
func (err EventError) SequenceId() uint16 {
	return err.Sequence
}

// BadId returns the 'BadValue' number if one exists for the BadEvent error. If no bad value exists, 0 is returned.
func (err EventError) BadId() uint32 {
	return 0
}

// Error returns a rudimentary string representation of the BadEvent error.

func (err EventError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadEvent {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["XInputExtension"][1] = EventErrorNew
}

// BadMode is the error number for a BadMode.
const BadMode = 2

type ModeError struct {
	Sequence uint16
	NiceName string
}

// ModeErrorNew constructs a ModeError value that implements xgb.Error from a byte slice.
func ModeErrorNew(buf []byte) xgb.Error {
	v := ModeError{}
	v.NiceName = "Mode"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

// SequenceId returns the sequence id attached to the BadMode error.
// This is mostly used internally.
func (err ModeError) SequenceId() uint16 {
	return err.Sequence
}

// BadId returns the 'BadValue' number if one exists for the BadMode error. If no bad value exists, 0 is returned.
func (err ModeError) BadId() uint32 {
	return 0
}

// Error returns a rudimentary string representation of the BadMode error.

func (err ModeError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadMode {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["XInputExtension"][2] = ModeErrorNew
}

// BadDeviceBusy is the error number for a BadDeviceBusy.
const BadDeviceBusy = 3

type DeviceBusyError struct {
	Sequence uint16
	NiceName string
}

// DeviceBusyErrorNew constructs a DeviceBusyError value that implements xgb.Error from a byte slice.
func DeviceBusyErrorNew(buf []byte) xgb.Error {
	v := DeviceBusyError{}
	v.NiceName = "DeviceBusy"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

// SequenceId returns the sequence id attached to the BadDeviceBusy error.
// This is mostly used internally.
func (err DeviceBusyError) SequenceId() uint16 {
	return err.Sequence
}

// BadId returns the 'BadValue' number if one exists for the BadDeviceBusy error. If no bad value exists, 0 is returned.
func (err DeviceBusyError) BadId() uint32 {
	return 0
}

// Error returns a rudimentary string representation of the BadDeviceBusy error.

func (err DeviceBusyError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadDeviceBusy {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["XInputExtension"][3] = DeviceBusyErrorNew
}

// BadClass is the error number for a BadClass.
const BadClass = 4

type ClassError struct {
	Sequence uint16
	NiceName string
}

// ClassErrorNew constructs a ClassError value that implements xgb.Error from a byte slice.
func ClassErrorNew(buf []byte) xgb.Error {
	v := ClassError{}
	v.NiceName = "Class"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

// SequenceId returns the sequence id attached to the BadClass error.
// This is mostly used internally.
func (err ClassError) SequenceId() uint16 {
	return err.Sequence
}

// BadId returns the 'BadValue' number if one exists for the BadClass error. If no bad value exists, 0 is returned.
func (err ClassError) BadId() uint32 {
	return 0
}

// Error returns a rudimentary string representation of the BadClass error.

func (err ClassError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadClass {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["XInputExtension"][4] = ClassErrorNew
}

// GetExtensionVersionCookie is a cookie used only for GetExtensionVersion requests.
type GetExtensionVersionCookie struct {
	*xgb.Cookie
}

// GetExtensionVersion sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetExtensionVersionCookie.Reply()
func GetExtensionVersion(c *xgb.Conn, NameLen uint16, Name string) GetExtensionVersionCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetExtensionVersion' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getExtensionVersionRequest(c, NameLen, Name), cookie)
	return GetExtensionVersionCookie{cookie}
}

// GetExtensionVersionUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetExtensionVersionUnchecked(c *xgb.Conn, NameLen uint16, Name string) GetExtensionVersionCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetExtensionVersion' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getExtensionVersionRequest(c, NameLen, Name), cookie)
	return GetExtensionVersionCookie{cookie}
}

// GetExtensionVersionReply represents the data returned from a GetExtensionVersion request.
type GetExtensionVersionReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	ServerMajor uint16
	ServerMinor uint16
	Present     bool
	// padding: 19 bytes
}

// Reply blocks and returns the reply data for a GetExtensionVersion request.
func (cook GetExtensionVersionCookie) Reply() (*GetExtensionVersionReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getExtensionVersionReply(buf), nil
}

// getExtensionVersionReply reads a byte slice into a GetExtensionVersionReply value.
func getExtensionVersionReply(buf []byte) *GetExtensionVersionReply {
	v := new(GetExtensionVersionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ServerMajor = xgb.Get16(buf[b:])
	b += 2

	v.ServerMinor = xgb.Get16(buf[b:])
	b += 2

	if buf[b] == 1 {
		v.Present = true
	} else {
		v.Present = false
	}
	b += 1

	b += 19 // padding

	return v
}

// Write request to wire for GetExtensionVersion
// getExtensionVersionRequest writes a GetExtensionVersion request to a byte slice.
func getExtensionVersionRequest(c *xgb.Conn, NameLen uint16, Name string) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(NameLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], NameLen)
	b += 2

	b += 2 // padding

	copy(buf[b:], Name[:NameLen])
	b += xgb.Pad(int(NameLen))

	return buf
}

// ListInputDevicesCookie is a cookie used only for ListInputDevices requests.
type ListInputDevicesCookie struct {
	*xgb.Cookie
}

// ListInputDevices sends a checked request.
// If an error occurs, it will be returned with the reply by calling ListInputDevicesCookie.Reply()
func ListInputDevices(c *xgb.Conn) ListInputDevicesCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'ListInputDevices' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(listInputDevicesRequest(c), cookie)
	return ListInputDevicesCookie{cookie}
}

// ListInputDevicesUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func ListInputDevicesUnchecked(c *xgb.Conn) ListInputDevicesCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'ListInputDevices' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(listInputDevicesRequest(c), cookie)
	return ListInputDevicesCookie{cookie}
}

// ListInputDevicesReply represents the data returned from a ListInputDevices request.
type ListInputDevicesReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	DevicesLen byte
	// padding: 23 bytes
	Devices []DeviceInfo // size: xgb.Pad((int(DevicesLen) * 8))
}

// Reply blocks and returns the reply data for a ListInputDevices request.
func (cook ListInputDevicesCookie) Reply() (*ListInputDevicesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listInputDevicesReply(buf), nil
}

// listInputDevicesReply reads a byte slice into a ListInputDevicesReply value.
func listInputDevicesReply(buf []byte) *ListInputDevicesReply {
	v := new(ListInputDevicesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.DevicesLen = buf[b]
	b += 1

	b += 23 // padding

	v.Devices = make([]DeviceInfo, v.DevicesLen)
	b += DeviceInfoReadList(buf[b:], v.Devices)

	return v
}

// Write request to wire for ListInputDevices
// listInputDevicesRequest writes a ListInputDevices request to a byte slice.
func listInputDevicesRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// OpenDeviceCookie is a cookie used only for OpenDevice requests.
type OpenDeviceCookie struct {
	*xgb.Cookie
}

// OpenDevice sends a checked request.
// If an error occurs, it will be returned with the reply by calling OpenDeviceCookie.Reply()
func OpenDevice(c *xgb.Conn, DeviceId byte) OpenDeviceCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'OpenDevice' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(openDeviceRequest(c, DeviceId), cookie)
	return OpenDeviceCookie{cookie}
}

// OpenDeviceUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func OpenDeviceUnchecked(c *xgb.Conn, DeviceId byte) OpenDeviceCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'OpenDevice' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(openDeviceRequest(c, DeviceId), cookie)
	return OpenDeviceCookie{cookie}
}

// OpenDeviceReply represents the data returned from a OpenDevice request.
type OpenDeviceReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	NumClasses byte
	// padding: 23 bytes
	ClassInfo []InputClassInfo // size: xgb.Pad((int(NumClasses) * 2))
}

// Reply blocks and returns the reply data for a OpenDevice request.
func (cook OpenDeviceCookie) Reply() (*OpenDeviceReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return openDeviceReply(buf), nil
}

// openDeviceReply reads a byte slice into a OpenDeviceReply value.
func openDeviceReply(buf []byte) *OpenDeviceReply {
	v := new(OpenDeviceReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumClasses = buf[b]
	b += 1

	b += 23 // padding

	v.ClassInfo = make([]InputClassInfo, v.NumClasses)
	b += InputClassInfoReadList(buf[b:], v.ClassInfo)

	return v
}

// Write request to wire for OpenDevice
// openDeviceRequest writes a OpenDevice request to a byte slice.
func openDeviceRequest(c *xgb.Conn, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// CloseDeviceCookie is a cookie used only for CloseDevice requests.
type CloseDeviceCookie struct {
	*xgb.Cookie
}

// CloseDevice sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func CloseDevice(c *xgb.Conn, DeviceId byte) CloseDeviceCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'CloseDevice' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(closeDeviceRequest(c, DeviceId), cookie)
	return CloseDeviceCookie{cookie}
}

// CloseDeviceChecked sends a checked request.
// If an error occurs, it can be retrieved using CloseDeviceCookie.Check()
func CloseDeviceChecked(c *xgb.Conn, DeviceId byte) CloseDeviceCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'CloseDevice' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(closeDeviceRequest(c, DeviceId), cookie)
	return CloseDeviceCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook CloseDeviceCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CloseDevice
// closeDeviceRequest writes a CloseDevice request to a byte slice.
func closeDeviceRequest(c *xgb.Conn, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// SetDeviceModeCookie is a cookie used only for SetDeviceMode requests.
type SetDeviceModeCookie struct {
	*xgb.Cookie
}

// SetDeviceMode sends a checked request.
// If an error occurs, it will be returned with the reply by calling SetDeviceModeCookie.Reply()
func SetDeviceMode(c *xgb.Conn, DeviceId byte, Mode byte) SetDeviceModeCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'SetDeviceMode' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(setDeviceModeRequest(c, DeviceId, Mode), cookie)
	return SetDeviceModeCookie{cookie}
}

// SetDeviceModeUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SetDeviceModeUnchecked(c *xgb.Conn, DeviceId byte, Mode byte) SetDeviceModeCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'SetDeviceMode' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(setDeviceModeRequest(c, DeviceId, Mode), cookie)
	return SetDeviceModeCookie{cookie}
}

// SetDeviceModeReply represents the data returned from a SetDeviceMode request.
type SetDeviceModeReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Reply blocks and returns the reply data for a SetDeviceMode request.
func (cook SetDeviceModeCookie) Reply() (*SetDeviceModeReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return setDeviceModeReply(buf), nil
}

// setDeviceModeReply reads a byte slice into a SetDeviceModeReply value.
func setDeviceModeReply(buf []byte) *SetDeviceModeReply {
	v := new(SetDeviceModeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for SetDeviceMode
// setDeviceModeRequest writes a SetDeviceMode request to a byte slice.
func setDeviceModeRequest(c *xgb.Conn, DeviceId byte, Mode byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = Mode
	b += 1

	b += 2 // padding

	return buf
}

// SelectExtensionEventCookie is a cookie used only for SelectExtensionEvent requests.
type SelectExtensionEventCookie struct {
	*xgb.Cookie
}

// SelectExtensionEvent sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SelectExtensionEvent(c *xgb.Conn, Window xproto.Window, NumClasses uint16, Classes []EventClass) SelectExtensionEventCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'SelectExtensionEvent' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(selectExtensionEventRequest(c, Window, NumClasses, Classes), cookie)
	return SelectExtensionEventCookie{cookie}
}

// SelectExtensionEventChecked sends a checked request.
// If an error occurs, it can be retrieved using SelectExtensionEventCookie.Check()
func SelectExtensionEventChecked(c *xgb.Conn, Window xproto.Window, NumClasses uint16, Classes []EventClass) SelectExtensionEventCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'SelectExtensionEvent' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(selectExtensionEventRequest(c, Window, NumClasses, Classes), cookie)
	return SelectExtensionEventCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook SelectExtensionEventCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SelectExtensionEvent
// selectExtensionEventRequest writes a SelectExtensionEvent request to a byte slice.
func selectExtensionEventRequest(c *xgb.Conn, Window xproto.Window, NumClasses uint16, Classes []EventClass) []byte {
	size := xgb.Pad((12 + xgb.Pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put16(buf[b:], NumClasses)
	b += 2

	b += 2 // padding

	for i := 0; i < int(NumClasses); i++ {
		xgb.Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// GetSelectedExtensionEventsCookie is a cookie used only for GetSelectedExtensionEvents requests.
type GetSelectedExtensionEventsCookie struct {
	*xgb.Cookie
}

// GetSelectedExtensionEvents sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetSelectedExtensionEventsCookie.Reply()
func GetSelectedExtensionEvents(c *xgb.Conn, Window xproto.Window) GetSelectedExtensionEventsCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetSelectedExtensionEvents' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getSelectedExtensionEventsRequest(c, Window), cookie)
	return GetSelectedExtensionEventsCookie{cookie}
}

// GetSelectedExtensionEventsUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetSelectedExtensionEventsUnchecked(c *xgb.Conn, Window xproto.Window) GetSelectedExtensionEventsCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetSelectedExtensionEvents' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getSelectedExtensionEventsRequest(c, Window), cookie)
	return GetSelectedExtensionEventsCookie{cookie}
}

// GetSelectedExtensionEventsReply represents the data returned from a GetSelectedExtensionEvents request.
type GetSelectedExtensionEventsReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	NumThisClasses uint16
	NumAllClasses  uint16
	// padding: 20 bytes
	ThisClasses []EventClass // size: xgb.Pad((int(NumThisClasses) * 4))
	AllClasses  []EventClass // size: xgb.Pad((int(NumAllClasses) * 4))
}

// Reply blocks and returns the reply data for a GetSelectedExtensionEvents request.
func (cook GetSelectedExtensionEventsCookie) Reply() (*GetSelectedExtensionEventsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getSelectedExtensionEventsReply(buf), nil
}

// getSelectedExtensionEventsReply reads a byte slice into a GetSelectedExtensionEventsReply value.
func getSelectedExtensionEventsReply(buf []byte) *GetSelectedExtensionEventsReply {
	v := new(GetSelectedExtensionEventsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumThisClasses = xgb.Get16(buf[b:])
	b += 2

	v.NumAllClasses = xgb.Get16(buf[b:])
	b += 2

	b += 20 // padding

	v.ThisClasses = make([]EventClass, v.NumThisClasses)
	for i := 0; i < int(v.NumThisClasses); i++ {
		v.ThisClasses[i] = EventClass(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	v.AllClasses = make([]EventClass, v.NumAllClasses)
	for i := 0; i < int(v.NumAllClasses); i++ {
		v.AllClasses[i] = EventClass(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetSelectedExtensionEvents
// getSelectedExtensionEventsRequest writes a GetSelectedExtensionEvents request to a byte slice.
func getSelectedExtensionEventsRequest(c *xgb.Conn, Window xproto.Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// ChangeDeviceDontPropagateListCookie is a cookie used only for ChangeDeviceDontPropagateList requests.
type ChangeDeviceDontPropagateListCookie struct {
	*xgb.Cookie
}

// ChangeDeviceDontPropagateList sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func ChangeDeviceDontPropagateList(c *xgb.Conn, Window xproto.Window, NumClasses uint16, Mode byte, Classes []EventClass) ChangeDeviceDontPropagateListCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'ChangeDeviceDontPropagateList' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeDeviceDontPropagateListRequest(c, Window, NumClasses, Mode, Classes), cookie)
	return ChangeDeviceDontPropagateListCookie{cookie}
}

// ChangeDeviceDontPropagateListChecked sends a checked request.
// If an error occurs, it can be retrieved using ChangeDeviceDontPropagateListCookie.Check()
func ChangeDeviceDontPropagateListChecked(c *xgb.Conn, Window xproto.Window, NumClasses uint16, Mode byte, Classes []EventClass) ChangeDeviceDontPropagateListCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'ChangeDeviceDontPropagateList' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeDeviceDontPropagateListRequest(c, Window, NumClasses, Mode, Classes), cookie)
	return ChangeDeviceDontPropagateListCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook ChangeDeviceDontPropagateListCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeDeviceDontPropagateList
// changeDeviceDontPropagateListRequest writes a ChangeDeviceDontPropagateList request to a byte slice.
func changeDeviceDontPropagateListRequest(c *xgb.Conn, Window xproto.Window, NumClasses uint16, Mode byte, Classes []EventClass) []byte {
	size := xgb.Pad((12 + xgb.Pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 8 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put16(buf[b:], NumClasses)
	b += 2

	buf[b] = Mode
	b += 1

	b += 1 // padding

	for i := 0; i < int(NumClasses); i++ {
		xgb.Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// GetDeviceDontPropagateListCookie is a cookie used only for GetDeviceDontPropagateList requests.
type GetDeviceDontPropagateListCookie struct {
	*xgb.Cookie
}

// GetDeviceDontPropagateList sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetDeviceDontPropagateListCookie.Reply()
func GetDeviceDontPropagateList(c *xgb.Conn, Window xproto.Window) GetDeviceDontPropagateListCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetDeviceDontPropagateList' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceDontPropagateListRequest(c, Window), cookie)
	return GetDeviceDontPropagateListCookie{cookie}
}

// GetDeviceDontPropagateListUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetDeviceDontPropagateListUnchecked(c *xgb.Conn, Window xproto.Window) GetDeviceDontPropagateListCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetDeviceDontPropagateList' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceDontPropagateListRequest(c, Window), cookie)
	return GetDeviceDontPropagateListCookie{cookie}
}

// GetDeviceDontPropagateListReply represents the data returned from a GetDeviceDontPropagateList request.
type GetDeviceDontPropagateListReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	NumClasses uint16
	// padding: 22 bytes
	Classes []EventClass // size: xgb.Pad((int(NumClasses) * 4))
}

// Reply blocks and returns the reply data for a GetDeviceDontPropagateList request.
func (cook GetDeviceDontPropagateListCookie) Reply() (*GetDeviceDontPropagateListReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceDontPropagateListReply(buf), nil
}

// getDeviceDontPropagateListReply reads a byte slice into a GetDeviceDontPropagateListReply value.
func getDeviceDontPropagateListReply(buf []byte) *GetDeviceDontPropagateListReply {
	v := new(GetDeviceDontPropagateListReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumClasses = xgb.Get16(buf[b:])
	b += 2

	b += 22 // padding

	v.Classes = make([]EventClass, v.NumClasses)
	for i := 0; i < int(v.NumClasses); i++ {
		v.Classes[i] = EventClass(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetDeviceDontPropagateList
// getDeviceDontPropagateListRequest writes a GetDeviceDontPropagateList request to a byte slice.
func getDeviceDontPropagateListRequest(c *xgb.Conn, Window xproto.Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 9 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// GetDeviceMotionEventsCookie is a cookie used only for GetDeviceMotionEvents requests.
type GetDeviceMotionEventsCookie struct {
	*xgb.Cookie
}

// GetDeviceMotionEvents sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetDeviceMotionEventsCookie.Reply()
func GetDeviceMotionEvents(c *xgb.Conn, Start xproto.Timestamp, Stop xproto.Timestamp, DeviceId byte) GetDeviceMotionEventsCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetDeviceMotionEvents' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceMotionEventsRequest(c, Start, Stop, DeviceId), cookie)
	return GetDeviceMotionEventsCookie{cookie}
}

// GetDeviceMotionEventsUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetDeviceMotionEventsUnchecked(c *xgb.Conn, Start xproto.Timestamp, Stop xproto.Timestamp, DeviceId byte) GetDeviceMotionEventsCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetDeviceMotionEvents' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceMotionEventsRequest(c, Start, Stop, DeviceId), cookie)
	return GetDeviceMotionEventsCookie{cookie}
}

// GetDeviceMotionEventsReply represents the data returned from a GetDeviceMotionEvents request.
type GetDeviceMotionEventsReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	NumCoords  uint32
	NumAxes    byte
	DeviceMode byte
	// padding: 18 bytes
}

// Reply blocks and returns the reply data for a GetDeviceMotionEvents request.
func (cook GetDeviceMotionEventsCookie) Reply() (*GetDeviceMotionEventsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceMotionEventsReply(buf), nil
}

// getDeviceMotionEventsReply reads a byte slice into a GetDeviceMotionEventsReply value.
func getDeviceMotionEventsReply(buf []byte) *GetDeviceMotionEventsReply {
	v := new(GetDeviceMotionEventsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumCoords = xgb.Get32(buf[b:])
	b += 4

	v.NumAxes = buf[b]
	b += 1

	v.DeviceMode = buf[b]
	b += 1

	b += 18 // padding

	return v
}

// Write request to wire for GetDeviceMotionEvents
// getDeviceMotionEventsRequest writes a GetDeviceMotionEvents request to a byte slice.
func getDeviceMotionEventsRequest(c *xgb.Conn, Start xproto.Timestamp, Stop xproto.Timestamp, DeviceId byte) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 10 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Start))
	b += 4

	xgb.Put32(buf[b:], uint32(Stop))
	b += 4

	buf[b] = DeviceId
	b += 1

	return buf
}

// ChangeKeyboardDeviceCookie is a cookie used only for ChangeKeyboardDevice requests.
type ChangeKeyboardDeviceCookie struct {
	*xgb.Cookie
}

// ChangeKeyboardDevice sends a checked request.
// If an error occurs, it will be returned with the reply by calling ChangeKeyboardDeviceCookie.Reply()
func ChangeKeyboardDevice(c *xgb.Conn, DeviceId byte) ChangeKeyboardDeviceCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'ChangeKeyboardDevice' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(changeKeyboardDeviceRequest(c, DeviceId), cookie)
	return ChangeKeyboardDeviceCookie{cookie}
}

// ChangeKeyboardDeviceUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func ChangeKeyboardDeviceUnchecked(c *xgb.Conn, DeviceId byte) ChangeKeyboardDeviceCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'ChangeKeyboardDevice' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(changeKeyboardDeviceRequest(c, DeviceId), cookie)
	return ChangeKeyboardDeviceCookie{cookie}
}

// ChangeKeyboardDeviceReply represents the data returned from a ChangeKeyboardDevice request.
type ChangeKeyboardDeviceReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Reply blocks and returns the reply data for a ChangeKeyboardDevice request.
func (cook ChangeKeyboardDeviceCookie) Reply() (*ChangeKeyboardDeviceReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return changeKeyboardDeviceReply(buf), nil
}

// changeKeyboardDeviceReply reads a byte slice into a ChangeKeyboardDeviceReply value.
func changeKeyboardDeviceReply(buf []byte) *ChangeKeyboardDeviceReply {
	v := new(ChangeKeyboardDeviceReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for ChangeKeyboardDevice
// changeKeyboardDeviceRequest writes a ChangeKeyboardDevice request to a byte slice.
func changeKeyboardDeviceRequest(c *xgb.Conn, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 11 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// ChangePointerDeviceCookie is a cookie used only for ChangePointerDevice requests.
type ChangePointerDeviceCookie struct {
	*xgb.Cookie
}

// ChangePointerDevice sends a checked request.
// If an error occurs, it will be returned with the reply by calling ChangePointerDeviceCookie.Reply()
func ChangePointerDevice(c *xgb.Conn, XAxis byte, YAxis byte, DeviceId byte) ChangePointerDeviceCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'ChangePointerDevice' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(changePointerDeviceRequest(c, XAxis, YAxis, DeviceId), cookie)
	return ChangePointerDeviceCookie{cookie}
}

// ChangePointerDeviceUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func ChangePointerDeviceUnchecked(c *xgb.Conn, XAxis byte, YAxis byte, DeviceId byte) ChangePointerDeviceCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'ChangePointerDevice' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(changePointerDeviceRequest(c, XAxis, YAxis, DeviceId), cookie)
	return ChangePointerDeviceCookie{cookie}
}

// ChangePointerDeviceReply represents the data returned from a ChangePointerDevice request.
type ChangePointerDeviceReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Reply blocks and returns the reply data for a ChangePointerDevice request.
func (cook ChangePointerDeviceCookie) Reply() (*ChangePointerDeviceReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return changePointerDeviceReply(buf), nil
}

// changePointerDeviceReply reads a byte slice into a ChangePointerDeviceReply value.
func changePointerDeviceReply(buf []byte) *ChangePointerDeviceReply {
	v := new(ChangePointerDeviceReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for ChangePointerDevice
// changePointerDeviceRequest writes a ChangePointerDevice request to a byte slice.
func changePointerDeviceRequest(c *xgb.Conn, XAxis byte, YAxis byte, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 12 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = XAxis
	b += 1

	buf[b] = YAxis
	b += 1

	buf[b] = DeviceId
	b += 1

	b += 1 // padding

	return buf
}

// GrabDeviceCookie is a cookie used only for GrabDevice requests.
type GrabDeviceCookie struct {
	*xgb.Cookie
}

// GrabDevice sends a checked request.
// If an error occurs, it will be returned with the reply by calling GrabDeviceCookie.Reply()
func GrabDevice(c *xgb.Conn, GrabWindow xproto.Window, Time xproto.Timestamp, NumClasses uint16, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, DeviceId byte, Classes []EventClass) GrabDeviceCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GrabDevice' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(grabDeviceRequest(c, GrabWindow, Time, NumClasses, ThisDeviceMode, OtherDeviceMode, OwnerEvents, DeviceId, Classes), cookie)
	return GrabDeviceCookie{cookie}
}

// GrabDeviceUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GrabDeviceUnchecked(c *xgb.Conn, GrabWindow xproto.Window, Time xproto.Timestamp, NumClasses uint16, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, DeviceId byte, Classes []EventClass) GrabDeviceCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GrabDevice' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(grabDeviceRequest(c, GrabWindow, Time, NumClasses, ThisDeviceMode, OtherDeviceMode, OwnerEvents, DeviceId, Classes), cookie)
	return GrabDeviceCookie{cookie}
}

// GrabDeviceReply represents the data returned from a GrabDevice request.
type GrabDeviceReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Reply blocks and returns the reply data for a GrabDevice request.
func (cook GrabDeviceCookie) Reply() (*GrabDeviceReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return grabDeviceReply(buf), nil
}

// grabDeviceReply reads a byte slice into a GrabDeviceReply value.
func grabDeviceReply(buf []byte) *GrabDeviceReply {
	v := new(GrabDeviceReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for GrabDevice
// grabDeviceRequest writes a GrabDevice request to a byte slice.
func grabDeviceRequest(c *xgb.Conn, GrabWindow xproto.Window, Time xproto.Timestamp, NumClasses uint16, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, DeviceId byte, Classes []EventClass) []byte {
	size := xgb.Pad((20 + xgb.Pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 13 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GrabWindow))
	b += 4

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	xgb.Put16(buf[b:], NumClasses)
	b += 2

	buf[b] = ThisDeviceMode
	b += 1

	buf[b] = OtherDeviceMode
	b += 1

	if OwnerEvents {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	buf[b] = DeviceId
	b += 1

	b += 2 // padding

	for i := 0; i < int(NumClasses); i++ {
		xgb.Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// UngrabDeviceCookie is a cookie used only for UngrabDevice requests.
type UngrabDeviceCookie struct {
	*xgb.Cookie
}

// UngrabDevice sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func UngrabDevice(c *xgb.Conn, Time xproto.Timestamp, DeviceId byte) UngrabDeviceCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'UngrabDevice' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(ungrabDeviceRequest(c, Time, DeviceId), cookie)
	return UngrabDeviceCookie{cookie}
}

// UngrabDeviceChecked sends a checked request.
// If an error occurs, it can be retrieved using UngrabDeviceCookie.Check()
func UngrabDeviceChecked(c *xgb.Conn, Time xproto.Timestamp, DeviceId byte) UngrabDeviceCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'UngrabDevice' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(ungrabDeviceRequest(c, Time, DeviceId), cookie)
	return UngrabDeviceCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook UngrabDeviceCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UngrabDevice
// ungrabDeviceRequest writes a UngrabDevice request to a byte slice.
func ungrabDeviceRequest(c *xgb.Conn, Time xproto.Timestamp, DeviceId byte) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 14 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	buf[b] = DeviceId
	b += 1

	return buf
}

// GrabDeviceKeyCookie is a cookie used only for GrabDeviceKey requests.
type GrabDeviceKeyCookie struct {
	*xgb.Cookie
}

// GrabDeviceKey sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GrabDeviceKey(c *xgb.Conn, GrabWindow xproto.Window, NumClasses uint16, Modifiers uint16, ModifierDevice byte, GrabbedDevice byte, Key byte, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, Classes []EventClass) GrabDeviceKeyCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GrabDeviceKey' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(grabDeviceKeyRequest(c, GrabWindow, NumClasses, Modifiers, ModifierDevice, GrabbedDevice, Key, ThisDeviceMode, OtherDeviceMode, OwnerEvents, Classes), cookie)
	return GrabDeviceKeyCookie{cookie}
}

// GrabDeviceKeyChecked sends a checked request.
// If an error occurs, it can be retrieved using GrabDeviceKeyCookie.Check()
func GrabDeviceKeyChecked(c *xgb.Conn, GrabWindow xproto.Window, NumClasses uint16, Modifiers uint16, ModifierDevice byte, GrabbedDevice byte, Key byte, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, Classes []EventClass) GrabDeviceKeyCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GrabDeviceKey' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(grabDeviceKeyRequest(c, GrabWindow, NumClasses, Modifiers, ModifierDevice, GrabbedDevice, Key, ThisDeviceMode, OtherDeviceMode, OwnerEvents, Classes), cookie)
	return GrabDeviceKeyCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook GrabDeviceKeyCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for GrabDeviceKey
// grabDeviceKeyRequest writes a GrabDeviceKey request to a byte slice.
func grabDeviceKeyRequest(c *xgb.Conn, GrabWindow xproto.Window, NumClasses uint16, Modifiers uint16, ModifierDevice byte, GrabbedDevice byte, Key byte, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, Classes []EventClass) []byte {
	size := xgb.Pad((20 + xgb.Pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 15 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GrabWindow))
	b += 4

	xgb.Put16(buf[b:], NumClasses)
	b += 2

	xgb.Put16(buf[b:], Modifiers)
	b += 2

	buf[b] = ModifierDevice
	b += 1

	buf[b] = GrabbedDevice
	b += 1

	buf[b] = Key
	b += 1

	buf[b] = ThisDeviceMode
	b += 1

	buf[b] = OtherDeviceMode
	b += 1

	if OwnerEvents {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 2 // padding

	for i := 0; i < int(NumClasses); i++ {
		xgb.Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// UngrabDeviceKeyCookie is a cookie used only for UngrabDeviceKey requests.
type UngrabDeviceKeyCookie struct {
	*xgb.Cookie
}

// UngrabDeviceKey sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func UngrabDeviceKey(c *xgb.Conn, GrabWindow xproto.Window, Modifiers uint16, ModifierDevice byte, Key byte, GrabbedDevice byte) UngrabDeviceKeyCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'UngrabDeviceKey' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(ungrabDeviceKeyRequest(c, GrabWindow, Modifiers, ModifierDevice, Key, GrabbedDevice), cookie)
	return UngrabDeviceKeyCookie{cookie}
}

// UngrabDeviceKeyChecked sends a checked request.
// If an error occurs, it can be retrieved using UngrabDeviceKeyCookie.Check()
func UngrabDeviceKeyChecked(c *xgb.Conn, GrabWindow xproto.Window, Modifiers uint16, ModifierDevice byte, Key byte, GrabbedDevice byte) UngrabDeviceKeyCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'UngrabDeviceKey' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(ungrabDeviceKeyRequest(c, GrabWindow, Modifiers, ModifierDevice, Key, GrabbedDevice), cookie)
	return UngrabDeviceKeyCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook UngrabDeviceKeyCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UngrabDeviceKey
// ungrabDeviceKeyRequest writes a UngrabDeviceKey request to a byte slice.
func ungrabDeviceKeyRequest(c *xgb.Conn, GrabWindow xproto.Window, Modifiers uint16, ModifierDevice byte, Key byte, GrabbedDevice byte) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 16 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GrabWindow))
	b += 4

	xgb.Put16(buf[b:], Modifiers)
	b += 2

	buf[b] = ModifierDevice
	b += 1

	buf[b] = Key
	b += 1

	buf[b] = GrabbedDevice
	b += 1

	return buf
}

// GrabDeviceButtonCookie is a cookie used only for GrabDeviceButton requests.
type GrabDeviceButtonCookie struct {
	*xgb.Cookie
}

// GrabDeviceButton sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GrabDeviceButton(c *xgb.Conn, GrabWindow xproto.Window, GrabbedDevice byte, ModifierDevice byte, NumClasses uint16, Modifiers uint16, ThisDeviceMode byte, OtherDeviceMode byte, Button byte, OwnerEvents byte, Classes []EventClass) GrabDeviceButtonCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GrabDeviceButton' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(grabDeviceButtonRequest(c, GrabWindow, GrabbedDevice, ModifierDevice, NumClasses, Modifiers, ThisDeviceMode, OtherDeviceMode, Button, OwnerEvents, Classes), cookie)
	return GrabDeviceButtonCookie{cookie}
}

// GrabDeviceButtonChecked sends a checked request.
// If an error occurs, it can be retrieved using GrabDeviceButtonCookie.Check()
func GrabDeviceButtonChecked(c *xgb.Conn, GrabWindow xproto.Window, GrabbedDevice byte, ModifierDevice byte, NumClasses uint16, Modifiers uint16, ThisDeviceMode byte, OtherDeviceMode byte, Button byte, OwnerEvents byte, Classes []EventClass) GrabDeviceButtonCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GrabDeviceButton' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(grabDeviceButtonRequest(c, GrabWindow, GrabbedDevice, ModifierDevice, NumClasses, Modifiers, ThisDeviceMode, OtherDeviceMode, Button, OwnerEvents, Classes), cookie)
	return GrabDeviceButtonCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook GrabDeviceButtonCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for GrabDeviceButton
// grabDeviceButtonRequest writes a GrabDeviceButton request to a byte slice.
func grabDeviceButtonRequest(c *xgb.Conn, GrabWindow xproto.Window, GrabbedDevice byte, ModifierDevice byte, NumClasses uint16, Modifiers uint16, ThisDeviceMode byte, OtherDeviceMode byte, Button byte, OwnerEvents byte, Classes []EventClass) []byte {
	size := xgb.Pad((20 + xgb.Pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 17 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GrabWindow))
	b += 4

	buf[b] = GrabbedDevice
	b += 1

	buf[b] = ModifierDevice
	b += 1

	xgb.Put16(buf[b:], NumClasses)
	b += 2

	xgb.Put16(buf[b:], Modifiers)
	b += 2

	buf[b] = ThisDeviceMode
	b += 1

	buf[b] = OtherDeviceMode
	b += 1

	buf[b] = Button
	b += 1

	buf[b] = OwnerEvents
	b += 1

	b += 2 // padding

	for i := 0; i < int(NumClasses); i++ {
		xgb.Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// UngrabDeviceButtonCookie is a cookie used only for UngrabDeviceButton requests.
type UngrabDeviceButtonCookie struct {
	*xgb.Cookie
}

// UngrabDeviceButton sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func UngrabDeviceButton(c *xgb.Conn, GrabWindow xproto.Window, Modifiers uint16, ModifierDevice byte, Button byte, GrabbedDevice byte) UngrabDeviceButtonCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'UngrabDeviceButton' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(ungrabDeviceButtonRequest(c, GrabWindow, Modifiers, ModifierDevice, Button, GrabbedDevice), cookie)
	return UngrabDeviceButtonCookie{cookie}
}

// UngrabDeviceButtonChecked sends a checked request.
// If an error occurs, it can be retrieved using UngrabDeviceButtonCookie.Check()
func UngrabDeviceButtonChecked(c *xgb.Conn, GrabWindow xproto.Window, Modifiers uint16, ModifierDevice byte, Button byte, GrabbedDevice byte) UngrabDeviceButtonCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'UngrabDeviceButton' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(ungrabDeviceButtonRequest(c, GrabWindow, Modifiers, ModifierDevice, Button, GrabbedDevice), cookie)
	return UngrabDeviceButtonCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook UngrabDeviceButtonCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UngrabDeviceButton
// ungrabDeviceButtonRequest writes a UngrabDeviceButton request to a byte slice.
func ungrabDeviceButtonRequest(c *xgb.Conn, GrabWindow xproto.Window, Modifiers uint16, ModifierDevice byte, Button byte, GrabbedDevice byte) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 18 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GrabWindow))
	b += 4

	xgb.Put16(buf[b:], Modifiers)
	b += 2

	buf[b] = ModifierDevice
	b += 1

	buf[b] = Button
	b += 1

	buf[b] = GrabbedDevice
	b += 1

	return buf
}

// AllowDeviceEventsCookie is a cookie used only for AllowDeviceEvents requests.
type AllowDeviceEventsCookie struct {
	*xgb.Cookie
}

// AllowDeviceEvents sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func AllowDeviceEvents(c *xgb.Conn, Time xproto.Timestamp, Mode byte, DeviceId byte) AllowDeviceEventsCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'AllowDeviceEvents' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(allowDeviceEventsRequest(c, Time, Mode, DeviceId), cookie)
	return AllowDeviceEventsCookie{cookie}
}

// AllowDeviceEventsChecked sends a checked request.
// If an error occurs, it can be retrieved using AllowDeviceEventsCookie.Check()
func AllowDeviceEventsChecked(c *xgb.Conn, Time xproto.Timestamp, Mode byte, DeviceId byte) AllowDeviceEventsCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'AllowDeviceEvents' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(allowDeviceEventsRequest(c, Time, Mode, DeviceId), cookie)
	return AllowDeviceEventsCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook AllowDeviceEventsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for AllowDeviceEvents
// allowDeviceEventsRequest writes a AllowDeviceEvents request to a byte slice.
func allowDeviceEventsRequest(c *xgb.Conn, Time xproto.Timestamp, Mode byte, DeviceId byte) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 19 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	buf[b] = Mode
	b += 1

	buf[b] = DeviceId
	b += 1

	return buf
}

// GetDeviceFocusCookie is a cookie used only for GetDeviceFocus requests.
type GetDeviceFocusCookie struct {
	*xgb.Cookie
}

// GetDeviceFocus sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetDeviceFocusCookie.Reply()
func GetDeviceFocus(c *xgb.Conn, DeviceId byte) GetDeviceFocusCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetDeviceFocus' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceFocusRequest(c, DeviceId), cookie)
	return GetDeviceFocusCookie{cookie}
}

// GetDeviceFocusUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetDeviceFocusUnchecked(c *xgb.Conn, DeviceId byte) GetDeviceFocusCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetDeviceFocus' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceFocusRequest(c, DeviceId), cookie)
	return GetDeviceFocusCookie{cookie}
}

// GetDeviceFocusReply represents the data returned from a GetDeviceFocus request.
type GetDeviceFocusReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	Focus    xproto.Window
	Time     xproto.Timestamp
	RevertTo byte
	// padding: 15 bytes
}

// Reply blocks and returns the reply data for a GetDeviceFocus request.
func (cook GetDeviceFocusCookie) Reply() (*GetDeviceFocusReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceFocusReply(buf), nil
}

// getDeviceFocusReply reads a byte slice into a GetDeviceFocusReply value.
func getDeviceFocusReply(buf []byte) *GetDeviceFocusReply {
	v := new(GetDeviceFocusReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Focus = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.Time = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.RevertTo = buf[b]
	b += 1

	b += 15 // padding

	return v
}

// Write request to wire for GetDeviceFocus
// getDeviceFocusRequest writes a GetDeviceFocus request to a byte slice.
func getDeviceFocusRequest(c *xgb.Conn, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 20 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// SetDeviceFocusCookie is a cookie used only for SetDeviceFocus requests.
type SetDeviceFocusCookie struct {
	*xgb.Cookie
}

// SetDeviceFocus sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SetDeviceFocus(c *xgb.Conn, Focus xproto.Window, Time xproto.Timestamp, RevertTo byte, DeviceId byte) SetDeviceFocusCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'SetDeviceFocus' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(setDeviceFocusRequest(c, Focus, Time, RevertTo, DeviceId), cookie)
	return SetDeviceFocusCookie{cookie}
}

// SetDeviceFocusChecked sends a checked request.
// If an error occurs, it can be retrieved using SetDeviceFocusCookie.Check()
func SetDeviceFocusChecked(c *xgb.Conn, Focus xproto.Window, Time xproto.Timestamp, RevertTo byte, DeviceId byte) SetDeviceFocusCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'SetDeviceFocus' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(setDeviceFocusRequest(c, Focus, Time, RevertTo, DeviceId), cookie)
	return SetDeviceFocusCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook SetDeviceFocusCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetDeviceFocus
// setDeviceFocusRequest writes a SetDeviceFocus request to a byte slice.
func setDeviceFocusRequest(c *xgb.Conn, Focus xproto.Window, Time xproto.Timestamp, RevertTo byte, DeviceId byte) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 21 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Focus))
	b += 4

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	buf[b] = RevertTo
	b += 1

	buf[b] = DeviceId
	b += 1

	return buf
}

// GetFeedbackControlCookie is a cookie used only for GetFeedbackControl requests.
type GetFeedbackControlCookie struct {
	*xgb.Cookie
}

// GetFeedbackControl sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetFeedbackControlCookie.Reply()
func GetFeedbackControl(c *xgb.Conn, DeviceId byte) GetFeedbackControlCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetFeedbackControl' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getFeedbackControlRequest(c, DeviceId), cookie)
	return GetFeedbackControlCookie{cookie}
}

// GetFeedbackControlUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetFeedbackControlUnchecked(c *xgb.Conn, DeviceId byte) GetFeedbackControlCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetFeedbackControl' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getFeedbackControlRequest(c, DeviceId), cookie)
	return GetFeedbackControlCookie{cookie}
}

// GetFeedbackControlReply represents the data returned from a GetFeedbackControl request.
type GetFeedbackControlReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	NumFeedback uint16
	// padding: 22 bytes
}

// Reply blocks and returns the reply data for a GetFeedbackControl request.
func (cook GetFeedbackControlCookie) Reply() (*GetFeedbackControlReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getFeedbackControlReply(buf), nil
}

// getFeedbackControlReply reads a byte slice into a GetFeedbackControlReply value.
func getFeedbackControlReply(buf []byte) *GetFeedbackControlReply {
	v := new(GetFeedbackControlReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumFeedback = xgb.Get16(buf[b:])
	b += 2

	b += 22 // padding

	return v
}

// Write request to wire for GetFeedbackControl
// getFeedbackControlRequest writes a GetFeedbackControl request to a byte slice.
func getFeedbackControlRequest(c *xgb.Conn, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 22 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// GetDeviceKeyMappingCookie is a cookie used only for GetDeviceKeyMapping requests.
type GetDeviceKeyMappingCookie struct {
	*xgb.Cookie
}

// GetDeviceKeyMapping sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetDeviceKeyMappingCookie.Reply()
func GetDeviceKeyMapping(c *xgb.Conn, DeviceId byte, FirstKeycode KeyCode, Count byte) GetDeviceKeyMappingCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetDeviceKeyMapping' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceKeyMappingRequest(c, DeviceId, FirstKeycode, Count), cookie)
	return GetDeviceKeyMappingCookie{cookie}
}

// GetDeviceKeyMappingUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetDeviceKeyMappingUnchecked(c *xgb.Conn, DeviceId byte, FirstKeycode KeyCode, Count byte) GetDeviceKeyMappingCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetDeviceKeyMapping' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceKeyMappingRequest(c, DeviceId, FirstKeycode, Count), cookie)
	return GetDeviceKeyMappingCookie{cookie}
}

// GetDeviceKeyMappingReply represents the data returned from a GetDeviceKeyMapping request.
type GetDeviceKeyMappingReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	KeysymsPerKeycode byte
	// padding: 23 bytes
	Keysyms []xproto.Keysym // size: xgb.Pad((int(Length) * 4))
}

// Reply blocks and returns the reply data for a GetDeviceKeyMapping request.
func (cook GetDeviceKeyMappingCookie) Reply() (*GetDeviceKeyMappingReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceKeyMappingReply(buf), nil
}

// getDeviceKeyMappingReply reads a byte slice into a GetDeviceKeyMappingReply value.
func getDeviceKeyMappingReply(buf []byte) *GetDeviceKeyMappingReply {
	v := new(GetDeviceKeyMappingReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.KeysymsPerKeycode = buf[b]
	b += 1

	b += 23 // padding

	v.Keysyms = make([]xproto.Keysym, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.Keysyms[i] = xproto.Keysym(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetDeviceKeyMapping
// getDeviceKeyMappingRequest writes a GetDeviceKeyMapping request to a byte slice.
func getDeviceKeyMappingRequest(c *xgb.Conn, DeviceId byte, FirstKeycode KeyCode, Count byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 24 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = byte(FirstKeycode)
	b += 1

	buf[b] = Count
	b += 1

	return buf
}

// ChangeDeviceKeyMappingCookie is a cookie used only for ChangeDeviceKeyMapping requests.
type ChangeDeviceKeyMappingCookie struct {
	*xgb.Cookie
}

// ChangeDeviceKeyMapping sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func ChangeDeviceKeyMapping(c *xgb.Conn, DeviceId byte, FirstKeycode KeyCode, KeysymsPerKeycode byte, KeycodeCount byte, Keysyms []xproto.Keysym) ChangeDeviceKeyMappingCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'ChangeDeviceKeyMapping' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeDeviceKeyMappingRequest(c, DeviceId, FirstKeycode, KeysymsPerKeycode, KeycodeCount, Keysyms), cookie)
	return ChangeDeviceKeyMappingCookie{cookie}
}

// ChangeDeviceKeyMappingChecked sends a checked request.
// If an error occurs, it can be retrieved using ChangeDeviceKeyMappingCookie.Check()
func ChangeDeviceKeyMappingChecked(c *xgb.Conn, DeviceId byte, FirstKeycode KeyCode, KeysymsPerKeycode byte, KeycodeCount byte, Keysyms []xproto.Keysym) ChangeDeviceKeyMappingCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'ChangeDeviceKeyMapping' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeDeviceKeyMappingRequest(c, DeviceId, FirstKeycode, KeysymsPerKeycode, KeycodeCount, Keysyms), cookie)
	return ChangeDeviceKeyMappingCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook ChangeDeviceKeyMappingCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeDeviceKeyMapping
// changeDeviceKeyMappingRequest writes a ChangeDeviceKeyMapping request to a byte slice.
func changeDeviceKeyMappingRequest(c *xgb.Conn, DeviceId byte, FirstKeycode KeyCode, KeysymsPerKeycode byte, KeycodeCount byte, Keysyms []xproto.Keysym) []byte {
	size := xgb.Pad((8 + xgb.Pad(((int(KeycodeCount) * int(KeysymsPerKeycode)) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 25 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = byte(FirstKeycode)
	b += 1

	buf[b] = KeysymsPerKeycode
	b += 1

	buf[b] = KeycodeCount
	b += 1

	for i := 0; i < int((int(KeycodeCount) * int(KeysymsPerKeycode))); i++ {
		xgb.Put32(buf[b:], uint32(Keysyms[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// GetDeviceModifierMappingCookie is a cookie used only for GetDeviceModifierMapping requests.
type GetDeviceModifierMappingCookie struct {
	*xgb.Cookie
}

// GetDeviceModifierMapping sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetDeviceModifierMappingCookie.Reply()
func GetDeviceModifierMapping(c *xgb.Conn, DeviceId byte) GetDeviceModifierMappingCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetDeviceModifierMapping' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceModifierMappingRequest(c, DeviceId), cookie)
	return GetDeviceModifierMappingCookie{cookie}
}

// GetDeviceModifierMappingUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetDeviceModifierMappingUnchecked(c *xgb.Conn, DeviceId byte) GetDeviceModifierMappingCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetDeviceModifierMapping' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceModifierMappingRequest(c, DeviceId), cookie)
	return GetDeviceModifierMappingCookie{cookie}
}

// GetDeviceModifierMappingReply represents the data returned from a GetDeviceModifierMapping request.
type GetDeviceModifierMappingReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	KeycodesPerModifier byte
	// padding: 23 bytes
	Keymaps []byte // size: xgb.Pad(((int(KeycodesPerModifier) * 8) * 1))
}

// Reply blocks and returns the reply data for a GetDeviceModifierMapping request.
func (cook GetDeviceModifierMappingCookie) Reply() (*GetDeviceModifierMappingReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceModifierMappingReply(buf), nil
}

// getDeviceModifierMappingReply reads a byte slice into a GetDeviceModifierMappingReply value.
func getDeviceModifierMappingReply(buf []byte) *GetDeviceModifierMappingReply {
	v := new(GetDeviceModifierMappingReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.KeycodesPerModifier = buf[b]
	b += 1

	b += 23 // padding

	v.Keymaps = make([]byte, (int(v.KeycodesPerModifier) * 8))
	copy(v.Keymaps[:(int(v.KeycodesPerModifier)*8)], buf[b:])
	b += xgb.Pad(int((int(v.KeycodesPerModifier) * 8)))

	return v
}

// Write request to wire for GetDeviceModifierMapping
// getDeviceModifierMappingRequest writes a GetDeviceModifierMapping request to a byte slice.
func getDeviceModifierMappingRequest(c *xgb.Conn, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 26 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// SetDeviceModifierMappingCookie is a cookie used only for SetDeviceModifierMapping requests.
type SetDeviceModifierMappingCookie struct {
	*xgb.Cookie
}

// SetDeviceModifierMapping sends a checked request.
// If an error occurs, it will be returned with the reply by calling SetDeviceModifierMappingCookie.Reply()
func SetDeviceModifierMapping(c *xgb.Conn, DeviceId byte, KeycodesPerModifier byte, Keymaps []byte) SetDeviceModifierMappingCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'SetDeviceModifierMapping' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(setDeviceModifierMappingRequest(c, DeviceId, KeycodesPerModifier, Keymaps), cookie)
	return SetDeviceModifierMappingCookie{cookie}
}

// SetDeviceModifierMappingUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SetDeviceModifierMappingUnchecked(c *xgb.Conn, DeviceId byte, KeycodesPerModifier byte, Keymaps []byte) SetDeviceModifierMappingCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'SetDeviceModifierMapping' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(setDeviceModifierMappingRequest(c, DeviceId, KeycodesPerModifier, Keymaps), cookie)
	return SetDeviceModifierMappingCookie{cookie}
}

// SetDeviceModifierMappingReply represents the data returned from a SetDeviceModifierMapping request.
type SetDeviceModifierMappingReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Reply blocks and returns the reply data for a SetDeviceModifierMapping request.
func (cook SetDeviceModifierMappingCookie) Reply() (*SetDeviceModifierMappingReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return setDeviceModifierMappingReply(buf), nil
}

// setDeviceModifierMappingReply reads a byte slice into a SetDeviceModifierMappingReply value.
func setDeviceModifierMappingReply(buf []byte) *SetDeviceModifierMappingReply {
	v := new(SetDeviceModifierMappingReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for SetDeviceModifierMapping
// setDeviceModifierMappingRequest writes a SetDeviceModifierMapping request to a byte slice.
func setDeviceModifierMappingRequest(c *xgb.Conn, DeviceId byte, KeycodesPerModifier byte, Keymaps []byte) []byte {
	size := xgb.Pad((7 + xgb.Pad(((int(KeycodesPerModifier) * 8) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 27 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = KeycodesPerModifier
	b += 1

	b += 1 // padding

	copy(buf[b:], Keymaps[:(int(KeycodesPerModifier)*8)])
	b += xgb.Pad(int((int(KeycodesPerModifier) * 8)))

	return buf
}

// GetDeviceButtonMappingCookie is a cookie used only for GetDeviceButtonMapping requests.
type GetDeviceButtonMappingCookie struct {
	*xgb.Cookie
}

// GetDeviceButtonMapping sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetDeviceButtonMappingCookie.Reply()
func GetDeviceButtonMapping(c *xgb.Conn, DeviceId byte) GetDeviceButtonMappingCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetDeviceButtonMapping' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceButtonMappingRequest(c, DeviceId), cookie)
	return GetDeviceButtonMappingCookie{cookie}
}

// GetDeviceButtonMappingUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetDeviceButtonMappingUnchecked(c *xgb.Conn, DeviceId byte) GetDeviceButtonMappingCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetDeviceButtonMapping' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceButtonMappingRequest(c, DeviceId), cookie)
	return GetDeviceButtonMappingCookie{cookie}
}

// GetDeviceButtonMappingReply represents the data returned from a GetDeviceButtonMapping request.
type GetDeviceButtonMappingReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	MapSize byte
	// padding: 23 bytes
	Map []byte // size: xgb.Pad((int(MapSize) * 1))
}

// Reply blocks and returns the reply data for a GetDeviceButtonMapping request.
func (cook GetDeviceButtonMappingCookie) Reply() (*GetDeviceButtonMappingReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceButtonMappingReply(buf), nil
}

// getDeviceButtonMappingReply reads a byte slice into a GetDeviceButtonMappingReply value.
func getDeviceButtonMappingReply(buf []byte) *GetDeviceButtonMappingReply {
	v := new(GetDeviceButtonMappingReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.MapSize = buf[b]
	b += 1

	b += 23 // padding

	v.Map = make([]byte, v.MapSize)
	copy(v.Map[:v.MapSize], buf[b:])
	b += xgb.Pad(int(v.MapSize))

	return v
}

// Write request to wire for GetDeviceButtonMapping
// getDeviceButtonMappingRequest writes a GetDeviceButtonMapping request to a byte slice.
func getDeviceButtonMappingRequest(c *xgb.Conn, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 28 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// SetDeviceButtonMappingCookie is a cookie used only for SetDeviceButtonMapping requests.
type SetDeviceButtonMappingCookie struct {
	*xgb.Cookie
}

// SetDeviceButtonMapping sends a checked request.
// If an error occurs, it will be returned with the reply by calling SetDeviceButtonMappingCookie.Reply()
func SetDeviceButtonMapping(c *xgb.Conn, DeviceId byte, MapSize byte, Map []byte) SetDeviceButtonMappingCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'SetDeviceButtonMapping' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(setDeviceButtonMappingRequest(c, DeviceId, MapSize, Map), cookie)
	return SetDeviceButtonMappingCookie{cookie}
}

// SetDeviceButtonMappingUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SetDeviceButtonMappingUnchecked(c *xgb.Conn, DeviceId byte, MapSize byte, Map []byte) SetDeviceButtonMappingCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'SetDeviceButtonMapping' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(setDeviceButtonMappingRequest(c, DeviceId, MapSize, Map), cookie)
	return SetDeviceButtonMappingCookie{cookie}
}

// SetDeviceButtonMappingReply represents the data returned from a SetDeviceButtonMapping request.
type SetDeviceButtonMappingReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Reply blocks and returns the reply data for a SetDeviceButtonMapping request.
func (cook SetDeviceButtonMappingCookie) Reply() (*SetDeviceButtonMappingReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return setDeviceButtonMappingReply(buf), nil
}

// setDeviceButtonMappingReply reads a byte slice into a SetDeviceButtonMappingReply value.
func setDeviceButtonMappingReply(buf []byte) *SetDeviceButtonMappingReply {
	v := new(SetDeviceButtonMappingReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for SetDeviceButtonMapping
// setDeviceButtonMappingRequest writes a SetDeviceButtonMapping request to a byte slice.
func setDeviceButtonMappingRequest(c *xgb.Conn, DeviceId byte, MapSize byte, Map []byte) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(MapSize) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 29 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = MapSize
	b += 1

	b += 2 // padding

	copy(buf[b:], Map[:MapSize])
	b += xgb.Pad(int(MapSize))

	return buf
}

// QueryDeviceStateCookie is a cookie used only for QueryDeviceState requests.
type QueryDeviceStateCookie struct {
	*xgb.Cookie
}

// QueryDeviceState sends a checked request.
// If an error occurs, it will be returned with the reply by calling QueryDeviceStateCookie.Reply()
func QueryDeviceState(c *xgb.Conn, DeviceId byte) QueryDeviceStateCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'QueryDeviceState' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryDeviceStateRequest(c, DeviceId), cookie)
	return QueryDeviceStateCookie{cookie}
}

// QueryDeviceStateUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func QueryDeviceStateUnchecked(c *xgb.Conn, DeviceId byte) QueryDeviceStateCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'QueryDeviceState' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryDeviceStateRequest(c, DeviceId), cookie)
	return QueryDeviceStateCookie{cookie}
}

// QueryDeviceStateReply represents the data returned from a QueryDeviceState request.
type QueryDeviceStateReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	NumClasses byte
	// padding: 23 bytes
}

// Reply blocks and returns the reply data for a QueryDeviceState request.
func (cook QueryDeviceStateCookie) Reply() (*QueryDeviceStateReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryDeviceStateReply(buf), nil
}

// queryDeviceStateReply reads a byte slice into a QueryDeviceStateReply value.
func queryDeviceStateReply(buf []byte) *QueryDeviceStateReply {
	v := new(QueryDeviceStateReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumClasses = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for QueryDeviceState
// queryDeviceStateRequest writes a QueryDeviceState request to a byte slice.
func queryDeviceStateRequest(c *xgb.Conn, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 30 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// SendExtensionEventCookie is a cookie used only for SendExtensionEvent requests.
type SendExtensionEventCookie struct {
	*xgb.Cookie
}

// SendExtensionEvent sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SendExtensionEvent(c *xgb.Conn, Destination xproto.Window, DeviceId byte, Propagate bool, NumClasses uint16, NumEvents byte, Events string, Classes []EventClass) SendExtensionEventCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'SendExtensionEvent' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(sendExtensionEventRequest(c, Destination, DeviceId, Propagate, NumClasses, NumEvents, Events, Classes), cookie)
	return SendExtensionEventCookie{cookie}
}

// SendExtensionEventChecked sends a checked request.
// If an error occurs, it can be retrieved using SendExtensionEventCookie.Check()
func SendExtensionEventChecked(c *xgb.Conn, Destination xproto.Window, DeviceId byte, Propagate bool, NumClasses uint16, NumEvents byte, Events string, Classes []EventClass) SendExtensionEventCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'SendExtensionEvent' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(sendExtensionEventRequest(c, Destination, DeviceId, Propagate, NumClasses, NumEvents, Events, Classes), cookie)
	return SendExtensionEventCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook SendExtensionEventCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SendExtensionEvent
// sendExtensionEventRequest writes a SendExtensionEvent request to a byte slice.
func sendExtensionEventRequest(c *xgb.Conn, Destination xproto.Window, DeviceId byte, Propagate bool, NumClasses uint16, NumEvents byte, Events string, Classes []EventClass) []byte {
	size := xgb.Pad(((16 + xgb.Pad(((int(NumEvents) * 32) * 1))) + xgb.Pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 31 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Destination))
	b += 4

	buf[b] = DeviceId
	b += 1

	if Propagate {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	xgb.Put16(buf[b:], NumClasses)
	b += 2

	buf[b] = NumEvents
	b += 1

	b += 3 // padding

	copy(buf[b:], Events[:(int(NumEvents)*32)])
	b += xgb.Pad(int((int(NumEvents) * 32)))

	for i := 0; i < int(NumClasses); i++ {
		xgb.Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// DeviceBellCookie is a cookie used only for DeviceBell requests.
type DeviceBellCookie struct {
	*xgb.Cookie
}

// DeviceBell sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func DeviceBell(c *xgb.Conn, DeviceId byte, FeedbackId byte, FeedbackClass byte, Percent int8) DeviceBellCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'DeviceBell' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(deviceBellRequest(c, DeviceId, FeedbackId, FeedbackClass, Percent), cookie)
	return DeviceBellCookie{cookie}
}

// DeviceBellChecked sends a checked request.
// If an error occurs, it can be retrieved using DeviceBellCookie.Check()
func DeviceBellChecked(c *xgb.Conn, DeviceId byte, FeedbackId byte, FeedbackClass byte, Percent int8) DeviceBellCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'DeviceBell' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(deviceBellRequest(c, DeviceId, FeedbackId, FeedbackClass, Percent), cookie)
	return DeviceBellCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook DeviceBellCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DeviceBell
// deviceBellRequest writes a DeviceBell request to a byte slice.
func deviceBellRequest(c *xgb.Conn, DeviceId byte, FeedbackId byte, FeedbackClass byte, Percent int8) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 32 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = FeedbackId
	b += 1

	buf[b] = FeedbackClass
	b += 1

	buf[b] = byte(Percent)
	b += 1

	return buf
}

// SetDeviceValuatorsCookie is a cookie used only for SetDeviceValuators requests.
type SetDeviceValuatorsCookie struct {
	*xgb.Cookie
}

// SetDeviceValuators sends a checked request.
// If an error occurs, it will be returned with the reply by calling SetDeviceValuatorsCookie.Reply()
func SetDeviceValuators(c *xgb.Conn, DeviceId byte, FirstValuator byte, NumValuators byte, Valuators []int32) SetDeviceValuatorsCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'SetDeviceValuators' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(setDeviceValuatorsRequest(c, DeviceId, FirstValuator, NumValuators, Valuators), cookie)
	return SetDeviceValuatorsCookie{cookie}
}

// SetDeviceValuatorsUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SetDeviceValuatorsUnchecked(c *xgb.Conn, DeviceId byte, FirstValuator byte, NumValuators byte, Valuators []int32) SetDeviceValuatorsCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'SetDeviceValuators' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(setDeviceValuatorsRequest(c, DeviceId, FirstValuator, NumValuators, Valuators), cookie)
	return SetDeviceValuatorsCookie{cookie}
}

// SetDeviceValuatorsReply represents the data returned from a SetDeviceValuators request.
type SetDeviceValuatorsReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Reply blocks and returns the reply data for a SetDeviceValuators request.
func (cook SetDeviceValuatorsCookie) Reply() (*SetDeviceValuatorsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return setDeviceValuatorsReply(buf), nil
}

// setDeviceValuatorsReply reads a byte slice into a SetDeviceValuatorsReply value.
func setDeviceValuatorsReply(buf []byte) *SetDeviceValuatorsReply {
	v := new(SetDeviceValuatorsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for SetDeviceValuators
// setDeviceValuatorsRequest writes a SetDeviceValuators request to a byte slice.
func setDeviceValuatorsRequest(c *xgb.Conn, DeviceId byte, FirstValuator byte, NumValuators byte, Valuators []int32) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(NumValuators) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 33 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = FirstValuator
	b += 1

	buf[b] = NumValuators
	b += 1

	b += 1 // padding

	for i := 0; i < int(NumValuators); i++ {
		xgb.Put32(buf[b:], uint32(Valuators[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// GetDeviceControlCookie is a cookie used only for GetDeviceControl requests.
type GetDeviceControlCookie struct {
	*xgb.Cookie
}

// GetDeviceControl sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetDeviceControlCookie.Reply()
func GetDeviceControl(c *xgb.Conn, ControlId uint16, DeviceId byte) GetDeviceControlCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetDeviceControl' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceControlRequest(c, ControlId, DeviceId), cookie)
	return GetDeviceControlCookie{cookie}
}

// GetDeviceControlUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetDeviceControlUnchecked(c *xgb.Conn, ControlId uint16, DeviceId byte) GetDeviceControlCookie {
	if _, ok := c.Extensions["XINPUTEXTENSION"]; !ok {
		panic("Cannot issue request 'GetDeviceControl' using the uninitialized extension 'XInputExtension'. xinput.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceControlRequest(c, ControlId, DeviceId), cookie)
	return GetDeviceControlCookie{cookie}
}

// GetDeviceControlReply represents the data returned from a GetDeviceControl request.
type GetDeviceControlReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Reply blocks and returns the reply data for a GetDeviceControl request.
func (cook GetDeviceControlCookie) Reply() (*GetDeviceControlReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceControlReply(buf), nil
}

// getDeviceControlReply reads a byte slice into a GetDeviceControlReply value.
func getDeviceControlReply(buf []byte) *GetDeviceControlReply {
	v := new(GetDeviceControlReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for GetDeviceControl
// getDeviceControlRequest writes a GetDeviceControl request to a byte slice.
func getDeviceControlRequest(c *xgb.Conn, ControlId uint16, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 34 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], ControlId)
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 1 // padding

	return buf
}
