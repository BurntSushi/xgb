package xgb

/*
	This file was generated by glx.xml on May 10 2012 12:39:33pm EDT.
	This file is automatically generated. Edit at your peril!
*/

// Imports are not necessary for XGB because everything is 
// in one package. They are still listed here for reference.
// import "xproto"

// GlxInit must be called before using the GLX extension.
func (c *Conn) GlxInit() error {
	reply, err := c.QueryExtension(3, "GLX").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return errorf("No extension named GLX could be found on on the server.")
	}

	c.extLock.Lock()
	c.extensions["GLX"] = reply.MajorOpcode
	for evNum, fun := range newExtEventFuncs["GLX"] {
		newEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range newExtErrorFuncs["GLX"] {
		newErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	c.extLock.Unlock()

	return nil
}

func init() {
	newExtEventFuncs["GLX"] = make(map[int]newEventFun)
	newExtErrorFuncs["GLX"] = make(map[int]newErrorFun)
}

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

const (
	GlxPbcetDamaged = 32791
	GlxPbcetSaved   = 32792
)

const (
	GlxPbcdtWindow  = 32793
	GlxPbcdtPbuffer = 32794
)

const (
	GlxGcGlCurrentBit        = 1
	GlxGcGlPointBit          = 2
	GlxGcGlLineBit           = 4
	GlxGcGlPolygonBit        = 8
	GlxGcGlPolygonStippleBit = 16
	GlxGcGlPixelModeBit      = 32
	GlxGcGlLightingBit       = 64
	GlxGcGlFogBit            = 128
	GlxGcGlDepthBufferBit    = 256
	GlxGcGlAccumBufferBit    = 512
	GlxGcGlStencilBufferBit  = 1024
	GlxGcGlViewportBit       = 2048
	GlxGcGlTransformBit      = 4096
	GlxGcGlEnableBit         = 8192
	GlxGcGlColorBufferBit    = 16384
	GlxGcGlHintBit           = 32768
	GlxGcGlEvalBit           = 65536
	GlxGcGlListBit           = 131072
	GlxGcGlTextureBit        = 262144
	GlxGcGlScissorBit        = 524288
	GlxGcGlAllAttribBits     = 16777215
)

const (
	GlxRmGlRender   = 7168
	GlxRmGlFeedback = 7169
	GlxRmGlSelect   = 7170
)

type GlxPixmap uint32

func (c *Conn) NewGlxPixmapId() (GlxPixmap, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return GlxPixmap(id), nil
}

type GlxContext uint32

func (c *Conn) NewGlxContextId() (GlxContext, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return GlxContext(id), nil
}

type GlxPbuffer uint32

func (c *Conn) NewGlxPbufferId() (GlxPbuffer, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return GlxPbuffer(id), nil
}

type GlxWindow uint32

func (c *Conn) NewGlxWindowId() (GlxWindow, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return GlxWindow(id), nil
}

type GlxFbconfig uint32

func (c *Conn) NewGlxFbconfigId() (GlxFbconfig, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return GlxFbconfig(id), nil
}

type GlxDrawable uint32

func (c *Conn) NewGlxDrawableId() (GlxDrawable, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return GlxDrawable(id), nil
}

type GlxFloat32 float64

type GlxFloat64 float64

type GlxBool32 uint32

type GlxContextTag uint32

// Event definition GlxPbufferClobber (0)
// Size: 32

const GlxPbufferClobber = 0

type GlxPbufferClobberEvent struct {
	Sequence uint16
	// padding: 1 bytes
	EventType uint16
	DrawType  uint16
	Drawable  GlxDrawable
	BMask     uint32
	AuxBuffer uint16
	X         uint16
	Y         uint16
	Width     uint16
	Height    uint16
	Count     uint16
	// padding: 4 bytes
}

// Event read GlxPbufferClobber
func NewGlxPbufferClobberEvent(buf []byte) Event {
	v := GlxPbufferClobberEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.EventType = Get16(buf[b:])
	b += 2

	v.DrawType = Get16(buf[b:])
	b += 2

	v.Drawable = GlxDrawable(Get32(buf[b:]))
	b += 4

	v.BMask = Get32(buf[b:])
	b += 4

	v.AuxBuffer = Get16(buf[b:])
	b += 2

	v.X = Get16(buf[b:])
	b += 2

	v.Y = Get16(buf[b:])
	b += 2

	v.Width = Get16(buf[b:])
	b += 2

	v.Height = Get16(buf[b:])
	b += 2

	v.Count = Get16(buf[b:])
	b += 2

	b += 4 // padding

	return v
}

// Event write GlxPbufferClobber
func (v GlxPbufferClobberEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 0
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	Put16(buf[b:], v.EventType)
	b += 2

	Put16(buf[b:], v.DrawType)
	b += 2

	Put32(buf[b:], uint32(v.Drawable))
	b += 4

	Put32(buf[b:], v.BMask)
	b += 4

	Put16(buf[b:], v.AuxBuffer)
	b += 2

	Put16(buf[b:], v.X)
	b += 2

	Put16(buf[b:], v.Y)
	b += 2

	Put16(buf[b:], v.Width)
	b += 2

	Put16(buf[b:], v.Height)
	b += 2

	Put16(buf[b:], v.Count)
	b += 2

	b += 4 // padding

	return buf
}

func (v GlxPbufferClobberEvent) ImplementsEvent() {}

func (v GlxPbufferClobberEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v GlxPbufferClobberEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("EventType: %d", v.EventType))
	fieldVals = append(fieldVals, sprintf("DrawType: %d", v.DrawType))
	fieldVals = append(fieldVals, sprintf("Drawable: %d", v.Drawable))
	fieldVals = append(fieldVals, sprintf("BMask: %d", v.BMask))
	fieldVals = append(fieldVals, sprintf("AuxBuffer: %d", v.AuxBuffer))
	fieldVals = append(fieldVals, sprintf("X: %d", v.X))
	fieldVals = append(fieldVals, sprintf("Y: %d", v.Y))
	fieldVals = append(fieldVals, sprintf("Width: %d", v.Width))
	fieldVals = append(fieldVals, sprintf("Height: %d", v.Height))
	fieldVals = append(fieldVals, sprintf("Count: %d", v.Count))
	return "GlxPbufferClobber {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["GLX"][0] = NewGlxPbufferClobberEvent
}

// Error definition GlxGeneric (-1)
// Size: 32

const BadGlxGeneric = -1

type GlxGenericError struct {
	Sequence    uint16
	NiceName    string
	BadValue    uint32
	MinorOpcode uint16
	MajorOpcode byte
	// padding: 21 bytes
}

// Error read GlxGeneric
func NewGlxGenericError(buf []byte) Error {
	v := GlxGenericError{}
	v.NiceName = "GlxGeneric"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = Get16(buf[b:])
	b += 2

	v.BadValue = Get32(buf[b:])
	b += 4

	v.MinorOpcode = Get16(buf[b:])
	b += 2

	v.MajorOpcode = buf[b]
	b += 1

	b += 21 // padding

	return v
}

func (err GlxGenericError) ImplementsError() {}

func (err GlxGenericError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlxGenericError) BadId() uint32 {
	return 0
}

func (err GlxGenericError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGlxGeneric {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["GLX"][-1] = NewGlxGenericError
}

// ErrorCopy definition GlxBadContext (0)

const BadGlxBadContext = 0

type GlxBadContextError GlxGenericError

func NewGlxBadContextError(buf []byte) Error {
	v := GlxBadContextError(NewGlxGenericError(buf).(GlxGenericError))
	v.NiceName = "GlxBadContext"
	return v
}

func (err GlxBadContextError) ImplementsError() {}

func (err GlxBadContextError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlxBadContextError) BadId() uint32 {
	return 0
}

func (err GlxBadContextError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGlxBadContext {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["GLX"][0] = NewGlxBadContextError
}

// ErrorCopy definition GlxBadContextState (1)

const BadGlxBadContextState = 1

type GlxBadContextStateError GlxGenericError

func NewGlxBadContextStateError(buf []byte) Error {
	v := GlxBadContextStateError(NewGlxGenericError(buf).(GlxGenericError))
	v.NiceName = "GlxBadContextState"
	return v
}

func (err GlxBadContextStateError) ImplementsError() {}

func (err GlxBadContextStateError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlxBadContextStateError) BadId() uint32 {
	return 0
}

func (err GlxBadContextStateError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGlxBadContextState {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["GLX"][1] = NewGlxBadContextStateError
}

// ErrorCopy definition GlxBadDrawable (2)

const BadGlxBadDrawable = 2

type GlxBadDrawableError GlxGenericError

func NewGlxBadDrawableError(buf []byte) Error {
	v := GlxBadDrawableError(NewGlxGenericError(buf).(GlxGenericError))
	v.NiceName = "GlxBadDrawable"
	return v
}

func (err GlxBadDrawableError) ImplementsError() {}

func (err GlxBadDrawableError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlxBadDrawableError) BadId() uint32 {
	return 0
}

func (err GlxBadDrawableError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGlxBadDrawable {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["GLX"][2] = NewGlxBadDrawableError
}

// ErrorCopy definition GlxBadPixmap (3)

const BadGlxBadPixmap = 3

type GlxBadPixmapError GlxGenericError

func NewGlxBadPixmapError(buf []byte) Error {
	v := GlxBadPixmapError(NewGlxGenericError(buf).(GlxGenericError))
	v.NiceName = "GlxBadPixmap"
	return v
}

func (err GlxBadPixmapError) ImplementsError() {}

func (err GlxBadPixmapError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlxBadPixmapError) BadId() uint32 {
	return 0
}

func (err GlxBadPixmapError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGlxBadPixmap {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["GLX"][3] = NewGlxBadPixmapError
}

// ErrorCopy definition GlxBadContextTag (4)

const BadGlxBadContextTag = 4

type GlxBadContextTagError GlxGenericError

func NewGlxBadContextTagError(buf []byte) Error {
	v := GlxBadContextTagError(NewGlxGenericError(buf).(GlxGenericError))
	v.NiceName = "GlxBadContextTag"
	return v
}

func (err GlxBadContextTagError) ImplementsError() {}

func (err GlxBadContextTagError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlxBadContextTagError) BadId() uint32 {
	return 0
}

func (err GlxBadContextTagError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGlxBadContextTag {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["GLX"][4] = NewGlxBadContextTagError
}

// ErrorCopy definition GlxBadCurrentWindow (5)

const BadGlxBadCurrentWindow = 5

type GlxBadCurrentWindowError GlxGenericError

func NewGlxBadCurrentWindowError(buf []byte) Error {
	v := GlxBadCurrentWindowError(NewGlxGenericError(buf).(GlxGenericError))
	v.NiceName = "GlxBadCurrentWindow"
	return v
}

func (err GlxBadCurrentWindowError) ImplementsError() {}

func (err GlxBadCurrentWindowError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlxBadCurrentWindowError) BadId() uint32 {
	return 0
}

func (err GlxBadCurrentWindowError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGlxBadCurrentWindow {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["GLX"][5] = NewGlxBadCurrentWindowError
}

// ErrorCopy definition GlxBadRenderRequest (6)

const BadGlxBadRenderRequest = 6

type GlxBadRenderRequestError GlxGenericError

func NewGlxBadRenderRequestError(buf []byte) Error {
	v := GlxBadRenderRequestError(NewGlxGenericError(buf).(GlxGenericError))
	v.NiceName = "GlxBadRenderRequest"
	return v
}

func (err GlxBadRenderRequestError) ImplementsError() {}

func (err GlxBadRenderRequestError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlxBadRenderRequestError) BadId() uint32 {
	return 0
}

func (err GlxBadRenderRequestError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGlxBadRenderRequest {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["GLX"][6] = NewGlxBadRenderRequestError
}

// ErrorCopy definition GlxBadLargeRequest (7)

const BadGlxBadLargeRequest = 7

type GlxBadLargeRequestError GlxGenericError

func NewGlxBadLargeRequestError(buf []byte) Error {
	v := GlxBadLargeRequestError(NewGlxGenericError(buf).(GlxGenericError))
	v.NiceName = "GlxBadLargeRequest"
	return v
}

func (err GlxBadLargeRequestError) ImplementsError() {}

func (err GlxBadLargeRequestError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlxBadLargeRequestError) BadId() uint32 {
	return 0
}

func (err GlxBadLargeRequestError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGlxBadLargeRequest {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["GLX"][7] = NewGlxBadLargeRequestError
}

// ErrorCopy definition GlxUnsupportedPrivateRequest (8)

const BadGlxUnsupportedPrivateRequest = 8

type GlxUnsupportedPrivateRequestError GlxGenericError

func NewGlxUnsupportedPrivateRequestError(buf []byte) Error {
	v := GlxUnsupportedPrivateRequestError(NewGlxGenericError(buf).(GlxGenericError))
	v.NiceName = "GlxUnsupportedPrivateRequest"
	return v
}

func (err GlxUnsupportedPrivateRequestError) ImplementsError() {}

func (err GlxUnsupportedPrivateRequestError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlxUnsupportedPrivateRequestError) BadId() uint32 {
	return 0
}

func (err GlxUnsupportedPrivateRequestError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGlxUnsupportedPrivateRequest {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["GLX"][8] = NewGlxUnsupportedPrivateRequestError
}

// ErrorCopy definition GlxBadFBConfig (9)

const BadGlxBadFBConfig = 9

type GlxBadFBConfigError GlxGenericError

func NewGlxBadFBConfigError(buf []byte) Error {
	v := GlxBadFBConfigError(NewGlxGenericError(buf).(GlxGenericError))
	v.NiceName = "GlxBadFBConfig"
	return v
}

func (err GlxBadFBConfigError) ImplementsError() {}

func (err GlxBadFBConfigError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlxBadFBConfigError) BadId() uint32 {
	return 0
}

func (err GlxBadFBConfigError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGlxBadFBConfig {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["GLX"][9] = NewGlxBadFBConfigError
}

// ErrorCopy definition GlxBadPbuffer (10)

const BadGlxBadPbuffer = 10

type GlxBadPbufferError GlxGenericError

func NewGlxBadPbufferError(buf []byte) Error {
	v := GlxBadPbufferError(NewGlxGenericError(buf).(GlxGenericError))
	v.NiceName = "GlxBadPbuffer"
	return v
}

func (err GlxBadPbufferError) ImplementsError() {}

func (err GlxBadPbufferError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlxBadPbufferError) BadId() uint32 {
	return 0
}

func (err GlxBadPbufferError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGlxBadPbuffer {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["GLX"][10] = NewGlxBadPbufferError
}

// ErrorCopy definition GlxBadCurrentDrawable (11)

const BadGlxBadCurrentDrawable = 11

type GlxBadCurrentDrawableError GlxGenericError

func NewGlxBadCurrentDrawableError(buf []byte) Error {
	v := GlxBadCurrentDrawableError(NewGlxGenericError(buf).(GlxGenericError))
	v.NiceName = "GlxBadCurrentDrawable"
	return v
}

func (err GlxBadCurrentDrawableError) ImplementsError() {}

func (err GlxBadCurrentDrawableError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlxBadCurrentDrawableError) BadId() uint32 {
	return 0
}

func (err GlxBadCurrentDrawableError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGlxBadCurrentDrawable {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["GLX"][11] = NewGlxBadCurrentDrawableError
}

// ErrorCopy definition GlxBadWindow (12)

const BadGlxBadWindow = 12

type GlxBadWindowError GlxGenericError

func NewGlxBadWindowError(buf []byte) Error {
	v := GlxBadWindowError(NewGlxGenericError(buf).(GlxGenericError))
	v.NiceName = "GlxBadWindow"
	return v
}

func (err GlxBadWindowError) ImplementsError() {}

func (err GlxBadWindowError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlxBadWindowError) BadId() uint32 {
	return 0
}

func (err GlxBadWindowError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGlxBadWindow {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["GLX"][12] = NewGlxBadWindowError
}

// ErrorCopy definition GlxGLXBadProfileARB (13)

const BadGlxGLXBadProfileARB = 13

type GlxGLXBadProfileARBError GlxGenericError

func NewGlxGLXBadProfileARBError(buf []byte) Error {
	v := GlxGLXBadProfileARBError(NewGlxGenericError(buf).(GlxGenericError))
	v.NiceName = "GlxGLXBadProfileARB"
	return v
}

func (err GlxGLXBadProfileARBError) ImplementsError() {}

func (err GlxGLXBadProfileARBError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlxGLXBadProfileARBError) BadId() uint32 {
	return 0
}

func (err GlxGLXBadProfileARBError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGlxGLXBadProfileARB {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["GLX"][13] = NewGlxGLXBadProfileARBError
}

// Request GlxRender
// size: pad((8 + pad((len(Data) * 1))))
type GlxRenderCookie struct {
	*cookie
}

// Write request to wire for GlxRender
func (c *Conn) GlxRender(ContextTag GlxContextTag, Data []byte) GlxRenderCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxRenderRequest(ContextTag, Data), cookie)
	return GlxRenderCookie{cookie}
}

func (c *Conn) GlxRenderChecked(ContextTag GlxContextTag, Data []byte) GlxRenderCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxRenderRequest(ContextTag, Data), cookie)
	return GlxRenderCookie{cookie}
}

func (cook GlxRenderCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxRender
func (c *Conn) glxRenderRequest(ContextTag GlxContextTag, Data []byte) []byte {
	size := pad((8 + pad((len(Data) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	copy(buf[b:], Data[:len(Data)])
	b += pad(int(len(Data)))

	return buf
}

// Request GlxRenderLarge
// size: pad((16 + pad((int(DataLen) * 1))))
type GlxRenderLargeCookie struct {
	*cookie
}

// Write request to wire for GlxRenderLarge
func (c *Conn) GlxRenderLarge(ContextTag GlxContextTag, RequestNum uint16, RequestTotal uint16, DataLen uint32, Data []byte) GlxRenderLargeCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxRenderLargeRequest(ContextTag, RequestNum, RequestTotal, DataLen, Data), cookie)
	return GlxRenderLargeCookie{cookie}
}

func (c *Conn) GlxRenderLargeChecked(ContextTag GlxContextTag, RequestNum uint16, RequestTotal uint16, DataLen uint32, Data []byte) GlxRenderLargeCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxRenderLargeRequest(ContextTag, RequestNum, RequestTotal, DataLen, Data), cookie)
	return GlxRenderLargeCookie{cookie}
}

func (cook GlxRenderLargeCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxRenderLarge
func (c *Conn) glxRenderLargeRequest(ContextTag GlxContextTag, RequestNum uint16, RequestTotal uint16, DataLen uint32, Data []byte) []byte {
	size := pad((16 + pad((int(DataLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put16(buf[b:], RequestNum)
	b += 2

	Put16(buf[b:], RequestTotal)
	b += 2

	Put32(buf[b:], DataLen)
	b += 4

	copy(buf[b:], Data[:DataLen])
	b += pad(int(DataLen))

	return buf
}

// Request GlxCreateContext
// size: 24
type GlxCreateContextCookie struct {
	*cookie
}

// Write request to wire for GlxCreateContext
func (c *Conn) GlxCreateContext(Context GlxContext, Visual Visualid, Screen uint32, ShareList GlxContext, IsDirect bool) GlxCreateContextCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxCreateContextRequest(Context, Visual, Screen, ShareList, IsDirect), cookie)
	return GlxCreateContextCookie{cookie}
}

func (c *Conn) GlxCreateContextChecked(Context GlxContext, Visual Visualid, Screen uint32, ShareList GlxContext, IsDirect bool) GlxCreateContextCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxCreateContextRequest(Context, Visual, Screen, ShareList, IsDirect), cookie)
	return GlxCreateContextCookie{cookie}
}

func (cook GlxCreateContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxCreateContext
func (c *Conn) glxCreateContextRequest(Context GlxContext, Visual Visualid, Screen uint32, ShareList GlxContext, IsDirect bool) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Context))
	b += 4

	Put32(buf[b:], uint32(Visual))
	b += 4

	Put32(buf[b:], Screen)
	b += 4

	Put32(buf[b:], uint32(ShareList))
	b += 4

	if IsDirect {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 3 // padding

	return buf
}

// Request GlxDestroyContext
// size: 8
type GlxDestroyContextCookie struct {
	*cookie
}

// Write request to wire for GlxDestroyContext
func (c *Conn) GlxDestroyContext(Context GlxContext) GlxDestroyContextCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxDestroyContextRequest(Context), cookie)
	return GlxDestroyContextCookie{cookie}
}

func (c *Conn) GlxDestroyContextChecked(Context GlxContext) GlxDestroyContextCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxDestroyContextRequest(Context), cookie)
	return GlxDestroyContextCookie{cookie}
}

func (cook GlxDestroyContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxDestroyContext
func (c *Conn) glxDestroyContextRequest(Context GlxContext) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Context))
	b += 4

	return buf
}

// Request GlxMakeCurrent
// size: 16
type GlxMakeCurrentCookie struct {
	*cookie
}

func (c *Conn) GlxMakeCurrent(Drawable GlxDrawable, Context GlxContext, OldContextTag GlxContextTag) GlxMakeCurrentCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxMakeCurrentRequest(Drawable, Context, OldContextTag), cookie)
	return GlxMakeCurrentCookie{cookie}
}

func (c *Conn) GlxMakeCurrentUnchecked(Drawable GlxDrawable, Context GlxContext, OldContextTag GlxContextTag) GlxMakeCurrentCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxMakeCurrentRequest(Drawable, Context, OldContextTag), cookie)
	return GlxMakeCurrentCookie{cookie}
}

// Request reply for GlxMakeCurrent
// size: 32
type GlxMakeCurrentReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextTag GlxContextTag
	// padding: 20 bytes
}

// Waits and reads reply data from request GlxMakeCurrent
func (cook GlxMakeCurrentCookie) Reply() (*GlxMakeCurrentReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxMakeCurrentReply(buf), nil
}

// Read reply into structure from buffer for GlxMakeCurrent
func glxMakeCurrentReply(buf []byte) *GlxMakeCurrentReply {
	v := new(GlxMakeCurrentReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextTag = GlxContextTag(Get32(buf[b:]))
	b += 4

	b += 20 // padding

	return v
}

func (cook GlxMakeCurrentCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxMakeCurrent
func (c *Conn) glxMakeCurrentRequest(Drawable GlxDrawable, Context GlxContext, OldContextTag GlxContextTag) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Drawable))
	b += 4

	Put32(buf[b:], uint32(Context))
	b += 4

	Put32(buf[b:], uint32(OldContextTag))
	b += 4

	return buf
}

// Request GlxIsDirect
// size: 8
type GlxIsDirectCookie struct {
	*cookie
}

func (c *Conn) GlxIsDirect(Context GlxContext) GlxIsDirectCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxIsDirectRequest(Context), cookie)
	return GlxIsDirectCookie{cookie}
}

func (c *Conn) GlxIsDirectUnchecked(Context GlxContext) GlxIsDirectCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxIsDirectRequest(Context), cookie)
	return GlxIsDirectCookie{cookie}
}

// Request reply for GlxIsDirect
// size: 32
type GlxIsDirectReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	IsDirect bool
	// padding: 23 bytes
}

// Waits and reads reply data from request GlxIsDirect
func (cook GlxIsDirectCookie) Reply() (*GlxIsDirectReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxIsDirectReply(buf), nil
}

// Read reply into structure from buffer for GlxIsDirect
func glxIsDirectReply(buf []byte) *GlxIsDirectReply {
	v := new(GlxIsDirectReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	if buf[b] == 1 {
		v.IsDirect = true
	} else {
		v.IsDirect = false
	}
	b += 1

	b += 23 // padding

	return v
}

func (cook GlxIsDirectCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxIsDirect
func (c *Conn) glxIsDirectRequest(Context GlxContext) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Context))
	b += 4

	return buf
}

// Request GlxQueryVersion
// size: 12
type GlxQueryVersionCookie struct {
	*cookie
}

func (c *Conn) GlxQueryVersion(MajorVersion uint32, MinorVersion uint32) GlxQueryVersionCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxQueryVersionRequest(MajorVersion, MinorVersion), cookie)
	return GlxQueryVersionCookie{cookie}
}

func (c *Conn) GlxQueryVersionUnchecked(MajorVersion uint32, MinorVersion uint32) GlxQueryVersionCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxQueryVersionRequest(MajorVersion, MinorVersion), cookie)
	return GlxQueryVersionCookie{cookie}
}

// Request reply for GlxQueryVersion
// size: 32
type GlxQueryVersionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	MajorVersion uint32
	MinorVersion uint32
	// padding: 16 bytes
}

// Waits and reads reply data from request GlxQueryVersion
func (cook GlxQueryVersionCookie) Reply() (*GlxQueryVersionReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxQueryVersionReply(buf), nil
}

// Read reply into structure from buffer for GlxQueryVersion
func glxQueryVersionReply(buf []byte) *GlxQueryVersionReply {
	v := new(GlxQueryVersionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.MajorVersion = Get32(buf[b:])
	b += 4

	v.MinorVersion = Get32(buf[b:])
	b += 4

	b += 16 // padding

	return v
}

func (cook GlxQueryVersionCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxQueryVersion
func (c *Conn) glxQueryVersionRequest(MajorVersion uint32, MinorVersion uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], MajorVersion)
	b += 4

	Put32(buf[b:], MinorVersion)
	b += 4

	return buf
}

// Request GlxWaitGL
// size: 8
type GlxWaitGLCookie struct {
	*cookie
}

// Write request to wire for GlxWaitGL
func (c *Conn) GlxWaitGL(ContextTag GlxContextTag) GlxWaitGLCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxWaitGLRequest(ContextTag), cookie)
	return GlxWaitGLCookie{cookie}
}

func (c *Conn) GlxWaitGLChecked(ContextTag GlxContextTag) GlxWaitGLCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxWaitGLRequest(ContextTag), cookie)
	return GlxWaitGLCookie{cookie}
}

func (cook GlxWaitGLCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxWaitGL
func (c *Conn) glxWaitGLRequest(ContextTag GlxContextTag) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 8 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	return buf
}

// Request GlxWaitX
// size: 8
type GlxWaitXCookie struct {
	*cookie
}

// Write request to wire for GlxWaitX
func (c *Conn) GlxWaitX(ContextTag GlxContextTag) GlxWaitXCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxWaitXRequest(ContextTag), cookie)
	return GlxWaitXCookie{cookie}
}

func (c *Conn) GlxWaitXChecked(ContextTag GlxContextTag) GlxWaitXCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxWaitXRequest(ContextTag), cookie)
	return GlxWaitXCookie{cookie}
}

func (cook GlxWaitXCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxWaitX
func (c *Conn) glxWaitXRequest(ContextTag GlxContextTag) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 9 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	return buf
}

// Request GlxCopyContext
// size: 20
type GlxCopyContextCookie struct {
	*cookie
}

// Write request to wire for GlxCopyContext
func (c *Conn) GlxCopyContext(Src GlxContext, Dest GlxContext, Mask uint32, SrcContextTag GlxContextTag) GlxCopyContextCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxCopyContextRequest(Src, Dest, Mask, SrcContextTag), cookie)
	return GlxCopyContextCookie{cookie}
}

func (c *Conn) GlxCopyContextChecked(Src GlxContext, Dest GlxContext, Mask uint32, SrcContextTag GlxContextTag) GlxCopyContextCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxCopyContextRequest(Src, Dest, Mask, SrcContextTag), cookie)
	return GlxCopyContextCookie{cookie}
}

func (cook GlxCopyContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxCopyContext
func (c *Conn) glxCopyContextRequest(Src GlxContext, Dest GlxContext, Mask uint32, SrcContextTag GlxContextTag) []byte {
	size := 20
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 10 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Src))
	b += 4

	Put32(buf[b:], uint32(Dest))
	b += 4

	Put32(buf[b:], Mask)
	b += 4

	Put32(buf[b:], uint32(SrcContextTag))
	b += 4

	return buf
}

// Request GlxSwapBuffers
// size: 12
type GlxSwapBuffersCookie struct {
	*cookie
}

// Write request to wire for GlxSwapBuffers
func (c *Conn) GlxSwapBuffers(ContextTag GlxContextTag, Drawable GlxDrawable) GlxSwapBuffersCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxSwapBuffersRequest(ContextTag, Drawable), cookie)
	return GlxSwapBuffersCookie{cookie}
}

func (c *Conn) GlxSwapBuffersChecked(ContextTag GlxContextTag, Drawable GlxDrawable) GlxSwapBuffersCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxSwapBuffersRequest(ContextTag, Drawable), cookie)
	return GlxSwapBuffersCookie{cookie}
}

func (cook GlxSwapBuffersCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxSwapBuffers
func (c *Conn) glxSwapBuffersRequest(ContextTag GlxContextTag, Drawable GlxDrawable) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 11 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], uint32(Drawable))
	b += 4

	return buf
}

// Request GlxUseXFont
// size: 24
type GlxUseXFontCookie struct {
	*cookie
}

// Write request to wire for GlxUseXFont
func (c *Conn) GlxUseXFont(ContextTag GlxContextTag, Font Font, First uint32, Count uint32, ListBase uint32) GlxUseXFontCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxUseXFontRequest(ContextTag, Font, First, Count, ListBase), cookie)
	return GlxUseXFontCookie{cookie}
}

func (c *Conn) GlxUseXFontChecked(ContextTag GlxContextTag, Font Font, First uint32, Count uint32, ListBase uint32) GlxUseXFontCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxUseXFontRequest(ContextTag, Font, First, Count, ListBase), cookie)
	return GlxUseXFontCookie{cookie}
}

func (cook GlxUseXFontCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxUseXFont
func (c *Conn) glxUseXFontRequest(ContextTag GlxContextTag, Font Font, First uint32, Count uint32, ListBase uint32) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 12 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], uint32(Font))
	b += 4

	Put32(buf[b:], First)
	b += 4

	Put32(buf[b:], Count)
	b += 4

	Put32(buf[b:], ListBase)
	b += 4

	return buf
}

// Request GlxCreateGLXPixmap
// size: 20
type GlxCreateGLXPixmapCookie struct {
	*cookie
}

// Write request to wire for GlxCreateGLXPixmap
func (c *Conn) GlxCreateGLXPixmap(Screen uint32, Visual Visualid, Pixmap Pixmap, GlxPixmap GlxPixmap) GlxCreateGLXPixmapCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxCreateGLXPixmapRequest(Screen, Visual, Pixmap, GlxPixmap), cookie)
	return GlxCreateGLXPixmapCookie{cookie}
}

func (c *Conn) GlxCreateGLXPixmapChecked(Screen uint32, Visual Visualid, Pixmap Pixmap, GlxPixmap GlxPixmap) GlxCreateGLXPixmapCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxCreateGLXPixmapRequest(Screen, Visual, Pixmap, GlxPixmap), cookie)
	return GlxCreateGLXPixmapCookie{cookie}
}

func (cook GlxCreateGLXPixmapCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxCreateGLXPixmap
func (c *Conn) glxCreateGLXPixmapRequest(Screen uint32, Visual Visualid, Pixmap Pixmap, GlxPixmap GlxPixmap) []byte {
	size := 20
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 13 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], Screen)
	b += 4

	Put32(buf[b:], uint32(Visual))
	b += 4

	Put32(buf[b:], uint32(Pixmap))
	b += 4

	Put32(buf[b:], uint32(GlxPixmap))
	b += 4

	return buf
}

// Request GlxGetVisualConfigs
// size: 8
type GlxGetVisualConfigsCookie struct {
	*cookie
}

func (c *Conn) GlxGetVisualConfigs(Screen uint32) GlxGetVisualConfigsCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetVisualConfigsRequest(Screen), cookie)
	return GlxGetVisualConfigsCookie{cookie}
}

func (c *Conn) GlxGetVisualConfigsUnchecked(Screen uint32) GlxGetVisualConfigsCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetVisualConfigsRequest(Screen), cookie)
	return GlxGetVisualConfigsCookie{cookie}
}

// Request reply for GlxGetVisualConfigs
// size: (32 + pad((int(Length) * 4)))
type GlxGetVisualConfigsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumVisuals    uint32
	NumProperties uint32
	// padding: 16 bytes
	PropertyList []uint32 // size: pad((int(Length) * 4))
}

// Waits and reads reply data from request GlxGetVisualConfigs
func (cook GlxGetVisualConfigsCookie) Reply() (*GlxGetVisualConfigsReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetVisualConfigsReply(buf), nil
}

// Read reply into structure from buffer for GlxGetVisualConfigs
func glxGetVisualConfigsReply(buf []byte) *GlxGetVisualConfigsReply {
	v := new(GlxGetVisualConfigsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumVisuals = Get32(buf[b:])
	b += 4

	v.NumProperties = Get32(buf[b:])
	b += 4

	b += 16 // padding

	v.PropertyList = make([]uint32, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.PropertyList[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetVisualConfigsCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetVisualConfigs
func (c *Conn) glxGetVisualConfigsRequest(Screen uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 14 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], Screen)
	b += 4

	return buf
}

// Request GlxDestroyGLXPixmap
// size: 8
type GlxDestroyGLXPixmapCookie struct {
	*cookie
}

// Write request to wire for GlxDestroyGLXPixmap
func (c *Conn) GlxDestroyGLXPixmap(GlxPixmap GlxPixmap) GlxDestroyGLXPixmapCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxDestroyGLXPixmapRequest(GlxPixmap), cookie)
	return GlxDestroyGLXPixmapCookie{cookie}
}

func (c *Conn) GlxDestroyGLXPixmapChecked(GlxPixmap GlxPixmap) GlxDestroyGLXPixmapCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxDestroyGLXPixmapRequest(GlxPixmap), cookie)
	return GlxDestroyGLXPixmapCookie{cookie}
}

func (cook GlxDestroyGLXPixmapCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxDestroyGLXPixmap
func (c *Conn) glxDestroyGLXPixmapRequest(GlxPixmap GlxPixmap) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 15 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(GlxPixmap))
	b += 4

	return buf
}

// Request GlxVendorPrivate
// size: pad((12 + pad((len(Data) * 1))))
type GlxVendorPrivateCookie struct {
	*cookie
}

// Write request to wire for GlxVendorPrivate
func (c *Conn) GlxVendorPrivate(VendorCode uint32, ContextTag GlxContextTag, Data []byte) GlxVendorPrivateCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxVendorPrivateRequest(VendorCode, ContextTag, Data), cookie)
	return GlxVendorPrivateCookie{cookie}
}

func (c *Conn) GlxVendorPrivateChecked(VendorCode uint32, ContextTag GlxContextTag, Data []byte) GlxVendorPrivateCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxVendorPrivateRequest(VendorCode, ContextTag, Data), cookie)
	return GlxVendorPrivateCookie{cookie}
}

func (cook GlxVendorPrivateCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxVendorPrivate
func (c *Conn) glxVendorPrivateRequest(VendorCode uint32, ContextTag GlxContextTag, Data []byte) []byte {
	size := pad((12 + pad((len(Data) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 16 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], VendorCode)
	b += 4

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	copy(buf[b:], Data[:len(Data)])
	b += pad(int(len(Data)))

	return buf
}

// Request GlxVendorPrivateWithReply
// size: pad((12 + pad((len(Data) * 1))))
type GlxVendorPrivateWithReplyCookie struct {
	*cookie
}

func (c *Conn) GlxVendorPrivateWithReply(VendorCode uint32, ContextTag GlxContextTag, Data []byte) GlxVendorPrivateWithReplyCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxVendorPrivateWithReplyRequest(VendorCode, ContextTag, Data), cookie)
	return GlxVendorPrivateWithReplyCookie{cookie}
}

func (c *Conn) GlxVendorPrivateWithReplyUnchecked(VendorCode uint32, ContextTag GlxContextTag, Data []byte) GlxVendorPrivateWithReplyCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxVendorPrivateWithReplyRequest(VendorCode, ContextTag, Data), cookie)
	return GlxVendorPrivateWithReplyCookie{cookie}
}

// Request reply for GlxVendorPrivateWithReply
// size: (36 + pad(((int(Length) * 4) * 1)))
type GlxVendorPrivateWithReplyReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Retval uint32
	Data1  []byte // size: 24
	Data2  []byte // size: pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GlxVendorPrivateWithReply
func (cook GlxVendorPrivateWithReplyCookie) Reply() (*GlxVendorPrivateWithReplyReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxVendorPrivateWithReplyReply(buf), nil
}

// Read reply into structure from buffer for GlxVendorPrivateWithReply
func glxVendorPrivateWithReplyReply(buf []byte) *GlxVendorPrivateWithReplyReply {
	v := new(GlxVendorPrivateWithReplyReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Retval = Get32(buf[b:])
	b += 4

	v.Data1 = make([]byte, 24)
	copy(v.Data1[:24], buf[b:])
	b += pad(int(24))

	v.Data2 = make([]byte, (int(v.Length) * 4))
	copy(v.Data2[:(int(v.Length)*4)], buf[b:])
	b += pad(int((int(v.Length) * 4)))

	return v
}

func (cook GlxVendorPrivateWithReplyCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxVendorPrivateWithReply
func (c *Conn) glxVendorPrivateWithReplyRequest(VendorCode uint32, ContextTag GlxContextTag, Data []byte) []byte {
	size := pad((12 + pad((len(Data) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 17 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], VendorCode)
	b += 4

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	copy(buf[b:], Data[:len(Data)])
	b += pad(int(len(Data)))

	return buf
}

// Request GlxQueryExtensionsString
// size: 8
type GlxQueryExtensionsStringCookie struct {
	*cookie
}

func (c *Conn) GlxQueryExtensionsString(Screen uint32) GlxQueryExtensionsStringCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxQueryExtensionsStringRequest(Screen), cookie)
	return GlxQueryExtensionsStringCookie{cookie}
}

func (c *Conn) GlxQueryExtensionsStringUnchecked(Screen uint32) GlxQueryExtensionsStringCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxQueryExtensionsStringRequest(Screen), cookie)
	return GlxQueryExtensionsStringCookie{cookie}
}

// Request reply for GlxQueryExtensionsString
// size: 32
type GlxQueryExtensionsStringReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N uint32
	// padding: 16 bytes
}

// Waits and reads reply data from request GlxQueryExtensionsString
func (cook GlxQueryExtensionsStringCookie) Reply() (*GlxQueryExtensionsStringReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxQueryExtensionsStringReply(buf), nil
}

// Read reply into structure from buffer for GlxQueryExtensionsString
func glxQueryExtensionsStringReply(buf []byte) *GlxQueryExtensionsStringReply {
	v := new(GlxQueryExtensionsStringReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	b += 16 // padding

	return v
}

func (cook GlxQueryExtensionsStringCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxQueryExtensionsString
func (c *Conn) glxQueryExtensionsStringRequest(Screen uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 18 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], Screen)
	b += 4

	return buf
}

// Request GlxQueryServerString
// size: 12
type GlxQueryServerStringCookie struct {
	*cookie
}

func (c *Conn) GlxQueryServerString(Screen uint32, Name uint32) GlxQueryServerStringCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxQueryServerStringRequest(Screen, Name), cookie)
	return GlxQueryServerStringCookie{cookie}
}

func (c *Conn) GlxQueryServerStringUnchecked(Screen uint32, Name uint32) GlxQueryServerStringCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxQueryServerStringRequest(Screen, Name), cookie)
	return GlxQueryServerStringCookie{cookie}
}

// Request reply for GlxQueryServerString
// size: (32 + pad((int(StrLen) * 1)))
type GlxQueryServerStringReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	StrLen uint32
	// padding: 16 bytes
	String string // size: pad((int(StrLen) * 1))
}

// Waits and reads reply data from request GlxQueryServerString
func (cook GlxQueryServerStringCookie) Reply() (*GlxQueryServerStringReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxQueryServerStringReply(buf), nil
}

// Read reply into structure from buffer for GlxQueryServerString
func glxQueryServerStringReply(buf []byte) *GlxQueryServerStringReply {
	v := new(GlxQueryServerStringReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.StrLen = Get32(buf[b:])
	b += 4

	b += 16 // padding

	{
		byteString := make([]byte, v.StrLen)
		copy(byteString[:v.StrLen], buf[b:])
		v.String = string(byteString)
		b += pad(int(v.StrLen))
	}

	return v
}

func (cook GlxQueryServerStringCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxQueryServerString
func (c *Conn) glxQueryServerStringRequest(Screen uint32, Name uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 19 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], Screen)
	b += 4

	Put32(buf[b:], Name)
	b += 4

	return buf
}

// Request GlxClientInfo
// size: pad((16 + pad((int(StrLen) * 1))))
type GlxClientInfoCookie struct {
	*cookie
}

// Write request to wire for GlxClientInfo
func (c *Conn) GlxClientInfo(MajorVersion uint32, MinorVersion uint32, StrLen uint32, String string) GlxClientInfoCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxClientInfoRequest(MajorVersion, MinorVersion, StrLen, String), cookie)
	return GlxClientInfoCookie{cookie}
}

func (c *Conn) GlxClientInfoChecked(MajorVersion uint32, MinorVersion uint32, StrLen uint32, String string) GlxClientInfoCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxClientInfoRequest(MajorVersion, MinorVersion, StrLen, String), cookie)
	return GlxClientInfoCookie{cookie}
}

func (cook GlxClientInfoCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxClientInfo
func (c *Conn) glxClientInfoRequest(MajorVersion uint32, MinorVersion uint32, StrLen uint32, String string) []byte {
	size := pad((16 + pad((int(StrLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 20 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], MajorVersion)
	b += 4

	Put32(buf[b:], MinorVersion)
	b += 4

	Put32(buf[b:], StrLen)
	b += 4

	copy(buf[b:], String[:StrLen])
	b += pad(int(StrLen))

	return buf
}

// Request GlxGetFBConfigs
// size: 8
type GlxGetFBConfigsCookie struct {
	*cookie
}

func (c *Conn) GlxGetFBConfigs(Screen uint32) GlxGetFBConfigsCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetFBConfigsRequest(Screen), cookie)
	return GlxGetFBConfigsCookie{cookie}
}

func (c *Conn) GlxGetFBConfigsUnchecked(Screen uint32) GlxGetFBConfigsCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetFBConfigsRequest(Screen), cookie)
	return GlxGetFBConfigsCookie{cookie}
}

// Request reply for GlxGetFBConfigs
// size: (32 + pad((int(Length) * 4)))
type GlxGetFBConfigsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumFbConfigs  uint32
	NumProperties uint32
	// padding: 16 bytes
	PropertyList []uint32 // size: pad((int(Length) * 4))
}

// Waits and reads reply data from request GlxGetFBConfigs
func (cook GlxGetFBConfigsCookie) Reply() (*GlxGetFBConfigsReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetFBConfigsReply(buf), nil
}

// Read reply into structure from buffer for GlxGetFBConfigs
func glxGetFBConfigsReply(buf []byte) *GlxGetFBConfigsReply {
	v := new(GlxGetFBConfigsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumFbConfigs = Get32(buf[b:])
	b += 4

	v.NumProperties = Get32(buf[b:])
	b += 4

	b += 16 // padding

	v.PropertyList = make([]uint32, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.PropertyList[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetFBConfigsCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetFBConfigs
func (c *Conn) glxGetFBConfigsRequest(Screen uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 21 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], Screen)
	b += 4

	return buf
}

// Request GlxCreatePixmap
// size: pad((24 + pad(((int(NumAttribs) * 2) * 4))))
type GlxCreatePixmapCookie struct {
	*cookie
}

// Write request to wire for GlxCreatePixmap
func (c *Conn) GlxCreatePixmap(Screen uint32, Fbconfig GlxFbconfig, Pixmap Pixmap, GlxPixmap GlxPixmap, NumAttribs uint32, Attribs []uint32) GlxCreatePixmapCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxCreatePixmapRequest(Screen, Fbconfig, Pixmap, GlxPixmap, NumAttribs, Attribs), cookie)
	return GlxCreatePixmapCookie{cookie}
}

func (c *Conn) GlxCreatePixmapChecked(Screen uint32, Fbconfig GlxFbconfig, Pixmap Pixmap, GlxPixmap GlxPixmap, NumAttribs uint32, Attribs []uint32) GlxCreatePixmapCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxCreatePixmapRequest(Screen, Fbconfig, Pixmap, GlxPixmap, NumAttribs, Attribs), cookie)
	return GlxCreatePixmapCookie{cookie}
}

func (cook GlxCreatePixmapCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxCreatePixmap
func (c *Conn) glxCreatePixmapRequest(Screen uint32, Fbconfig GlxFbconfig, Pixmap Pixmap, GlxPixmap GlxPixmap, NumAttribs uint32, Attribs []uint32) []byte {
	size := pad((24 + pad(((int(NumAttribs) * 2) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 22 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], Screen)
	b += 4

	Put32(buf[b:], uint32(Fbconfig))
	b += 4

	Put32(buf[b:], uint32(Pixmap))
	b += 4

	Put32(buf[b:], uint32(GlxPixmap))
	b += 4

	Put32(buf[b:], NumAttribs)
	b += 4

	for i := 0; i < int((int(NumAttribs) * 2)); i++ {
		Put32(buf[b:], Attribs[i])
		b += 4
	}
	b = pad(b)

	return buf
}

// Request GlxDestroyPixmap
// size: 8
type GlxDestroyPixmapCookie struct {
	*cookie
}

// Write request to wire for GlxDestroyPixmap
func (c *Conn) GlxDestroyPixmap(GlxPixmap GlxPixmap) GlxDestroyPixmapCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxDestroyPixmapRequest(GlxPixmap), cookie)
	return GlxDestroyPixmapCookie{cookie}
}

func (c *Conn) GlxDestroyPixmapChecked(GlxPixmap GlxPixmap) GlxDestroyPixmapCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxDestroyPixmapRequest(GlxPixmap), cookie)
	return GlxDestroyPixmapCookie{cookie}
}

func (cook GlxDestroyPixmapCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxDestroyPixmap
func (c *Conn) glxDestroyPixmapRequest(GlxPixmap GlxPixmap) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 23 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(GlxPixmap))
	b += 4

	return buf
}

// Request GlxCreateNewContext
// size: 28
type GlxCreateNewContextCookie struct {
	*cookie
}

// Write request to wire for GlxCreateNewContext
func (c *Conn) GlxCreateNewContext(Context GlxContext, Fbconfig GlxFbconfig, Screen uint32, RenderType uint32, ShareList GlxContext, IsDirect bool) GlxCreateNewContextCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxCreateNewContextRequest(Context, Fbconfig, Screen, RenderType, ShareList, IsDirect), cookie)
	return GlxCreateNewContextCookie{cookie}
}

func (c *Conn) GlxCreateNewContextChecked(Context GlxContext, Fbconfig GlxFbconfig, Screen uint32, RenderType uint32, ShareList GlxContext, IsDirect bool) GlxCreateNewContextCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxCreateNewContextRequest(Context, Fbconfig, Screen, RenderType, ShareList, IsDirect), cookie)
	return GlxCreateNewContextCookie{cookie}
}

func (cook GlxCreateNewContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxCreateNewContext
func (c *Conn) glxCreateNewContextRequest(Context GlxContext, Fbconfig GlxFbconfig, Screen uint32, RenderType uint32, ShareList GlxContext, IsDirect bool) []byte {
	size := 28
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 24 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Context))
	b += 4

	Put32(buf[b:], uint32(Fbconfig))
	b += 4

	Put32(buf[b:], Screen)
	b += 4

	Put32(buf[b:], RenderType)
	b += 4

	Put32(buf[b:], uint32(ShareList))
	b += 4

	if IsDirect {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 3 // padding

	return buf
}

// Request GlxQueryContext
// size: 8
type GlxQueryContextCookie struct {
	*cookie
}

func (c *Conn) GlxQueryContext(Context GlxContext) GlxQueryContextCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxQueryContextRequest(Context), cookie)
	return GlxQueryContextCookie{cookie}
}

func (c *Conn) GlxQueryContextUnchecked(Context GlxContext) GlxQueryContextCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxQueryContextRequest(Context), cookie)
	return GlxQueryContextCookie{cookie}
}

// Request reply for GlxQueryContext
// size: (32 + pad(((int(NumAttribs) * 2) * 4)))
type GlxQueryContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumAttribs uint32
	// padding: 20 bytes
	Attribs []uint32 // size: pad(((int(NumAttribs) * 2) * 4))
}

// Waits and reads reply data from request GlxQueryContext
func (cook GlxQueryContextCookie) Reply() (*GlxQueryContextReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxQueryContextReply(buf), nil
}

// Read reply into structure from buffer for GlxQueryContext
func glxQueryContextReply(buf []byte) *GlxQueryContextReply {
	v := new(GlxQueryContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumAttribs = Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.Attribs = make([]uint32, (int(v.NumAttribs) * 2))
	for i := 0; i < int((int(v.NumAttribs) * 2)); i++ {
		v.Attribs[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxQueryContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxQueryContext
func (c *Conn) glxQueryContextRequest(Context GlxContext) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 25 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Context))
	b += 4

	return buf
}

// Request GlxMakeContextCurrent
// size: 20
type GlxMakeContextCurrentCookie struct {
	*cookie
}

func (c *Conn) GlxMakeContextCurrent(OldContextTag GlxContextTag, Drawable GlxDrawable, ReadDrawable GlxDrawable, Context GlxContext) GlxMakeContextCurrentCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxMakeContextCurrentRequest(OldContextTag, Drawable, ReadDrawable, Context), cookie)
	return GlxMakeContextCurrentCookie{cookie}
}

func (c *Conn) GlxMakeContextCurrentUnchecked(OldContextTag GlxContextTag, Drawable GlxDrawable, ReadDrawable GlxDrawable, Context GlxContext) GlxMakeContextCurrentCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxMakeContextCurrentRequest(OldContextTag, Drawable, ReadDrawable, Context), cookie)
	return GlxMakeContextCurrentCookie{cookie}
}

// Request reply for GlxMakeContextCurrent
// size: 32
type GlxMakeContextCurrentReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextTag GlxContextTag
	// padding: 20 bytes
}

// Waits and reads reply data from request GlxMakeContextCurrent
func (cook GlxMakeContextCurrentCookie) Reply() (*GlxMakeContextCurrentReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxMakeContextCurrentReply(buf), nil
}

// Read reply into structure from buffer for GlxMakeContextCurrent
func glxMakeContextCurrentReply(buf []byte) *GlxMakeContextCurrentReply {
	v := new(GlxMakeContextCurrentReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextTag = GlxContextTag(Get32(buf[b:]))
	b += 4

	b += 20 // padding

	return v
}

func (cook GlxMakeContextCurrentCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxMakeContextCurrent
func (c *Conn) glxMakeContextCurrentRequest(OldContextTag GlxContextTag, Drawable GlxDrawable, ReadDrawable GlxDrawable, Context GlxContext) []byte {
	size := 20
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 26 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(OldContextTag))
	b += 4

	Put32(buf[b:], uint32(Drawable))
	b += 4

	Put32(buf[b:], uint32(ReadDrawable))
	b += 4

	Put32(buf[b:], uint32(Context))
	b += 4

	return buf
}

// Request GlxCreatePbuffer
// size: pad((20 + pad(((int(NumAttribs) * 2) * 4))))
type GlxCreatePbufferCookie struct {
	*cookie
}

// Write request to wire for GlxCreatePbuffer
func (c *Conn) GlxCreatePbuffer(Screen uint32, Fbconfig GlxFbconfig, Pbuffer GlxPbuffer, NumAttribs uint32, Attribs []uint32) GlxCreatePbufferCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxCreatePbufferRequest(Screen, Fbconfig, Pbuffer, NumAttribs, Attribs), cookie)
	return GlxCreatePbufferCookie{cookie}
}

func (c *Conn) GlxCreatePbufferChecked(Screen uint32, Fbconfig GlxFbconfig, Pbuffer GlxPbuffer, NumAttribs uint32, Attribs []uint32) GlxCreatePbufferCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxCreatePbufferRequest(Screen, Fbconfig, Pbuffer, NumAttribs, Attribs), cookie)
	return GlxCreatePbufferCookie{cookie}
}

func (cook GlxCreatePbufferCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxCreatePbuffer
func (c *Conn) glxCreatePbufferRequest(Screen uint32, Fbconfig GlxFbconfig, Pbuffer GlxPbuffer, NumAttribs uint32, Attribs []uint32) []byte {
	size := pad((20 + pad(((int(NumAttribs) * 2) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 27 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], Screen)
	b += 4

	Put32(buf[b:], uint32(Fbconfig))
	b += 4

	Put32(buf[b:], uint32(Pbuffer))
	b += 4

	Put32(buf[b:], NumAttribs)
	b += 4

	for i := 0; i < int((int(NumAttribs) * 2)); i++ {
		Put32(buf[b:], Attribs[i])
		b += 4
	}
	b = pad(b)

	return buf
}

// Request GlxDestroyPbuffer
// size: 8
type GlxDestroyPbufferCookie struct {
	*cookie
}

// Write request to wire for GlxDestroyPbuffer
func (c *Conn) GlxDestroyPbuffer(Pbuffer GlxPbuffer) GlxDestroyPbufferCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxDestroyPbufferRequest(Pbuffer), cookie)
	return GlxDestroyPbufferCookie{cookie}
}

func (c *Conn) GlxDestroyPbufferChecked(Pbuffer GlxPbuffer) GlxDestroyPbufferCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxDestroyPbufferRequest(Pbuffer), cookie)
	return GlxDestroyPbufferCookie{cookie}
}

func (cook GlxDestroyPbufferCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxDestroyPbuffer
func (c *Conn) glxDestroyPbufferRequest(Pbuffer GlxPbuffer) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 28 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Pbuffer))
	b += 4

	return buf
}

// Request GlxGetDrawableAttributes
// size: 8
type GlxGetDrawableAttributesCookie struct {
	*cookie
}

func (c *Conn) GlxGetDrawableAttributes(Drawable GlxDrawable) GlxGetDrawableAttributesCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetDrawableAttributesRequest(Drawable), cookie)
	return GlxGetDrawableAttributesCookie{cookie}
}

func (c *Conn) GlxGetDrawableAttributesUnchecked(Drawable GlxDrawable) GlxGetDrawableAttributesCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetDrawableAttributesRequest(Drawable), cookie)
	return GlxGetDrawableAttributesCookie{cookie}
}

// Request reply for GlxGetDrawableAttributes
// size: (32 + pad(((int(NumAttribs) * 2) * 4)))
type GlxGetDrawableAttributesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumAttribs uint32
	// padding: 20 bytes
	Attribs []uint32 // size: pad(((int(NumAttribs) * 2) * 4))
}

// Waits and reads reply data from request GlxGetDrawableAttributes
func (cook GlxGetDrawableAttributesCookie) Reply() (*GlxGetDrawableAttributesReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetDrawableAttributesReply(buf), nil
}

// Read reply into structure from buffer for GlxGetDrawableAttributes
func glxGetDrawableAttributesReply(buf []byte) *GlxGetDrawableAttributesReply {
	v := new(GlxGetDrawableAttributesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumAttribs = Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.Attribs = make([]uint32, (int(v.NumAttribs) * 2))
	for i := 0; i < int((int(v.NumAttribs) * 2)); i++ {
		v.Attribs[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetDrawableAttributesCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetDrawableAttributes
func (c *Conn) glxGetDrawableAttributesRequest(Drawable GlxDrawable) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 29 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Drawable))
	b += 4

	return buf
}

// Request GlxChangeDrawableAttributes
// size: pad((12 + pad(((int(NumAttribs) * 2) * 4))))
type GlxChangeDrawableAttributesCookie struct {
	*cookie
}

// Write request to wire for GlxChangeDrawableAttributes
func (c *Conn) GlxChangeDrawableAttributes(Drawable GlxDrawable, NumAttribs uint32, Attribs []uint32) GlxChangeDrawableAttributesCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxChangeDrawableAttributesRequest(Drawable, NumAttribs, Attribs), cookie)
	return GlxChangeDrawableAttributesCookie{cookie}
}

func (c *Conn) GlxChangeDrawableAttributesChecked(Drawable GlxDrawable, NumAttribs uint32, Attribs []uint32) GlxChangeDrawableAttributesCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxChangeDrawableAttributesRequest(Drawable, NumAttribs, Attribs), cookie)
	return GlxChangeDrawableAttributesCookie{cookie}
}

func (cook GlxChangeDrawableAttributesCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxChangeDrawableAttributes
func (c *Conn) glxChangeDrawableAttributesRequest(Drawable GlxDrawable, NumAttribs uint32, Attribs []uint32) []byte {
	size := pad((12 + pad(((int(NumAttribs) * 2) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 30 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Drawable))
	b += 4

	Put32(buf[b:], NumAttribs)
	b += 4

	for i := 0; i < int((int(NumAttribs) * 2)); i++ {
		Put32(buf[b:], Attribs[i])
		b += 4
	}
	b = pad(b)

	return buf
}

// Request GlxCreateWindow
// size: pad((24 + pad(((int(NumAttribs) * 2) * 4))))
type GlxCreateWindowCookie struct {
	*cookie
}

// Write request to wire for GlxCreateWindow
func (c *Conn) GlxCreateWindow(Screen uint32, Fbconfig GlxFbconfig, Window Window, GlxWindow GlxWindow, NumAttribs uint32, Attribs []uint32) GlxCreateWindowCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxCreateWindowRequest(Screen, Fbconfig, Window, GlxWindow, NumAttribs, Attribs), cookie)
	return GlxCreateWindowCookie{cookie}
}

func (c *Conn) GlxCreateWindowChecked(Screen uint32, Fbconfig GlxFbconfig, Window Window, GlxWindow GlxWindow, NumAttribs uint32, Attribs []uint32) GlxCreateWindowCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxCreateWindowRequest(Screen, Fbconfig, Window, GlxWindow, NumAttribs, Attribs), cookie)
	return GlxCreateWindowCookie{cookie}
}

func (cook GlxCreateWindowCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxCreateWindow
func (c *Conn) glxCreateWindowRequest(Screen uint32, Fbconfig GlxFbconfig, Window Window, GlxWindow GlxWindow, NumAttribs uint32, Attribs []uint32) []byte {
	size := pad((24 + pad(((int(NumAttribs) * 2) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 31 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], Screen)
	b += 4

	Put32(buf[b:], uint32(Fbconfig))
	b += 4

	Put32(buf[b:], uint32(Window))
	b += 4

	Put32(buf[b:], uint32(GlxWindow))
	b += 4

	Put32(buf[b:], NumAttribs)
	b += 4

	for i := 0; i < int((int(NumAttribs) * 2)); i++ {
		Put32(buf[b:], Attribs[i])
		b += 4
	}
	b = pad(b)

	return buf
}

// Request GlxDeleteWindow
// size: 8
type GlxDeleteWindowCookie struct {
	*cookie
}

// Write request to wire for GlxDeleteWindow
func (c *Conn) GlxDeleteWindow(Glxwindow GlxWindow) GlxDeleteWindowCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxDeleteWindowRequest(Glxwindow), cookie)
	return GlxDeleteWindowCookie{cookie}
}

func (c *Conn) GlxDeleteWindowChecked(Glxwindow GlxWindow) GlxDeleteWindowCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxDeleteWindowRequest(Glxwindow), cookie)
	return GlxDeleteWindowCookie{cookie}
}

func (cook GlxDeleteWindowCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxDeleteWindow
func (c *Conn) glxDeleteWindowRequest(Glxwindow GlxWindow) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 32 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Glxwindow))
	b += 4

	return buf
}

// Request GlxSetClientInfoARB
// size: pad((((24 + pad(((int(NumVersions) * 2) * 4))) + pad((int(GlStrLen) * 1))) + pad((int(GlxStrLen) * 1))))
type GlxSetClientInfoARBCookie struct {
	*cookie
}

// Write request to wire for GlxSetClientInfoARB
func (c *Conn) GlxSetClientInfoARB(MajorVersion uint32, MinorVersion uint32, NumVersions uint32, GlStrLen uint32, GlxStrLen uint32, GlVersions []uint32, GlExtensionString string, GlxExtensionString string) GlxSetClientInfoARBCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxSetClientInfoARBRequest(MajorVersion, MinorVersion, NumVersions, GlStrLen, GlxStrLen, GlVersions, GlExtensionString, GlxExtensionString), cookie)
	return GlxSetClientInfoARBCookie{cookie}
}

func (c *Conn) GlxSetClientInfoARBChecked(MajorVersion uint32, MinorVersion uint32, NumVersions uint32, GlStrLen uint32, GlxStrLen uint32, GlVersions []uint32, GlExtensionString string, GlxExtensionString string) GlxSetClientInfoARBCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxSetClientInfoARBRequest(MajorVersion, MinorVersion, NumVersions, GlStrLen, GlxStrLen, GlVersions, GlExtensionString, GlxExtensionString), cookie)
	return GlxSetClientInfoARBCookie{cookie}
}

func (cook GlxSetClientInfoARBCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxSetClientInfoARB
func (c *Conn) glxSetClientInfoARBRequest(MajorVersion uint32, MinorVersion uint32, NumVersions uint32, GlStrLen uint32, GlxStrLen uint32, GlVersions []uint32, GlExtensionString string, GlxExtensionString string) []byte {
	size := pad((((24 + pad(((int(NumVersions) * 2) * 4))) + pad((int(GlStrLen) * 1))) + pad((int(GlxStrLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 33 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], MajorVersion)
	b += 4

	Put32(buf[b:], MinorVersion)
	b += 4

	Put32(buf[b:], NumVersions)
	b += 4

	Put32(buf[b:], GlStrLen)
	b += 4

	Put32(buf[b:], GlxStrLen)
	b += 4

	for i := 0; i < int((int(NumVersions) * 2)); i++ {
		Put32(buf[b:], GlVersions[i])
		b += 4
	}
	b = pad(b)

	copy(buf[b:], GlExtensionString[:GlStrLen])
	b += pad(int(GlStrLen))

	copy(buf[b:], GlxExtensionString[:GlxStrLen])
	b += pad(int(GlxStrLen))

	return buf
}

// Request GlxCreateContextAttribsARB
// size: pad((28 + pad(((int(NumAttribs) * 2) * 4))))
type GlxCreateContextAttribsARBCookie struct {
	*cookie
}

// Write request to wire for GlxCreateContextAttribsARB
func (c *Conn) GlxCreateContextAttribsARB(Context GlxContext, Fbconfig GlxFbconfig, Screen uint32, ShareList GlxContext, IsDirect bool, NumAttribs uint32, Attribs []uint32) GlxCreateContextAttribsARBCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxCreateContextAttribsARBRequest(Context, Fbconfig, Screen, ShareList, IsDirect, NumAttribs, Attribs), cookie)
	return GlxCreateContextAttribsARBCookie{cookie}
}

func (c *Conn) GlxCreateContextAttribsARBChecked(Context GlxContext, Fbconfig GlxFbconfig, Screen uint32, ShareList GlxContext, IsDirect bool, NumAttribs uint32, Attribs []uint32) GlxCreateContextAttribsARBCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxCreateContextAttribsARBRequest(Context, Fbconfig, Screen, ShareList, IsDirect, NumAttribs, Attribs), cookie)
	return GlxCreateContextAttribsARBCookie{cookie}
}

func (cook GlxCreateContextAttribsARBCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxCreateContextAttribsARB
func (c *Conn) glxCreateContextAttribsARBRequest(Context GlxContext, Fbconfig GlxFbconfig, Screen uint32, ShareList GlxContext, IsDirect bool, NumAttribs uint32, Attribs []uint32) []byte {
	size := pad((28 + pad(((int(NumAttribs) * 2) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 34 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Context))
	b += 4

	Put32(buf[b:], uint32(Fbconfig))
	b += 4

	Put32(buf[b:], Screen)
	b += 4

	Put32(buf[b:], uint32(ShareList))
	b += 4

	if IsDirect {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 3 // padding

	Put32(buf[b:], NumAttribs)
	b += 4

	for i := 0; i < int((int(NumAttribs) * 2)); i++ {
		Put32(buf[b:], Attribs[i])
		b += 4
	}
	b = pad(b)

	return buf
}

// Request GlxSetClientInfo2ARB
// size: pad((((24 + pad(((int(NumVersions) * 3) * 4))) + pad((int(GlStrLen) * 1))) + pad((int(GlxStrLen) * 1))))
type GlxSetClientInfo2ARBCookie struct {
	*cookie
}

// Write request to wire for GlxSetClientInfo2ARB
func (c *Conn) GlxSetClientInfo2ARB(MajorVersion uint32, MinorVersion uint32, NumVersions uint32, GlStrLen uint32, GlxStrLen uint32, GlVersions []uint32, GlExtensionString string, GlxExtensionString string) GlxSetClientInfo2ARBCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxSetClientInfo2ARBRequest(MajorVersion, MinorVersion, NumVersions, GlStrLen, GlxStrLen, GlVersions, GlExtensionString, GlxExtensionString), cookie)
	return GlxSetClientInfo2ARBCookie{cookie}
}

func (c *Conn) GlxSetClientInfo2ARBChecked(MajorVersion uint32, MinorVersion uint32, NumVersions uint32, GlStrLen uint32, GlxStrLen uint32, GlVersions []uint32, GlExtensionString string, GlxExtensionString string) GlxSetClientInfo2ARBCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxSetClientInfo2ARBRequest(MajorVersion, MinorVersion, NumVersions, GlStrLen, GlxStrLen, GlVersions, GlExtensionString, GlxExtensionString), cookie)
	return GlxSetClientInfo2ARBCookie{cookie}
}

func (cook GlxSetClientInfo2ARBCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxSetClientInfo2ARB
func (c *Conn) glxSetClientInfo2ARBRequest(MajorVersion uint32, MinorVersion uint32, NumVersions uint32, GlStrLen uint32, GlxStrLen uint32, GlVersions []uint32, GlExtensionString string, GlxExtensionString string) []byte {
	size := pad((((24 + pad(((int(NumVersions) * 3) * 4))) + pad((int(GlStrLen) * 1))) + pad((int(GlxStrLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 35 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], MajorVersion)
	b += 4

	Put32(buf[b:], MinorVersion)
	b += 4

	Put32(buf[b:], NumVersions)
	b += 4

	Put32(buf[b:], GlStrLen)
	b += 4

	Put32(buf[b:], GlxStrLen)
	b += 4

	for i := 0; i < int((int(NumVersions) * 3)); i++ {
		Put32(buf[b:], GlVersions[i])
		b += 4
	}
	b = pad(b)

	copy(buf[b:], GlExtensionString[:GlStrLen])
	b += pad(int(GlStrLen))

	copy(buf[b:], GlxExtensionString[:GlxStrLen])
	b += pad(int(GlxStrLen))

	return buf
}

// Request GlxNewList
// size: 16
type GlxNewListCookie struct {
	*cookie
}

// Write request to wire for GlxNewList
func (c *Conn) GlxNewList(ContextTag GlxContextTag, List uint32, Mode uint32) GlxNewListCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxNewListRequest(ContextTag, List, Mode), cookie)
	return GlxNewListCookie{cookie}
}

func (c *Conn) GlxNewListChecked(ContextTag GlxContextTag, List uint32, Mode uint32) GlxNewListCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxNewListRequest(ContextTag, List, Mode), cookie)
	return GlxNewListCookie{cookie}
}

func (cook GlxNewListCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxNewList
func (c *Conn) glxNewListRequest(ContextTag GlxContextTag, List uint32, Mode uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 101 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], List)
	b += 4

	Put32(buf[b:], Mode)
	b += 4

	return buf
}

// Request GlxEndList
// size: 8
type GlxEndListCookie struct {
	*cookie
}

// Write request to wire for GlxEndList
func (c *Conn) GlxEndList(ContextTag GlxContextTag) GlxEndListCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxEndListRequest(ContextTag), cookie)
	return GlxEndListCookie{cookie}
}

func (c *Conn) GlxEndListChecked(ContextTag GlxContextTag) GlxEndListCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxEndListRequest(ContextTag), cookie)
	return GlxEndListCookie{cookie}
}

func (cook GlxEndListCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxEndList
func (c *Conn) glxEndListRequest(ContextTag GlxContextTag) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 102 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	return buf
}

// Request GlxDeleteLists
// size: 16
type GlxDeleteListsCookie struct {
	*cookie
}

// Write request to wire for GlxDeleteLists
func (c *Conn) GlxDeleteLists(ContextTag GlxContextTag, List uint32, Range int32) GlxDeleteListsCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxDeleteListsRequest(ContextTag, List, Range), cookie)
	return GlxDeleteListsCookie{cookie}
}

func (c *Conn) GlxDeleteListsChecked(ContextTag GlxContextTag, List uint32, Range int32) GlxDeleteListsCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxDeleteListsRequest(ContextTag, List, Range), cookie)
	return GlxDeleteListsCookie{cookie}
}

func (cook GlxDeleteListsCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxDeleteLists
func (c *Conn) glxDeleteListsRequest(ContextTag GlxContextTag, List uint32, Range int32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 103 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], List)
	b += 4

	Put32(buf[b:], uint32(Range))
	b += 4

	return buf
}

// Request GlxGenLists
// size: 12
type GlxGenListsCookie struct {
	*cookie
}

func (c *Conn) GlxGenLists(ContextTag GlxContextTag, Range int32) GlxGenListsCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGenListsRequest(ContextTag, Range), cookie)
	return GlxGenListsCookie{cookie}
}

func (c *Conn) GlxGenListsUnchecked(ContextTag GlxContextTag, Range int32) GlxGenListsCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGenListsRequest(ContextTag, Range), cookie)
	return GlxGenListsCookie{cookie}
}

// Request reply for GlxGenLists
// size: 12
type GlxGenListsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	RetVal uint32
}

// Waits and reads reply data from request GlxGenLists
func (cook GlxGenListsCookie) Reply() (*GlxGenListsReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGenListsReply(buf), nil
}

// Read reply into structure from buffer for GlxGenLists
func glxGenListsReply(buf []byte) *GlxGenListsReply {
	v := new(GlxGenListsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.RetVal = Get32(buf[b:])
	b += 4

	return v
}

func (cook GlxGenListsCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGenLists
func (c *Conn) glxGenListsRequest(ContextTag GlxContextTag, Range int32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 104 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], uint32(Range))
	b += 4

	return buf
}

// Request GlxFeedbackBuffer
// size: 16
type GlxFeedbackBufferCookie struct {
	*cookie
}

// Write request to wire for GlxFeedbackBuffer
func (c *Conn) GlxFeedbackBuffer(ContextTag GlxContextTag, Size int32, Type int32) GlxFeedbackBufferCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxFeedbackBufferRequest(ContextTag, Size, Type), cookie)
	return GlxFeedbackBufferCookie{cookie}
}

func (c *Conn) GlxFeedbackBufferChecked(ContextTag GlxContextTag, Size int32, Type int32) GlxFeedbackBufferCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxFeedbackBufferRequest(ContextTag, Size, Type), cookie)
	return GlxFeedbackBufferCookie{cookie}
}

func (cook GlxFeedbackBufferCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxFeedbackBuffer
func (c *Conn) glxFeedbackBufferRequest(ContextTag GlxContextTag, Size int32, Type int32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 105 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], uint32(Size))
	b += 4

	Put32(buf[b:], uint32(Type))
	b += 4

	return buf
}

// Request GlxSelectBuffer
// size: 12
type GlxSelectBufferCookie struct {
	*cookie
}

// Write request to wire for GlxSelectBuffer
func (c *Conn) GlxSelectBuffer(ContextTag GlxContextTag, Size int32) GlxSelectBufferCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxSelectBufferRequest(ContextTag, Size), cookie)
	return GlxSelectBufferCookie{cookie}
}

func (c *Conn) GlxSelectBufferChecked(ContextTag GlxContextTag, Size int32) GlxSelectBufferCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxSelectBufferRequest(ContextTag, Size), cookie)
	return GlxSelectBufferCookie{cookie}
}

func (cook GlxSelectBufferCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxSelectBuffer
func (c *Conn) glxSelectBufferRequest(ContextTag GlxContextTag, Size int32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 106 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], uint32(Size))
	b += 4

	return buf
}

// Request GlxRenderMode
// size: 12
type GlxRenderModeCookie struct {
	*cookie
}

func (c *Conn) GlxRenderMode(ContextTag GlxContextTag, Mode uint32) GlxRenderModeCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxRenderModeRequest(ContextTag, Mode), cookie)
	return GlxRenderModeCookie{cookie}
}

func (c *Conn) GlxRenderModeUnchecked(ContextTag GlxContextTag, Mode uint32) GlxRenderModeCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxRenderModeRequest(ContextTag, Mode), cookie)
	return GlxRenderModeCookie{cookie}
}

// Request reply for GlxRenderMode
// size: (32 + pad((int(N) * 4)))
type GlxRenderModeReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	RetVal  uint32
	N       uint32
	NewMode uint32
	// padding: 12 bytes
	Data []uint32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxRenderMode
func (cook GlxRenderModeCookie) Reply() (*GlxRenderModeReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxRenderModeReply(buf), nil
}

// Read reply into structure from buffer for GlxRenderMode
func glxRenderModeReply(buf []byte) *GlxRenderModeReply {
	v := new(GlxRenderModeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.RetVal = Get32(buf[b:])
	b += 4

	v.N = Get32(buf[b:])
	b += 4

	v.NewMode = Get32(buf[b:])
	b += 4

	b += 12 // padding

	v.Data = make([]uint32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxRenderModeCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxRenderMode
func (c *Conn) glxRenderModeRequest(ContextTag GlxContextTag, Mode uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 107 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Mode)
	b += 4

	return buf
}

// Request GlxFinish
// size: 8
type GlxFinishCookie struct {
	*cookie
}

func (c *Conn) GlxFinish(ContextTag GlxContextTag) GlxFinishCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxFinishRequest(ContextTag), cookie)
	return GlxFinishCookie{cookie}
}

func (c *Conn) GlxFinishUnchecked(ContextTag GlxContextTag) GlxFinishCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxFinishRequest(ContextTag), cookie)
	return GlxFinishCookie{cookie}
}

// Request reply for GlxFinish
// size: 8
type GlxFinishReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
}

// Waits and reads reply data from request GlxFinish
func (cook GlxFinishCookie) Reply() (*GlxFinishReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxFinishReply(buf), nil
}

// Read reply into structure from buffer for GlxFinish
func glxFinishReply(buf []byte) *GlxFinishReply {
	v := new(GlxFinishReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	return v
}

func (cook GlxFinishCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxFinish
func (c *Conn) glxFinishRequest(ContextTag GlxContextTag) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 108 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	return buf
}

// Request GlxPixelStoref
// size: 16
type GlxPixelStorefCookie struct {
	*cookie
}

// Write request to wire for GlxPixelStoref
func (c *Conn) GlxPixelStoref(ContextTag GlxContextTag, Pname uint32, Datum GlxFloat32) GlxPixelStorefCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxPixelStorefRequest(ContextTag, Pname, Datum), cookie)
	return GlxPixelStorefCookie{cookie}
}

func (c *Conn) GlxPixelStorefChecked(ContextTag GlxContextTag, Pname uint32, Datum GlxFloat32) GlxPixelStorefCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxPixelStorefRequest(ContextTag, Pname, Datum), cookie)
	return GlxPixelStorefCookie{cookie}
}

func (cook GlxPixelStorefCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxPixelStoref
func (c *Conn) glxPixelStorefRequest(ContextTag GlxContextTag, Pname uint32, Datum GlxFloat32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 109 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	Put32(buf[b:], uint32(Datum))
	b += 4

	return buf
}

// Request GlxPixelStorei
// size: 16
type GlxPixelStoreiCookie struct {
	*cookie
}

// Write request to wire for GlxPixelStorei
func (c *Conn) GlxPixelStorei(ContextTag GlxContextTag, Pname uint32, Datum int32) GlxPixelStoreiCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxPixelStoreiRequest(ContextTag, Pname, Datum), cookie)
	return GlxPixelStoreiCookie{cookie}
}

func (c *Conn) GlxPixelStoreiChecked(ContextTag GlxContextTag, Pname uint32, Datum int32) GlxPixelStoreiCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxPixelStoreiRequest(ContextTag, Pname, Datum), cookie)
	return GlxPixelStoreiCookie{cookie}
}

func (cook GlxPixelStoreiCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxPixelStorei
func (c *Conn) glxPixelStoreiRequest(ContextTag GlxContextTag, Pname uint32, Datum int32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 110 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	Put32(buf[b:], uint32(Datum))
	b += 4

	return buf
}

// Request GlxReadPixels
// size: 36
type GlxReadPixelsCookie struct {
	*cookie
}

func (c *Conn) GlxReadPixels(ContextTag GlxContextTag, X int32, Y int32, Width int32, Height int32, Format uint32, Type uint32, SwapBytes bool, LsbFirst bool) GlxReadPixelsCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxReadPixelsRequest(ContextTag, X, Y, Width, Height, Format, Type, SwapBytes, LsbFirst), cookie)
	return GlxReadPixelsCookie{cookie}
}

func (c *Conn) GlxReadPixelsUnchecked(ContextTag GlxContextTag, X int32, Y int32, Width int32, Height int32, Format uint32, Type uint32, SwapBytes bool, LsbFirst bool) GlxReadPixelsCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxReadPixelsRequest(ContextTag, X, Y, Width, Height, Format, Type, SwapBytes, LsbFirst), cookie)
	return GlxReadPixelsCookie{cookie}
}

// Request reply for GlxReadPixels
// size: (32 + pad(((int(Length) * 4) * 1)))
type GlxReadPixelsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
	Data []byte // size: pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GlxReadPixels
func (cook GlxReadPixelsCookie) Reply() (*GlxReadPixelsReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxReadPixelsReply(buf), nil
}

// Read reply into structure from buffer for GlxReadPixels
func glxReadPixelsReply(buf []byte) *GlxReadPixelsReply {
	v := new(GlxReadPixelsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += pad(int((int(v.Length) * 4)))

	return v
}

func (cook GlxReadPixelsCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxReadPixels
func (c *Conn) glxReadPixelsRequest(ContextTag GlxContextTag, X int32, Y int32, Width int32, Height int32, Format uint32, Type uint32, SwapBytes bool, LsbFirst bool) []byte {
	size := 36
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 111 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], uint32(X))
	b += 4

	Put32(buf[b:], uint32(Y))
	b += 4

	Put32(buf[b:], uint32(Width))
	b += 4

	Put32(buf[b:], uint32(Height))
	b += 4

	Put32(buf[b:], Format)
	b += 4

	Put32(buf[b:], Type)
	b += 4

	if SwapBytes {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	if LsbFirst {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GlxGetBooleanv
// size: 12
type GlxGetBooleanvCookie struct {
	*cookie
}

func (c *Conn) GlxGetBooleanv(ContextTag GlxContextTag, Pname int32) GlxGetBooleanvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetBooleanvRequest(ContextTag, Pname), cookie)
	return GlxGetBooleanvCookie{cookie}
}

func (c *Conn) GlxGetBooleanvUnchecked(ContextTag GlxContextTag, Pname int32) GlxGetBooleanvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetBooleanvRequest(ContextTag, Pname), cookie)
	return GlxGetBooleanvCookie{cookie}
}

// Request reply for GlxGetBooleanv
// size: (32 + pad((int(N) * 1)))
type GlxGetBooleanvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum bool
	// padding: 15 bytes
	Data []bool // size: pad((int(N) * 1))
}

// Waits and reads reply data from request GlxGetBooleanv
func (cook GlxGetBooleanvCookie) Reply() (*GlxGetBooleanvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetBooleanvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetBooleanv
func glxGetBooleanvReply(buf []byte) *GlxGetBooleanvReply {
	v := new(GlxGetBooleanvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	if buf[b] == 1 {
		v.Datum = true
	} else {
		v.Datum = false
	}
	b += 1

	b += 15 // padding

	v.Data = make([]bool, v.N)
	for i := 0; i < int(v.N); i++ {
		if buf[b] == 1 {
			v.Data[i] = true
		} else {
			v.Data[i] = false
		}
		b += 1
	}
	b = pad(b)

	return v
}

func (cook GlxGetBooleanvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetBooleanv
func (c *Conn) glxGetBooleanvRequest(ContextTag GlxContextTag, Pname int32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 112 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], uint32(Pname))
	b += 4

	return buf
}

// Request GlxGetClipPlane
// size: 12
type GlxGetClipPlaneCookie struct {
	*cookie
}

func (c *Conn) GlxGetClipPlane(ContextTag GlxContextTag, Plane int32) GlxGetClipPlaneCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetClipPlaneRequest(ContextTag, Plane), cookie)
	return GlxGetClipPlaneCookie{cookie}
}

func (c *Conn) GlxGetClipPlaneUnchecked(ContextTag GlxContextTag, Plane int32) GlxGetClipPlaneCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetClipPlaneRequest(ContextTag, Plane), cookie)
	return GlxGetClipPlaneCookie{cookie}
}

// Request reply for GlxGetClipPlane
// size: (32 + pad(((int(Length) / 2) * 8)))
type GlxGetClipPlaneReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
	Data []GlxFloat64 // size: pad(((int(Length) / 2) * 8))
}

// Waits and reads reply data from request GlxGetClipPlane
func (cook GlxGetClipPlaneCookie) Reply() (*GlxGetClipPlaneReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetClipPlaneReply(buf), nil
}

// Read reply into structure from buffer for GlxGetClipPlane
func glxGetClipPlaneReply(buf []byte) *GlxGetClipPlaneReply {
	v := new(GlxGetClipPlaneReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.Data = make([]GlxFloat64, (int(v.Length) / 2))
	for i := 0; i < int((int(v.Length) / 2)); i++ {
		v.Data[i] = GlxFloat64(Get64(buf[b:]))
		b += 8
	}
	b = pad(b)

	return v
}

func (cook GlxGetClipPlaneCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetClipPlane
func (c *Conn) glxGetClipPlaneRequest(ContextTag GlxContextTag, Plane int32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 113 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], uint32(Plane))
	b += 4

	return buf
}

// Request GlxGetDoublev
// size: 12
type GlxGetDoublevCookie struct {
	*cookie
}

func (c *Conn) GlxGetDoublev(ContextTag GlxContextTag, Pname uint32) GlxGetDoublevCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetDoublevRequest(ContextTag, Pname), cookie)
	return GlxGetDoublevCookie{cookie}
}

func (c *Conn) GlxGetDoublevUnchecked(ContextTag GlxContextTag, Pname uint32) GlxGetDoublevCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetDoublevRequest(ContextTag, Pname), cookie)
	return GlxGetDoublevCookie{cookie}
}

// Request reply for GlxGetDoublev
// size: (32 + pad((int(N) * 8)))
type GlxGetDoublevReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum GlxFloat64
	// padding: 8 bytes
	Data []GlxFloat64 // size: pad((int(N) * 8))
}

// Waits and reads reply data from request GlxGetDoublev
func (cook GlxGetDoublevCookie) Reply() (*GlxGetDoublevReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetDoublevReply(buf), nil
}

// Read reply into structure from buffer for GlxGetDoublev
func glxGetDoublevReply(buf []byte) *GlxGetDoublevReply {
	v := new(GlxGetDoublevReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = GlxFloat64(Get64(buf[b:]))
	b += 8

	b += 8 // padding

	v.Data = make([]GlxFloat64, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = GlxFloat64(Get64(buf[b:]))
		b += 8
	}
	b = pad(b)

	return v
}

func (cook GlxGetDoublevCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetDoublev
func (c *Conn) glxGetDoublevRequest(ContextTag GlxContextTag, Pname uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 114 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetError
// size: 8
type GlxGetErrorCookie struct {
	*cookie
}

func (c *Conn) GlxGetError(ContextTag GlxContextTag) GlxGetErrorCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetErrorRequest(ContextTag), cookie)
	return GlxGetErrorCookie{cookie}
}

func (c *Conn) GlxGetErrorUnchecked(ContextTag GlxContextTag) GlxGetErrorCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetErrorRequest(ContextTag), cookie)
	return GlxGetErrorCookie{cookie}
}

// Request reply for GlxGetError
// size: 12
type GlxGetErrorReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Error int32
}

// Waits and reads reply data from request GlxGetError
func (cook GlxGetErrorCookie) Reply() (*GlxGetErrorReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetErrorReply(buf), nil
}

// Read reply into structure from buffer for GlxGetError
func glxGetErrorReply(buf []byte) *GlxGetErrorReply {
	v := new(GlxGetErrorReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Error = int32(Get32(buf[b:]))
	b += 4

	return v
}

func (cook GlxGetErrorCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetError
func (c *Conn) glxGetErrorRequest(ContextTag GlxContextTag) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 115 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	return buf
}

// Request GlxGetFloatv
// size: 12
type GlxGetFloatvCookie struct {
	*cookie
}

func (c *Conn) GlxGetFloatv(ContextTag GlxContextTag, Pname uint32) GlxGetFloatvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetFloatvRequest(ContextTag, Pname), cookie)
	return GlxGetFloatvCookie{cookie}
}

func (c *Conn) GlxGetFloatvUnchecked(ContextTag GlxContextTag, Pname uint32) GlxGetFloatvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetFloatvRequest(ContextTag, Pname), cookie)
	return GlxGetFloatvCookie{cookie}
}

// Request reply for GlxGetFloatv
// size: (32 + pad((int(N) * 4)))
type GlxGetFloatvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum GlxFloat32
	// padding: 12 bytes
	Data []GlxFloat32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetFloatv
func (cook GlxGetFloatvCookie) Reply() (*GlxGetFloatvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetFloatvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetFloatv
func glxGetFloatvReply(buf []byte) *GlxGetFloatvReply {
	v := new(GlxGetFloatvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = GlxFloat32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]GlxFloat32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = GlxFloat32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetFloatvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetFloatv
func (c *Conn) glxGetFloatvRequest(ContextTag GlxContextTag, Pname uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 116 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetIntegerv
// size: 12
type GlxGetIntegervCookie struct {
	*cookie
}

func (c *Conn) GlxGetIntegerv(ContextTag GlxContextTag, Pname uint32) GlxGetIntegervCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetIntegervRequest(ContextTag, Pname), cookie)
	return GlxGetIntegervCookie{cookie}
}

func (c *Conn) GlxGetIntegervUnchecked(ContextTag GlxContextTag, Pname uint32) GlxGetIntegervCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetIntegervRequest(ContextTag, Pname), cookie)
	return GlxGetIntegervCookie{cookie}
}

// Request reply for GlxGetIntegerv
// size: (32 + pad((int(N) * 4)))
type GlxGetIntegervReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetIntegerv
func (cook GlxGetIntegervCookie) Reply() (*GlxGetIntegervReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetIntegervReply(buf), nil
}

// Read reply into structure from buffer for GlxGetIntegerv
func glxGetIntegervReply(buf []byte) *GlxGetIntegervReply {
	v := new(GlxGetIntegervReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetIntegervCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetIntegerv
func (c *Conn) glxGetIntegervRequest(ContextTag GlxContextTag, Pname uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 117 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetLightfv
// size: 16
type GlxGetLightfvCookie struct {
	*cookie
}

func (c *Conn) GlxGetLightfv(ContextTag GlxContextTag, Light uint32, Pname uint32) GlxGetLightfvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetLightfvRequest(ContextTag, Light, Pname), cookie)
	return GlxGetLightfvCookie{cookie}
}

func (c *Conn) GlxGetLightfvUnchecked(ContextTag GlxContextTag, Light uint32, Pname uint32) GlxGetLightfvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetLightfvRequest(ContextTag, Light, Pname), cookie)
	return GlxGetLightfvCookie{cookie}
}

// Request reply for GlxGetLightfv
// size: (32 + pad((int(N) * 4)))
type GlxGetLightfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum GlxFloat32
	// padding: 12 bytes
	Data []GlxFloat32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetLightfv
func (cook GlxGetLightfvCookie) Reply() (*GlxGetLightfvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetLightfvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetLightfv
func glxGetLightfvReply(buf []byte) *GlxGetLightfvReply {
	v := new(GlxGetLightfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = GlxFloat32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]GlxFloat32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = GlxFloat32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetLightfvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetLightfv
func (c *Conn) glxGetLightfvRequest(ContextTag GlxContextTag, Light uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 118 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Light)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetLightiv
// size: 16
type GlxGetLightivCookie struct {
	*cookie
}

func (c *Conn) GlxGetLightiv(ContextTag GlxContextTag, Light uint32, Pname uint32) GlxGetLightivCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetLightivRequest(ContextTag, Light, Pname), cookie)
	return GlxGetLightivCookie{cookie}
}

func (c *Conn) GlxGetLightivUnchecked(ContextTag GlxContextTag, Light uint32, Pname uint32) GlxGetLightivCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetLightivRequest(ContextTag, Light, Pname), cookie)
	return GlxGetLightivCookie{cookie}
}

// Request reply for GlxGetLightiv
// size: (32 + pad((int(N) * 4)))
type GlxGetLightivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetLightiv
func (cook GlxGetLightivCookie) Reply() (*GlxGetLightivReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetLightivReply(buf), nil
}

// Read reply into structure from buffer for GlxGetLightiv
func glxGetLightivReply(buf []byte) *GlxGetLightivReply {
	v := new(GlxGetLightivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetLightivCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetLightiv
func (c *Conn) glxGetLightivRequest(ContextTag GlxContextTag, Light uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 119 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Light)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetMapdv
// size: 16
type GlxGetMapdvCookie struct {
	*cookie
}

func (c *Conn) GlxGetMapdv(ContextTag GlxContextTag, Target uint32, Query uint32) GlxGetMapdvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetMapdvRequest(ContextTag, Target, Query), cookie)
	return GlxGetMapdvCookie{cookie}
}

func (c *Conn) GlxGetMapdvUnchecked(ContextTag GlxContextTag, Target uint32, Query uint32) GlxGetMapdvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetMapdvRequest(ContextTag, Target, Query), cookie)
	return GlxGetMapdvCookie{cookie}
}

// Request reply for GlxGetMapdv
// size: (32 + pad((int(N) * 8)))
type GlxGetMapdvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum GlxFloat64
	// padding: 8 bytes
	Data []GlxFloat64 // size: pad((int(N) * 8))
}

// Waits and reads reply data from request GlxGetMapdv
func (cook GlxGetMapdvCookie) Reply() (*GlxGetMapdvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetMapdvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetMapdv
func glxGetMapdvReply(buf []byte) *GlxGetMapdvReply {
	v := new(GlxGetMapdvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = GlxFloat64(Get64(buf[b:]))
	b += 8

	b += 8 // padding

	v.Data = make([]GlxFloat64, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = GlxFloat64(Get64(buf[b:]))
		b += 8
	}
	b = pad(b)

	return v
}

func (cook GlxGetMapdvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetMapdv
func (c *Conn) glxGetMapdvRequest(ContextTag GlxContextTag, Target uint32, Query uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 120 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Query)
	b += 4

	return buf
}

// Request GlxGetMapfv
// size: 16
type GlxGetMapfvCookie struct {
	*cookie
}

func (c *Conn) GlxGetMapfv(ContextTag GlxContextTag, Target uint32, Query uint32) GlxGetMapfvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetMapfvRequest(ContextTag, Target, Query), cookie)
	return GlxGetMapfvCookie{cookie}
}

func (c *Conn) GlxGetMapfvUnchecked(ContextTag GlxContextTag, Target uint32, Query uint32) GlxGetMapfvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetMapfvRequest(ContextTag, Target, Query), cookie)
	return GlxGetMapfvCookie{cookie}
}

// Request reply for GlxGetMapfv
// size: (32 + pad((int(N) * 4)))
type GlxGetMapfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum GlxFloat32
	// padding: 12 bytes
	Data []GlxFloat32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetMapfv
func (cook GlxGetMapfvCookie) Reply() (*GlxGetMapfvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetMapfvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetMapfv
func glxGetMapfvReply(buf []byte) *GlxGetMapfvReply {
	v := new(GlxGetMapfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = GlxFloat32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]GlxFloat32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = GlxFloat32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetMapfvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetMapfv
func (c *Conn) glxGetMapfvRequest(ContextTag GlxContextTag, Target uint32, Query uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 121 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Query)
	b += 4

	return buf
}

// Request GlxGetMapiv
// size: 16
type GlxGetMapivCookie struct {
	*cookie
}

func (c *Conn) GlxGetMapiv(ContextTag GlxContextTag, Target uint32, Query uint32) GlxGetMapivCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetMapivRequest(ContextTag, Target, Query), cookie)
	return GlxGetMapivCookie{cookie}
}

func (c *Conn) GlxGetMapivUnchecked(ContextTag GlxContextTag, Target uint32, Query uint32) GlxGetMapivCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetMapivRequest(ContextTag, Target, Query), cookie)
	return GlxGetMapivCookie{cookie}
}

// Request reply for GlxGetMapiv
// size: (32 + pad((int(N) * 4)))
type GlxGetMapivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetMapiv
func (cook GlxGetMapivCookie) Reply() (*GlxGetMapivReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetMapivReply(buf), nil
}

// Read reply into structure from buffer for GlxGetMapiv
func glxGetMapivReply(buf []byte) *GlxGetMapivReply {
	v := new(GlxGetMapivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetMapivCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetMapiv
func (c *Conn) glxGetMapivRequest(ContextTag GlxContextTag, Target uint32, Query uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 122 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Query)
	b += 4

	return buf
}

// Request GlxGetMaterialfv
// size: 16
type GlxGetMaterialfvCookie struct {
	*cookie
}

func (c *Conn) GlxGetMaterialfv(ContextTag GlxContextTag, Face uint32, Pname uint32) GlxGetMaterialfvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetMaterialfvRequest(ContextTag, Face, Pname), cookie)
	return GlxGetMaterialfvCookie{cookie}
}

func (c *Conn) GlxGetMaterialfvUnchecked(ContextTag GlxContextTag, Face uint32, Pname uint32) GlxGetMaterialfvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetMaterialfvRequest(ContextTag, Face, Pname), cookie)
	return GlxGetMaterialfvCookie{cookie}
}

// Request reply for GlxGetMaterialfv
// size: (32 + pad((int(N) * 4)))
type GlxGetMaterialfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum GlxFloat32
	// padding: 12 bytes
	Data []GlxFloat32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetMaterialfv
func (cook GlxGetMaterialfvCookie) Reply() (*GlxGetMaterialfvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetMaterialfvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetMaterialfv
func glxGetMaterialfvReply(buf []byte) *GlxGetMaterialfvReply {
	v := new(GlxGetMaterialfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = GlxFloat32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]GlxFloat32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = GlxFloat32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetMaterialfvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetMaterialfv
func (c *Conn) glxGetMaterialfvRequest(ContextTag GlxContextTag, Face uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 123 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Face)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetMaterialiv
// size: 16
type GlxGetMaterialivCookie struct {
	*cookie
}

func (c *Conn) GlxGetMaterialiv(ContextTag GlxContextTag, Face uint32, Pname uint32) GlxGetMaterialivCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetMaterialivRequest(ContextTag, Face, Pname), cookie)
	return GlxGetMaterialivCookie{cookie}
}

func (c *Conn) GlxGetMaterialivUnchecked(ContextTag GlxContextTag, Face uint32, Pname uint32) GlxGetMaterialivCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetMaterialivRequest(ContextTag, Face, Pname), cookie)
	return GlxGetMaterialivCookie{cookie}
}

// Request reply for GlxGetMaterialiv
// size: (32 + pad((int(N) * 4)))
type GlxGetMaterialivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetMaterialiv
func (cook GlxGetMaterialivCookie) Reply() (*GlxGetMaterialivReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetMaterialivReply(buf), nil
}

// Read reply into structure from buffer for GlxGetMaterialiv
func glxGetMaterialivReply(buf []byte) *GlxGetMaterialivReply {
	v := new(GlxGetMaterialivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetMaterialivCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetMaterialiv
func (c *Conn) glxGetMaterialivRequest(ContextTag GlxContextTag, Face uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 124 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Face)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetPixelMapfv
// size: 12
type GlxGetPixelMapfvCookie struct {
	*cookie
}

func (c *Conn) GlxGetPixelMapfv(ContextTag GlxContextTag, Map uint32) GlxGetPixelMapfvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetPixelMapfvRequest(ContextTag, Map), cookie)
	return GlxGetPixelMapfvCookie{cookie}
}

func (c *Conn) GlxGetPixelMapfvUnchecked(ContextTag GlxContextTag, Map uint32) GlxGetPixelMapfvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetPixelMapfvRequest(ContextTag, Map), cookie)
	return GlxGetPixelMapfvCookie{cookie}
}

// Request reply for GlxGetPixelMapfv
// size: (32 + pad((int(N) * 4)))
type GlxGetPixelMapfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum GlxFloat32
	// padding: 12 bytes
	Data []GlxFloat32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetPixelMapfv
func (cook GlxGetPixelMapfvCookie) Reply() (*GlxGetPixelMapfvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetPixelMapfvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetPixelMapfv
func glxGetPixelMapfvReply(buf []byte) *GlxGetPixelMapfvReply {
	v := new(GlxGetPixelMapfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = GlxFloat32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]GlxFloat32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = GlxFloat32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetPixelMapfvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetPixelMapfv
func (c *Conn) glxGetPixelMapfvRequest(ContextTag GlxContextTag, Map uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 125 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Map)
	b += 4

	return buf
}

// Request GlxGetPixelMapuiv
// size: 12
type GlxGetPixelMapuivCookie struct {
	*cookie
}

func (c *Conn) GlxGetPixelMapuiv(ContextTag GlxContextTag, Map uint32) GlxGetPixelMapuivCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetPixelMapuivRequest(ContextTag, Map), cookie)
	return GlxGetPixelMapuivCookie{cookie}
}

func (c *Conn) GlxGetPixelMapuivUnchecked(ContextTag GlxContextTag, Map uint32) GlxGetPixelMapuivCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetPixelMapuivRequest(ContextTag, Map), cookie)
	return GlxGetPixelMapuivCookie{cookie}
}

// Request reply for GlxGetPixelMapuiv
// size: (32 + pad((int(N) * 4)))
type GlxGetPixelMapuivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum uint32
	// padding: 12 bytes
	Data []uint32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetPixelMapuiv
func (cook GlxGetPixelMapuivCookie) Reply() (*GlxGetPixelMapuivReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetPixelMapuivReply(buf), nil
}

// Read reply into structure from buffer for GlxGetPixelMapuiv
func glxGetPixelMapuivReply(buf []byte) *GlxGetPixelMapuivReply {
	v := new(GlxGetPixelMapuivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = Get32(buf[b:])
	b += 4

	b += 12 // padding

	v.Data = make([]uint32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetPixelMapuivCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetPixelMapuiv
func (c *Conn) glxGetPixelMapuivRequest(ContextTag GlxContextTag, Map uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 126 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Map)
	b += 4

	return buf
}

// Request GlxGetPixelMapusv
// size: 12
type GlxGetPixelMapusvCookie struct {
	*cookie
}

func (c *Conn) GlxGetPixelMapusv(ContextTag GlxContextTag, Map uint32) GlxGetPixelMapusvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetPixelMapusvRequest(ContextTag, Map), cookie)
	return GlxGetPixelMapusvCookie{cookie}
}

func (c *Conn) GlxGetPixelMapusvUnchecked(ContextTag GlxContextTag, Map uint32) GlxGetPixelMapusvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetPixelMapusvRequest(ContextTag, Map), cookie)
	return GlxGetPixelMapusvCookie{cookie}
}

// Request reply for GlxGetPixelMapusv
// size: (34 + pad((int(N) * 2)))
type GlxGetPixelMapusvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum uint16
	// padding: 16 bytes
	Data []uint16 // size: pad((int(N) * 2))
}

// Waits and reads reply data from request GlxGetPixelMapusv
func (cook GlxGetPixelMapusvCookie) Reply() (*GlxGetPixelMapusvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetPixelMapusvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetPixelMapusv
func glxGetPixelMapusvReply(buf []byte) *GlxGetPixelMapusvReply {
	v := new(GlxGetPixelMapusvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = Get16(buf[b:])
	b += 2

	b += 16 // padding

	v.Data = make([]uint16, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Get16(buf[b:])
		b += 2
	}
	b = pad(b)

	return v
}

func (cook GlxGetPixelMapusvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetPixelMapusv
func (c *Conn) glxGetPixelMapusvRequest(ContextTag GlxContextTag, Map uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 127 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Map)
	b += 4

	return buf
}

// Request GlxGetPolygonStipple
// size: 12
type GlxGetPolygonStippleCookie struct {
	*cookie
}

func (c *Conn) GlxGetPolygonStipple(ContextTag GlxContextTag, LsbFirst bool) GlxGetPolygonStippleCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetPolygonStippleRequest(ContextTag, LsbFirst), cookie)
	return GlxGetPolygonStippleCookie{cookie}
}

func (c *Conn) GlxGetPolygonStippleUnchecked(ContextTag GlxContextTag, LsbFirst bool) GlxGetPolygonStippleCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetPolygonStippleRequest(ContextTag, LsbFirst), cookie)
	return GlxGetPolygonStippleCookie{cookie}
}

// Request reply for GlxGetPolygonStipple
// size: (32 + pad(((int(Length) * 4) * 1)))
type GlxGetPolygonStippleReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
	Data []byte // size: pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GlxGetPolygonStipple
func (cook GlxGetPolygonStippleCookie) Reply() (*GlxGetPolygonStippleReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetPolygonStippleReply(buf), nil
}

// Read reply into structure from buffer for GlxGetPolygonStipple
func glxGetPolygonStippleReply(buf []byte) *GlxGetPolygonStippleReply {
	v := new(GlxGetPolygonStippleReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += pad(int((int(v.Length) * 4)))

	return v
}

func (cook GlxGetPolygonStippleCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetPolygonStipple
func (c *Conn) glxGetPolygonStippleRequest(ContextTag GlxContextTag, LsbFirst bool) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 128 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	if LsbFirst {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GlxGetString
// size: 12
type GlxGetStringCookie struct {
	*cookie
}

func (c *Conn) GlxGetString(ContextTag GlxContextTag, Name uint32) GlxGetStringCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetStringRequest(ContextTag, Name), cookie)
	return GlxGetStringCookie{cookie}
}

func (c *Conn) GlxGetStringUnchecked(ContextTag GlxContextTag, Name uint32) GlxGetStringCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetStringRequest(ContextTag, Name), cookie)
	return GlxGetStringCookie{cookie}
}

// Request reply for GlxGetString
// size: (32 + pad((int(N) * 1)))
type GlxGetStringReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N uint32
	// padding: 16 bytes
	String string // size: pad((int(N) * 1))
}

// Waits and reads reply data from request GlxGetString
func (cook GlxGetStringCookie) Reply() (*GlxGetStringReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetStringReply(buf), nil
}

// Read reply into structure from buffer for GlxGetString
func glxGetStringReply(buf []byte) *GlxGetStringReply {
	v := new(GlxGetStringReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	b += 16 // padding

	{
		byteString := make([]byte, v.N)
		copy(byteString[:v.N], buf[b:])
		v.String = string(byteString)
		b += pad(int(v.N))
	}

	return v
}

func (cook GlxGetStringCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetString
func (c *Conn) glxGetStringRequest(ContextTag GlxContextTag, Name uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 129 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Name)
	b += 4

	return buf
}

// Request GlxGetTexEnvfv
// size: 16
type GlxGetTexEnvfvCookie struct {
	*cookie
}

func (c *Conn) GlxGetTexEnvfv(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetTexEnvfvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetTexEnvfvRequest(ContextTag, Target, Pname), cookie)
	return GlxGetTexEnvfvCookie{cookie}
}

func (c *Conn) GlxGetTexEnvfvUnchecked(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetTexEnvfvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetTexEnvfvRequest(ContextTag, Target, Pname), cookie)
	return GlxGetTexEnvfvCookie{cookie}
}

// Request reply for GlxGetTexEnvfv
// size: (32 + pad((int(N) * 4)))
type GlxGetTexEnvfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum GlxFloat32
	// padding: 12 bytes
	Data []GlxFloat32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetTexEnvfv
func (cook GlxGetTexEnvfvCookie) Reply() (*GlxGetTexEnvfvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetTexEnvfvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetTexEnvfv
func glxGetTexEnvfvReply(buf []byte) *GlxGetTexEnvfvReply {
	v := new(GlxGetTexEnvfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = GlxFloat32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]GlxFloat32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = GlxFloat32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetTexEnvfvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetTexEnvfv
func (c *Conn) glxGetTexEnvfvRequest(ContextTag GlxContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 130 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetTexEnviv
// size: 16
type GlxGetTexEnvivCookie struct {
	*cookie
}

func (c *Conn) GlxGetTexEnviv(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetTexEnvivCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetTexEnvivRequest(ContextTag, Target, Pname), cookie)
	return GlxGetTexEnvivCookie{cookie}
}

func (c *Conn) GlxGetTexEnvivUnchecked(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetTexEnvivCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetTexEnvivRequest(ContextTag, Target, Pname), cookie)
	return GlxGetTexEnvivCookie{cookie}
}

// Request reply for GlxGetTexEnviv
// size: (32 + pad((int(N) * 4)))
type GlxGetTexEnvivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetTexEnviv
func (cook GlxGetTexEnvivCookie) Reply() (*GlxGetTexEnvivReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetTexEnvivReply(buf), nil
}

// Read reply into structure from buffer for GlxGetTexEnviv
func glxGetTexEnvivReply(buf []byte) *GlxGetTexEnvivReply {
	v := new(GlxGetTexEnvivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetTexEnvivCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetTexEnviv
func (c *Conn) glxGetTexEnvivRequest(ContextTag GlxContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 131 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetTexGendv
// size: 16
type GlxGetTexGendvCookie struct {
	*cookie
}

func (c *Conn) GlxGetTexGendv(ContextTag GlxContextTag, Coord uint32, Pname uint32) GlxGetTexGendvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetTexGendvRequest(ContextTag, Coord, Pname), cookie)
	return GlxGetTexGendvCookie{cookie}
}

func (c *Conn) GlxGetTexGendvUnchecked(ContextTag GlxContextTag, Coord uint32, Pname uint32) GlxGetTexGendvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetTexGendvRequest(ContextTag, Coord, Pname), cookie)
	return GlxGetTexGendvCookie{cookie}
}

// Request reply for GlxGetTexGendv
// size: (32 + pad((int(N) * 8)))
type GlxGetTexGendvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum GlxFloat64
	// padding: 8 bytes
	Data []GlxFloat64 // size: pad((int(N) * 8))
}

// Waits and reads reply data from request GlxGetTexGendv
func (cook GlxGetTexGendvCookie) Reply() (*GlxGetTexGendvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetTexGendvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetTexGendv
func glxGetTexGendvReply(buf []byte) *GlxGetTexGendvReply {
	v := new(GlxGetTexGendvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = GlxFloat64(Get64(buf[b:]))
	b += 8

	b += 8 // padding

	v.Data = make([]GlxFloat64, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = GlxFloat64(Get64(buf[b:]))
		b += 8
	}
	b = pad(b)

	return v
}

func (cook GlxGetTexGendvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetTexGendv
func (c *Conn) glxGetTexGendvRequest(ContextTag GlxContextTag, Coord uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 132 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Coord)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetTexGenfv
// size: 16
type GlxGetTexGenfvCookie struct {
	*cookie
}

func (c *Conn) GlxGetTexGenfv(ContextTag GlxContextTag, Coord uint32, Pname uint32) GlxGetTexGenfvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetTexGenfvRequest(ContextTag, Coord, Pname), cookie)
	return GlxGetTexGenfvCookie{cookie}
}

func (c *Conn) GlxGetTexGenfvUnchecked(ContextTag GlxContextTag, Coord uint32, Pname uint32) GlxGetTexGenfvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetTexGenfvRequest(ContextTag, Coord, Pname), cookie)
	return GlxGetTexGenfvCookie{cookie}
}

// Request reply for GlxGetTexGenfv
// size: (32 + pad((int(N) * 4)))
type GlxGetTexGenfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum GlxFloat32
	// padding: 12 bytes
	Data []GlxFloat32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetTexGenfv
func (cook GlxGetTexGenfvCookie) Reply() (*GlxGetTexGenfvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetTexGenfvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetTexGenfv
func glxGetTexGenfvReply(buf []byte) *GlxGetTexGenfvReply {
	v := new(GlxGetTexGenfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = GlxFloat32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]GlxFloat32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = GlxFloat32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetTexGenfvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetTexGenfv
func (c *Conn) glxGetTexGenfvRequest(ContextTag GlxContextTag, Coord uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 133 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Coord)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetTexGeniv
// size: 16
type GlxGetTexGenivCookie struct {
	*cookie
}

func (c *Conn) GlxGetTexGeniv(ContextTag GlxContextTag, Coord uint32, Pname uint32) GlxGetTexGenivCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetTexGenivRequest(ContextTag, Coord, Pname), cookie)
	return GlxGetTexGenivCookie{cookie}
}

func (c *Conn) GlxGetTexGenivUnchecked(ContextTag GlxContextTag, Coord uint32, Pname uint32) GlxGetTexGenivCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetTexGenivRequest(ContextTag, Coord, Pname), cookie)
	return GlxGetTexGenivCookie{cookie}
}

// Request reply for GlxGetTexGeniv
// size: (32 + pad((int(N) * 4)))
type GlxGetTexGenivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetTexGeniv
func (cook GlxGetTexGenivCookie) Reply() (*GlxGetTexGenivReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetTexGenivReply(buf), nil
}

// Read reply into structure from buffer for GlxGetTexGeniv
func glxGetTexGenivReply(buf []byte) *GlxGetTexGenivReply {
	v := new(GlxGetTexGenivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetTexGenivCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetTexGeniv
func (c *Conn) glxGetTexGenivRequest(ContextTag GlxContextTag, Coord uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 134 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Coord)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetTexImage
// size: 28
type GlxGetTexImageCookie struct {
	*cookie
}

func (c *Conn) GlxGetTexImage(ContextTag GlxContextTag, Target uint32, Level int32, Format uint32, Type uint32, SwapBytes bool) GlxGetTexImageCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetTexImageRequest(ContextTag, Target, Level, Format, Type, SwapBytes), cookie)
	return GlxGetTexImageCookie{cookie}
}

func (c *Conn) GlxGetTexImageUnchecked(ContextTag GlxContextTag, Target uint32, Level int32, Format uint32, Type uint32, SwapBytes bool) GlxGetTexImageCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetTexImageRequest(ContextTag, Target, Level, Format, Type, SwapBytes), cookie)
	return GlxGetTexImageCookie{cookie}
}

// Request reply for GlxGetTexImage
// size: (32 + pad(((int(Length) * 4) * 1)))
type GlxGetTexImageReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 8 bytes
	Width  int32
	Height int32
	Depth  int32
	// padding: 4 bytes
	Data []byte // size: pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GlxGetTexImage
func (cook GlxGetTexImageCookie) Reply() (*GlxGetTexImageReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetTexImageReply(buf), nil
}

// Read reply into structure from buffer for GlxGetTexImage
func glxGetTexImageReply(buf []byte) *GlxGetTexImageReply {
	v := new(GlxGetTexImageReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 8 // padding

	v.Width = int32(Get32(buf[b:]))
	b += 4

	v.Height = int32(Get32(buf[b:]))
	b += 4

	v.Depth = int32(Get32(buf[b:]))
	b += 4

	b += 4 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += pad(int((int(v.Length) * 4)))

	return v
}

func (cook GlxGetTexImageCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetTexImage
func (c *Conn) glxGetTexImageRequest(ContextTag GlxContextTag, Target uint32, Level int32, Format uint32, Type uint32, SwapBytes bool) []byte {
	size := 28
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 135 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], uint32(Level))
	b += 4

	Put32(buf[b:], Format)
	b += 4

	Put32(buf[b:], Type)
	b += 4

	if SwapBytes {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GlxGetTexParameterfv
// size: 16
type GlxGetTexParameterfvCookie struct {
	*cookie
}

func (c *Conn) GlxGetTexParameterfv(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetTexParameterfvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetTexParameterfvRequest(ContextTag, Target, Pname), cookie)
	return GlxGetTexParameterfvCookie{cookie}
}

func (c *Conn) GlxGetTexParameterfvUnchecked(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetTexParameterfvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetTexParameterfvRequest(ContextTag, Target, Pname), cookie)
	return GlxGetTexParameterfvCookie{cookie}
}

// Request reply for GlxGetTexParameterfv
// size: (32 + pad((int(N) * 4)))
type GlxGetTexParameterfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum GlxFloat32
	// padding: 12 bytes
	Data []GlxFloat32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetTexParameterfv
func (cook GlxGetTexParameterfvCookie) Reply() (*GlxGetTexParameterfvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetTexParameterfvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetTexParameterfv
func glxGetTexParameterfvReply(buf []byte) *GlxGetTexParameterfvReply {
	v := new(GlxGetTexParameterfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = GlxFloat32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]GlxFloat32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = GlxFloat32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetTexParameterfvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetTexParameterfv
func (c *Conn) glxGetTexParameterfvRequest(ContextTag GlxContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 136 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetTexParameteriv
// size: 16
type GlxGetTexParameterivCookie struct {
	*cookie
}

func (c *Conn) GlxGetTexParameteriv(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetTexParameterivCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetTexParameterivRequest(ContextTag, Target, Pname), cookie)
	return GlxGetTexParameterivCookie{cookie}
}

func (c *Conn) GlxGetTexParameterivUnchecked(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetTexParameterivCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetTexParameterivRequest(ContextTag, Target, Pname), cookie)
	return GlxGetTexParameterivCookie{cookie}
}

// Request reply for GlxGetTexParameteriv
// size: (32 + pad((int(N) * 4)))
type GlxGetTexParameterivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetTexParameteriv
func (cook GlxGetTexParameterivCookie) Reply() (*GlxGetTexParameterivReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetTexParameterivReply(buf), nil
}

// Read reply into structure from buffer for GlxGetTexParameteriv
func glxGetTexParameterivReply(buf []byte) *GlxGetTexParameterivReply {
	v := new(GlxGetTexParameterivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetTexParameterivCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetTexParameteriv
func (c *Conn) glxGetTexParameterivRequest(ContextTag GlxContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 137 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetTexLevelParameterfv
// size: 20
type GlxGetTexLevelParameterfvCookie struct {
	*cookie
}

func (c *Conn) GlxGetTexLevelParameterfv(ContextTag GlxContextTag, Target uint32, Level int32, Pname uint32) GlxGetTexLevelParameterfvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetTexLevelParameterfvRequest(ContextTag, Target, Level, Pname), cookie)
	return GlxGetTexLevelParameterfvCookie{cookie}
}

func (c *Conn) GlxGetTexLevelParameterfvUnchecked(ContextTag GlxContextTag, Target uint32, Level int32, Pname uint32) GlxGetTexLevelParameterfvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetTexLevelParameterfvRequest(ContextTag, Target, Level, Pname), cookie)
	return GlxGetTexLevelParameterfvCookie{cookie}
}

// Request reply for GlxGetTexLevelParameterfv
// size: (32 + pad((int(N) * 4)))
type GlxGetTexLevelParameterfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum GlxFloat32
	// padding: 12 bytes
	Data []GlxFloat32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetTexLevelParameterfv
func (cook GlxGetTexLevelParameterfvCookie) Reply() (*GlxGetTexLevelParameterfvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetTexLevelParameterfvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetTexLevelParameterfv
func glxGetTexLevelParameterfvReply(buf []byte) *GlxGetTexLevelParameterfvReply {
	v := new(GlxGetTexLevelParameterfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = GlxFloat32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]GlxFloat32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = GlxFloat32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetTexLevelParameterfvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetTexLevelParameterfv
func (c *Conn) glxGetTexLevelParameterfvRequest(ContextTag GlxContextTag, Target uint32, Level int32, Pname uint32) []byte {
	size := 20
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 138 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], uint32(Level))
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetTexLevelParameteriv
// size: 20
type GlxGetTexLevelParameterivCookie struct {
	*cookie
}

func (c *Conn) GlxGetTexLevelParameteriv(ContextTag GlxContextTag, Target uint32, Level int32, Pname uint32) GlxGetTexLevelParameterivCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetTexLevelParameterivRequest(ContextTag, Target, Level, Pname), cookie)
	return GlxGetTexLevelParameterivCookie{cookie}
}

func (c *Conn) GlxGetTexLevelParameterivUnchecked(ContextTag GlxContextTag, Target uint32, Level int32, Pname uint32) GlxGetTexLevelParameterivCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetTexLevelParameterivRequest(ContextTag, Target, Level, Pname), cookie)
	return GlxGetTexLevelParameterivCookie{cookie}
}

// Request reply for GlxGetTexLevelParameteriv
// size: (32 + pad((int(N) * 4)))
type GlxGetTexLevelParameterivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetTexLevelParameteriv
func (cook GlxGetTexLevelParameterivCookie) Reply() (*GlxGetTexLevelParameterivReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetTexLevelParameterivReply(buf), nil
}

// Read reply into structure from buffer for GlxGetTexLevelParameteriv
func glxGetTexLevelParameterivReply(buf []byte) *GlxGetTexLevelParameterivReply {
	v := new(GlxGetTexLevelParameterivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetTexLevelParameterivCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetTexLevelParameteriv
func (c *Conn) glxGetTexLevelParameterivRequest(ContextTag GlxContextTag, Target uint32, Level int32, Pname uint32) []byte {
	size := 20
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 139 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], uint32(Level))
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxIsList
// size: 12
type GlxIsListCookie struct {
	*cookie
}

func (c *Conn) GlxIsList(ContextTag GlxContextTag, List uint32) GlxIsListCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxIsListRequest(ContextTag, List), cookie)
	return GlxIsListCookie{cookie}
}

func (c *Conn) GlxIsListUnchecked(ContextTag GlxContextTag, List uint32) GlxIsListCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxIsListRequest(ContextTag, List), cookie)
	return GlxIsListCookie{cookie}
}

// Request reply for GlxIsList
// size: 12
type GlxIsListReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	RetVal GlxBool32
}

// Waits and reads reply data from request GlxIsList
func (cook GlxIsListCookie) Reply() (*GlxIsListReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxIsListReply(buf), nil
}

// Read reply into structure from buffer for GlxIsList
func glxIsListReply(buf []byte) *GlxIsListReply {
	v := new(GlxIsListReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.RetVal = GlxBool32(Get32(buf[b:]))
	b += 4

	return v
}

func (cook GlxIsListCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxIsList
func (c *Conn) glxIsListRequest(ContextTag GlxContextTag, List uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 141 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], List)
	b += 4

	return buf
}

// Request GlxFlush
// size: 8
type GlxFlushCookie struct {
	*cookie
}

// Write request to wire for GlxFlush
func (c *Conn) GlxFlush(ContextTag GlxContextTag) GlxFlushCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxFlushRequest(ContextTag), cookie)
	return GlxFlushCookie{cookie}
}

func (c *Conn) GlxFlushChecked(ContextTag GlxContextTag) GlxFlushCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxFlushRequest(ContextTag), cookie)
	return GlxFlushCookie{cookie}
}

func (cook GlxFlushCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxFlush
func (c *Conn) glxFlushRequest(ContextTag GlxContextTag) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 142 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	return buf
}

// Request GlxAreTexturesResident
// size: pad((12 + pad((int(N) * 4))))
type GlxAreTexturesResidentCookie struct {
	*cookie
}

func (c *Conn) GlxAreTexturesResident(ContextTag GlxContextTag, N int32, Textures []uint32) GlxAreTexturesResidentCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxAreTexturesResidentRequest(ContextTag, N, Textures), cookie)
	return GlxAreTexturesResidentCookie{cookie}
}

func (c *Conn) GlxAreTexturesResidentUnchecked(ContextTag GlxContextTag, N int32, Textures []uint32) GlxAreTexturesResidentCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxAreTexturesResidentRequest(ContextTag, N, Textures), cookie)
	return GlxAreTexturesResidentCookie{cookie}
}

// Request reply for GlxAreTexturesResident
// size: (32 + pad(((int(Length) * 4) * 1)))
type GlxAreTexturesResidentReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	RetVal GlxBool32
	// padding: 20 bytes
	Data []bool // size: pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GlxAreTexturesResident
func (cook GlxAreTexturesResidentCookie) Reply() (*GlxAreTexturesResidentReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxAreTexturesResidentReply(buf), nil
}

// Read reply into structure from buffer for GlxAreTexturesResident
func glxAreTexturesResidentReply(buf []byte) *GlxAreTexturesResidentReply {
	v := new(GlxAreTexturesResidentReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.RetVal = GlxBool32(Get32(buf[b:]))
	b += 4

	b += 20 // padding

	v.Data = make([]bool, (int(v.Length) * 4))
	for i := 0; i < int((int(v.Length) * 4)); i++ {
		if buf[b] == 1 {
			v.Data[i] = true
		} else {
			v.Data[i] = false
		}
		b += 1
	}
	b = pad(b)

	return v
}

func (cook GlxAreTexturesResidentCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxAreTexturesResident
func (c *Conn) glxAreTexturesResidentRequest(ContextTag GlxContextTag, N int32, Textures []uint32) []byte {
	size := pad((12 + pad((int(N) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 143 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], uint32(N))
	b += 4

	for i := 0; i < int(N); i++ {
		Put32(buf[b:], Textures[i])
		b += 4
	}
	b = pad(b)

	return buf
}

// Request GlxDeleteTextures
// size: pad((12 + pad((int(N) * 4))))
type GlxDeleteTexturesCookie struct {
	*cookie
}

// Write request to wire for GlxDeleteTextures
func (c *Conn) GlxDeleteTextures(ContextTag GlxContextTag, N int32, Textures []uint32) GlxDeleteTexturesCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxDeleteTexturesRequest(ContextTag, N, Textures), cookie)
	return GlxDeleteTexturesCookie{cookie}
}

func (c *Conn) GlxDeleteTexturesChecked(ContextTag GlxContextTag, N int32, Textures []uint32) GlxDeleteTexturesCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxDeleteTexturesRequest(ContextTag, N, Textures), cookie)
	return GlxDeleteTexturesCookie{cookie}
}

func (cook GlxDeleteTexturesCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxDeleteTextures
func (c *Conn) glxDeleteTexturesRequest(ContextTag GlxContextTag, N int32, Textures []uint32) []byte {
	size := pad((12 + pad((int(N) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 144 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], uint32(N))
	b += 4

	for i := 0; i < int(N); i++ {
		Put32(buf[b:], Textures[i])
		b += 4
	}
	b = pad(b)

	return buf
}

// Request GlxGenTextures
// size: 12
type GlxGenTexturesCookie struct {
	*cookie
}

func (c *Conn) GlxGenTextures(ContextTag GlxContextTag, N int32) GlxGenTexturesCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGenTexturesRequest(ContextTag, N), cookie)
	return GlxGenTexturesCookie{cookie}
}

func (c *Conn) GlxGenTexturesUnchecked(ContextTag GlxContextTag, N int32) GlxGenTexturesCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGenTexturesRequest(ContextTag, N), cookie)
	return GlxGenTexturesCookie{cookie}
}

// Request reply for GlxGenTextures
// size: (32 + pad((int(Length) * 4)))
type GlxGenTexturesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
	Data []uint32 // size: pad((int(Length) * 4))
}

// Waits and reads reply data from request GlxGenTextures
func (cook GlxGenTexturesCookie) Reply() (*GlxGenTexturesReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGenTexturesReply(buf), nil
}

// Read reply into structure from buffer for GlxGenTextures
func glxGenTexturesReply(buf []byte) *GlxGenTexturesReply {
	v := new(GlxGenTexturesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.Data = make([]uint32, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.Data[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGenTexturesCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGenTextures
func (c *Conn) glxGenTexturesRequest(ContextTag GlxContextTag, N int32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 145 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], uint32(N))
	b += 4

	return buf
}

// Request GlxIsTexture
// size: 12
type GlxIsTextureCookie struct {
	*cookie
}

func (c *Conn) GlxIsTexture(ContextTag GlxContextTag, Texture uint32) GlxIsTextureCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxIsTextureRequest(ContextTag, Texture), cookie)
	return GlxIsTextureCookie{cookie}
}

func (c *Conn) GlxIsTextureUnchecked(ContextTag GlxContextTag, Texture uint32) GlxIsTextureCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxIsTextureRequest(ContextTag, Texture), cookie)
	return GlxIsTextureCookie{cookie}
}

// Request reply for GlxIsTexture
// size: 12
type GlxIsTextureReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	RetVal GlxBool32
}

// Waits and reads reply data from request GlxIsTexture
func (cook GlxIsTextureCookie) Reply() (*GlxIsTextureReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxIsTextureReply(buf), nil
}

// Read reply into structure from buffer for GlxIsTexture
func glxIsTextureReply(buf []byte) *GlxIsTextureReply {
	v := new(GlxIsTextureReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.RetVal = GlxBool32(Get32(buf[b:]))
	b += 4

	return v
}

func (cook GlxIsTextureCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxIsTexture
func (c *Conn) glxIsTextureRequest(ContextTag GlxContextTag, Texture uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 146 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Texture)
	b += 4

	return buf
}

// Request GlxGetColorTable
// size: 24
type GlxGetColorTableCookie struct {
	*cookie
}

func (c *Conn) GlxGetColorTable(ContextTag GlxContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) GlxGetColorTableCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetColorTableRequest(ContextTag, Target, Format, Type, SwapBytes), cookie)
	return GlxGetColorTableCookie{cookie}
}

func (c *Conn) GlxGetColorTableUnchecked(ContextTag GlxContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) GlxGetColorTableCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetColorTableRequest(ContextTag, Target, Format, Type, SwapBytes), cookie)
	return GlxGetColorTableCookie{cookie}
}

// Request reply for GlxGetColorTable
// size: (32 + pad(((int(Length) * 4) * 1)))
type GlxGetColorTableReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 8 bytes
	Width int32
	// padding: 12 bytes
	Data []byte // size: pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GlxGetColorTable
func (cook GlxGetColorTableCookie) Reply() (*GlxGetColorTableReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetColorTableReply(buf), nil
}

// Read reply into structure from buffer for GlxGetColorTable
func glxGetColorTableReply(buf []byte) *GlxGetColorTableReply {
	v := new(GlxGetColorTableReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 8 // padding

	v.Width = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += pad(int((int(v.Length) * 4)))

	return v
}

func (cook GlxGetColorTableCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetColorTable
func (c *Conn) glxGetColorTableRequest(ContextTag GlxContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 147 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Format)
	b += 4

	Put32(buf[b:], Type)
	b += 4

	if SwapBytes {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GlxGetColorTableParameterfv
// size: 16
type GlxGetColorTableParameterfvCookie struct {
	*cookie
}

func (c *Conn) GlxGetColorTableParameterfv(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetColorTableParameterfvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetColorTableParameterfvRequest(ContextTag, Target, Pname), cookie)
	return GlxGetColorTableParameterfvCookie{cookie}
}

func (c *Conn) GlxGetColorTableParameterfvUnchecked(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetColorTableParameterfvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetColorTableParameterfvRequest(ContextTag, Target, Pname), cookie)
	return GlxGetColorTableParameterfvCookie{cookie}
}

// Request reply for GlxGetColorTableParameterfv
// size: (32 + pad((int(N) * 4)))
type GlxGetColorTableParameterfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum GlxFloat32
	// padding: 12 bytes
	Data []GlxFloat32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetColorTableParameterfv
func (cook GlxGetColorTableParameterfvCookie) Reply() (*GlxGetColorTableParameterfvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetColorTableParameterfvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetColorTableParameterfv
func glxGetColorTableParameterfvReply(buf []byte) *GlxGetColorTableParameterfvReply {
	v := new(GlxGetColorTableParameterfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = GlxFloat32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]GlxFloat32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = GlxFloat32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetColorTableParameterfvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetColorTableParameterfv
func (c *Conn) glxGetColorTableParameterfvRequest(ContextTag GlxContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 148 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetColorTableParameteriv
// size: 16
type GlxGetColorTableParameterivCookie struct {
	*cookie
}

func (c *Conn) GlxGetColorTableParameteriv(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetColorTableParameterivCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetColorTableParameterivRequest(ContextTag, Target, Pname), cookie)
	return GlxGetColorTableParameterivCookie{cookie}
}

func (c *Conn) GlxGetColorTableParameterivUnchecked(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetColorTableParameterivCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetColorTableParameterivRequest(ContextTag, Target, Pname), cookie)
	return GlxGetColorTableParameterivCookie{cookie}
}

// Request reply for GlxGetColorTableParameteriv
// size: (32 + pad((int(N) * 4)))
type GlxGetColorTableParameterivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetColorTableParameteriv
func (cook GlxGetColorTableParameterivCookie) Reply() (*GlxGetColorTableParameterivReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetColorTableParameterivReply(buf), nil
}

// Read reply into structure from buffer for GlxGetColorTableParameteriv
func glxGetColorTableParameterivReply(buf []byte) *GlxGetColorTableParameterivReply {
	v := new(GlxGetColorTableParameterivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetColorTableParameterivCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetColorTableParameteriv
func (c *Conn) glxGetColorTableParameterivRequest(ContextTag GlxContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 149 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetConvolutionFilter
// size: 24
type GlxGetConvolutionFilterCookie struct {
	*cookie
}

func (c *Conn) GlxGetConvolutionFilter(ContextTag GlxContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) GlxGetConvolutionFilterCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetConvolutionFilterRequest(ContextTag, Target, Format, Type, SwapBytes), cookie)
	return GlxGetConvolutionFilterCookie{cookie}
}

func (c *Conn) GlxGetConvolutionFilterUnchecked(ContextTag GlxContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) GlxGetConvolutionFilterCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetConvolutionFilterRequest(ContextTag, Target, Format, Type, SwapBytes), cookie)
	return GlxGetConvolutionFilterCookie{cookie}
}

// Request reply for GlxGetConvolutionFilter
// size: (32 + pad(((int(Length) * 4) * 1)))
type GlxGetConvolutionFilterReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 8 bytes
	Width  int32
	Height int32
	// padding: 8 bytes
	Data []byte // size: pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GlxGetConvolutionFilter
func (cook GlxGetConvolutionFilterCookie) Reply() (*GlxGetConvolutionFilterReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetConvolutionFilterReply(buf), nil
}

// Read reply into structure from buffer for GlxGetConvolutionFilter
func glxGetConvolutionFilterReply(buf []byte) *GlxGetConvolutionFilterReply {
	v := new(GlxGetConvolutionFilterReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 8 // padding

	v.Width = int32(Get32(buf[b:]))
	b += 4

	v.Height = int32(Get32(buf[b:]))
	b += 4

	b += 8 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += pad(int((int(v.Length) * 4)))

	return v
}

func (cook GlxGetConvolutionFilterCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetConvolutionFilter
func (c *Conn) glxGetConvolutionFilterRequest(ContextTag GlxContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 150 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Format)
	b += 4

	Put32(buf[b:], Type)
	b += 4

	if SwapBytes {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GlxGetConvolutionParameterfv
// size: 16
type GlxGetConvolutionParameterfvCookie struct {
	*cookie
}

func (c *Conn) GlxGetConvolutionParameterfv(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetConvolutionParameterfvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetConvolutionParameterfvRequest(ContextTag, Target, Pname), cookie)
	return GlxGetConvolutionParameterfvCookie{cookie}
}

func (c *Conn) GlxGetConvolutionParameterfvUnchecked(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetConvolutionParameterfvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetConvolutionParameterfvRequest(ContextTag, Target, Pname), cookie)
	return GlxGetConvolutionParameterfvCookie{cookie}
}

// Request reply for GlxGetConvolutionParameterfv
// size: (32 + pad((int(N) * 4)))
type GlxGetConvolutionParameterfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum GlxFloat32
	// padding: 12 bytes
	Data []GlxFloat32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetConvolutionParameterfv
func (cook GlxGetConvolutionParameterfvCookie) Reply() (*GlxGetConvolutionParameterfvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetConvolutionParameterfvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetConvolutionParameterfv
func glxGetConvolutionParameterfvReply(buf []byte) *GlxGetConvolutionParameterfvReply {
	v := new(GlxGetConvolutionParameterfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = GlxFloat32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]GlxFloat32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = GlxFloat32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetConvolutionParameterfvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetConvolutionParameterfv
func (c *Conn) glxGetConvolutionParameterfvRequest(ContextTag GlxContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 151 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetConvolutionParameteriv
// size: 16
type GlxGetConvolutionParameterivCookie struct {
	*cookie
}

func (c *Conn) GlxGetConvolutionParameteriv(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetConvolutionParameterivCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetConvolutionParameterivRequest(ContextTag, Target, Pname), cookie)
	return GlxGetConvolutionParameterivCookie{cookie}
}

func (c *Conn) GlxGetConvolutionParameterivUnchecked(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetConvolutionParameterivCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetConvolutionParameterivRequest(ContextTag, Target, Pname), cookie)
	return GlxGetConvolutionParameterivCookie{cookie}
}

// Request reply for GlxGetConvolutionParameteriv
// size: (32 + pad((int(N) * 4)))
type GlxGetConvolutionParameterivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetConvolutionParameteriv
func (cook GlxGetConvolutionParameterivCookie) Reply() (*GlxGetConvolutionParameterivReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetConvolutionParameterivReply(buf), nil
}

// Read reply into structure from buffer for GlxGetConvolutionParameteriv
func glxGetConvolutionParameterivReply(buf []byte) *GlxGetConvolutionParameterivReply {
	v := new(GlxGetConvolutionParameterivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetConvolutionParameterivCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetConvolutionParameteriv
func (c *Conn) glxGetConvolutionParameterivRequest(ContextTag GlxContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 152 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetSeparableFilter
// size: 24
type GlxGetSeparableFilterCookie struct {
	*cookie
}

func (c *Conn) GlxGetSeparableFilter(ContextTag GlxContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) GlxGetSeparableFilterCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetSeparableFilterRequest(ContextTag, Target, Format, Type, SwapBytes), cookie)
	return GlxGetSeparableFilterCookie{cookie}
}

func (c *Conn) GlxGetSeparableFilterUnchecked(ContextTag GlxContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) GlxGetSeparableFilterCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetSeparableFilterRequest(ContextTag, Target, Format, Type, SwapBytes), cookie)
	return GlxGetSeparableFilterCookie{cookie}
}

// Request reply for GlxGetSeparableFilter
// size: (32 + pad(((int(Length) * 4) * 1)))
type GlxGetSeparableFilterReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 8 bytes
	RowW int32
	ColH int32
	// padding: 8 bytes
	RowsAndCols []byte // size: pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GlxGetSeparableFilter
func (cook GlxGetSeparableFilterCookie) Reply() (*GlxGetSeparableFilterReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetSeparableFilterReply(buf), nil
}

// Read reply into structure from buffer for GlxGetSeparableFilter
func glxGetSeparableFilterReply(buf []byte) *GlxGetSeparableFilterReply {
	v := new(GlxGetSeparableFilterReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 8 // padding

	v.RowW = int32(Get32(buf[b:]))
	b += 4

	v.ColH = int32(Get32(buf[b:]))
	b += 4

	b += 8 // padding

	v.RowsAndCols = make([]byte, (int(v.Length) * 4))
	copy(v.RowsAndCols[:(int(v.Length)*4)], buf[b:])
	b += pad(int((int(v.Length) * 4)))

	return v
}

func (cook GlxGetSeparableFilterCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetSeparableFilter
func (c *Conn) glxGetSeparableFilterRequest(ContextTag GlxContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 153 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Format)
	b += 4

	Put32(buf[b:], Type)
	b += 4

	if SwapBytes {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GlxGetHistogram
// size: 24
type GlxGetHistogramCookie struct {
	*cookie
}

func (c *Conn) GlxGetHistogram(ContextTag GlxContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool, Reset bool) GlxGetHistogramCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetHistogramRequest(ContextTag, Target, Format, Type, SwapBytes, Reset), cookie)
	return GlxGetHistogramCookie{cookie}
}

func (c *Conn) GlxGetHistogramUnchecked(ContextTag GlxContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool, Reset bool) GlxGetHistogramCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetHistogramRequest(ContextTag, Target, Format, Type, SwapBytes, Reset), cookie)
	return GlxGetHistogramCookie{cookie}
}

// Request reply for GlxGetHistogram
// size: (32 + pad(((int(Length) * 4) * 1)))
type GlxGetHistogramReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 8 bytes
	Width int32
	// padding: 12 bytes
	Data []byte // size: pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GlxGetHistogram
func (cook GlxGetHistogramCookie) Reply() (*GlxGetHistogramReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetHistogramReply(buf), nil
}

// Read reply into structure from buffer for GlxGetHistogram
func glxGetHistogramReply(buf []byte) *GlxGetHistogramReply {
	v := new(GlxGetHistogramReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 8 // padding

	v.Width = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += pad(int((int(v.Length) * 4)))

	return v
}

func (cook GlxGetHistogramCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetHistogram
func (c *Conn) glxGetHistogramRequest(ContextTag GlxContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool, Reset bool) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 154 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Format)
	b += 4

	Put32(buf[b:], Type)
	b += 4

	if SwapBytes {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	if Reset {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GlxGetHistogramParameterfv
// size: 16
type GlxGetHistogramParameterfvCookie struct {
	*cookie
}

func (c *Conn) GlxGetHistogramParameterfv(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetHistogramParameterfvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetHistogramParameterfvRequest(ContextTag, Target, Pname), cookie)
	return GlxGetHistogramParameterfvCookie{cookie}
}

func (c *Conn) GlxGetHistogramParameterfvUnchecked(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetHistogramParameterfvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetHistogramParameterfvRequest(ContextTag, Target, Pname), cookie)
	return GlxGetHistogramParameterfvCookie{cookie}
}

// Request reply for GlxGetHistogramParameterfv
// size: (32 + pad((int(N) * 4)))
type GlxGetHistogramParameterfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum GlxFloat32
	// padding: 12 bytes
	Data []GlxFloat32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetHistogramParameterfv
func (cook GlxGetHistogramParameterfvCookie) Reply() (*GlxGetHistogramParameterfvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetHistogramParameterfvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetHistogramParameterfv
func glxGetHistogramParameterfvReply(buf []byte) *GlxGetHistogramParameterfvReply {
	v := new(GlxGetHistogramParameterfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = GlxFloat32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]GlxFloat32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = GlxFloat32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetHistogramParameterfvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetHistogramParameterfv
func (c *Conn) glxGetHistogramParameterfvRequest(ContextTag GlxContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 155 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetHistogramParameteriv
// size: 16
type GlxGetHistogramParameterivCookie struct {
	*cookie
}

func (c *Conn) GlxGetHistogramParameteriv(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetHistogramParameterivCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetHistogramParameterivRequest(ContextTag, Target, Pname), cookie)
	return GlxGetHistogramParameterivCookie{cookie}
}

func (c *Conn) GlxGetHistogramParameterivUnchecked(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetHistogramParameterivCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetHistogramParameterivRequest(ContextTag, Target, Pname), cookie)
	return GlxGetHistogramParameterivCookie{cookie}
}

// Request reply for GlxGetHistogramParameteriv
// size: (32 + pad((int(N) * 4)))
type GlxGetHistogramParameterivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetHistogramParameteriv
func (cook GlxGetHistogramParameterivCookie) Reply() (*GlxGetHistogramParameterivReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetHistogramParameterivReply(buf), nil
}

// Read reply into structure from buffer for GlxGetHistogramParameteriv
func glxGetHistogramParameterivReply(buf []byte) *GlxGetHistogramParameterivReply {
	v := new(GlxGetHistogramParameterivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetHistogramParameterivCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetHistogramParameteriv
func (c *Conn) glxGetHistogramParameterivRequest(ContextTag GlxContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 156 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetMinmax
// size: 24
type GlxGetMinmaxCookie struct {
	*cookie
}

func (c *Conn) GlxGetMinmax(ContextTag GlxContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool, Reset bool) GlxGetMinmaxCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetMinmaxRequest(ContextTag, Target, Format, Type, SwapBytes, Reset), cookie)
	return GlxGetMinmaxCookie{cookie}
}

func (c *Conn) GlxGetMinmaxUnchecked(ContextTag GlxContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool, Reset bool) GlxGetMinmaxCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetMinmaxRequest(ContextTag, Target, Format, Type, SwapBytes, Reset), cookie)
	return GlxGetMinmaxCookie{cookie}
}

// Request reply for GlxGetMinmax
// size: (32 + pad(((int(Length) * 4) * 1)))
type GlxGetMinmaxReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
	Data []byte // size: pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GlxGetMinmax
func (cook GlxGetMinmaxCookie) Reply() (*GlxGetMinmaxReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetMinmaxReply(buf), nil
}

// Read reply into structure from buffer for GlxGetMinmax
func glxGetMinmaxReply(buf []byte) *GlxGetMinmaxReply {
	v := new(GlxGetMinmaxReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += pad(int((int(v.Length) * 4)))

	return v
}

func (cook GlxGetMinmaxCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetMinmax
func (c *Conn) glxGetMinmaxRequest(ContextTag GlxContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool, Reset bool) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 157 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Format)
	b += 4

	Put32(buf[b:], Type)
	b += 4

	if SwapBytes {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	if Reset {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GlxGetMinmaxParameterfv
// size: 16
type GlxGetMinmaxParameterfvCookie struct {
	*cookie
}

func (c *Conn) GlxGetMinmaxParameterfv(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetMinmaxParameterfvCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetMinmaxParameterfvRequest(ContextTag, Target, Pname), cookie)
	return GlxGetMinmaxParameterfvCookie{cookie}
}

func (c *Conn) GlxGetMinmaxParameterfvUnchecked(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetMinmaxParameterfvCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetMinmaxParameterfvRequest(ContextTag, Target, Pname), cookie)
	return GlxGetMinmaxParameterfvCookie{cookie}
}

// Request reply for GlxGetMinmaxParameterfv
// size: (32 + pad((int(N) * 4)))
type GlxGetMinmaxParameterfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum GlxFloat32
	// padding: 12 bytes
	Data []GlxFloat32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetMinmaxParameterfv
func (cook GlxGetMinmaxParameterfvCookie) Reply() (*GlxGetMinmaxParameterfvReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetMinmaxParameterfvReply(buf), nil
}

// Read reply into structure from buffer for GlxGetMinmaxParameterfv
func glxGetMinmaxParameterfvReply(buf []byte) *GlxGetMinmaxParameterfvReply {
	v := new(GlxGetMinmaxParameterfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = GlxFloat32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]GlxFloat32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = GlxFloat32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetMinmaxParameterfvCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetMinmaxParameterfv
func (c *Conn) glxGetMinmaxParameterfvRequest(ContextTag GlxContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 158 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetMinmaxParameteriv
// size: 16
type GlxGetMinmaxParameterivCookie struct {
	*cookie
}

func (c *Conn) GlxGetMinmaxParameteriv(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetMinmaxParameterivCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetMinmaxParameterivRequest(ContextTag, Target, Pname), cookie)
	return GlxGetMinmaxParameterivCookie{cookie}
}

func (c *Conn) GlxGetMinmaxParameterivUnchecked(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetMinmaxParameterivCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetMinmaxParameterivRequest(ContextTag, Target, Pname), cookie)
	return GlxGetMinmaxParameterivCookie{cookie}
}

// Request reply for GlxGetMinmaxParameteriv
// size: (32 + pad((int(N) * 4)))
type GlxGetMinmaxParameterivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetMinmaxParameteriv
func (cook GlxGetMinmaxParameterivCookie) Reply() (*GlxGetMinmaxParameterivReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetMinmaxParameterivReply(buf), nil
}

// Read reply into structure from buffer for GlxGetMinmaxParameteriv
func glxGetMinmaxParameterivReply(buf []byte) *GlxGetMinmaxParameterivReply {
	v := new(GlxGetMinmaxParameterivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetMinmaxParameterivCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetMinmaxParameteriv
func (c *Conn) glxGetMinmaxParameterivRequest(ContextTag GlxContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 159 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetCompressedTexImageARB
// size: 16
type GlxGetCompressedTexImageARBCookie struct {
	*cookie
}

func (c *Conn) GlxGetCompressedTexImageARB(ContextTag GlxContextTag, Target uint32, Level int32) GlxGetCompressedTexImageARBCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetCompressedTexImageARBRequest(ContextTag, Target, Level), cookie)
	return GlxGetCompressedTexImageARBCookie{cookie}
}

func (c *Conn) GlxGetCompressedTexImageARBUnchecked(ContextTag GlxContextTag, Target uint32, Level int32) GlxGetCompressedTexImageARBCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetCompressedTexImageARBRequest(ContextTag, Target, Level), cookie)
	return GlxGetCompressedTexImageARBCookie{cookie}
}

// Request reply for GlxGetCompressedTexImageARB
// size: (32 + pad(((int(Length) * 4) * 1)))
type GlxGetCompressedTexImageARBReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 8 bytes
	Size int32
	// padding: 12 bytes
	Data []byte // size: pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GlxGetCompressedTexImageARB
func (cook GlxGetCompressedTexImageARBCookie) Reply() (*GlxGetCompressedTexImageARBReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetCompressedTexImageARBReply(buf), nil
}

// Read reply into structure from buffer for GlxGetCompressedTexImageARB
func glxGetCompressedTexImageARBReply(buf []byte) *GlxGetCompressedTexImageARBReply {
	v := new(GlxGetCompressedTexImageARBReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 8 // padding

	v.Size = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += pad(int((int(v.Length) * 4)))

	return v
}

func (cook GlxGetCompressedTexImageARBCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetCompressedTexImageARB
func (c *Conn) glxGetCompressedTexImageARBRequest(ContextTag GlxContextTag, Target uint32, Level int32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 160 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], uint32(Level))
	b += 4

	return buf
}

// Request GlxDeleteQueriesARB
// size: pad((12 + pad((int(N) * 4))))
type GlxDeleteQueriesARBCookie struct {
	*cookie
}

// Write request to wire for GlxDeleteQueriesARB
func (c *Conn) GlxDeleteQueriesARB(ContextTag GlxContextTag, N int32, Ids []uint32) GlxDeleteQueriesARBCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.glxDeleteQueriesARBRequest(ContextTag, N, Ids), cookie)
	return GlxDeleteQueriesARBCookie{cookie}
}

func (c *Conn) GlxDeleteQueriesARBChecked(ContextTag GlxContextTag, N int32, Ids []uint32) GlxDeleteQueriesARBCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.glxDeleteQueriesARBRequest(ContextTag, N, Ids), cookie)
	return GlxDeleteQueriesARBCookie{cookie}
}

func (cook GlxDeleteQueriesARBCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxDeleteQueriesARB
func (c *Conn) glxDeleteQueriesARBRequest(ContextTag GlxContextTag, N int32, Ids []uint32) []byte {
	size := pad((12 + pad((int(N) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 161 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], uint32(N))
	b += 4

	for i := 0; i < int(N); i++ {
		Put32(buf[b:], Ids[i])
		b += 4
	}
	b = pad(b)

	return buf
}

// Request GlxGenQueriesARB
// size: 12
type GlxGenQueriesARBCookie struct {
	*cookie
}

func (c *Conn) GlxGenQueriesARB(ContextTag GlxContextTag, N int32) GlxGenQueriesARBCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGenQueriesARBRequest(ContextTag, N), cookie)
	return GlxGenQueriesARBCookie{cookie}
}

func (c *Conn) GlxGenQueriesARBUnchecked(ContextTag GlxContextTag, N int32) GlxGenQueriesARBCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGenQueriesARBRequest(ContextTag, N), cookie)
	return GlxGenQueriesARBCookie{cookie}
}

// Request reply for GlxGenQueriesARB
// size: (32 + pad((int(Length) * 4)))
type GlxGenQueriesARBReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
	Data []uint32 // size: pad((int(Length) * 4))
}

// Waits and reads reply data from request GlxGenQueriesARB
func (cook GlxGenQueriesARBCookie) Reply() (*GlxGenQueriesARBReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGenQueriesARBReply(buf), nil
}

// Read reply into structure from buffer for GlxGenQueriesARB
func glxGenQueriesARBReply(buf []byte) *GlxGenQueriesARBReply {
	v := new(GlxGenQueriesARBReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.Data = make([]uint32, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.Data[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGenQueriesARBCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGenQueriesARB
func (c *Conn) glxGenQueriesARBRequest(ContextTag GlxContextTag, N int32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 162 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], uint32(N))
	b += 4

	return buf
}

// Request GlxIsQueryARB
// size: 12
type GlxIsQueryARBCookie struct {
	*cookie
}

func (c *Conn) GlxIsQueryARB(ContextTag GlxContextTag, Id uint32) GlxIsQueryARBCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxIsQueryARBRequest(ContextTag, Id), cookie)
	return GlxIsQueryARBCookie{cookie}
}

func (c *Conn) GlxIsQueryARBUnchecked(ContextTag GlxContextTag, Id uint32) GlxIsQueryARBCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxIsQueryARBRequest(ContextTag, Id), cookie)
	return GlxIsQueryARBCookie{cookie}
}

// Request reply for GlxIsQueryARB
// size: 12
type GlxIsQueryARBReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	RetVal GlxBool32
}

// Waits and reads reply data from request GlxIsQueryARB
func (cook GlxIsQueryARBCookie) Reply() (*GlxIsQueryARBReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxIsQueryARBReply(buf), nil
}

// Read reply into structure from buffer for GlxIsQueryARB
func glxIsQueryARBReply(buf []byte) *GlxIsQueryARBReply {
	v := new(GlxIsQueryARBReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.RetVal = GlxBool32(Get32(buf[b:]))
	b += 4

	return v
}

func (cook GlxIsQueryARBCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxIsQueryARB
func (c *Conn) glxIsQueryARBRequest(ContextTag GlxContextTag, Id uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 163 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Id)
	b += 4

	return buf
}

// Request GlxGetQueryivARB
// size: 16
type GlxGetQueryivARBCookie struct {
	*cookie
}

func (c *Conn) GlxGetQueryivARB(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetQueryivARBCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetQueryivARBRequest(ContextTag, Target, Pname), cookie)
	return GlxGetQueryivARBCookie{cookie}
}

func (c *Conn) GlxGetQueryivARBUnchecked(ContextTag GlxContextTag, Target uint32, Pname uint32) GlxGetQueryivARBCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetQueryivARBRequest(ContextTag, Target, Pname), cookie)
	return GlxGetQueryivARBCookie{cookie}
}

// Request reply for GlxGetQueryivARB
// size: (32 + pad((int(N) * 4)))
type GlxGetQueryivARBReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetQueryivARB
func (cook GlxGetQueryivARBCookie) Reply() (*GlxGetQueryivARBReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetQueryivARBReply(buf), nil
}

// Read reply into structure from buffer for GlxGetQueryivARB
func glxGetQueryivARBReply(buf []byte) *GlxGetQueryivARBReply {
	v := new(GlxGetQueryivARBReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetQueryivARBCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetQueryivARB
func (c *Conn) glxGetQueryivARBRequest(ContextTag GlxContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 164 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Target)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetQueryObjectivARB
// size: 16
type GlxGetQueryObjectivARBCookie struct {
	*cookie
}

func (c *Conn) GlxGetQueryObjectivARB(ContextTag GlxContextTag, Id uint32, Pname uint32) GlxGetQueryObjectivARBCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetQueryObjectivARBRequest(ContextTag, Id, Pname), cookie)
	return GlxGetQueryObjectivARBCookie{cookie}
}

func (c *Conn) GlxGetQueryObjectivARBUnchecked(ContextTag GlxContextTag, Id uint32, Pname uint32) GlxGetQueryObjectivARBCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetQueryObjectivARBRequest(ContextTag, Id, Pname), cookie)
	return GlxGetQueryObjectivARBCookie{cookie}
}

// Request reply for GlxGetQueryObjectivARB
// size: (32 + pad((int(N) * 4)))
type GlxGetQueryObjectivARBReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetQueryObjectivARB
func (cook GlxGetQueryObjectivARBCookie) Reply() (*GlxGetQueryObjectivARBReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetQueryObjectivARBReply(buf), nil
}

// Read reply into structure from buffer for GlxGetQueryObjectivARB
func glxGetQueryObjectivARBReply(buf []byte) *GlxGetQueryObjectivARBReply {
	v := new(GlxGetQueryObjectivARBReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = int32(Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetQueryObjectivARBCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetQueryObjectivARB
func (c *Conn) glxGetQueryObjectivARBRequest(ContextTag GlxContextTag, Id uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 165 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Id)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GlxGetQueryObjectuivARB
// size: 16
type GlxGetQueryObjectuivARBCookie struct {
	*cookie
}

func (c *Conn) GlxGetQueryObjectuivARB(ContextTag GlxContextTag, Id uint32, Pname uint32) GlxGetQueryObjectuivARBCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.glxGetQueryObjectuivARBRequest(ContextTag, Id, Pname), cookie)
	return GlxGetQueryObjectuivARBCookie{cookie}
}

func (c *Conn) GlxGetQueryObjectuivARBUnchecked(ContextTag GlxContextTag, Id uint32, Pname uint32) GlxGetQueryObjectuivARBCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.glxGetQueryObjectuivARBRequest(ContextTag, Id, Pname), cookie)
	return GlxGetQueryObjectuivARBCookie{cookie}
}

// Request reply for GlxGetQueryObjectuivARB
// size: (32 + pad((int(N) * 4)))
type GlxGetQueryObjectuivARBReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum uint32
	// padding: 12 bytes
	Data []uint32 // size: pad((int(N) * 4))
}

// Waits and reads reply data from request GlxGetQueryObjectuivARB
func (cook GlxGetQueryObjectuivARBCookie) Reply() (*GlxGetQueryObjectuivARBReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return glxGetQueryObjectuivARBReply(buf), nil
}

// Read reply into structure from buffer for GlxGetQueryObjectuivARB
func glxGetQueryObjectuivARBReply(buf []byte) *GlxGetQueryObjectuivARBReply {
	v := new(GlxGetQueryObjectuivARBReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = Get32(buf[b:])
	b += 4

	v.Datum = Get32(buf[b:])
	b += 4

	b += 12 // padding

	v.Data = make([]uint32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	return v
}

func (cook GlxGetQueryObjectuivARBCookie) Check() error {
	return cook.check()
}

// Write request to wire for GlxGetQueryObjectuivARB
func (c *Conn) glxGetQueryObjectuivARBRequest(ContextTag GlxContextTag, Id uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["GLX"]
	b += 1

	buf[b] = 166 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(ContextTag))
	b += 4

	Put32(buf[b:], Id)
	b += 4

	Put32(buf[b:], Pname)
	b += 4

	return buf
}
