package main

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"log"
	"strings"
	"time"
)

// Context represents the protocol we're converting to Go, and a writer
// buffer to write the Go source to.
type Context struct {
	protocol *Protocol
	out      *bytes.Buffer
}

func newContext() *Context {
	return &Context{
		out: bytes.NewBuffer([]byte{}),
	}
}

// Putln calls put and adds a new line to the end of 'format'.
func (c *Context) Putln(format string, v ...interface{}) {
	c.Put(format+"\n", v...)
}

// Put is a short alias to write to 'out'.
func (c *Context) Put(format string, v ...interface{}) {
	_, err := c.out.WriteString(fmt.Sprintf(format, v...))
	if err != nil {
		log.Fatalf("There was an error writing to context buffer: %s", err)
	}
}

// Morph is the big daddy of them all. It takes in an XML byte slice,
// parse it, transforms the XML types into more usable types,
// and writes Go code to the 'out' buffer.
func (c *Context) Morph(xmlBytes []byte) {
	parsedXml := &XML{}
	err := xml.Unmarshal(xmlBytes, parsedXml)
	if err != nil {
		log.Fatal(err)
	}

	// Parse all imports
	parsedXml.Imports.Eval()

	// Translate XML types to nice types
	c.protocol = parsedXml.Translate()

	// Start with Go header.
	c.Putln("package xgb")
	c.Putln("")
	c.Putln("/*")
	c.Putln("\tThis file was generated by %s.xml on %s.",
		c.protocol.Name, time.Now().Format("Jan 2 2006 3:04:05pm MST"))
	c.Putln("\tThis file is automatically generated. Edit at your peril!")
	c.Putln("*/")
	c.Putln("")

	// Write imports in comments
	if len(c.protocol.Imports) > 0 {
		c.Putln("// Imports are not necessary for XGB because everything is ")
		c.Putln("// in one package. They are still listed here for reference.")
		for _, imp := range c.protocol.Imports {
			c.Putln("// import \"%s\"", imp.Name)
		}
		c.Putln("")
	}

	// If this is an extension, create a function to initialize the extension
	// before it can be used.
	if c.protocol.isExt() {
		name := strings.Title(c.protocol.Name) + "Init"
		xname := c.protocol.ExtXName

		c.Putln("// %s must be called before using the %s extension.",
			name, xname)
		c.Putln("func (c *Conn) %s() error {", name)
		c.Putln("reply, err := c.QueryExtension(%d, \"%s\").Reply()",
			len(xname), xname)
		c.Putln("switch {")
		c.Putln("case err != nil:")
		c.Putln("return err")
		c.Putln("case !reply.Present:")
		c.Putln("return errorf(\"No extension named %s could be found on "+
			"on the server.\")", xname)
		c.Putln("}")
		c.Putln("")
		c.Putln("c.extLock.Lock()")
		c.Putln("c.extensions[\"%s\"] = reply.MajorOpcode", xname)
		c.Putln("for evNum, fun := range newExtEventFuncs[\"%s\"] {", xname)
		c.Putln("newEventFuncs[int(reply.FirstEvent) + evNum] = fun")
		c.Putln("}")
		c.Putln("for errNum, fun := range newExtErrorFuncs[\"%s\"] {", xname)
		c.Putln("newErrorFuncs[int(reply.FirstError) + errNum] = fun")
		c.Putln("}")
		c.Putln("c.extLock.Unlock()")
		c.Putln("")
		c.Putln("return nil")
		c.Putln("}")
		c.Putln("")

		// Make sure newExtEventFuncs["EXT_NAME"] map is initialized.
		// Same deal for newExtErrorFuncs["EXT_NAME"]
		c.Putln("func init() {")
		c.Putln("newExtEventFuncs[\"%s\"] = make(map[int]newEventFun)", xname)
		c.Putln("newExtErrorFuncs[\"%s\"] = make(map[int]newErrorFun)", xname)
		c.Putln("}")
		c.Putln("")
	}

	// Now write Go source code
	for _, typ := range c.protocol.Types {
		typ.Define(c)
	}
	for _, req := range c.protocol.Requests {
		req.Define(c)
	}
}
