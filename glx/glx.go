package glx

/*
	This file was generated by glx.xml on May 10 2012 4:20:27pm EDT.
	This file is automatically generated. Edit at your peril!
*/

import (
	"github.com/BurntSushi/xgb"

	"github.com/BurntSushi/xgb/xproto"
)

// Init must be called before using the GLX extension.
func Init(c *xgb.Conn) error {
	reply, err := xproto.QueryExtension(c, 3, "GLX").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return xgb.Errorf("No extension named GLX could be found on on the server.")
	}

	xgb.ExtLock.Lock()
	c.Extensions["GLX"] = reply.MajorOpcode
	for evNum, fun := range xgb.NewExtEventFuncs["GLX"] {
		xgb.NewEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range xgb.NewExtErrorFuncs["GLX"] {
		xgb.NewErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	xgb.ExtLock.Unlock()

	return nil
}

func init() {
	xgb.NewExtEventFuncs["GLX"] = make(map[int]xgb.NewEventFun)
	xgb.NewExtErrorFuncs["GLX"] = make(map[int]xgb.NewErrorFun)
}

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Float'

const (
	PbcetDamaged = 32791
	PbcetSaved   = 32792
)

const (
	PbcdtWindow  = 32793
	PbcdtPbuffer = 32794
)

const (
	GcGlCurrentBit        = 1
	GcGlPointBit          = 2
	GcGlLineBit           = 4
	GcGlPolygonBit        = 8
	GcGlPolygonStippleBit = 16
	GcGlPixelModeBit      = 32
	GcGlLightingBit       = 64
	GcGlFogBit            = 128
	GcGlDepthBufferBit    = 256
	GcGlAccumBufferBit    = 512
	GcGlStencilBufferBit  = 1024
	GcGlViewportBit       = 2048
	GcGlTransformBit      = 4096
	GcGlEnableBit         = 8192
	GcGlColorBufferBit    = 16384
	GcGlHintBit           = 32768
	GcGlEvalBit           = 65536
	GcGlListBit           = 131072
	GcGlTextureBit        = 262144
	GcGlScissorBit        = 524288
	GcGlAllAttribBits     = 16777215
)

const (
	RmGlRender   = 7168
	RmGlFeedback = 7169
	RmGlSelect   = 7170
)

type Pixmap uint32

func NewPixmapId(c *xgb.Conn) (Pixmap, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Pixmap(id), nil
}

type Context uint32

func NewContextId(c *xgb.Conn) (Context, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Context(id), nil
}

type Pbuffer uint32

func NewPbufferId(c *xgb.Conn) (Pbuffer, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Pbuffer(id), nil
}

type Window uint32

func NewWindowId(c *xgb.Conn) (Window, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Window(id), nil
}

type Fbconfig uint32

func NewFbconfigId(c *xgb.Conn) (Fbconfig, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Fbconfig(id), nil
}

type Drawable uint32

func NewDrawableId(c *xgb.Conn) (Drawable, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Drawable(id), nil
}

type Float32 float64

type Float64 float64

type Bool32 uint32

type ContextTag uint32

// Event definition PbufferClobber (0)
// Size: 32

const PbufferClobber = 0

type PbufferClobberEvent struct {
	Sequence uint16
	// padding: 1 bytes
	EventType uint16
	DrawType  uint16
	Drawable  Drawable
	BMask     uint32
	AuxBuffer uint16
	X         uint16
	Y         uint16
	Width     uint16
	Height    uint16
	Count     uint16
	// padding: 4 bytes
}

// Event read PbufferClobber
func PbufferClobberEventNew(buf []byte) xgb.Event {
	v := PbufferClobberEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.EventType = xgb.Get16(buf[b:])
	b += 2

	v.DrawType = xgb.Get16(buf[b:])
	b += 2

	v.Drawable = Drawable(xgb.Get32(buf[b:]))
	b += 4

	v.BMask = xgb.Get32(buf[b:])
	b += 4

	v.AuxBuffer = xgb.Get16(buf[b:])
	b += 2

	v.X = xgb.Get16(buf[b:])
	b += 2

	v.Y = xgb.Get16(buf[b:])
	b += 2

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	v.Count = xgb.Get16(buf[b:])
	b += 2

	b += 4 // padding

	return v
}

// Event write PbufferClobber
func (v PbufferClobberEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 0
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put16(buf[b:], v.EventType)
	b += 2

	xgb.Put16(buf[b:], v.DrawType)
	b += 2

	xgb.Put32(buf[b:], uint32(v.Drawable))
	b += 4

	xgb.Put32(buf[b:], v.BMask)
	b += 4

	xgb.Put16(buf[b:], v.AuxBuffer)
	b += 2

	xgb.Put16(buf[b:], v.X)
	b += 2

	xgb.Put16(buf[b:], v.Y)
	b += 2

	xgb.Put16(buf[b:], v.Width)
	b += 2

	xgb.Put16(buf[b:], v.Height)
	b += 2

	xgb.Put16(buf[b:], v.Count)
	b += 2

	b += 4 // padding

	return buf
}

func (v PbufferClobberEvent) ImplementsEvent() {}

func (v PbufferClobberEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v PbufferClobberEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("EventType: %d", v.EventType))
	fieldVals = append(fieldVals, xgb.Sprintf("DrawType: %d", v.DrawType))
	fieldVals = append(fieldVals, xgb.Sprintf("Drawable: %d", v.Drawable))
	fieldVals = append(fieldVals, xgb.Sprintf("BMask: %d", v.BMask))
	fieldVals = append(fieldVals, xgb.Sprintf("AuxBuffer: %d", v.AuxBuffer))
	fieldVals = append(fieldVals, xgb.Sprintf("X: %d", v.X))
	fieldVals = append(fieldVals, xgb.Sprintf("Y: %d", v.Y))
	fieldVals = append(fieldVals, xgb.Sprintf("Width: %d", v.Width))
	fieldVals = append(fieldVals, xgb.Sprintf("Height: %d", v.Height))
	fieldVals = append(fieldVals, xgb.Sprintf("Count: %d", v.Count))
	return "PbufferClobber {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["GLX"][0] = PbufferClobberEventNew
}

// Error definition Generic (-1)
// Size: 32

const BadGeneric = -1

type GenericError struct {
	Sequence    uint16
	NiceName    string
	BadValue    uint32
	MinorOpcode uint16
	MajorOpcode byte
	// padding: 21 bytes
}

// Error read Generic
func GenericErrorNew(buf []byte) xgb.Error {
	v := GenericError{}
	v.NiceName = "Generic"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.BadValue = xgb.Get32(buf[b:])
	b += 4

	v.MinorOpcode = xgb.Get16(buf[b:])
	b += 2

	v.MajorOpcode = buf[b]
	b += 1

	b += 21 // padding

	return v
}

func (err GenericError) ImplementsError() {}

func (err GenericError) SequenceId() uint16 {
	return err.Sequence
}

func (err GenericError) BadId() uint32 {
	return 0
}

func (err GenericError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGeneric {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["GLX"][-1] = GenericErrorNew
}

// ErrorCopy definition BadContext (0)

const BadBadContext = 0

type BadContextError GenericError

func BadContextErrorNew(buf []byte) xgb.Error {
	v := BadContextError(GenericErrorNew(buf).(GenericError))
	v.NiceName = "BadContext"
	return v
}

func (err BadContextError) ImplementsError() {}

func (err BadContextError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadContextError) BadId() uint32 {
	return 0
}

func (err BadContextError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadBadContext {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["GLX"][0] = BadContextErrorNew
}

// ErrorCopy definition BadContextState (1)

const BadBadContextState = 1

type BadContextStateError GenericError

func BadContextStateErrorNew(buf []byte) xgb.Error {
	v := BadContextStateError(GenericErrorNew(buf).(GenericError))
	v.NiceName = "BadContextState"
	return v
}

func (err BadContextStateError) ImplementsError() {}

func (err BadContextStateError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadContextStateError) BadId() uint32 {
	return 0
}

func (err BadContextStateError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadBadContextState {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["GLX"][1] = BadContextStateErrorNew
}

// ErrorCopy definition BadDrawable (2)

const BadBadDrawable = 2

type BadDrawableError GenericError

func BadDrawableErrorNew(buf []byte) xgb.Error {
	v := BadDrawableError(GenericErrorNew(buf).(GenericError))
	v.NiceName = "BadDrawable"
	return v
}

func (err BadDrawableError) ImplementsError() {}

func (err BadDrawableError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadDrawableError) BadId() uint32 {
	return 0
}

func (err BadDrawableError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadBadDrawable {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["GLX"][2] = BadDrawableErrorNew
}

// ErrorCopy definition BadPixmap (3)

const BadBadPixmap = 3

type BadPixmapError GenericError

func BadPixmapErrorNew(buf []byte) xgb.Error {
	v := BadPixmapError(GenericErrorNew(buf).(GenericError))
	v.NiceName = "BadPixmap"
	return v
}

func (err BadPixmapError) ImplementsError() {}

func (err BadPixmapError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadPixmapError) BadId() uint32 {
	return 0
}

func (err BadPixmapError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadBadPixmap {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["GLX"][3] = BadPixmapErrorNew
}

// ErrorCopy definition BadContextTag (4)

const BadBadContextTag = 4

type BadContextTagError GenericError

func BadContextTagErrorNew(buf []byte) xgb.Error {
	v := BadContextTagError(GenericErrorNew(buf).(GenericError))
	v.NiceName = "BadContextTag"
	return v
}

func (err BadContextTagError) ImplementsError() {}

func (err BadContextTagError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadContextTagError) BadId() uint32 {
	return 0
}

func (err BadContextTagError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadBadContextTag {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["GLX"][4] = BadContextTagErrorNew
}

// ErrorCopy definition BadCurrentWindow (5)

const BadBadCurrentWindow = 5

type BadCurrentWindowError GenericError

func BadCurrentWindowErrorNew(buf []byte) xgb.Error {
	v := BadCurrentWindowError(GenericErrorNew(buf).(GenericError))
	v.NiceName = "BadCurrentWindow"
	return v
}

func (err BadCurrentWindowError) ImplementsError() {}

func (err BadCurrentWindowError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadCurrentWindowError) BadId() uint32 {
	return 0
}

func (err BadCurrentWindowError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadBadCurrentWindow {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["GLX"][5] = BadCurrentWindowErrorNew
}

// ErrorCopy definition BadRenderRequest (6)

const BadBadRenderRequest = 6

type BadRenderRequestError GenericError

func BadRenderRequestErrorNew(buf []byte) xgb.Error {
	v := BadRenderRequestError(GenericErrorNew(buf).(GenericError))
	v.NiceName = "BadRenderRequest"
	return v
}

func (err BadRenderRequestError) ImplementsError() {}

func (err BadRenderRequestError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadRenderRequestError) BadId() uint32 {
	return 0
}

func (err BadRenderRequestError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadBadRenderRequest {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["GLX"][6] = BadRenderRequestErrorNew
}

// ErrorCopy definition BadLargeRequest (7)

const BadBadLargeRequest = 7

type BadLargeRequestError GenericError

func BadLargeRequestErrorNew(buf []byte) xgb.Error {
	v := BadLargeRequestError(GenericErrorNew(buf).(GenericError))
	v.NiceName = "BadLargeRequest"
	return v
}

func (err BadLargeRequestError) ImplementsError() {}

func (err BadLargeRequestError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadLargeRequestError) BadId() uint32 {
	return 0
}

func (err BadLargeRequestError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadBadLargeRequest {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["GLX"][7] = BadLargeRequestErrorNew
}

// ErrorCopy definition UnsupportedPrivateRequest (8)

const BadUnsupportedPrivateRequest = 8

type UnsupportedPrivateRequestError GenericError

func UnsupportedPrivateRequestErrorNew(buf []byte) xgb.Error {
	v := UnsupportedPrivateRequestError(GenericErrorNew(buf).(GenericError))
	v.NiceName = "UnsupportedPrivateRequest"
	return v
}

func (err UnsupportedPrivateRequestError) ImplementsError() {}

func (err UnsupportedPrivateRequestError) SequenceId() uint16 {
	return err.Sequence
}

func (err UnsupportedPrivateRequestError) BadId() uint32 {
	return 0
}

func (err UnsupportedPrivateRequestError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadUnsupportedPrivateRequest {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["GLX"][8] = UnsupportedPrivateRequestErrorNew
}

// ErrorCopy definition BadFBConfig (9)

const BadBadFBConfig = 9

type BadFBConfigError GenericError

func BadFBConfigErrorNew(buf []byte) xgb.Error {
	v := BadFBConfigError(GenericErrorNew(buf).(GenericError))
	v.NiceName = "BadFBConfig"
	return v
}

func (err BadFBConfigError) ImplementsError() {}

func (err BadFBConfigError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadFBConfigError) BadId() uint32 {
	return 0
}

func (err BadFBConfigError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadBadFBConfig {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["GLX"][9] = BadFBConfigErrorNew
}

// ErrorCopy definition BadPbuffer (10)

const BadBadPbuffer = 10

type BadPbufferError GenericError

func BadPbufferErrorNew(buf []byte) xgb.Error {
	v := BadPbufferError(GenericErrorNew(buf).(GenericError))
	v.NiceName = "BadPbuffer"
	return v
}

func (err BadPbufferError) ImplementsError() {}

func (err BadPbufferError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadPbufferError) BadId() uint32 {
	return 0
}

func (err BadPbufferError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadBadPbuffer {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["GLX"][10] = BadPbufferErrorNew
}

// ErrorCopy definition BadCurrentDrawable (11)

const BadBadCurrentDrawable = 11

type BadCurrentDrawableError GenericError

func BadCurrentDrawableErrorNew(buf []byte) xgb.Error {
	v := BadCurrentDrawableError(GenericErrorNew(buf).(GenericError))
	v.NiceName = "BadCurrentDrawable"
	return v
}

func (err BadCurrentDrawableError) ImplementsError() {}

func (err BadCurrentDrawableError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadCurrentDrawableError) BadId() uint32 {
	return 0
}

func (err BadCurrentDrawableError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadBadCurrentDrawable {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["GLX"][11] = BadCurrentDrawableErrorNew
}

// ErrorCopy definition BadWindow (12)

const BadBadWindow = 12

type BadWindowError GenericError

func BadWindowErrorNew(buf []byte) xgb.Error {
	v := BadWindowError(GenericErrorNew(buf).(GenericError))
	v.NiceName = "BadWindow"
	return v
}

func (err BadWindowError) ImplementsError() {}

func (err BadWindowError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadWindowError) BadId() uint32 {
	return 0
}

func (err BadWindowError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadBadWindow {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["GLX"][12] = BadWindowErrorNew
}

// ErrorCopy definition GLXBadProfileARB (13)

const BadGLXBadProfileARB = 13

type GLXBadProfileARBError GenericError

func GLXBadProfileARBErrorNew(buf []byte) xgb.Error {
	v := GLXBadProfileARBError(GenericErrorNew(buf).(GenericError))
	v.NiceName = "GLXBadProfileARB"
	return v
}

func (err GLXBadProfileARBError) ImplementsError() {}

func (err GLXBadProfileARBError) SequenceId() uint16 {
	return err.Sequence
}

func (err GLXBadProfileARBError) BadId() uint32 {
	return 0
}

func (err GLXBadProfileARBError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGLXBadProfileARB {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["GLX"][13] = GLXBadProfileARBErrorNew
}

// Request Render
// size: xgb.Pad((8 + xgb.Pad((len(Data) * 1))))
type RenderCookie struct {
	*xgb.Cookie
}

// Write request to wire for Render
func Render(c *xgb.Conn, ContextTag ContextTag, Data []byte) RenderCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(renderRequest(c, ContextTag, Data), cookie)
	return RenderCookie{cookie}
}

func RenderChecked(c *xgb.Conn, ContextTag ContextTag, Data []byte) RenderCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(renderRequest(c, ContextTag, Data), cookie)
	return RenderCookie{cookie}
}

func (cook RenderCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for Render
func renderRequest(c *xgb.Conn, ContextTag ContextTag, Data []byte) []byte {
	size := xgb.Pad((8 + xgb.Pad((len(Data) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	copy(buf[b:], Data[:len(Data)])
	b += xgb.Pad(int(len(Data)))

	return buf
}

// Request RenderLarge
// size: xgb.Pad((16 + xgb.Pad((int(DataLen) * 1))))
type RenderLargeCookie struct {
	*xgb.Cookie
}

// Write request to wire for RenderLarge
func RenderLarge(c *xgb.Conn, ContextTag ContextTag, RequestNum uint16, RequestTotal uint16, DataLen uint32, Data []byte) RenderLargeCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(renderLargeRequest(c, ContextTag, RequestNum, RequestTotal, DataLen, Data), cookie)
	return RenderLargeCookie{cookie}
}

func RenderLargeChecked(c *xgb.Conn, ContextTag ContextTag, RequestNum uint16, RequestTotal uint16, DataLen uint32, Data []byte) RenderLargeCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(renderLargeRequest(c, ContextTag, RequestNum, RequestTotal, DataLen, Data), cookie)
	return RenderLargeCookie{cookie}
}

func (cook RenderLargeCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for RenderLarge
func renderLargeRequest(c *xgb.Conn, ContextTag ContextTag, RequestNum uint16, RequestTotal uint16, DataLen uint32, Data []byte) []byte {
	size := xgb.Pad((16 + xgb.Pad((int(DataLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put16(buf[b:], RequestNum)
	b += 2

	xgb.Put16(buf[b:], RequestTotal)
	b += 2

	xgb.Put32(buf[b:], DataLen)
	b += 4

	copy(buf[b:], Data[:DataLen])
	b += xgb.Pad(int(DataLen))

	return buf
}

// Request CreateContext
// size: 24
type CreateContextCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateContext
func CreateContext(c *xgb.Conn, Context Context, Visual xproto.Visualid, Screen uint32, ShareList Context, IsDirect bool) CreateContextCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createContextRequest(c, Context, Visual, Screen, ShareList, IsDirect), cookie)
	return CreateContextCookie{cookie}
}

func CreateContextChecked(c *xgb.Conn, Context Context, Visual xproto.Visualid, Screen uint32, ShareList Context, IsDirect bool) CreateContextCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createContextRequest(c, Context, Visual, Screen, ShareList, IsDirect), cookie)
	return CreateContextCookie{cookie}
}

func (cook CreateContextCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateContext
func createContextRequest(c *xgb.Conn, Context Context, Visual xproto.Visualid, Screen uint32, ShareList Context, IsDirect bool) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Context))
	b += 4

	xgb.Put32(buf[b:], uint32(Visual))
	b += 4

	xgb.Put32(buf[b:], Screen)
	b += 4

	xgb.Put32(buf[b:], uint32(ShareList))
	b += 4

	if IsDirect {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 3 // padding

	return buf
}

// Request DestroyContext
// size: 8
type DestroyContextCookie struct {
	*xgb.Cookie
}

// Write request to wire for DestroyContext
func DestroyContext(c *xgb.Conn, Context Context) DestroyContextCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroyContextRequest(c, Context), cookie)
	return DestroyContextCookie{cookie}
}

func DestroyContextChecked(c *xgb.Conn, Context Context) DestroyContextCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroyContextRequest(c, Context), cookie)
	return DestroyContextCookie{cookie}
}

func (cook DestroyContextCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroyContext
func destroyContextRequest(c *xgb.Conn, Context Context) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Context))
	b += 4

	return buf
}

// Request MakeCurrent
// size: 16
type MakeCurrentCookie struct {
	*xgb.Cookie
}

func MakeCurrent(c *xgb.Conn, Drawable Drawable, Context Context, OldContextTag ContextTag) MakeCurrentCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(makeCurrentRequest(c, Drawable, Context, OldContextTag), cookie)
	return MakeCurrentCookie{cookie}
}

func MakeCurrentUnchecked(c *xgb.Conn, Drawable Drawable, Context Context, OldContextTag ContextTag) MakeCurrentCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(makeCurrentRequest(c, Drawable, Context, OldContextTag), cookie)
	return MakeCurrentCookie{cookie}
}

// Request reply for MakeCurrent
// size: 32
type MakeCurrentReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextTag ContextTag
	// padding: 20 bytes
}

// Waits and reads reply data from request MakeCurrent
func (cook MakeCurrentCookie) Reply() (*MakeCurrentReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return makeCurrentReply(buf), nil
}

// Read reply into structure from buffer for MakeCurrent
func makeCurrentReply(buf []byte) *MakeCurrentReply {
	v := new(MakeCurrentReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextTag = ContextTag(xgb.Get32(buf[b:]))
	b += 4

	b += 20 // padding

	return v
}

// Write request to wire for MakeCurrent
func makeCurrentRequest(c *xgb.Conn, Drawable Drawable, Context Context, OldContextTag ContextTag) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Context))
	b += 4

	xgb.Put32(buf[b:], uint32(OldContextTag))
	b += 4

	return buf
}

// Request IsDirect
// size: 8
type IsDirectCookie struct {
	*xgb.Cookie
}

func IsDirect(c *xgb.Conn, Context Context) IsDirectCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(isDirectRequest(c, Context), cookie)
	return IsDirectCookie{cookie}
}

func IsDirectUnchecked(c *xgb.Conn, Context Context) IsDirectCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(isDirectRequest(c, Context), cookie)
	return IsDirectCookie{cookie}
}

// Request reply for IsDirect
// size: 32
type IsDirectReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	IsDirect bool
	// padding: 23 bytes
}

// Waits and reads reply data from request IsDirect
func (cook IsDirectCookie) Reply() (*IsDirectReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return isDirectReply(buf), nil
}

// Read reply into structure from buffer for IsDirect
func isDirectReply(buf []byte) *IsDirectReply {
	v := new(IsDirectReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	if buf[b] == 1 {
		v.IsDirect = true
	} else {
		v.IsDirect = false
	}
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for IsDirect
func isDirectRequest(c *xgb.Conn, Context Context) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Context))
	b += 4

	return buf
}

// Request QueryVersion
// size: 12
type QueryVersionCookie struct {
	*xgb.Cookie
}

func QueryVersion(c *xgb.Conn, MajorVersion uint32, MinorVersion uint32) QueryVersionCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryVersionRequest(c, MajorVersion, MinorVersion), cookie)
	return QueryVersionCookie{cookie}
}

func QueryVersionUnchecked(c *xgb.Conn, MajorVersion uint32, MinorVersion uint32) QueryVersionCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryVersionRequest(c, MajorVersion, MinorVersion), cookie)
	return QueryVersionCookie{cookie}
}

// Request reply for QueryVersion
// size: 32
type QueryVersionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	MajorVersion uint32
	MinorVersion uint32
	// padding: 16 bytes
}

// Waits and reads reply data from request QueryVersion
func (cook QueryVersionCookie) Reply() (*QueryVersionReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryVersionReply(buf), nil
}

// Read reply into structure from buffer for QueryVersion
func queryVersionReply(buf []byte) *QueryVersionReply {
	v := new(QueryVersionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.MajorVersion = xgb.Get32(buf[b:])
	b += 4

	v.MinorVersion = xgb.Get32(buf[b:])
	b += 4

	b += 16 // padding

	return v
}

// Write request to wire for QueryVersion
func queryVersionRequest(c *xgb.Conn, MajorVersion uint32, MinorVersion uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], MajorVersion)
	b += 4

	xgb.Put32(buf[b:], MinorVersion)
	b += 4

	return buf
}

// Request WaitGL
// size: 8
type WaitGLCookie struct {
	*xgb.Cookie
}

// Write request to wire for WaitGL
func WaitGL(c *xgb.Conn, ContextTag ContextTag) WaitGLCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(waitGLRequest(c, ContextTag), cookie)
	return WaitGLCookie{cookie}
}

func WaitGLChecked(c *xgb.Conn, ContextTag ContextTag) WaitGLCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(waitGLRequest(c, ContextTag), cookie)
	return WaitGLCookie{cookie}
}

func (cook WaitGLCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for WaitGL
func waitGLRequest(c *xgb.Conn, ContextTag ContextTag) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 8 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	return buf
}

// Request WaitX
// size: 8
type WaitXCookie struct {
	*xgb.Cookie
}

// Write request to wire for WaitX
func WaitX(c *xgb.Conn, ContextTag ContextTag) WaitXCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(waitXRequest(c, ContextTag), cookie)
	return WaitXCookie{cookie}
}

func WaitXChecked(c *xgb.Conn, ContextTag ContextTag) WaitXCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(waitXRequest(c, ContextTag), cookie)
	return WaitXCookie{cookie}
}

func (cook WaitXCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for WaitX
func waitXRequest(c *xgb.Conn, ContextTag ContextTag) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 9 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	return buf
}

// Request CopyContext
// size: 20
type CopyContextCookie struct {
	*xgb.Cookie
}

// Write request to wire for CopyContext
func CopyContext(c *xgb.Conn, Src Context, Dest Context, Mask uint32, SrcContextTag ContextTag) CopyContextCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(copyContextRequest(c, Src, Dest, Mask, SrcContextTag), cookie)
	return CopyContextCookie{cookie}
}

func CopyContextChecked(c *xgb.Conn, Src Context, Dest Context, Mask uint32, SrcContextTag ContextTag) CopyContextCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(copyContextRequest(c, Src, Dest, Mask, SrcContextTag), cookie)
	return CopyContextCookie{cookie}
}

func (cook CopyContextCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CopyContext
func copyContextRequest(c *xgb.Conn, Src Context, Dest Context, Mask uint32, SrcContextTag ContextTag) []byte {
	size := 20
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 10 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Src))
	b += 4

	xgb.Put32(buf[b:], uint32(Dest))
	b += 4

	xgb.Put32(buf[b:], Mask)
	b += 4

	xgb.Put32(buf[b:], uint32(SrcContextTag))
	b += 4

	return buf
}

// Request SwapBuffers
// size: 12
type SwapBuffersCookie struct {
	*xgb.Cookie
}

// Write request to wire for SwapBuffers
func SwapBuffers(c *xgb.Conn, ContextTag ContextTag, Drawable Drawable) SwapBuffersCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(swapBuffersRequest(c, ContextTag, Drawable), cookie)
	return SwapBuffersCookie{cookie}
}

func SwapBuffersChecked(c *xgb.Conn, ContextTag ContextTag, Drawable Drawable) SwapBuffersCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(swapBuffersRequest(c, ContextTag, Drawable), cookie)
	return SwapBuffersCookie{cookie}
}

func (cook SwapBuffersCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SwapBuffers
func swapBuffersRequest(c *xgb.Conn, ContextTag ContextTag, Drawable Drawable) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 11 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	return buf
}

// Request UseXFont
// size: 24
type UseXFontCookie struct {
	*xgb.Cookie
}

// Write request to wire for UseXFont
func UseXFont(c *xgb.Conn, ContextTag ContextTag, Font xproto.Font, First uint32, Count uint32, ListBase uint32) UseXFontCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(useXFontRequest(c, ContextTag, Font, First, Count, ListBase), cookie)
	return UseXFontCookie{cookie}
}

func UseXFontChecked(c *xgb.Conn, ContextTag ContextTag, Font xproto.Font, First uint32, Count uint32, ListBase uint32) UseXFontCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(useXFontRequest(c, ContextTag, Font, First, Count, ListBase), cookie)
	return UseXFontCookie{cookie}
}

func (cook UseXFontCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UseXFont
func useXFontRequest(c *xgb.Conn, ContextTag ContextTag, Font xproto.Font, First uint32, Count uint32, ListBase uint32) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 12 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], uint32(Font))
	b += 4

	xgb.Put32(buf[b:], First)
	b += 4

	xgb.Put32(buf[b:], Count)
	b += 4

	xgb.Put32(buf[b:], ListBase)
	b += 4

	return buf
}

// Request CreateGLXPixmap
// size: 20
type CreateGLXPixmapCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateGLXPixmap
func CreateGLXPixmap(c *xgb.Conn, Screen uint32, Visual xproto.Visualid, Pixmap xproto.Pixmap, GlxPixmap Pixmap) CreateGLXPixmapCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createGLXPixmapRequest(c, Screen, Visual, Pixmap, GlxPixmap), cookie)
	return CreateGLXPixmapCookie{cookie}
}

func CreateGLXPixmapChecked(c *xgb.Conn, Screen uint32, Visual xproto.Visualid, Pixmap xproto.Pixmap, GlxPixmap Pixmap) CreateGLXPixmapCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createGLXPixmapRequest(c, Screen, Visual, Pixmap, GlxPixmap), cookie)
	return CreateGLXPixmapCookie{cookie}
}

func (cook CreateGLXPixmapCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateGLXPixmap
func createGLXPixmapRequest(c *xgb.Conn, Screen uint32, Visual xproto.Visualid, Pixmap xproto.Pixmap, GlxPixmap Pixmap) []byte {
	size := 20
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 13 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	xgb.Put32(buf[b:], uint32(Visual))
	b += 4

	xgb.Put32(buf[b:], uint32(Pixmap))
	b += 4

	xgb.Put32(buf[b:], uint32(GlxPixmap))
	b += 4

	return buf
}

// Request GetVisualConfigs
// size: 8
type GetVisualConfigsCookie struct {
	*xgb.Cookie
}

func GetVisualConfigs(c *xgb.Conn, Screen uint32) GetVisualConfigsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getVisualConfigsRequest(c, Screen), cookie)
	return GetVisualConfigsCookie{cookie}
}

func GetVisualConfigsUnchecked(c *xgb.Conn, Screen uint32) GetVisualConfigsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getVisualConfigsRequest(c, Screen), cookie)
	return GetVisualConfigsCookie{cookie}
}

// Request reply for GetVisualConfigs
// size: (32 + xgb.Pad((int(Length) * 4)))
type GetVisualConfigsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumVisuals    uint32
	NumProperties uint32
	// padding: 16 bytes
	PropertyList []uint32 // size: xgb.Pad((int(Length) * 4))
}

// Waits and reads reply data from request GetVisualConfigs
func (cook GetVisualConfigsCookie) Reply() (*GetVisualConfigsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getVisualConfigsReply(buf), nil
}

// Read reply into structure from buffer for GetVisualConfigs
func getVisualConfigsReply(buf []byte) *GetVisualConfigsReply {
	v := new(GetVisualConfigsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumVisuals = xgb.Get32(buf[b:])
	b += 4

	v.NumProperties = xgb.Get32(buf[b:])
	b += 4

	b += 16 // padding

	v.PropertyList = make([]uint32, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.PropertyList[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetVisualConfigs
func getVisualConfigsRequest(c *xgb.Conn, Screen uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 14 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	return buf
}

// Request DestroyGLXPixmap
// size: 8
type DestroyGLXPixmapCookie struct {
	*xgb.Cookie
}

// Write request to wire for DestroyGLXPixmap
func DestroyGLXPixmap(c *xgb.Conn, GlxPixmap Pixmap) DestroyGLXPixmapCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroyGLXPixmapRequest(c, GlxPixmap), cookie)
	return DestroyGLXPixmapCookie{cookie}
}

func DestroyGLXPixmapChecked(c *xgb.Conn, GlxPixmap Pixmap) DestroyGLXPixmapCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroyGLXPixmapRequest(c, GlxPixmap), cookie)
	return DestroyGLXPixmapCookie{cookie}
}

func (cook DestroyGLXPixmapCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroyGLXPixmap
func destroyGLXPixmapRequest(c *xgb.Conn, GlxPixmap Pixmap) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 15 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GlxPixmap))
	b += 4

	return buf
}

// Request VendorPrivate
// size: xgb.Pad((12 + xgb.Pad((len(Data) * 1))))
type VendorPrivateCookie struct {
	*xgb.Cookie
}

// Write request to wire for VendorPrivate
func VendorPrivate(c *xgb.Conn, VendorCode uint32, ContextTag ContextTag, Data []byte) VendorPrivateCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(vendorPrivateRequest(c, VendorCode, ContextTag, Data), cookie)
	return VendorPrivateCookie{cookie}
}

func VendorPrivateChecked(c *xgb.Conn, VendorCode uint32, ContextTag ContextTag, Data []byte) VendorPrivateCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(vendorPrivateRequest(c, VendorCode, ContextTag, Data), cookie)
	return VendorPrivateCookie{cookie}
}

func (cook VendorPrivateCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for VendorPrivate
func vendorPrivateRequest(c *xgb.Conn, VendorCode uint32, ContextTag ContextTag, Data []byte) []byte {
	size := xgb.Pad((12 + xgb.Pad((len(Data) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 16 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], VendorCode)
	b += 4

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	copy(buf[b:], Data[:len(Data)])
	b += xgb.Pad(int(len(Data)))

	return buf
}

// Request VendorPrivateWithReply
// size: xgb.Pad((12 + xgb.Pad((len(Data) * 1))))
type VendorPrivateWithReplyCookie struct {
	*xgb.Cookie
}

func VendorPrivateWithReply(c *xgb.Conn, VendorCode uint32, ContextTag ContextTag, Data []byte) VendorPrivateWithReplyCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(vendorPrivateWithReplyRequest(c, VendorCode, ContextTag, Data), cookie)
	return VendorPrivateWithReplyCookie{cookie}
}

func VendorPrivateWithReplyUnchecked(c *xgb.Conn, VendorCode uint32, ContextTag ContextTag, Data []byte) VendorPrivateWithReplyCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(vendorPrivateWithReplyRequest(c, VendorCode, ContextTag, Data), cookie)
	return VendorPrivateWithReplyCookie{cookie}
}

// Request reply for VendorPrivateWithReply
// size: (36 + xgb.Pad(((int(Length) * 4) * 1)))
type VendorPrivateWithReplyReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Retval uint32
	Data1  []byte // size: 24
	Data2  []byte // size: xgb.Pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request VendorPrivateWithReply
func (cook VendorPrivateWithReplyCookie) Reply() (*VendorPrivateWithReplyReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return vendorPrivateWithReplyReply(buf), nil
}

// Read reply into structure from buffer for VendorPrivateWithReply
func vendorPrivateWithReplyReply(buf []byte) *VendorPrivateWithReplyReply {
	v := new(VendorPrivateWithReplyReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Retval = xgb.Get32(buf[b:])
	b += 4

	v.Data1 = make([]byte, 24)
	copy(v.Data1[:24], buf[b:])
	b += xgb.Pad(int(24))

	v.Data2 = make([]byte, (int(v.Length) * 4))
	copy(v.Data2[:(int(v.Length)*4)], buf[b:])
	b += xgb.Pad(int((int(v.Length) * 4)))

	return v
}

// Write request to wire for VendorPrivateWithReply
func vendorPrivateWithReplyRequest(c *xgb.Conn, VendorCode uint32, ContextTag ContextTag, Data []byte) []byte {
	size := xgb.Pad((12 + xgb.Pad((len(Data) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 17 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], VendorCode)
	b += 4

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	copy(buf[b:], Data[:len(Data)])
	b += xgb.Pad(int(len(Data)))

	return buf
}

// Request QueryExtensionsString
// size: 8
type QueryExtensionsStringCookie struct {
	*xgb.Cookie
}

func QueryExtensionsString(c *xgb.Conn, Screen uint32) QueryExtensionsStringCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryExtensionsStringRequest(c, Screen), cookie)
	return QueryExtensionsStringCookie{cookie}
}

func QueryExtensionsStringUnchecked(c *xgb.Conn, Screen uint32) QueryExtensionsStringCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryExtensionsStringRequest(c, Screen), cookie)
	return QueryExtensionsStringCookie{cookie}
}

// Request reply for QueryExtensionsString
// size: 32
type QueryExtensionsStringReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N uint32
	// padding: 16 bytes
}

// Waits and reads reply data from request QueryExtensionsString
func (cook QueryExtensionsStringCookie) Reply() (*QueryExtensionsStringReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryExtensionsStringReply(buf), nil
}

// Read reply into structure from buffer for QueryExtensionsString
func queryExtensionsStringReply(buf []byte) *QueryExtensionsStringReply {
	v := new(QueryExtensionsStringReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	b += 16 // padding

	return v
}

// Write request to wire for QueryExtensionsString
func queryExtensionsStringRequest(c *xgb.Conn, Screen uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 18 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	return buf
}

// Request QueryServerString
// size: 12
type QueryServerStringCookie struct {
	*xgb.Cookie
}

func QueryServerString(c *xgb.Conn, Screen uint32, Name uint32) QueryServerStringCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryServerStringRequest(c, Screen, Name), cookie)
	return QueryServerStringCookie{cookie}
}

func QueryServerStringUnchecked(c *xgb.Conn, Screen uint32, Name uint32) QueryServerStringCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryServerStringRequest(c, Screen, Name), cookie)
	return QueryServerStringCookie{cookie}
}

// Request reply for QueryServerString
// size: (32 + xgb.Pad((int(StrLen) * 1)))
type QueryServerStringReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	StrLen uint32
	// padding: 16 bytes
	String string // size: xgb.Pad((int(StrLen) * 1))
}

// Waits and reads reply data from request QueryServerString
func (cook QueryServerStringCookie) Reply() (*QueryServerStringReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryServerStringReply(buf), nil
}

// Read reply into structure from buffer for QueryServerString
func queryServerStringReply(buf []byte) *QueryServerStringReply {
	v := new(QueryServerStringReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.StrLen = xgb.Get32(buf[b:])
	b += 4

	b += 16 // padding

	{
		byteString := make([]byte, v.StrLen)
		copy(byteString[:v.StrLen], buf[b:])
		v.String = string(byteString)
		b += xgb.Pad(int(v.StrLen))
	}

	return v
}

// Write request to wire for QueryServerString
func queryServerStringRequest(c *xgb.Conn, Screen uint32, Name uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 19 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	xgb.Put32(buf[b:], Name)
	b += 4

	return buf
}

// Request ClientInfo
// size: xgb.Pad((16 + xgb.Pad((int(StrLen) * 1))))
type ClientInfoCookie struct {
	*xgb.Cookie
}

// Write request to wire for ClientInfo
func ClientInfo(c *xgb.Conn, MajorVersion uint32, MinorVersion uint32, StrLen uint32, String string) ClientInfoCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(clientInfoRequest(c, MajorVersion, MinorVersion, StrLen, String), cookie)
	return ClientInfoCookie{cookie}
}

func ClientInfoChecked(c *xgb.Conn, MajorVersion uint32, MinorVersion uint32, StrLen uint32, String string) ClientInfoCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(clientInfoRequest(c, MajorVersion, MinorVersion, StrLen, String), cookie)
	return ClientInfoCookie{cookie}
}

func (cook ClientInfoCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ClientInfo
func clientInfoRequest(c *xgb.Conn, MajorVersion uint32, MinorVersion uint32, StrLen uint32, String string) []byte {
	size := xgb.Pad((16 + xgb.Pad((int(StrLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 20 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], MajorVersion)
	b += 4

	xgb.Put32(buf[b:], MinorVersion)
	b += 4

	xgb.Put32(buf[b:], StrLen)
	b += 4

	copy(buf[b:], String[:StrLen])
	b += xgb.Pad(int(StrLen))

	return buf
}

// Request GetFBConfigs
// size: 8
type GetFBConfigsCookie struct {
	*xgb.Cookie
}

func GetFBConfigs(c *xgb.Conn, Screen uint32) GetFBConfigsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getFBConfigsRequest(c, Screen), cookie)
	return GetFBConfigsCookie{cookie}
}

func GetFBConfigsUnchecked(c *xgb.Conn, Screen uint32) GetFBConfigsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getFBConfigsRequest(c, Screen), cookie)
	return GetFBConfigsCookie{cookie}
}

// Request reply for GetFBConfigs
// size: (32 + xgb.Pad((int(Length) * 4)))
type GetFBConfigsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumFbConfigs  uint32
	NumProperties uint32
	// padding: 16 bytes
	PropertyList []uint32 // size: xgb.Pad((int(Length) * 4))
}

// Waits and reads reply data from request GetFBConfigs
func (cook GetFBConfigsCookie) Reply() (*GetFBConfigsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getFBConfigsReply(buf), nil
}

// Read reply into structure from buffer for GetFBConfigs
func getFBConfigsReply(buf []byte) *GetFBConfigsReply {
	v := new(GetFBConfigsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumFbConfigs = xgb.Get32(buf[b:])
	b += 4

	v.NumProperties = xgb.Get32(buf[b:])
	b += 4

	b += 16 // padding

	v.PropertyList = make([]uint32, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.PropertyList[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetFBConfigs
func getFBConfigsRequest(c *xgb.Conn, Screen uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 21 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	return buf
}

// Request CreatePixmap
// size: xgb.Pad((24 + xgb.Pad(((int(NumAttribs) * 2) * 4))))
type CreatePixmapCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreatePixmap
func CreatePixmap(c *xgb.Conn, Screen uint32, Fbconfig Fbconfig, Pixmap xproto.Pixmap, GlxPixmap Pixmap, NumAttribs uint32, Attribs []uint32) CreatePixmapCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createPixmapRequest(c, Screen, Fbconfig, Pixmap, GlxPixmap, NumAttribs, Attribs), cookie)
	return CreatePixmapCookie{cookie}
}

func CreatePixmapChecked(c *xgb.Conn, Screen uint32, Fbconfig Fbconfig, Pixmap xproto.Pixmap, GlxPixmap Pixmap, NumAttribs uint32, Attribs []uint32) CreatePixmapCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createPixmapRequest(c, Screen, Fbconfig, Pixmap, GlxPixmap, NumAttribs, Attribs), cookie)
	return CreatePixmapCookie{cookie}
}

func (cook CreatePixmapCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreatePixmap
func createPixmapRequest(c *xgb.Conn, Screen uint32, Fbconfig Fbconfig, Pixmap xproto.Pixmap, GlxPixmap Pixmap, NumAttribs uint32, Attribs []uint32) []byte {
	size := xgb.Pad((24 + xgb.Pad(((int(NumAttribs) * 2) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 22 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	xgb.Put32(buf[b:], uint32(Fbconfig))
	b += 4

	xgb.Put32(buf[b:], uint32(Pixmap))
	b += 4

	xgb.Put32(buf[b:], uint32(GlxPixmap))
	b += 4

	xgb.Put32(buf[b:], NumAttribs)
	b += 4

	for i := 0; i < int((int(NumAttribs) * 2)); i++ {
		xgb.Put32(buf[b:], Attribs[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request DestroyPixmap
// size: 8
type DestroyPixmapCookie struct {
	*xgb.Cookie
}

// Write request to wire for DestroyPixmap
func DestroyPixmap(c *xgb.Conn, GlxPixmap Pixmap) DestroyPixmapCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroyPixmapRequest(c, GlxPixmap), cookie)
	return DestroyPixmapCookie{cookie}
}

func DestroyPixmapChecked(c *xgb.Conn, GlxPixmap Pixmap) DestroyPixmapCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroyPixmapRequest(c, GlxPixmap), cookie)
	return DestroyPixmapCookie{cookie}
}

func (cook DestroyPixmapCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroyPixmap
func destroyPixmapRequest(c *xgb.Conn, GlxPixmap Pixmap) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 23 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GlxPixmap))
	b += 4

	return buf
}

// Request CreateNewContext
// size: 28
type CreateNewContextCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateNewContext
func CreateNewContext(c *xgb.Conn, Context Context, Fbconfig Fbconfig, Screen uint32, RenderType uint32, ShareList Context, IsDirect bool) CreateNewContextCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createNewContextRequest(c, Context, Fbconfig, Screen, RenderType, ShareList, IsDirect), cookie)
	return CreateNewContextCookie{cookie}
}

func CreateNewContextChecked(c *xgb.Conn, Context Context, Fbconfig Fbconfig, Screen uint32, RenderType uint32, ShareList Context, IsDirect bool) CreateNewContextCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createNewContextRequest(c, Context, Fbconfig, Screen, RenderType, ShareList, IsDirect), cookie)
	return CreateNewContextCookie{cookie}
}

func (cook CreateNewContextCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateNewContext
func createNewContextRequest(c *xgb.Conn, Context Context, Fbconfig Fbconfig, Screen uint32, RenderType uint32, ShareList Context, IsDirect bool) []byte {
	size := 28
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 24 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Context))
	b += 4

	xgb.Put32(buf[b:], uint32(Fbconfig))
	b += 4

	xgb.Put32(buf[b:], Screen)
	b += 4

	xgb.Put32(buf[b:], RenderType)
	b += 4

	xgb.Put32(buf[b:], uint32(ShareList))
	b += 4

	if IsDirect {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 3 // padding

	return buf
}

// Request QueryContext
// size: 8
type QueryContextCookie struct {
	*xgb.Cookie
}

func QueryContext(c *xgb.Conn, Context Context) QueryContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryContextRequest(c, Context), cookie)
	return QueryContextCookie{cookie}
}

func QueryContextUnchecked(c *xgb.Conn, Context Context) QueryContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryContextRequest(c, Context), cookie)
	return QueryContextCookie{cookie}
}

// Request reply for QueryContext
// size: (32 + xgb.Pad(((int(NumAttribs) * 2) * 4)))
type QueryContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumAttribs uint32
	// padding: 20 bytes
	Attribs []uint32 // size: xgb.Pad(((int(NumAttribs) * 2) * 4))
}

// Waits and reads reply data from request QueryContext
func (cook QueryContextCookie) Reply() (*QueryContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryContextReply(buf), nil
}

// Read reply into structure from buffer for QueryContext
func queryContextReply(buf []byte) *QueryContextReply {
	v := new(QueryContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumAttribs = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.Attribs = make([]uint32, (int(v.NumAttribs) * 2))
	for i := 0; i < int((int(v.NumAttribs) * 2)); i++ {
		v.Attribs[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for QueryContext
func queryContextRequest(c *xgb.Conn, Context Context) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 25 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Context))
	b += 4

	return buf
}

// Request MakeContextCurrent
// size: 20
type MakeContextCurrentCookie struct {
	*xgb.Cookie
}

func MakeContextCurrent(c *xgb.Conn, OldContextTag ContextTag, Drawable Drawable, ReadDrawable Drawable, Context Context) MakeContextCurrentCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(makeContextCurrentRequest(c, OldContextTag, Drawable, ReadDrawable, Context), cookie)
	return MakeContextCurrentCookie{cookie}
}

func MakeContextCurrentUnchecked(c *xgb.Conn, OldContextTag ContextTag, Drawable Drawable, ReadDrawable Drawable, Context Context) MakeContextCurrentCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(makeContextCurrentRequest(c, OldContextTag, Drawable, ReadDrawable, Context), cookie)
	return MakeContextCurrentCookie{cookie}
}

// Request reply for MakeContextCurrent
// size: 32
type MakeContextCurrentReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextTag ContextTag
	// padding: 20 bytes
}

// Waits and reads reply data from request MakeContextCurrent
func (cook MakeContextCurrentCookie) Reply() (*MakeContextCurrentReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return makeContextCurrentReply(buf), nil
}

// Read reply into structure from buffer for MakeContextCurrent
func makeContextCurrentReply(buf []byte) *MakeContextCurrentReply {
	v := new(MakeContextCurrentReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextTag = ContextTag(xgb.Get32(buf[b:]))
	b += 4

	b += 20 // padding

	return v
}

// Write request to wire for MakeContextCurrent
func makeContextCurrentRequest(c *xgb.Conn, OldContextTag ContextTag, Drawable Drawable, ReadDrawable Drawable, Context Context) []byte {
	size := 20
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 26 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(OldContextTag))
	b += 4

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(ReadDrawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Context))
	b += 4

	return buf
}

// Request CreatePbuffer
// size: xgb.Pad((20 + xgb.Pad(((int(NumAttribs) * 2) * 4))))
type CreatePbufferCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreatePbuffer
func CreatePbuffer(c *xgb.Conn, Screen uint32, Fbconfig Fbconfig, Pbuffer Pbuffer, NumAttribs uint32, Attribs []uint32) CreatePbufferCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createPbufferRequest(c, Screen, Fbconfig, Pbuffer, NumAttribs, Attribs), cookie)
	return CreatePbufferCookie{cookie}
}

func CreatePbufferChecked(c *xgb.Conn, Screen uint32, Fbconfig Fbconfig, Pbuffer Pbuffer, NumAttribs uint32, Attribs []uint32) CreatePbufferCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createPbufferRequest(c, Screen, Fbconfig, Pbuffer, NumAttribs, Attribs), cookie)
	return CreatePbufferCookie{cookie}
}

func (cook CreatePbufferCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreatePbuffer
func createPbufferRequest(c *xgb.Conn, Screen uint32, Fbconfig Fbconfig, Pbuffer Pbuffer, NumAttribs uint32, Attribs []uint32) []byte {
	size := xgb.Pad((20 + xgb.Pad(((int(NumAttribs) * 2) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 27 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	xgb.Put32(buf[b:], uint32(Fbconfig))
	b += 4

	xgb.Put32(buf[b:], uint32(Pbuffer))
	b += 4

	xgb.Put32(buf[b:], NumAttribs)
	b += 4

	for i := 0; i < int((int(NumAttribs) * 2)); i++ {
		xgb.Put32(buf[b:], Attribs[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request DestroyPbuffer
// size: 8
type DestroyPbufferCookie struct {
	*xgb.Cookie
}

// Write request to wire for DestroyPbuffer
func DestroyPbuffer(c *xgb.Conn, Pbuffer Pbuffer) DestroyPbufferCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroyPbufferRequest(c, Pbuffer), cookie)
	return DestroyPbufferCookie{cookie}
}

func DestroyPbufferChecked(c *xgb.Conn, Pbuffer Pbuffer) DestroyPbufferCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroyPbufferRequest(c, Pbuffer), cookie)
	return DestroyPbufferCookie{cookie}
}

func (cook DestroyPbufferCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroyPbuffer
func destroyPbufferRequest(c *xgb.Conn, Pbuffer Pbuffer) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 28 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Pbuffer))
	b += 4

	return buf
}

// Request GetDrawableAttributes
// size: 8
type GetDrawableAttributesCookie struct {
	*xgb.Cookie
}

func GetDrawableAttributes(c *xgb.Conn, Drawable Drawable) GetDrawableAttributesCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDrawableAttributesRequest(c, Drawable), cookie)
	return GetDrawableAttributesCookie{cookie}
}

func GetDrawableAttributesUnchecked(c *xgb.Conn, Drawable Drawable) GetDrawableAttributesCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDrawableAttributesRequest(c, Drawable), cookie)
	return GetDrawableAttributesCookie{cookie}
}

// Request reply for GetDrawableAttributes
// size: (32 + xgb.Pad(((int(NumAttribs) * 2) * 4)))
type GetDrawableAttributesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumAttribs uint32
	// padding: 20 bytes
	Attribs []uint32 // size: xgb.Pad(((int(NumAttribs) * 2) * 4))
}

// Waits and reads reply data from request GetDrawableAttributes
func (cook GetDrawableAttributesCookie) Reply() (*GetDrawableAttributesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDrawableAttributesReply(buf), nil
}

// Read reply into structure from buffer for GetDrawableAttributes
func getDrawableAttributesReply(buf []byte) *GetDrawableAttributesReply {
	v := new(GetDrawableAttributesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumAttribs = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.Attribs = make([]uint32, (int(v.NumAttribs) * 2))
	for i := 0; i < int((int(v.NumAttribs) * 2)); i++ {
		v.Attribs[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetDrawableAttributes
func getDrawableAttributesRequest(c *xgb.Conn, Drawable Drawable) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 29 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	return buf
}

// Request ChangeDrawableAttributes
// size: xgb.Pad((12 + xgb.Pad(((int(NumAttribs) * 2) * 4))))
type ChangeDrawableAttributesCookie struct {
	*xgb.Cookie
}

// Write request to wire for ChangeDrawableAttributes
func ChangeDrawableAttributes(c *xgb.Conn, Drawable Drawable, NumAttribs uint32, Attribs []uint32) ChangeDrawableAttributesCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeDrawableAttributesRequest(c, Drawable, NumAttribs, Attribs), cookie)
	return ChangeDrawableAttributesCookie{cookie}
}

func ChangeDrawableAttributesChecked(c *xgb.Conn, Drawable Drawable, NumAttribs uint32, Attribs []uint32) ChangeDrawableAttributesCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeDrawableAttributesRequest(c, Drawable, NumAttribs, Attribs), cookie)
	return ChangeDrawableAttributesCookie{cookie}
}

func (cook ChangeDrawableAttributesCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeDrawableAttributes
func changeDrawableAttributesRequest(c *xgb.Conn, Drawable Drawable, NumAttribs uint32, Attribs []uint32) []byte {
	size := xgb.Pad((12 + xgb.Pad(((int(NumAttribs) * 2) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 30 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], NumAttribs)
	b += 4

	for i := 0; i < int((int(NumAttribs) * 2)); i++ {
		xgb.Put32(buf[b:], Attribs[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request CreateWindow
// size: xgb.Pad((24 + xgb.Pad(((int(NumAttribs) * 2) * 4))))
type CreateWindowCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateWindow
func CreateWindow(c *xgb.Conn, Screen uint32, Fbconfig Fbconfig, Window xproto.Window, GlxWindow Window, NumAttribs uint32, Attribs []uint32) CreateWindowCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createWindowRequest(c, Screen, Fbconfig, Window, GlxWindow, NumAttribs, Attribs), cookie)
	return CreateWindowCookie{cookie}
}

func CreateWindowChecked(c *xgb.Conn, Screen uint32, Fbconfig Fbconfig, Window xproto.Window, GlxWindow Window, NumAttribs uint32, Attribs []uint32) CreateWindowCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createWindowRequest(c, Screen, Fbconfig, Window, GlxWindow, NumAttribs, Attribs), cookie)
	return CreateWindowCookie{cookie}
}

func (cook CreateWindowCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateWindow
func createWindowRequest(c *xgb.Conn, Screen uint32, Fbconfig Fbconfig, Window xproto.Window, GlxWindow Window, NumAttribs uint32, Attribs []uint32) []byte {
	size := xgb.Pad((24 + xgb.Pad(((int(NumAttribs) * 2) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 31 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	xgb.Put32(buf[b:], uint32(Fbconfig))
	b += 4

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put32(buf[b:], uint32(GlxWindow))
	b += 4

	xgb.Put32(buf[b:], NumAttribs)
	b += 4

	for i := 0; i < int((int(NumAttribs) * 2)); i++ {
		xgb.Put32(buf[b:], Attribs[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request DeleteWindow
// size: 8
type DeleteWindowCookie struct {
	*xgb.Cookie
}

// Write request to wire for DeleteWindow
func DeleteWindow(c *xgb.Conn, Glxwindow Window) DeleteWindowCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(deleteWindowRequest(c, Glxwindow), cookie)
	return DeleteWindowCookie{cookie}
}

func DeleteWindowChecked(c *xgb.Conn, Glxwindow Window) DeleteWindowCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(deleteWindowRequest(c, Glxwindow), cookie)
	return DeleteWindowCookie{cookie}
}

func (cook DeleteWindowCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DeleteWindow
func deleteWindowRequest(c *xgb.Conn, Glxwindow Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 32 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Glxwindow))
	b += 4

	return buf
}

// Request SetClientInfoARB
// size: xgb.Pad((((24 + xgb.Pad(((int(NumVersions) * 2) * 4))) + xgb.Pad((int(GlStrLen) * 1))) + xgb.Pad((int(GlxStrLen) * 1))))
type SetClientInfoARBCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetClientInfoARB
func SetClientInfoARB(c *xgb.Conn, MajorVersion uint32, MinorVersion uint32, NumVersions uint32, GlStrLen uint32, GlxStrLen uint32, GlVersions []uint32, GlExtensionString string, GlxExtensionString string) SetClientInfoARBCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setClientInfoARBRequest(c, MajorVersion, MinorVersion, NumVersions, GlStrLen, GlxStrLen, GlVersions, GlExtensionString, GlxExtensionString), cookie)
	return SetClientInfoARBCookie{cookie}
}

func SetClientInfoARBChecked(c *xgb.Conn, MajorVersion uint32, MinorVersion uint32, NumVersions uint32, GlStrLen uint32, GlxStrLen uint32, GlVersions []uint32, GlExtensionString string, GlxExtensionString string) SetClientInfoARBCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setClientInfoARBRequest(c, MajorVersion, MinorVersion, NumVersions, GlStrLen, GlxStrLen, GlVersions, GlExtensionString, GlxExtensionString), cookie)
	return SetClientInfoARBCookie{cookie}
}

func (cook SetClientInfoARBCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetClientInfoARB
func setClientInfoARBRequest(c *xgb.Conn, MajorVersion uint32, MinorVersion uint32, NumVersions uint32, GlStrLen uint32, GlxStrLen uint32, GlVersions []uint32, GlExtensionString string, GlxExtensionString string) []byte {
	size := xgb.Pad((((24 + xgb.Pad(((int(NumVersions) * 2) * 4))) + xgb.Pad((int(GlStrLen) * 1))) + xgb.Pad((int(GlxStrLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 33 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], MajorVersion)
	b += 4

	xgb.Put32(buf[b:], MinorVersion)
	b += 4

	xgb.Put32(buf[b:], NumVersions)
	b += 4

	xgb.Put32(buf[b:], GlStrLen)
	b += 4

	xgb.Put32(buf[b:], GlxStrLen)
	b += 4

	for i := 0; i < int((int(NumVersions) * 2)); i++ {
		xgb.Put32(buf[b:], GlVersions[i])
		b += 4
	}
	b = xgb.Pad(b)

	copy(buf[b:], GlExtensionString[:GlStrLen])
	b += xgb.Pad(int(GlStrLen))

	copy(buf[b:], GlxExtensionString[:GlxStrLen])
	b += xgb.Pad(int(GlxStrLen))

	return buf
}

// Request CreateContextAttribsARB
// size: xgb.Pad((28 + xgb.Pad(((int(NumAttribs) * 2) * 4))))
type CreateContextAttribsARBCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateContextAttribsARB
func CreateContextAttribsARB(c *xgb.Conn, Context Context, Fbconfig Fbconfig, Screen uint32, ShareList Context, IsDirect bool, NumAttribs uint32, Attribs []uint32) CreateContextAttribsARBCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createContextAttribsARBRequest(c, Context, Fbconfig, Screen, ShareList, IsDirect, NumAttribs, Attribs), cookie)
	return CreateContextAttribsARBCookie{cookie}
}

func CreateContextAttribsARBChecked(c *xgb.Conn, Context Context, Fbconfig Fbconfig, Screen uint32, ShareList Context, IsDirect bool, NumAttribs uint32, Attribs []uint32) CreateContextAttribsARBCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createContextAttribsARBRequest(c, Context, Fbconfig, Screen, ShareList, IsDirect, NumAttribs, Attribs), cookie)
	return CreateContextAttribsARBCookie{cookie}
}

func (cook CreateContextAttribsARBCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateContextAttribsARB
func createContextAttribsARBRequest(c *xgb.Conn, Context Context, Fbconfig Fbconfig, Screen uint32, ShareList Context, IsDirect bool, NumAttribs uint32, Attribs []uint32) []byte {
	size := xgb.Pad((28 + xgb.Pad(((int(NumAttribs) * 2) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 34 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Context))
	b += 4

	xgb.Put32(buf[b:], uint32(Fbconfig))
	b += 4

	xgb.Put32(buf[b:], Screen)
	b += 4

	xgb.Put32(buf[b:], uint32(ShareList))
	b += 4

	if IsDirect {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], NumAttribs)
	b += 4

	for i := 0; i < int((int(NumAttribs) * 2)); i++ {
		xgb.Put32(buf[b:], Attribs[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request SetClientInfo2ARB
// size: xgb.Pad((((24 + xgb.Pad(((int(NumVersions) * 3) * 4))) + xgb.Pad((int(GlStrLen) * 1))) + xgb.Pad((int(GlxStrLen) * 1))))
type SetClientInfo2ARBCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetClientInfo2ARB
func SetClientInfo2ARB(c *xgb.Conn, MajorVersion uint32, MinorVersion uint32, NumVersions uint32, GlStrLen uint32, GlxStrLen uint32, GlVersions []uint32, GlExtensionString string, GlxExtensionString string) SetClientInfo2ARBCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setClientInfo2ARBRequest(c, MajorVersion, MinorVersion, NumVersions, GlStrLen, GlxStrLen, GlVersions, GlExtensionString, GlxExtensionString), cookie)
	return SetClientInfo2ARBCookie{cookie}
}

func SetClientInfo2ARBChecked(c *xgb.Conn, MajorVersion uint32, MinorVersion uint32, NumVersions uint32, GlStrLen uint32, GlxStrLen uint32, GlVersions []uint32, GlExtensionString string, GlxExtensionString string) SetClientInfo2ARBCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setClientInfo2ARBRequest(c, MajorVersion, MinorVersion, NumVersions, GlStrLen, GlxStrLen, GlVersions, GlExtensionString, GlxExtensionString), cookie)
	return SetClientInfo2ARBCookie{cookie}
}

func (cook SetClientInfo2ARBCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetClientInfo2ARB
func setClientInfo2ARBRequest(c *xgb.Conn, MajorVersion uint32, MinorVersion uint32, NumVersions uint32, GlStrLen uint32, GlxStrLen uint32, GlVersions []uint32, GlExtensionString string, GlxExtensionString string) []byte {
	size := xgb.Pad((((24 + xgb.Pad(((int(NumVersions) * 3) * 4))) + xgb.Pad((int(GlStrLen) * 1))) + xgb.Pad((int(GlxStrLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 35 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], MajorVersion)
	b += 4

	xgb.Put32(buf[b:], MinorVersion)
	b += 4

	xgb.Put32(buf[b:], NumVersions)
	b += 4

	xgb.Put32(buf[b:], GlStrLen)
	b += 4

	xgb.Put32(buf[b:], GlxStrLen)
	b += 4

	for i := 0; i < int((int(NumVersions) * 3)); i++ {
		xgb.Put32(buf[b:], GlVersions[i])
		b += 4
	}
	b = xgb.Pad(b)

	copy(buf[b:], GlExtensionString[:GlStrLen])
	b += xgb.Pad(int(GlStrLen))

	copy(buf[b:], GlxExtensionString[:GlxStrLen])
	b += xgb.Pad(int(GlxStrLen))

	return buf
}

// Request NewList
// size: 16
type NewListCookie struct {
	*xgb.Cookie
}

// Write request to wire for NewList
func NewList(c *xgb.Conn, ContextTag ContextTag, List uint32, Mode uint32) NewListCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(newListRequest(c, ContextTag, List, Mode), cookie)
	return NewListCookie{cookie}
}

func NewListChecked(c *xgb.Conn, ContextTag ContextTag, List uint32, Mode uint32) NewListCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(newListRequest(c, ContextTag, List, Mode), cookie)
	return NewListCookie{cookie}
}

func (cook NewListCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for NewList
func newListRequest(c *xgb.Conn, ContextTag ContextTag, List uint32, Mode uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 101 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], List)
	b += 4

	xgb.Put32(buf[b:], Mode)
	b += 4

	return buf
}

// Request EndList
// size: 8
type EndListCookie struct {
	*xgb.Cookie
}

// Write request to wire for EndList
func EndList(c *xgb.Conn, ContextTag ContextTag) EndListCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(endListRequest(c, ContextTag), cookie)
	return EndListCookie{cookie}
}

func EndListChecked(c *xgb.Conn, ContextTag ContextTag) EndListCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(endListRequest(c, ContextTag), cookie)
	return EndListCookie{cookie}
}

func (cook EndListCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for EndList
func endListRequest(c *xgb.Conn, ContextTag ContextTag) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 102 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	return buf
}

// Request DeleteLists
// size: 16
type DeleteListsCookie struct {
	*xgb.Cookie
}

// Write request to wire for DeleteLists
func DeleteLists(c *xgb.Conn, ContextTag ContextTag, List uint32, Range int32) DeleteListsCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(deleteListsRequest(c, ContextTag, List, Range), cookie)
	return DeleteListsCookie{cookie}
}

func DeleteListsChecked(c *xgb.Conn, ContextTag ContextTag, List uint32, Range int32) DeleteListsCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(deleteListsRequest(c, ContextTag, List, Range), cookie)
	return DeleteListsCookie{cookie}
}

func (cook DeleteListsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DeleteLists
func deleteListsRequest(c *xgb.Conn, ContextTag ContextTag, List uint32, Range int32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 103 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], List)
	b += 4

	xgb.Put32(buf[b:], uint32(Range))
	b += 4

	return buf
}

// Request GenLists
// size: 12
type GenListsCookie struct {
	*xgb.Cookie
}

func GenLists(c *xgb.Conn, ContextTag ContextTag, Range int32) GenListsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(genListsRequest(c, ContextTag, Range), cookie)
	return GenListsCookie{cookie}
}

func GenListsUnchecked(c *xgb.Conn, ContextTag ContextTag, Range int32) GenListsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(genListsRequest(c, ContextTag, Range), cookie)
	return GenListsCookie{cookie}
}

// Request reply for GenLists
// size: 12
type GenListsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	RetVal uint32
}

// Waits and reads reply data from request GenLists
func (cook GenListsCookie) Reply() (*GenListsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return genListsReply(buf), nil
}

// Read reply into structure from buffer for GenLists
func genListsReply(buf []byte) *GenListsReply {
	v := new(GenListsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.RetVal = xgb.Get32(buf[b:])
	b += 4

	return v
}

// Write request to wire for GenLists
func genListsRequest(c *xgb.Conn, ContextTag ContextTag, Range int32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 104 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], uint32(Range))
	b += 4

	return buf
}

// Request FeedbackBuffer
// size: 16
type FeedbackBufferCookie struct {
	*xgb.Cookie
}

// Write request to wire for FeedbackBuffer
func FeedbackBuffer(c *xgb.Conn, ContextTag ContextTag, Size int32, Type int32) FeedbackBufferCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(feedbackBufferRequest(c, ContextTag, Size, Type), cookie)
	return FeedbackBufferCookie{cookie}
}

func FeedbackBufferChecked(c *xgb.Conn, ContextTag ContextTag, Size int32, Type int32) FeedbackBufferCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(feedbackBufferRequest(c, ContextTag, Size, Type), cookie)
	return FeedbackBufferCookie{cookie}
}

func (cook FeedbackBufferCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for FeedbackBuffer
func feedbackBufferRequest(c *xgb.Conn, ContextTag ContextTag, Size int32, Type int32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 105 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], uint32(Size))
	b += 4

	xgb.Put32(buf[b:], uint32(Type))
	b += 4

	return buf
}

// Request SelectBuffer
// size: 12
type SelectBufferCookie struct {
	*xgb.Cookie
}

// Write request to wire for SelectBuffer
func SelectBuffer(c *xgb.Conn, ContextTag ContextTag, Size int32) SelectBufferCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(selectBufferRequest(c, ContextTag, Size), cookie)
	return SelectBufferCookie{cookie}
}

func SelectBufferChecked(c *xgb.Conn, ContextTag ContextTag, Size int32) SelectBufferCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(selectBufferRequest(c, ContextTag, Size), cookie)
	return SelectBufferCookie{cookie}
}

func (cook SelectBufferCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SelectBuffer
func selectBufferRequest(c *xgb.Conn, ContextTag ContextTag, Size int32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 106 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], uint32(Size))
	b += 4

	return buf
}

// Request RenderMode
// size: 12
type RenderModeCookie struct {
	*xgb.Cookie
}

func RenderMode(c *xgb.Conn, ContextTag ContextTag, Mode uint32) RenderModeCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(renderModeRequest(c, ContextTag, Mode), cookie)
	return RenderModeCookie{cookie}
}

func RenderModeUnchecked(c *xgb.Conn, ContextTag ContextTag, Mode uint32) RenderModeCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(renderModeRequest(c, ContextTag, Mode), cookie)
	return RenderModeCookie{cookie}
}

// Request reply for RenderMode
// size: (32 + xgb.Pad((int(N) * 4)))
type RenderModeReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	RetVal  uint32
	N       uint32
	NewMode uint32
	// padding: 12 bytes
	Data []uint32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request RenderMode
func (cook RenderModeCookie) Reply() (*RenderModeReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return renderModeReply(buf), nil
}

// Read reply into structure from buffer for RenderMode
func renderModeReply(buf []byte) *RenderModeReply {
	v := new(RenderModeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.RetVal = xgb.Get32(buf[b:])
	b += 4

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.NewMode = xgb.Get32(buf[b:])
	b += 4

	b += 12 // padding

	v.Data = make([]uint32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for RenderMode
func renderModeRequest(c *xgb.Conn, ContextTag ContextTag, Mode uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 107 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Mode)
	b += 4

	return buf
}

// Request Finish
// size: 8
type FinishCookie struct {
	*xgb.Cookie
}

func Finish(c *xgb.Conn, ContextTag ContextTag) FinishCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(finishRequest(c, ContextTag), cookie)
	return FinishCookie{cookie}
}

func FinishUnchecked(c *xgb.Conn, ContextTag ContextTag) FinishCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(finishRequest(c, ContextTag), cookie)
	return FinishCookie{cookie}
}

// Request reply for Finish
// size: 8
type FinishReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
}

// Waits and reads reply data from request Finish
func (cook FinishCookie) Reply() (*FinishReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return finishReply(buf), nil
}

// Read reply into structure from buffer for Finish
func finishReply(buf []byte) *FinishReply {
	v := new(FinishReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	return v
}

// Write request to wire for Finish
func finishRequest(c *xgb.Conn, ContextTag ContextTag) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 108 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	return buf
}

// Request PixelStoref
// size: 16
type PixelStorefCookie struct {
	*xgb.Cookie
}

// Write request to wire for PixelStoref
func PixelStoref(c *xgb.Conn, ContextTag ContextTag, Pname uint32, Datum Float32) PixelStorefCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(pixelStorefRequest(c, ContextTag, Pname, Datum), cookie)
	return PixelStorefCookie{cookie}
}

func PixelStorefChecked(c *xgb.Conn, ContextTag ContextTag, Pname uint32, Datum Float32) PixelStorefCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(pixelStorefRequest(c, ContextTag, Pname, Datum), cookie)
	return PixelStorefCookie{cookie}
}

func (cook PixelStorefCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for PixelStoref
func pixelStorefRequest(c *xgb.Conn, ContextTag ContextTag, Pname uint32, Datum Float32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 109 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	xgb.Put32(buf[b:], uint32(Datum))
	b += 4

	return buf
}

// Request PixelStorei
// size: 16
type PixelStoreiCookie struct {
	*xgb.Cookie
}

// Write request to wire for PixelStorei
func PixelStorei(c *xgb.Conn, ContextTag ContextTag, Pname uint32, Datum int32) PixelStoreiCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(pixelStoreiRequest(c, ContextTag, Pname, Datum), cookie)
	return PixelStoreiCookie{cookie}
}

func PixelStoreiChecked(c *xgb.Conn, ContextTag ContextTag, Pname uint32, Datum int32) PixelStoreiCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(pixelStoreiRequest(c, ContextTag, Pname, Datum), cookie)
	return PixelStoreiCookie{cookie}
}

func (cook PixelStoreiCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for PixelStorei
func pixelStoreiRequest(c *xgb.Conn, ContextTag ContextTag, Pname uint32, Datum int32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 110 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	xgb.Put32(buf[b:], uint32(Datum))
	b += 4

	return buf
}

// Request ReadPixels
// size: 36
type ReadPixelsCookie struct {
	*xgb.Cookie
}

func ReadPixels(c *xgb.Conn, ContextTag ContextTag, X int32, Y int32, Width int32, Height int32, Format uint32, Type uint32, SwapBytes bool, LsbFirst bool) ReadPixelsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(readPixelsRequest(c, ContextTag, X, Y, Width, Height, Format, Type, SwapBytes, LsbFirst), cookie)
	return ReadPixelsCookie{cookie}
}

func ReadPixelsUnchecked(c *xgb.Conn, ContextTag ContextTag, X int32, Y int32, Width int32, Height int32, Format uint32, Type uint32, SwapBytes bool, LsbFirst bool) ReadPixelsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(readPixelsRequest(c, ContextTag, X, Y, Width, Height, Format, Type, SwapBytes, LsbFirst), cookie)
	return ReadPixelsCookie{cookie}
}

// Request reply for ReadPixels
// size: (32 + xgb.Pad(((int(Length) * 4) * 1)))
type ReadPixelsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
	Data []byte // size: xgb.Pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request ReadPixels
func (cook ReadPixelsCookie) Reply() (*ReadPixelsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return readPixelsReply(buf), nil
}

// Read reply into structure from buffer for ReadPixels
func readPixelsReply(buf []byte) *ReadPixelsReply {
	v := new(ReadPixelsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += xgb.Pad(int((int(v.Length) * 4)))

	return v
}

// Write request to wire for ReadPixels
func readPixelsRequest(c *xgb.Conn, ContextTag ContextTag, X int32, Y int32, Width int32, Height int32, Format uint32, Type uint32, SwapBytes bool, LsbFirst bool) []byte {
	size := 36
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 111 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], uint32(X))
	b += 4

	xgb.Put32(buf[b:], uint32(Y))
	b += 4

	xgb.Put32(buf[b:], uint32(Width))
	b += 4

	xgb.Put32(buf[b:], uint32(Height))
	b += 4

	xgb.Put32(buf[b:], Format)
	b += 4

	xgb.Put32(buf[b:], Type)
	b += 4

	if SwapBytes {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	if LsbFirst {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GetBooleanv
// size: 12
type GetBooleanvCookie struct {
	*xgb.Cookie
}

func GetBooleanv(c *xgb.Conn, ContextTag ContextTag, Pname int32) GetBooleanvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getBooleanvRequest(c, ContextTag, Pname), cookie)
	return GetBooleanvCookie{cookie}
}

func GetBooleanvUnchecked(c *xgb.Conn, ContextTag ContextTag, Pname int32) GetBooleanvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getBooleanvRequest(c, ContextTag, Pname), cookie)
	return GetBooleanvCookie{cookie}
}

// Request reply for GetBooleanv
// size: (32 + xgb.Pad((int(N) * 1)))
type GetBooleanvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum bool
	// padding: 15 bytes
	Data []bool // size: xgb.Pad((int(N) * 1))
}

// Waits and reads reply data from request GetBooleanv
func (cook GetBooleanvCookie) Reply() (*GetBooleanvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getBooleanvReply(buf), nil
}

// Read reply into structure from buffer for GetBooleanv
func getBooleanvReply(buf []byte) *GetBooleanvReply {
	v := new(GetBooleanvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	if buf[b] == 1 {
		v.Datum = true
	} else {
		v.Datum = false
	}
	b += 1

	b += 15 // padding

	v.Data = make([]bool, v.N)
	for i := 0; i < int(v.N); i++ {
		if buf[b] == 1 {
			v.Data[i] = true
		} else {
			v.Data[i] = false
		}
		b += 1
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetBooleanv
func getBooleanvRequest(c *xgb.Conn, ContextTag ContextTag, Pname int32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 112 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], uint32(Pname))
	b += 4

	return buf
}

// Request GetClipPlane
// size: 12
type GetClipPlaneCookie struct {
	*xgb.Cookie
}

func GetClipPlane(c *xgb.Conn, ContextTag ContextTag, Plane int32) GetClipPlaneCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getClipPlaneRequest(c, ContextTag, Plane), cookie)
	return GetClipPlaneCookie{cookie}
}

func GetClipPlaneUnchecked(c *xgb.Conn, ContextTag ContextTag, Plane int32) GetClipPlaneCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getClipPlaneRequest(c, ContextTag, Plane), cookie)
	return GetClipPlaneCookie{cookie}
}

// Request reply for GetClipPlane
// size: (32 + xgb.Pad(((int(Length) / 2) * 8)))
type GetClipPlaneReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
	Data []Float64 // size: xgb.Pad(((int(Length) / 2) * 8))
}

// Waits and reads reply data from request GetClipPlane
func (cook GetClipPlaneCookie) Reply() (*GetClipPlaneReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getClipPlaneReply(buf), nil
}

// Read reply into structure from buffer for GetClipPlane
func getClipPlaneReply(buf []byte) *GetClipPlaneReply {
	v := new(GetClipPlaneReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.Data = make([]Float64, (int(v.Length) / 2))
	for i := 0; i < int((int(v.Length) / 2)); i++ {
		v.Data[i] = Float64(xgb.Get64(buf[b:]))
		b += 8
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetClipPlane
func getClipPlaneRequest(c *xgb.Conn, ContextTag ContextTag, Plane int32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 113 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], uint32(Plane))
	b += 4

	return buf
}

// Request GetDoublev
// size: 12
type GetDoublevCookie struct {
	*xgb.Cookie
}

func GetDoublev(c *xgb.Conn, ContextTag ContextTag, Pname uint32) GetDoublevCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDoublevRequest(c, ContextTag, Pname), cookie)
	return GetDoublevCookie{cookie}
}

func GetDoublevUnchecked(c *xgb.Conn, ContextTag ContextTag, Pname uint32) GetDoublevCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDoublevRequest(c, ContextTag, Pname), cookie)
	return GetDoublevCookie{cookie}
}

// Request reply for GetDoublev
// size: (32 + xgb.Pad((int(N) * 8)))
type GetDoublevReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum Float64
	// padding: 8 bytes
	Data []Float64 // size: xgb.Pad((int(N) * 8))
}

// Waits and reads reply data from request GetDoublev
func (cook GetDoublevCookie) Reply() (*GetDoublevReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDoublevReply(buf), nil
}

// Read reply into structure from buffer for GetDoublev
func getDoublevReply(buf []byte) *GetDoublevReply {
	v := new(GetDoublevReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = Float64(xgb.Get64(buf[b:]))
	b += 8

	b += 8 // padding

	v.Data = make([]Float64, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Float64(xgb.Get64(buf[b:]))
		b += 8
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetDoublev
func getDoublevRequest(c *xgb.Conn, ContextTag ContextTag, Pname uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 114 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetError
// size: 8
type GetErrorCookie struct {
	*xgb.Cookie
}

func GetError(c *xgb.Conn, ContextTag ContextTag) GetErrorCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getErrorRequest(c, ContextTag), cookie)
	return GetErrorCookie{cookie}
}

func GetErrorUnchecked(c *xgb.Conn, ContextTag ContextTag) GetErrorCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getErrorRequest(c, ContextTag), cookie)
	return GetErrorCookie{cookie}
}

// Request reply for GetError
// size: 12
type GetErrorReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Error int32
}

// Waits and reads reply data from request GetError
func (cook GetErrorCookie) Reply() (*GetErrorReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getErrorReply(buf), nil
}

// Read reply into structure from buffer for GetError
func getErrorReply(buf []byte) *GetErrorReply {
	v := new(GetErrorReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Error = int32(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Write request to wire for GetError
func getErrorRequest(c *xgb.Conn, ContextTag ContextTag) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 115 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	return buf
}

// Request GetFloatv
// size: 12
type GetFloatvCookie struct {
	*xgb.Cookie
}

func GetFloatv(c *xgb.Conn, ContextTag ContextTag, Pname uint32) GetFloatvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getFloatvRequest(c, ContextTag, Pname), cookie)
	return GetFloatvCookie{cookie}
}

func GetFloatvUnchecked(c *xgb.Conn, ContextTag ContextTag, Pname uint32) GetFloatvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getFloatvRequest(c, ContextTag, Pname), cookie)
	return GetFloatvCookie{cookie}
}

// Request reply for GetFloatv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetFloatvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum Float32
	// padding: 12 bytes
	Data []Float32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetFloatv
func (cook GetFloatvCookie) Reply() (*GetFloatvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getFloatvReply(buf), nil
}

// Read reply into structure from buffer for GetFloatv
func getFloatvReply(buf []byte) *GetFloatvReply {
	v := new(GetFloatvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = Float32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]Float32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Float32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetFloatv
func getFloatvRequest(c *xgb.Conn, ContextTag ContextTag, Pname uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 116 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetIntegerv
// size: 12
type GetIntegervCookie struct {
	*xgb.Cookie
}

func GetIntegerv(c *xgb.Conn, ContextTag ContextTag, Pname uint32) GetIntegervCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getIntegervRequest(c, ContextTag, Pname), cookie)
	return GetIntegervCookie{cookie}
}

func GetIntegervUnchecked(c *xgb.Conn, ContextTag ContextTag, Pname uint32) GetIntegervCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getIntegervRequest(c, ContextTag, Pname), cookie)
	return GetIntegervCookie{cookie}
}

// Request reply for GetIntegerv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetIntegervReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetIntegerv
func (cook GetIntegervCookie) Reply() (*GetIntegervReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getIntegervReply(buf), nil
}

// Read reply into structure from buffer for GetIntegerv
func getIntegervReply(buf []byte) *GetIntegervReply {
	v := new(GetIntegervReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetIntegerv
func getIntegervRequest(c *xgb.Conn, ContextTag ContextTag, Pname uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 117 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetLightfv
// size: 16
type GetLightfvCookie struct {
	*xgb.Cookie
}

func GetLightfv(c *xgb.Conn, ContextTag ContextTag, Light uint32, Pname uint32) GetLightfvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getLightfvRequest(c, ContextTag, Light, Pname), cookie)
	return GetLightfvCookie{cookie}
}

func GetLightfvUnchecked(c *xgb.Conn, ContextTag ContextTag, Light uint32, Pname uint32) GetLightfvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getLightfvRequest(c, ContextTag, Light, Pname), cookie)
	return GetLightfvCookie{cookie}
}

// Request reply for GetLightfv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetLightfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum Float32
	// padding: 12 bytes
	Data []Float32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetLightfv
func (cook GetLightfvCookie) Reply() (*GetLightfvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getLightfvReply(buf), nil
}

// Read reply into structure from buffer for GetLightfv
func getLightfvReply(buf []byte) *GetLightfvReply {
	v := new(GetLightfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = Float32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]Float32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Float32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetLightfv
func getLightfvRequest(c *xgb.Conn, ContextTag ContextTag, Light uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 118 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Light)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetLightiv
// size: 16
type GetLightivCookie struct {
	*xgb.Cookie
}

func GetLightiv(c *xgb.Conn, ContextTag ContextTag, Light uint32, Pname uint32) GetLightivCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getLightivRequest(c, ContextTag, Light, Pname), cookie)
	return GetLightivCookie{cookie}
}

func GetLightivUnchecked(c *xgb.Conn, ContextTag ContextTag, Light uint32, Pname uint32) GetLightivCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getLightivRequest(c, ContextTag, Light, Pname), cookie)
	return GetLightivCookie{cookie}
}

// Request reply for GetLightiv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetLightivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetLightiv
func (cook GetLightivCookie) Reply() (*GetLightivReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getLightivReply(buf), nil
}

// Read reply into structure from buffer for GetLightiv
func getLightivReply(buf []byte) *GetLightivReply {
	v := new(GetLightivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetLightiv
func getLightivRequest(c *xgb.Conn, ContextTag ContextTag, Light uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 119 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Light)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetMapdv
// size: 16
type GetMapdvCookie struct {
	*xgb.Cookie
}

func GetMapdv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Query uint32) GetMapdvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getMapdvRequest(c, ContextTag, Target, Query), cookie)
	return GetMapdvCookie{cookie}
}

func GetMapdvUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Query uint32) GetMapdvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getMapdvRequest(c, ContextTag, Target, Query), cookie)
	return GetMapdvCookie{cookie}
}

// Request reply for GetMapdv
// size: (32 + xgb.Pad((int(N) * 8)))
type GetMapdvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum Float64
	// padding: 8 bytes
	Data []Float64 // size: xgb.Pad((int(N) * 8))
}

// Waits and reads reply data from request GetMapdv
func (cook GetMapdvCookie) Reply() (*GetMapdvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getMapdvReply(buf), nil
}

// Read reply into structure from buffer for GetMapdv
func getMapdvReply(buf []byte) *GetMapdvReply {
	v := new(GetMapdvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = Float64(xgb.Get64(buf[b:]))
	b += 8

	b += 8 // padding

	v.Data = make([]Float64, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Float64(xgb.Get64(buf[b:]))
		b += 8
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetMapdv
func getMapdvRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Query uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 120 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Query)
	b += 4

	return buf
}

// Request GetMapfv
// size: 16
type GetMapfvCookie struct {
	*xgb.Cookie
}

func GetMapfv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Query uint32) GetMapfvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getMapfvRequest(c, ContextTag, Target, Query), cookie)
	return GetMapfvCookie{cookie}
}

func GetMapfvUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Query uint32) GetMapfvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getMapfvRequest(c, ContextTag, Target, Query), cookie)
	return GetMapfvCookie{cookie}
}

// Request reply for GetMapfv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetMapfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum Float32
	// padding: 12 bytes
	Data []Float32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetMapfv
func (cook GetMapfvCookie) Reply() (*GetMapfvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getMapfvReply(buf), nil
}

// Read reply into structure from buffer for GetMapfv
func getMapfvReply(buf []byte) *GetMapfvReply {
	v := new(GetMapfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = Float32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]Float32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Float32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetMapfv
func getMapfvRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Query uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 121 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Query)
	b += 4

	return buf
}

// Request GetMapiv
// size: 16
type GetMapivCookie struct {
	*xgb.Cookie
}

func GetMapiv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Query uint32) GetMapivCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getMapivRequest(c, ContextTag, Target, Query), cookie)
	return GetMapivCookie{cookie}
}

func GetMapivUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Query uint32) GetMapivCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getMapivRequest(c, ContextTag, Target, Query), cookie)
	return GetMapivCookie{cookie}
}

// Request reply for GetMapiv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetMapivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetMapiv
func (cook GetMapivCookie) Reply() (*GetMapivReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getMapivReply(buf), nil
}

// Read reply into structure from buffer for GetMapiv
func getMapivReply(buf []byte) *GetMapivReply {
	v := new(GetMapivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetMapiv
func getMapivRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Query uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 122 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Query)
	b += 4

	return buf
}

// Request GetMaterialfv
// size: 16
type GetMaterialfvCookie struct {
	*xgb.Cookie
}

func GetMaterialfv(c *xgb.Conn, ContextTag ContextTag, Face uint32, Pname uint32) GetMaterialfvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getMaterialfvRequest(c, ContextTag, Face, Pname), cookie)
	return GetMaterialfvCookie{cookie}
}

func GetMaterialfvUnchecked(c *xgb.Conn, ContextTag ContextTag, Face uint32, Pname uint32) GetMaterialfvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getMaterialfvRequest(c, ContextTag, Face, Pname), cookie)
	return GetMaterialfvCookie{cookie}
}

// Request reply for GetMaterialfv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetMaterialfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum Float32
	// padding: 12 bytes
	Data []Float32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetMaterialfv
func (cook GetMaterialfvCookie) Reply() (*GetMaterialfvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getMaterialfvReply(buf), nil
}

// Read reply into structure from buffer for GetMaterialfv
func getMaterialfvReply(buf []byte) *GetMaterialfvReply {
	v := new(GetMaterialfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = Float32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]Float32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Float32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetMaterialfv
func getMaterialfvRequest(c *xgb.Conn, ContextTag ContextTag, Face uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 123 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Face)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetMaterialiv
// size: 16
type GetMaterialivCookie struct {
	*xgb.Cookie
}

func GetMaterialiv(c *xgb.Conn, ContextTag ContextTag, Face uint32, Pname uint32) GetMaterialivCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getMaterialivRequest(c, ContextTag, Face, Pname), cookie)
	return GetMaterialivCookie{cookie}
}

func GetMaterialivUnchecked(c *xgb.Conn, ContextTag ContextTag, Face uint32, Pname uint32) GetMaterialivCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getMaterialivRequest(c, ContextTag, Face, Pname), cookie)
	return GetMaterialivCookie{cookie}
}

// Request reply for GetMaterialiv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetMaterialivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetMaterialiv
func (cook GetMaterialivCookie) Reply() (*GetMaterialivReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getMaterialivReply(buf), nil
}

// Read reply into structure from buffer for GetMaterialiv
func getMaterialivReply(buf []byte) *GetMaterialivReply {
	v := new(GetMaterialivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetMaterialiv
func getMaterialivRequest(c *xgb.Conn, ContextTag ContextTag, Face uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 124 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Face)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetPixelMapfv
// size: 12
type GetPixelMapfvCookie struct {
	*xgb.Cookie
}

func GetPixelMapfv(c *xgb.Conn, ContextTag ContextTag, Map uint32) GetPixelMapfvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getPixelMapfvRequest(c, ContextTag, Map), cookie)
	return GetPixelMapfvCookie{cookie}
}

func GetPixelMapfvUnchecked(c *xgb.Conn, ContextTag ContextTag, Map uint32) GetPixelMapfvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getPixelMapfvRequest(c, ContextTag, Map), cookie)
	return GetPixelMapfvCookie{cookie}
}

// Request reply for GetPixelMapfv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetPixelMapfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum Float32
	// padding: 12 bytes
	Data []Float32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetPixelMapfv
func (cook GetPixelMapfvCookie) Reply() (*GetPixelMapfvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getPixelMapfvReply(buf), nil
}

// Read reply into structure from buffer for GetPixelMapfv
func getPixelMapfvReply(buf []byte) *GetPixelMapfvReply {
	v := new(GetPixelMapfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = Float32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]Float32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Float32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetPixelMapfv
func getPixelMapfvRequest(c *xgb.Conn, ContextTag ContextTag, Map uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 125 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Map)
	b += 4

	return buf
}

// Request GetPixelMapuiv
// size: 12
type GetPixelMapuivCookie struct {
	*xgb.Cookie
}

func GetPixelMapuiv(c *xgb.Conn, ContextTag ContextTag, Map uint32) GetPixelMapuivCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getPixelMapuivRequest(c, ContextTag, Map), cookie)
	return GetPixelMapuivCookie{cookie}
}

func GetPixelMapuivUnchecked(c *xgb.Conn, ContextTag ContextTag, Map uint32) GetPixelMapuivCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getPixelMapuivRequest(c, ContextTag, Map), cookie)
	return GetPixelMapuivCookie{cookie}
}

// Request reply for GetPixelMapuiv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetPixelMapuivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum uint32
	// padding: 12 bytes
	Data []uint32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetPixelMapuiv
func (cook GetPixelMapuivCookie) Reply() (*GetPixelMapuivReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getPixelMapuivReply(buf), nil
}

// Read reply into structure from buffer for GetPixelMapuiv
func getPixelMapuivReply(buf []byte) *GetPixelMapuivReply {
	v := new(GetPixelMapuivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = xgb.Get32(buf[b:])
	b += 4

	b += 12 // padding

	v.Data = make([]uint32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetPixelMapuiv
func getPixelMapuivRequest(c *xgb.Conn, ContextTag ContextTag, Map uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 126 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Map)
	b += 4

	return buf
}

// Request GetPixelMapusv
// size: 12
type GetPixelMapusvCookie struct {
	*xgb.Cookie
}

func GetPixelMapusv(c *xgb.Conn, ContextTag ContextTag, Map uint32) GetPixelMapusvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getPixelMapusvRequest(c, ContextTag, Map), cookie)
	return GetPixelMapusvCookie{cookie}
}

func GetPixelMapusvUnchecked(c *xgb.Conn, ContextTag ContextTag, Map uint32) GetPixelMapusvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getPixelMapusvRequest(c, ContextTag, Map), cookie)
	return GetPixelMapusvCookie{cookie}
}

// Request reply for GetPixelMapusv
// size: (34 + xgb.Pad((int(N) * 2)))
type GetPixelMapusvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum uint16
	// padding: 16 bytes
	Data []uint16 // size: xgb.Pad((int(N) * 2))
}

// Waits and reads reply data from request GetPixelMapusv
func (cook GetPixelMapusvCookie) Reply() (*GetPixelMapusvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getPixelMapusvReply(buf), nil
}

// Read reply into structure from buffer for GetPixelMapusv
func getPixelMapusvReply(buf []byte) *GetPixelMapusvReply {
	v := new(GetPixelMapusvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = xgb.Get16(buf[b:])
	b += 2

	b += 16 // padding

	v.Data = make([]uint16, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = xgb.Get16(buf[b:])
		b += 2
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetPixelMapusv
func getPixelMapusvRequest(c *xgb.Conn, ContextTag ContextTag, Map uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 127 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Map)
	b += 4

	return buf
}

// Request GetPolygonStipple
// size: 12
type GetPolygonStippleCookie struct {
	*xgb.Cookie
}

func GetPolygonStipple(c *xgb.Conn, ContextTag ContextTag, LsbFirst bool) GetPolygonStippleCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getPolygonStippleRequest(c, ContextTag, LsbFirst), cookie)
	return GetPolygonStippleCookie{cookie}
}

func GetPolygonStippleUnchecked(c *xgb.Conn, ContextTag ContextTag, LsbFirst bool) GetPolygonStippleCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getPolygonStippleRequest(c, ContextTag, LsbFirst), cookie)
	return GetPolygonStippleCookie{cookie}
}

// Request reply for GetPolygonStipple
// size: (32 + xgb.Pad(((int(Length) * 4) * 1)))
type GetPolygonStippleReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
	Data []byte // size: xgb.Pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GetPolygonStipple
func (cook GetPolygonStippleCookie) Reply() (*GetPolygonStippleReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getPolygonStippleReply(buf), nil
}

// Read reply into structure from buffer for GetPolygonStipple
func getPolygonStippleReply(buf []byte) *GetPolygonStippleReply {
	v := new(GetPolygonStippleReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += xgb.Pad(int((int(v.Length) * 4)))

	return v
}

// Write request to wire for GetPolygonStipple
func getPolygonStippleRequest(c *xgb.Conn, ContextTag ContextTag, LsbFirst bool) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 128 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	if LsbFirst {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GetString
// size: 12
type GetStringCookie struct {
	*xgb.Cookie
}

func GetString(c *xgb.Conn, ContextTag ContextTag, Name uint32) GetStringCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getStringRequest(c, ContextTag, Name), cookie)
	return GetStringCookie{cookie}
}

func GetStringUnchecked(c *xgb.Conn, ContextTag ContextTag, Name uint32) GetStringCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getStringRequest(c, ContextTag, Name), cookie)
	return GetStringCookie{cookie}
}

// Request reply for GetString
// size: (32 + xgb.Pad((int(N) * 1)))
type GetStringReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N uint32
	// padding: 16 bytes
	String string // size: xgb.Pad((int(N) * 1))
}

// Waits and reads reply data from request GetString
func (cook GetStringCookie) Reply() (*GetStringReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getStringReply(buf), nil
}

// Read reply into structure from buffer for GetString
func getStringReply(buf []byte) *GetStringReply {
	v := new(GetStringReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	b += 16 // padding

	{
		byteString := make([]byte, v.N)
		copy(byteString[:v.N], buf[b:])
		v.String = string(byteString)
		b += xgb.Pad(int(v.N))
	}

	return v
}

// Write request to wire for GetString
func getStringRequest(c *xgb.Conn, ContextTag ContextTag, Name uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 129 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Name)
	b += 4

	return buf
}

// Request GetTexEnvfv
// size: 16
type GetTexEnvfvCookie struct {
	*xgb.Cookie
}

func GetTexEnvfv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetTexEnvfvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getTexEnvfvRequest(c, ContextTag, Target, Pname), cookie)
	return GetTexEnvfvCookie{cookie}
}

func GetTexEnvfvUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetTexEnvfvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getTexEnvfvRequest(c, ContextTag, Target, Pname), cookie)
	return GetTexEnvfvCookie{cookie}
}

// Request reply for GetTexEnvfv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetTexEnvfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum Float32
	// padding: 12 bytes
	Data []Float32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetTexEnvfv
func (cook GetTexEnvfvCookie) Reply() (*GetTexEnvfvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getTexEnvfvReply(buf), nil
}

// Read reply into structure from buffer for GetTexEnvfv
func getTexEnvfvReply(buf []byte) *GetTexEnvfvReply {
	v := new(GetTexEnvfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = Float32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]Float32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Float32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetTexEnvfv
func getTexEnvfvRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 130 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetTexEnviv
// size: 16
type GetTexEnvivCookie struct {
	*xgb.Cookie
}

func GetTexEnviv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetTexEnvivCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getTexEnvivRequest(c, ContextTag, Target, Pname), cookie)
	return GetTexEnvivCookie{cookie}
}

func GetTexEnvivUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetTexEnvivCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getTexEnvivRequest(c, ContextTag, Target, Pname), cookie)
	return GetTexEnvivCookie{cookie}
}

// Request reply for GetTexEnviv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetTexEnvivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetTexEnviv
func (cook GetTexEnvivCookie) Reply() (*GetTexEnvivReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getTexEnvivReply(buf), nil
}

// Read reply into structure from buffer for GetTexEnviv
func getTexEnvivReply(buf []byte) *GetTexEnvivReply {
	v := new(GetTexEnvivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetTexEnviv
func getTexEnvivRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 131 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetTexGendv
// size: 16
type GetTexGendvCookie struct {
	*xgb.Cookie
}

func GetTexGendv(c *xgb.Conn, ContextTag ContextTag, Coord uint32, Pname uint32) GetTexGendvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getTexGendvRequest(c, ContextTag, Coord, Pname), cookie)
	return GetTexGendvCookie{cookie}
}

func GetTexGendvUnchecked(c *xgb.Conn, ContextTag ContextTag, Coord uint32, Pname uint32) GetTexGendvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getTexGendvRequest(c, ContextTag, Coord, Pname), cookie)
	return GetTexGendvCookie{cookie}
}

// Request reply for GetTexGendv
// size: (32 + xgb.Pad((int(N) * 8)))
type GetTexGendvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum Float64
	// padding: 8 bytes
	Data []Float64 // size: xgb.Pad((int(N) * 8))
}

// Waits and reads reply data from request GetTexGendv
func (cook GetTexGendvCookie) Reply() (*GetTexGendvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getTexGendvReply(buf), nil
}

// Read reply into structure from buffer for GetTexGendv
func getTexGendvReply(buf []byte) *GetTexGendvReply {
	v := new(GetTexGendvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = Float64(xgb.Get64(buf[b:]))
	b += 8

	b += 8 // padding

	v.Data = make([]Float64, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Float64(xgb.Get64(buf[b:]))
		b += 8
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetTexGendv
func getTexGendvRequest(c *xgb.Conn, ContextTag ContextTag, Coord uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 132 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Coord)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetTexGenfv
// size: 16
type GetTexGenfvCookie struct {
	*xgb.Cookie
}

func GetTexGenfv(c *xgb.Conn, ContextTag ContextTag, Coord uint32, Pname uint32) GetTexGenfvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getTexGenfvRequest(c, ContextTag, Coord, Pname), cookie)
	return GetTexGenfvCookie{cookie}
}

func GetTexGenfvUnchecked(c *xgb.Conn, ContextTag ContextTag, Coord uint32, Pname uint32) GetTexGenfvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getTexGenfvRequest(c, ContextTag, Coord, Pname), cookie)
	return GetTexGenfvCookie{cookie}
}

// Request reply for GetTexGenfv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetTexGenfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum Float32
	// padding: 12 bytes
	Data []Float32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetTexGenfv
func (cook GetTexGenfvCookie) Reply() (*GetTexGenfvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getTexGenfvReply(buf), nil
}

// Read reply into structure from buffer for GetTexGenfv
func getTexGenfvReply(buf []byte) *GetTexGenfvReply {
	v := new(GetTexGenfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = Float32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]Float32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Float32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetTexGenfv
func getTexGenfvRequest(c *xgb.Conn, ContextTag ContextTag, Coord uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 133 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Coord)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetTexGeniv
// size: 16
type GetTexGenivCookie struct {
	*xgb.Cookie
}

func GetTexGeniv(c *xgb.Conn, ContextTag ContextTag, Coord uint32, Pname uint32) GetTexGenivCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getTexGenivRequest(c, ContextTag, Coord, Pname), cookie)
	return GetTexGenivCookie{cookie}
}

func GetTexGenivUnchecked(c *xgb.Conn, ContextTag ContextTag, Coord uint32, Pname uint32) GetTexGenivCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getTexGenivRequest(c, ContextTag, Coord, Pname), cookie)
	return GetTexGenivCookie{cookie}
}

// Request reply for GetTexGeniv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetTexGenivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetTexGeniv
func (cook GetTexGenivCookie) Reply() (*GetTexGenivReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getTexGenivReply(buf), nil
}

// Read reply into structure from buffer for GetTexGeniv
func getTexGenivReply(buf []byte) *GetTexGenivReply {
	v := new(GetTexGenivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetTexGeniv
func getTexGenivRequest(c *xgb.Conn, ContextTag ContextTag, Coord uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 134 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Coord)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetTexImage
// size: 28
type GetTexImageCookie struct {
	*xgb.Cookie
}

func GetTexImage(c *xgb.Conn, ContextTag ContextTag, Target uint32, Level int32, Format uint32, Type uint32, SwapBytes bool) GetTexImageCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getTexImageRequest(c, ContextTag, Target, Level, Format, Type, SwapBytes), cookie)
	return GetTexImageCookie{cookie}
}

func GetTexImageUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Level int32, Format uint32, Type uint32, SwapBytes bool) GetTexImageCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getTexImageRequest(c, ContextTag, Target, Level, Format, Type, SwapBytes), cookie)
	return GetTexImageCookie{cookie}
}

// Request reply for GetTexImage
// size: (32 + xgb.Pad(((int(Length) * 4) * 1)))
type GetTexImageReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 8 bytes
	Width  int32
	Height int32
	Depth  int32
	// padding: 4 bytes
	Data []byte // size: xgb.Pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GetTexImage
func (cook GetTexImageCookie) Reply() (*GetTexImageReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getTexImageReply(buf), nil
}

// Read reply into structure from buffer for GetTexImage
func getTexImageReply(buf []byte) *GetTexImageReply {
	v := new(GetTexImageReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 8 // padding

	v.Width = int32(xgb.Get32(buf[b:]))
	b += 4

	v.Height = int32(xgb.Get32(buf[b:]))
	b += 4

	v.Depth = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 4 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += xgb.Pad(int((int(v.Length) * 4)))

	return v
}

// Write request to wire for GetTexImage
func getTexImageRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Level int32, Format uint32, Type uint32, SwapBytes bool) []byte {
	size := 28
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 135 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], uint32(Level))
	b += 4

	xgb.Put32(buf[b:], Format)
	b += 4

	xgb.Put32(buf[b:], Type)
	b += 4

	if SwapBytes {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GetTexParameterfv
// size: 16
type GetTexParameterfvCookie struct {
	*xgb.Cookie
}

func GetTexParameterfv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetTexParameterfvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getTexParameterfvRequest(c, ContextTag, Target, Pname), cookie)
	return GetTexParameterfvCookie{cookie}
}

func GetTexParameterfvUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetTexParameterfvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getTexParameterfvRequest(c, ContextTag, Target, Pname), cookie)
	return GetTexParameterfvCookie{cookie}
}

// Request reply for GetTexParameterfv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetTexParameterfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum Float32
	// padding: 12 bytes
	Data []Float32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetTexParameterfv
func (cook GetTexParameterfvCookie) Reply() (*GetTexParameterfvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getTexParameterfvReply(buf), nil
}

// Read reply into structure from buffer for GetTexParameterfv
func getTexParameterfvReply(buf []byte) *GetTexParameterfvReply {
	v := new(GetTexParameterfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = Float32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]Float32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Float32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetTexParameterfv
func getTexParameterfvRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 136 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetTexParameteriv
// size: 16
type GetTexParameterivCookie struct {
	*xgb.Cookie
}

func GetTexParameteriv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetTexParameterivCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getTexParameterivRequest(c, ContextTag, Target, Pname), cookie)
	return GetTexParameterivCookie{cookie}
}

func GetTexParameterivUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetTexParameterivCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getTexParameterivRequest(c, ContextTag, Target, Pname), cookie)
	return GetTexParameterivCookie{cookie}
}

// Request reply for GetTexParameteriv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetTexParameterivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetTexParameteriv
func (cook GetTexParameterivCookie) Reply() (*GetTexParameterivReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getTexParameterivReply(buf), nil
}

// Read reply into structure from buffer for GetTexParameteriv
func getTexParameterivReply(buf []byte) *GetTexParameterivReply {
	v := new(GetTexParameterivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetTexParameteriv
func getTexParameterivRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 137 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetTexLevelParameterfv
// size: 20
type GetTexLevelParameterfvCookie struct {
	*xgb.Cookie
}

func GetTexLevelParameterfv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Level int32, Pname uint32) GetTexLevelParameterfvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getTexLevelParameterfvRequest(c, ContextTag, Target, Level, Pname), cookie)
	return GetTexLevelParameterfvCookie{cookie}
}

func GetTexLevelParameterfvUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Level int32, Pname uint32) GetTexLevelParameterfvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getTexLevelParameterfvRequest(c, ContextTag, Target, Level, Pname), cookie)
	return GetTexLevelParameterfvCookie{cookie}
}

// Request reply for GetTexLevelParameterfv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetTexLevelParameterfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum Float32
	// padding: 12 bytes
	Data []Float32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetTexLevelParameterfv
func (cook GetTexLevelParameterfvCookie) Reply() (*GetTexLevelParameterfvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getTexLevelParameterfvReply(buf), nil
}

// Read reply into structure from buffer for GetTexLevelParameterfv
func getTexLevelParameterfvReply(buf []byte) *GetTexLevelParameterfvReply {
	v := new(GetTexLevelParameterfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = Float32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]Float32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Float32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetTexLevelParameterfv
func getTexLevelParameterfvRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Level int32, Pname uint32) []byte {
	size := 20
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 138 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], uint32(Level))
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetTexLevelParameteriv
// size: 20
type GetTexLevelParameterivCookie struct {
	*xgb.Cookie
}

func GetTexLevelParameteriv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Level int32, Pname uint32) GetTexLevelParameterivCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getTexLevelParameterivRequest(c, ContextTag, Target, Level, Pname), cookie)
	return GetTexLevelParameterivCookie{cookie}
}

func GetTexLevelParameterivUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Level int32, Pname uint32) GetTexLevelParameterivCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getTexLevelParameterivRequest(c, ContextTag, Target, Level, Pname), cookie)
	return GetTexLevelParameterivCookie{cookie}
}

// Request reply for GetTexLevelParameteriv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetTexLevelParameterivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetTexLevelParameteriv
func (cook GetTexLevelParameterivCookie) Reply() (*GetTexLevelParameterivReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getTexLevelParameterivReply(buf), nil
}

// Read reply into structure from buffer for GetTexLevelParameteriv
func getTexLevelParameterivReply(buf []byte) *GetTexLevelParameterivReply {
	v := new(GetTexLevelParameterivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetTexLevelParameteriv
func getTexLevelParameterivRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Level int32, Pname uint32) []byte {
	size := 20
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 139 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], uint32(Level))
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request IsList
// size: 12
type IsListCookie struct {
	*xgb.Cookie
}

func IsList(c *xgb.Conn, ContextTag ContextTag, List uint32) IsListCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(isListRequest(c, ContextTag, List), cookie)
	return IsListCookie{cookie}
}

func IsListUnchecked(c *xgb.Conn, ContextTag ContextTag, List uint32) IsListCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(isListRequest(c, ContextTag, List), cookie)
	return IsListCookie{cookie}
}

// Request reply for IsList
// size: 12
type IsListReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	RetVal Bool32
}

// Waits and reads reply data from request IsList
func (cook IsListCookie) Reply() (*IsListReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return isListReply(buf), nil
}

// Read reply into structure from buffer for IsList
func isListReply(buf []byte) *IsListReply {
	v := new(IsListReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.RetVal = Bool32(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Write request to wire for IsList
func isListRequest(c *xgb.Conn, ContextTag ContextTag, List uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 141 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], List)
	b += 4

	return buf
}

// Request Flush
// size: 8
type FlushCookie struct {
	*xgb.Cookie
}

// Write request to wire for Flush
func Flush(c *xgb.Conn, ContextTag ContextTag) FlushCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(flushRequest(c, ContextTag), cookie)
	return FlushCookie{cookie}
}

func FlushChecked(c *xgb.Conn, ContextTag ContextTag) FlushCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(flushRequest(c, ContextTag), cookie)
	return FlushCookie{cookie}
}

func (cook FlushCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for Flush
func flushRequest(c *xgb.Conn, ContextTag ContextTag) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 142 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	return buf
}

// Request AreTexturesResident
// size: xgb.Pad((12 + xgb.Pad((int(N) * 4))))
type AreTexturesResidentCookie struct {
	*xgb.Cookie
}

func AreTexturesResident(c *xgb.Conn, ContextTag ContextTag, N int32, Textures []uint32) AreTexturesResidentCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(areTexturesResidentRequest(c, ContextTag, N, Textures), cookie)
	return AreTexturesResidentCookie{cookie}
}

func AreTexturesResidentUnchecked(c *xgb.Conn, ContextTag ContextTag, N int32, Textures []uint32) AreTexturesResidentCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(areTexturesResidentRequest(c, ContextTag, N, Textures), cookie)
	return AreTexturesResidentCookie{cookie}
}

// Request reply for AreTexturesResident
// size: (32 + xgb.Pad(((int(Length) * 4) * 1)))
type AreTexturesResidentReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	RetVal Bool32
	// padding: 20 bytes
	Data []bool // size: xgb.Pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request AreTexturesResident
func (cook AreTexturesResidentCookie) Reply() (*AreTexturesResidentReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return areTexturesResidentReply(buf), nil
}

// Read reply into structure from buffer for AreTexturesResident
func areTexturesResidentReply(buf []byte) *AreTexturesResidentReply {
	v := new(AreTexturesResidentReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.RetVal = Bool32(xgb.Get32(buf[b:]))
	b += 4

	b += 20 // padding

	v.Data = make([]bool, (int(v.Length) * 4))
	for i := 0; i < int((int(v.Length) * 4)); i++ {
		if buf[b] == 1 {
			v.Data[i] = true
		} else {
			v.Data[i] = false
		}
		b += 1
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for AreTexturesResident
func areTexturesResidentRequest(c *xgb.Conn, ContextTag ContextTag, N int32, Textures []uint32) []byte {
	size := xgb.Pad((12 + xgb.Pad((int(N) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 143 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], uint32(N))
	b += 4

	for i := 0; i < int(N); i++ {
		xgb.Put32(buf[b:], Textures[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request DeleteTextures
// size: xgb.Pad((12 + xgb.Pad((int(N) * 4))))
type DeleteTexturesCookie struct {
	*xgb.Cookie
}

// Write request to wire for DeleteTextures
func DeleteTextures(c *xgb.Conn, ContextTag ContextTag, N int32, Textures []uint32) DeleteTexturesCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(deleteTexturesRequest(c, ContextTag, N, Textures), cookie)
	return DeleteTexturesCookie{cookie}
}

func DeleteTexturesChecked(c *xgb.Conn, ContextTag ContextTag, N int32, Textures []uint32) DeleteTexturesCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(deleteTexturesRequest(c, ContextTag, N, Textures), cookie)
	return DeleteTexturesCookie{cookie}
}

func (cook DeleteTexturesCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DeleteTextures
func deleteTexturesRequest(c *xgb.Conn, ContextTag ContextTag, N int32, Textures []uint32) []byte {
	size := xgb.Pad((12 + xgb.Pad((int(N) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 144 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], uint32(N))
	b += 4

	for i := 0; i < int(N); i++ {
		xgb.Put32(buf[b:], Textures[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request GenTextures
// size: 12
type GenTexturesCookie struct {
	*xgb.Cookie
}

func GenTextures(c *xgb.Conn, ContextTag ContextTag, N int32) GenTexturesCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(genTexturesRequest(c, ContextTag, N), cookie)
	return GenTexturesCookie{cookie}
}

func GenTexturesUnchecked(c *xgb.Conn, ContextTag ContextTag, N int32) GenTexturesCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(genTexturesRequest(c, ContextTag, N), cookie)
	return GenTexturesCookie{cookie}
}

// Request reply for GenTextures
// size: (32 + xgb.Pad((int(Length) * 4)))
type GenTexturesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
	Data []uint32 // size: xgb.Pad((int(Length) * 4))
}

// Waits and reads reply data from request GenTextures
func (cook GenTexturesCookie) Reply() (*GenTexturesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return genTexturesReply(buf), nil
}

// Read reply into structure from buffer for GenTextures
func genTexturesReply(buf []byte) *GenTexturesReply {
	v := new(GenTexturesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.Data = make([]uint32, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.Data[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GenTextures
func genTexturesRequest(c *xgb.Conn, ContextTag ContextTag, N int32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 145 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], uint32(N))
	b += 4

	return buf
}

// Request IsTexture
// size: 12
type IsTextureCookie struct {
	*xgb.Cookie
}

func IsTexture(c *xgb.Conn, ContextTag ContextTag, Texture uint32) IsTextureCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(isTextureRequest(c, ContextTag, Texture), cookie)
	return IsTextureCookie{cookie}
}

func IsTextureUnchecked(c *xgb.Conn, ContextTag ContextTag, Texture uint32) IsTextureCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(isTextureRequest(c, ContextTag, Texture), cookie)
	return IsTextureCookie{cookie}
}

// Request reply for IsTexture
// size: 12
type IsTextureReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	RetVal Bool32
}

// Waits and reads reply data from request IsTexture
func (cook IsTextureCookie) Reply() (*IsTextureReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return isTextureReply(buf), nil
}

// Read reply into structure from buffer for IsTexture
func isTextureReply(buf []byte) *IsTextureReply {
	v := new(IsTextureReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.RetVal = Bool32(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Write request to wire for IsTexture
func isTextureRequest(c *xgb.Conn, ContextTag ContextTag, Texture uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 146 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Texture)
	b += 4

	return buf
}

// Request GetColorTable
// size: 24
type GetColorTableCookie struct {
	*xgb.Cookie
}

func GetColorTable(c *xgb.Conn, ContextTag ContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) GetColorTableCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getColorTableRequest(c, ContextTag, Target, Format, Type, SwapBytes), cookie)
	return GetColorTableCookie{cookie}
}

func GetColorTableUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) GetColorTableCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getColorTableRequest(c, ContextTag, Target, Format, Type, SwapBytes), cookie)
	return GetColorTableCookie{cookie}
}

// Request reply for GetColorTable
// size: (32 + xgb.Pad(((int(Length) * 4) * 1)))
type GetColorTableReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 8 bytes
	Width int32
	// padding: 12 bytes
	Data []byte // size: xgb.Pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GetColorTable
func (cook GetColorTableCookie) Reply() (*GetColorTableReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getColorTableReply(buf), nil
}

// Read reply into structure from buffer for GetColorTable
func getColorTableReply(buf []byte) *GetColorTableReply {
	v := new(GetColorTableReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 8 // padding

	v.Width = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += xgb.Pad(int((int(v.Length) * 4)))

	return v
}

// Write request to wire for GetColorTable
func getColorTableRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 147 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Format)
	b += 4

	xgb.Put32(buf[b:], Type)
	b += 4

	if SwapBytes {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GetColorTableParameterfv
// size: 16
type GetColorTableParameterfvCookie struct {
	*xgb.Cookie
}

func GetColorTableParameterfv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetColorTableParameterfvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getColorTableParameterfvRequest(c, ContextTag, Target, Pname), cookie)
	return GetColorTableParameterfvCookie{cookie}
}

func GetColorTableParameterfvUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetColorTableParameterfvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getColorTableParameterfvRequest(c, ContextTag, Target, Pname), cookie)
	return GetColorTableParameterfvCookie{cookie}
}

// Request reply for GetColorTableParameterfv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetColorTableParameterfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum Float32
	// padding: 12 bytes
	Data []Float32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetColorTableParameterfv
func (cook GetColorTableParameterfvCookie) Reply() (*GetColorTableParameterfvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getColorTableParameterfvReply(buf), nil
}

// Read reply into structure from buffer for GetColorTableParameterfv
func getColorTableParameterfvReply(buf []byte) *GetColorTableParameterfvReply {
	v := new(GetColorTableParameterfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = Float32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]Float32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Float32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetColorTableParameterfv
func getColorTableParameterfvRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 148 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetColorTableParameteriv
// size: 16
type GetColorTableParameterivCookie struct {
	*xgb.Cookie
}

func GetColorTableParameteriv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetColorTableParameterivCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getColorTableParameterivRequest(c, ContextTag, Target, Pname), cookie)
	return GetColorTableParameterivCookie{cookie}
}

func GetColorTableParameterivUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetColorTableParameterivCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getColorTableParameterivRequest(c, ContextTag, Target, Pname), cookie)
	return GetColorTableParameterivCookie{cookie}
}

// Request reply for GetColorTableParameteriv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetColorTableParameterivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetColorTableParameteriv
func (cook GetColorTableParameterivCookie) Reply() (*GetColorTableParameterivReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getColorTableParameterivReply(buf), nil
}

// Read reply into structure from buffer for GetColorTableParameteriv
func getColorTableParameterivReply(buf []byte) *GetColorTableParameterivReply {
	v := new(GetColorTableParameterivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetColorTableParameteriv
func getColorTableParameterivRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 149 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetConvolutionFilter
// size: 24
type GetConvolutionFilterCookie struct {
	*xgb.Cookie
}

func GetConvolutionFilter(c *xgb.Conn, ContextTag ContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) GetConvolutionFilterCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getConvolutionFilterRequest(c, ContextTag, Target, Format, Type, SwapBytes), cookie)
	return GetConvolutionFilterCookie{cookie}
}

func GetConvolutionFilterUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) GetConvolutionFilterCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getConvolutionFilterRequest(c, ContextTag, Target, Format, Type, SwapBytes), cookie)
	return GetConvolutionFilterCookie{cookie}
}

// Request reply for GetConvolutionFilter
// size: (32 + xgb.Pad(((int(Length) * 4) * 1)))
type GetConvolutionFilterReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 8 bytes
	Width  int32
	Height int32
	// padding: 8 bytes
	Data []byte // size: xgb.Pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GetConvolutionFilter
func (cook GetConvolutionFilterCookie) Reply() (*GetConvolutionFilterReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getConvolutionFilterReply(buf), nil
}

// Read reply into structure from buffer for GetConvolutionFilter
func getConvolutionFilterReply(buf []byte) *GetConvolutionFilterReply {
	v := new(GetConvolutionFilterReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 8 // padding

	v.Width = int32(xgb.Get32(buf[b:]))
	b += 4

	v.Height = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 8 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += xgb.Pad(int((int(v.Length) * 4)))

	return v
}

// Write request to wire for GetConvolutionFilter
func getConvolutionFilterRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 150 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Format)
	b += 4

	xgb.Put32(buf[b:], Type)
	b += 4

	if SwapBytes {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GetConvolutionParameterfv
// size: 16
type GetConvolutionParameterfvCookie struct {
	*xgb.Cookie
}

func GetConvolutionParameterfv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetConvolutionParameterfvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getConvolutionParameterfvRequest(c, ContextTag, Target, Pname), cookie)
	return GetConvolutionParameterfvCookie{cookie}
}

func GetConvolutionParameterfvUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetConvolutionParameterfvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getConvolutionParameterfvRequest(c, ContextTag, Target, Pname), cookie)
	return GetConvolutionParameterfvCookie{cookie}
}

// Request reply for GetConvolutionParameterfv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetConvolutionParameterfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum Float32
	// padding: 12 bytes
	Data []Float32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetConvolutionParameterfv
func (cook GetConvolutionParameterfvCookie) Reply() (*GetConvolutionParameterfvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getConvolutionParameterfvReply(buf), nil
}

// Read reply into structure from buffer for GetConvolutionParameterfv
func getConvolutionParameterfvReply(buf []byte) *GetConvolutionParameterfvReply {
	v := new(GetConvolutionParameterfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = Float32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]Float32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Float32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetConvolutionParameterfv
func getConvolutionParameterfvRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 151 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetConvolutionParameteriv
// size: 16
type GetConvolutionParameterivCookie struct {
	*xgb.Cookie
}

func GetConvolutionParameteriv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetConvolutionParameterivCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getConvolutionParameterivRequest(c, ContextTag, Target, Pname), cookie)
	return GetConvolutionParameterivCookie{cookie}
}

func GetConvolutionParameterivUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetConvolutionParameterivCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getConvolutionParameterivRequest(c, ContextTag, Target, Pname), cookie)
	return GetConvolutionParameterivCookie{cookie}
}

// Request reply for GetConvolutionParameteriv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetConvolutionParameterivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetConvolutionParameteriv
func (cook GetConvolutionParameterivCookie) Reply() (*GetConvolutionParameterivReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getConvolutionParameterivReply(buf), nil
}

// Read reply into structure from buffer for GetConvolutionParameteriv
func getConvolutionParameterivReply(buf []byte) *GetConvolutionParameterivReply {
	v := new(GetConvolutionParameterivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetConvolutionParameteriv
func getConvolutionParameterivRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 152 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetSeparableFilter
// size: 24
type GetSeparableFilterCookie struct {
	*xgb.Cookie
}

func GetSeparableFilter(c *xgb.Conn, ContextTag ContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) GetSeparableFilterCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getSeparableFilterRequest(c, ContextTag, Target, Format, Type, SwapBytes), cookie)
	return GetSeparableFilterCookie{cookie}
}

func GetSeparableFilterUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) GetSeparableFilterCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getSeparableFilterRequest(c, ContextTag, Target, Format, Type, SwapBytes), cookie)
	return GetSeparableFilterCookie{cookie}
}

// Request reply for GetSeparableFilter
// size: (32 + xgb.Pad(((int(Length) * 4) * 1)))
type GetSeparableFilterReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 8 bytes
	RowW int32
	ColH int32
	// padding: 8 bytes
	RowsAndCols []byte // size: xgb.Pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GetSeparableFilter
func (cook GetSeparableFilterCookie) Reply() (*GetSeparableFilterReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getSeparableFilterReply(buf), nil
}

// Read reply into structure from buffer for GetSeparableFilter
func getSeparableFilterReply(buf []byte) *GetSeparableFilterReply {
	v := new(GetSeparableFilterReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 8 // padding

	v.RowW = int32(xgb.Get32(buf[b:]))
	b += 4

	v.ColH = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 8 // padding

	v.RowsAndCols = make([]byte, (int(v.Length) * 4))
	copy(v.RowsAndCols[:(int(v.Length)*4)], buf[b:])
	b += xgb.Pad(int((int(v.Length) * 4)))

	return v
}

// Write request to wire for GetSeparableFilter
func getSeparableFilterRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 153 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Format)
	b += 4

	xgb.Put32(buf[b:], Type)
	b += 4

	if SwapBytes {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GetHistogram
// size: 24
type GetHistogramCookie struct {
	*xgb.Cookie
}

func GetHistogram(c *xgb.Conn, ContextTag ContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool, Reset bool) GetHistogramCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getHistogramRequest(c, ContextTag, Target, Format, Type, SwapBytes, Reset), cookie)
	return GetHistogramCookie{cookie}
}

func GetHistogramUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool, Reset bool) GetHistogramCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getHistogramRequest(c, ContextTag, Target, Format, Type, SwapBytes, Reset), cookie)
	return GetHistogramCookie{cookie}
}

// Request reply for GetHistogram
// size: (32 + xgb.Pad(((int(Length) * 4) * 1)))
type GetHistogramReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 8 bytes
	Width int32
	// padding: 12 bytes
	Data []byte // size: xgb.Pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GetHistogram
func (cook GetHistogramCookie) Reply() (*GetHistogramReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getHistogramReply(buf), nil
}

// Read reply into structure from buffer for GetHistogram
func getHistogramReply(buf []byte) *GetHistogramReply {
	v := new(GetHistogramReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 8 // padding

	v.Width = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += xgb.Pad(int((int(v.Length) * 4)))

	return v
}

// Write request to wire for GetHistogram
func getHistogramRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool, Reset bool) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 154 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Format)
	b += 4

	xgb.Put32(buf[b:], Type)
	b += 4

	if SwapBytes {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	if Reset {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GetHistogramParameterfv
// size: 16
type GetHistogramParameterfvCookie struct {
	*xgb.Cookie
}

func GetHistogramParameterfv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetHistogramParameterfvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getHistogramParameterfvRequest(c, ContextTag, Target, Pname), cookie)
	return GetHistogramParameterfvCookie{cookie}
}

func GetHistogramParameterfvUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetHistogramParameterfvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getHistogramParameterfvRequest(c, ContextTag, Target, Pname), cookie)
	return GetHistogramParameterfvCookie{cookie}
}

// Request reply for GetHistogramParameterfv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetHistogramParameterfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum Float32
	// padding: 12 bytes
	Data []Float32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetHistogramParameterfv
func (cook GetHistogramParameterfvCookie) Reply() (*GetHistogramParameterfvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getHistogramParameterfvReply(buf), nil
}

// Read reply into structure from buffer for GetHistogramParameterfv
func getHistogramParameterfvReply(buf []byte) *GetHistogramParameterfvReply {
	v := new(GetHistogramParameterfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = Float32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]Float32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Float32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetHistogramParameterfv
func getHistogramParameterfvRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 155 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetHistogramParameteriv
// size: 16
type GetHistogramParameterivCookie struct {
	*xgb.Cookie
}

func GetHistogramParameteriv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetHistogramParameterivCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getHistogramParameterivRequest(c, ContextTag, Target, Pname), cookie)
	return GetHistogramParameterivCookie{cookie}
}

func GetHistogramParameterivUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetHistogramParameterivCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getHistogramParameterivRequest(c, ContextTag, Target, Pname), cookie)
	return GetHistogramParameterivCookie{cookie}
}

// Request reply for GetHistogramParameteriv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetHistogramParameterivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetHistogramParameteriv
func (cook GetHistogramParameterivCookie) Reply() (*GetHistogramParameterivReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getHistogramParameterivReply(buf), nil
}

// Read reply into structure from buffer for GetHistogramParameteriv
func getHistogramParameterivReply(buf []byte) *GetHistogramParameterivReply {
	v := new(GetHistogramParameterivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetHistogramParameteriv
func getHistogramParameterivRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 156 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetMinmax
// size: 24
type GetMinmaxCookie struct {
	*xgb.Cookie
}

func GetMinmax(c *xgb.Conn, ContextTag ContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool, Reset bool) GetMinmaxCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getMinmaxRequest(c, ContextTag, Target, Format, Type, SwapBytes, Reset), cookie)
	return GetMinmaxCookie{cookie}
}

func GetMinmaxUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool, Reset bool) GetMinmaxCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getMinmaxRequest(c, ContextTag, Target, Format, Type, SwapBytes, Reset), cookie)
	return GetMinmaxCookie{cookie}
}

// Request reply for GetMinmax
// size: (32 + xgb.Pad(((int(Length) * 4) * 1)))
type GetMinmaxReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
	Data []byte // size: xgb.Pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GetMinmax
func (cook GetMinmaxCookie) Reply() (*GetMinmaxReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getMinmaxReply(buf), nil
}

// Read reply into structure from buffer for GetMinmax
func getMinmaxReply(buf []byte) *GetMinmaxReply {
	v := new(GetMinmaxReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += xgb.Pad(int((int(v.Length) * 4)))

	return v
}

// Write request to wire for GetMinmax
func getMinmaxRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Format uint32, Type uint32, SwapBytes bool, Reset bool) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 157 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Format)
	b += 4

	xgb.Put32(buf[b:], Type)
	b += 4

	if SwapBytes {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	if Reset {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GetMinmaxParameterfv
// size: 16
type GetMinmaxParameterfvCookie struct {
	*xgb.Cookie
}

func GetMinmaxParameterfv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetMinmaxParameterfvCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getMinmaxParameterfvRequest(c, ContextTag, Target, Pname), cookie)
	return GetMinmaxParameterfvCookie{cookie}
}

func GetMinmaxParameterfvUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetMinmaxParameterfvCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getMinmaxParameterfvRequest(c, ContextTag, Target, Pname), cookie)
	return GetMinmaxParameterfvCookie{cookie}
}

// Request reply for GetMinmaxParameterfv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetMinmaxParameterfvReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum Float32
	// padding: 12 bytes
	Data []Float32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetMinmaxParameterfv
func (cook GetMinmaxParameterfvCookie) Reply() (*GetMinmaxParameterfvReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getMinmaxParameterfvReply(buf), nil
}

// Read reply into structure from buffer for GetMinmaxParameterfv
func getMinmaxParameterfvReply(buf []byte) *GetMinmaxParameterfvReply {
	v := new(GetMinmaxParameterfvReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = Float32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]Float32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = Float32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetMinmaxParameterfv
func getMinmaxParameterfvRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 158 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetMinmaxParameteriv
// size: 16
type GetMinmaxParameterivCookie struct {
	*xgb.Cookie
}

func GetMinmaxParameteriv(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetMinmaxParameterivCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getMinmaxParameterivRequest(c, ContextTag, Target, Pname), cookie)
	return GetMinmaxParameterivCookie{cookie}
}

func GetMinmaxParameterivUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetMinmaxParameterivCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getMinmaxParameterivRequest(c, ContextTag, Target, Pname), cookie)
	return GetMinmaxParameterivCookie{cookie}
}

// Request reply for GetMinmaxParameteriv
// size: (32 + xgb.Pad((int(N) * 4)))
type GetMinmaxParameterivReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetMinmaxParameteriv
func (cook GetMinmaxParameterivCookie) Reply() (*GetMinmaxParameterivReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getMinmaxParameterivReply(buf), nil
}

// Read reply into structure from buffer for GetMinmaxParameteriv
func getMinmaxParameterivReply(buf []byte) *GetMinmaxParameterivReply {
	v := new(GetMinmaxParameterivReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetMinmaxParameteriv
func getMinmaxParameterivRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 159 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetCompressedTexImageARB
// size: 16
type GetCompressedTexImageARBCookie struct {
	*xgb.Cookie
}

func GetCompressedTexImageARB(c *xgb.Conn, ContextTag ContextTag, Target uint32, Level int32) GetCompressedTexImageARBCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getCompressedTexImageARBRequest(c, ContextTag, Target, Level), cookie)
	return GetCompressedTexImageARBCookie{cookie}
}

func GetCompressedTexImageARBUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Level int32) GetCompressedTexImageARBCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getCompressedTexImageARBRequest(c, ContextTag, Target, Level), cookie)
	return GetCompressedTexImageARBCookie{cookie}
}

// Request reply for GetCompressedTexImageARB
// size: (32 + xgb.Pad(((int(Length) * 4) * 1)))
type GetCompressedTexImageARBReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 8 bytes
	Size int32
	// padding: 12 bytes
	Data []byte // size: xgb.Pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GetCompressedTexImageARB
func (cook GetCompressedTexImageARBCookie) Reply() (*GetCompressedTexImageARBReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getCompressedTexImageARBReply(buf), nil
}

// Read reply into structure from buffer for GetCompressedTexImageARB
func getCompressedTexImageARBReply(buf []byte) *GetCompressedTexImageARBReply {
	v := new(GetCompressedTexImageARBReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 8 // padding

	v.Size = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += xgb.Pad(int((int(v.Length) * 4)))

	return v
}

// Write request to wire for GetCompressedTexImageARB
func getCompressedTexImageARBRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Level int32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 160 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], uint32(Level))
	b += 4

	return buf
}

// Request DeleteQueriesARB
// size: xgb.Pad((12 + xgb.Pad((int(N) * 4))))
type DeleteQueriesARBCookie struct {
	*xgb.Cookie
}

// Write request to wire for DeleteQueriesARB
func DeleteQueriesARB(c *xgb.Conn, ContextTag ContextTag, N int32, Ids []uint32) DeleteQueriesARBCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(deleteQueriesARBRequest(c, ContextTag, N, Ids), cookie)
	return DeleteQueriesARBCookie{cookie}
}

func DeleteQueriesARBChecked(c *xgb.Conn, ContextTag ContextTag, N int32, Ids []uint32) DeleteQueriesARBCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(deleteQueriesARBRequest(c, ContextTag, N, Ids), cookie)
	return DeleteQueriesARBCookie{cookie}
}

func (cook DeleteQueriesARBCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DeleteQueriesARB
func deleteQueriesARBRequest(c *xgb.Conn, ContextTag ContextTag, N int32, Ids []uint32) []byte {
	size := xgb.Pad((12 + xgb.Pad((int(N) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 161 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], uint32(N))
	b += 4

	for i := 0; i < int(N); i++ {
		xgb.Put32(buf[b:], Ids[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request GenQueriesARB
// size: 12
type GenQueriesARBCookie struct {
	*xgb.Cookie
}

func GenQueriesARB(c *xgb.Conn, ContextTag ContextTag, N int32) GenQueriesARBCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(genQueriesARBRequest(c, ContextTag, N), cookie)
	return GenQueriesARBCookie{cookie}
}

func GenQueriesARBUnchecked(c *xgb.Conn, ContextTag ContextTag, N int32) GenQueriesARBCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(genQueriesARBRequest(c, ContextTag, N), cookie)
	return GenQueriesARBCookie{cookie}
}

// Request reply for GenQueriesARB
// size: (32 + xgb.Pad((int(Length) * 4)))
type GenQueriesARBReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
	Data []uint32 // size: xgb.Pad((int(Length) * 4))
}

// Waits and reads reply data from request GenQueriesARB
func (cook GenQueriesARBCookie) Reply() (*GenQueriesARBReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return genQueriesARBReply(buf), nil
}

// Read reply into structure from buffer for GenQueriesARB
func genQueriesARBReply(buf []byte) *GenQueriesARBReply {
	v := new(GenQueriesARBReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.Data = make([]uint32, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.Data[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GenQueriesARB
func genQueriesARBRequest(c *xgb.Conn, ContextTag ContextTag, N int32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 162 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], uint32(N))
	b += 4

	return buf
}

// Request IsQueryARB
// size: 12
type IsQueryARBCookie struct {
	*xgb.Cookie
}

func IsQueryARB(c *xgb.Conn, ContextTag ContextTag, Id uint32) IsQueryARBCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(isQueryARBRequest(c, ContextTag, Id), cookie)
	return IsQueryARBCookie{cookie}
}

func IsQueryARBUnchecked(c *xgb.Conn, ContextTag ContextTag, Id uint32) IsQueryARBCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(isQueryARBRequest(c, ContextTag, Id), cookie)
	return IsQueryARBCookie{cookie}
}

// Request reply for IsQueryARB
// size: 12
type IsQueryARBReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	RetVal Bool32
}

// Waits and reads reply data from request IsQueryARB
func (cook IsQueryARBCookie) Reply() (*IsQueryARBReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return isQueryARBReply(buf), nil
}

// Read reply into structure from buffer for IsQueryARB
func isQueryARBReply(buf []byte) *IsQueryARBReply {
	v := new(IsQueryARBReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.RetVal = Bool32(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Write request to wire for IsQueryARB
func isQueryARBRequest(c *xgb.Conn, ContextTag ContextTag, Id uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 163 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Id)
	b += 4

	return buf
}

// Request GetQueryivARB
// size: 16
type GetQueryivARBCookie struct {
	*xgb.Cookie
}

func GetQueryivARB(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetQueryivARBCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getQueryivARBRequest(c, ContextTag, Target, Pname), cookie)
	return GetQueryivARBCookie{cookie}
}

func GetQueryivARBUnchecked(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) GetQueryivARBCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getQueryivARBRequest(c, ContextTag, Target, Pname), cookie)
	return GetQueryivARBCookie{cookie}
}

// Request reply for GetQueryivARB
// size: (32 + xgb.Pad((int(N) * 4)))
type GetQueryivARBReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetQueryivARB
func (cook GetQueryivARBCookie) Reply() (*GetQueryivARBReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getQueryivARBReply(buf), nil
}

// Read reply into structure from buffer for GetQueryivARB
func getQueryivARBReply(buf []byte) *GetQueryivARBReply {
	v := new(GetQueryivARBReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetQueryivARB
func getQueryivARBRequest(c *xgb.Conn, ContextTag ContextTag, Target uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 164 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Target)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetQueryObjectivARB
// size: 16
type GetQueryObjectivARBCookie struct {
	*xgb.Cookie
}

func GetQueryObjectivARB(c *xgb.Conn, ContextTag ContextTag, Id uint32, Pname uint32) GetQueryObjectivARBCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getQueryObjectivARBRequest(c, ContextTag, Id, Pname), cookie)
	return GetQueryObjectivARBCookie{cookie}
}

func GetQueryObjectivARBUnchecked(c *xgb.Conn, ContextTag ContextTag, Id uint32, Pname uint32) GetQueryObjectivARBCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getQueryObjectivARBRequest(c, ContextTag, Id, Pname), cookie)
	return GetQueryObjectivARBCookie{cookie}
}

// Request reply for GetQueryObjectivARB
// size: (32 + xgb.Pad((int(N) * 4)))
type GetQueryObjectivARBReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum int32
	// padding: 12 bytes
	Data []int32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetQueryObjectivARB
func (cook GetQueryObjectivARBCookie) Reply() (*GetQueryObjectivARBReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getQueryObjectivARBReply(buf), nil
}

// Read reply into structure from buffer for GetQueryObjectivARB
func getQueryObjectivARBReply(buf []byte) *GetQueryObjectivARBReply {
	v := new(GetQueryObjectivARBReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = int32(xgb.Get32(buf[b:]))
	b += 4

	b += 12 // padding

	v.Data = make([]int32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetQueryObjectivARB
func getQueryObjectivARBRequest(c *xgb.Conn, ContextTag ContextTag, Id uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 165 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Id)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}

// Request GetQueryObjectuivARB
// size: 16
type GetQueryObjectuivARBCookie struct {
	*xgb.Cookie
}

func GetQueryObjectuivARB(c *xgb.Conn, ContextTag ContextTag, Id uint32, Pname uint32) GetQueryObjectuivARBCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getQueryObjectuivARBRequest(c, ContextTag, Id, Pname), cookie)
	return GetQueryObjectuivARBCookie{cookie}
}

func GetQueryObjectuivARBUnchecked(c *xgb.Conn, ContextTag ContextTag, Id uint32, Pname uint32) GetQueryObjectuivARBCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getQueryObjectuivARBRequest(c, ContextTag, Id, Pname), cookie)
	return GetQueryObjectuivARBCookie{cookie}
}

// Request reply for GetQueryObjectuivARB
// size: (32 + xgb.Pad((int(N) * 4)))
type GetQueryObjectuivARBReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 4 bytes
	N     uint32
	Datum uint32
	// padding: 12 bytes
	Data []uint32 // size: xgb.Pad((int(N) * 4))
}

// Waits and reads reply data from request GetQueryObjectuivARB
func (cook GetQueryObjectuivARBCookie) Reply() (*GetQueryObjectuivARBReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getQueryObjectuivARBReply(buf), nil
}

// Read reply into structure from buffer for GetQueryObjectuivARB
func getQueryObjectuivARBReply(buf []byte) *GetQueryObjectuivARBReply {
	v := new(GetQueryObjectuivARBReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 4 // padding

	v.N = xgb.Get32(buf[b:])
	b += 4

	v.Datum = xgb.Get32(buf[b:])
	b += 4

	b += 12 // padding

	v.Data = make([]uint32, v.N)
	for i := 0; i < int(v.N); i++ {
		v.Data[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetQueryObjectuivARB
func getQueryObjectuivARBRequest(c *xgb.Conn, ContextTag ContextTag, Id uint32, Pname uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["GLX"]
	b += 1

	buf[b] = 166 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextTag))
	b += 4

	xgb.Put32(buf[b:], Id)
	b += 4

	xgb.Put32(buf[b:], Pname)
	b += 4

	return buf
}
