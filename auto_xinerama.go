package xgb

/*
	This file was generated by xinerama.xml on May 6 2012 3:00:45am EDT.
	This file is automatically generated. Edit at your peril!
*/

// Imports are not necessary for XGB because everything is 
// in one package. They are still listed here for reference.
// import "xproto"

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Id'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// 'XineramaScreenInfo' struct definition
// Size: 8
type XineramaScreenInfo struct {
	XOrg   int16
	YOrg   int16
	Width  uint16
	Height uint16
}

// Struct read XineramaScreenInfo
func ReadXineramaScreenInfo(buf []byte, v *XineramaScreenInfo) int {
	b := 0

	v.XOrg = int16(Get16(buf[b:]))
	b += 2

	v.YOrg = int16(Get16(buf[b:]))
	b += 2

	v.Width = Get16(buf[b:])
	b += 2

	v.Height = Get16(buf[b:])
	b += 2

	return b
}

// Struct list read XineramaScreenInfo
func ReadXineramaScreenInfoList(buf []byte, dest []XineramaScreenInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XineramaScreenInfo{}
		b += ReadXineramaScreenInfo(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XineramaScreenInfo
func (v XineramaScreenInfo) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	Put16(buf[b:], uint16(v.XOrg))
	b += 2

	Put16(buf[b:], uint16(v.YOrg))
	b += 2

	Put16(buf[b:], v.Width)
	b += 2

	Put16(buf[b:], v.Height)
	b += 2

	return buf
}

// Write struct list XineramaScreenInfo
func XineramaScreenInfoListBytes(buf []byte, list []XineramaScreenInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Request XineramaQueryVersion
// size: 8
type XineramaQueryVersionCookie struct {
	*cookie
}

func (c *Conn) XineramaQueryVersion(Major byte, Minor byte) XineramaQueryVersionCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xineramaQueryVersionRequest(Major, Minor), cookie)
	return XineramaQueryVersionCookie{cookie}
}

func (c *Conn) XineramaQueryVersionUnchecked(Major byte, Minor byte) XineramaQueryVersionCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xineramaQueryVersionRequest(Major, Minor), cookie)
	return XineramaQueryVersionCookie{cookie}
}

// Request reply for XineramaQueryVersion
// size: 12
type XineramaQueryVersionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Major uint16
	Minor uint16
}

// Waits and reads reply data from request XineramaQueryVersion
func (cook XineramaQueryVersionCookie) Reply() (*XineramaQueryVersionReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xineramaQueryVersionReply(buf), nil
}

// Read reply into structure from buffer for XineramaQueryVersion
func xineramaQueryVersionReply(buf []byte) *XineramaQueryVersionReply {
	v := new(XineramaQueryVersionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Major = Get16(buf[b:])
	b += 2

	v.Minor = Get16(buf[b:])
	b += 2

	return v
}

func (cook XineramaQueryVersionCookie) Check() error {
	return cook.check()
}

// Write request to wire for XineramaQueryVersion
func (c *Conn) xineramaQueryVersionRequest(Major byte, Minor byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINERAMA"]
	b += 1

	buf[b] = 0 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = Major
	b += 1

	buf[b] = Minor
	b += 1

	return buf
}

// Request XineramaGetState
// size: 8
type XineramaGetStateCookie struct {
	*cookie
}

func (c *Conn) XineramaGetState(Window Id) XineramaGetStateCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xineramaGetStateRequest(Window), cookie)
	return XineramaGetStateCookie{cookie}
}

func (c *Conn) XineramaGetStateUnchecked(Window Id) XineramaGetStateCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xineramaGetStateRequest(Window), cookie)
	return XineramaGetStateCookie{cookie}
}

// Request reply for XineramaGetState
// size: 12
type XineramaGetStateReply struct {
	Sequence uint16
	Length   uint32
	State    byte
	Window   Id
}

// Waits and reads reply data from request XineramaGetState
func (cook XineramaGetStateCookie) Reply() (*XineramaGetStateReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xineramaGetStateReply(buf), nil
}

// Read reply into structure from buffer for XineramaGetState
func xineramaGetStateReply(buf []byte) *XineramaGetStateReply {
	v := new(XineramaGetStateReply)
	b := 1 // skip reply determinant

	v.State = buf[b]
	b += 1

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Window = Id(Get32(buf[b:]))
	b += 4

	return v
}

func (cook XineramaGetStateCookie) Check() error {
	return cook.check()
}

// Write request to wire for XineramaGetState
func (c *Conn) xineramaGetStateRequest(Window Id) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINERAMA"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request XineramaGetScreenCount
// size: 8
type XineramaGetScreenCountCookie struct {
	*cookie
}

func (c *Conn) XineramaGetScreenCount(Window Id) XineramaGetScreenCountCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xineramaGetScreenCountRequest(Window), cookie)
	return XineramaGetScreenCountCookie{cookie}
}

func (c *Conn) XineramaGetScreenCountUnchecked(Window Id) XineramaGetScreenCountCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xineramaGetScreenCountRequest(Window), cookie)
	return XineramaGetScreenCountCookie{cookie}
}

// Request reply for XineramaGetScreenCount
// size: 12
type XineramaGetScreenCountReply struct {
	Sequence    uint16
	Length      uint32
	ScreenCount byte
	Window      Id
}

// Waits and reads reply data from request XineramaGetScreenCount
func (cook XineramaGetScreenCountCookie) Reply() (*XineramaGetScreenCountReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xineramaGetScreenCountReply(buf), nil
}

// Read reply into structure from buffer for XineramaGetScreenCount
func xineramaGetScreenCountReply(buf []byte) *XineramaGetScreenCountReply {
	v := new(XineramaGetScreenCountReply)
	b := 1 // skip reply determinant

	v.ScreenCount = buf[b]
	b += 1

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Window = Id(Get32(buf[b:]))
	b += 4

	return v
}

func (cook XineramaGetScreenCountCookie) Check() error {
	return cook.check()
}

// Write request to wire for XineramaGetScreenCount
func (c *Conn) xineramaGetScreenCountRequest(Window Id) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINERAMA"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request XineramaGetScreenSize
// size: 12
type XineramaGetScreenSizeCookie struct {
	*cookie
}

func (c *Conn) XineramaGetScreenSize(Window Id, Screen uint32) XineramaGetScreenSizeCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xineramaGetScreenSizeRequest(Window, Screen), cookie)
	return XineramaGetScreenSizeCookie{cookie}
}

func (c *Conn) XineramaGetScreenSizeUnchecked(Window Id, Screen uint32) XineramaGetScreenSizeCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xineramaGetScreenSizeRequest(Window, Screen), cookie)
	return XineramaGetScreenSizeCookie{cookie}
}

// Request reply for XineramaGetScreenSize
// size: 24
type XineramaGetScreenSizeReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Width  uint32
	Height uint32
	Window Id
	Screen uint32
}

// Waits and reads reply data from request XineramaGetScreenSize
func (cook XineramaGetScreenSizeCookie) Reply() (*XineramaGetScreenSizeReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xineramaGetScreenSizeReply(buf), nil
}

// Read reply into structure from buffer for XineramaGetScreenSize
func xineramaGetScreenSizeReply(buf []byte) *XineramaGetScreenSizeReply {
	v := new(XineramaGetScreenSizeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Width = Get32(buf[b:])
	b += 4

	v.Height = Get32(buf[b:])
	b += 4

	v.Window = Id(Get32(buf[b:]))
	b += 4

	v.Screen = Get32(buf[b:])
	b += 4

	return v
}

func (cook XineramaGetScreenSizeCookie) Check() error {
	return cook.check()
}

// Write request to wire for XineramaGetScreenSize
func (c *Conn) xineramaGetScreenSizeRequest(Window Id, Screen uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINERAMA"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Window))
	b += 4

	Put32(buf[b:], Screen)
	b += 4

	return buf
}

// Request XineramaIsActive
// size: 4
type XineramaIsActiveCookie struct {
	*cookie
}

func (c *Conn) XineramaIsActive() XineramaIsActiveCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xineramaIsActiveRequest(), cookie)
	return XineramaIsActiveCookie{cookie}
}

func (c *Conn) XineramaIsActiveUnchecked() XineramaIsActiveCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xineramaIsActiveRequest(), cookie)
	return XineramaIsActiveCookie{cookie}
}

// Request reply for XineramaIsActive
// size: 12
type XineramaIsActiveReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	State uint32
}

// Waits and reads reply data from request XineramaIsActive
func (cook XineramaIsActiveCookie) Reply() (*XineramaIsActiveReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xineramaIsActiveReply(buf), nil
}

// Read reply into structure from buffer for XineramaIsActive
func xineramaIsActiveReply(buf []byte) *XineramaIsActiveReply {
	v := new(XineramaIsActiveReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.State = Get32(buf[b:])
	b += 4

	return v
}

func (cook XineramaIsActiveCookie) Check() error {
	return cook.check()
}

// Write request to wire for XineramaIsActive
func (c *Conn) xineramaIsActiveRequest() []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINERAMA"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request XineramaQueryScreens
// size: 4
type XineramaQueryScreensCookie struct {
	*cookie
}

func (c *Conn) XineramaQueryScreens() XineramaQueryScreensCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xineramaQueryScreensRequest(), cookie)
	return XineramaQueryScreensCookie{cookie}
}

func (c *Conn) XineramaQueryScreensUnchecked() XineramaQueryScreensCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xineramaQueryScreensRequest(), cookie)
	return XineramaQueryScreensCookie{cookie}
}

// Request reply for XineramaQueryScreens
// size: (32 + pad((int(Number) * 8)))
type XineramaQueryScreensReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Number uint32
	// padding: 20 bytes
	ScreenInfo []XineramaScreenInfo // size: pad((int(Number) * 8))
}

// Waits and reads reply data from request XineramaQueryScreens
func (cook XineramaQueryScreensCookie) Reply() (*XineramaQueryScreensReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xineramaQueryScreensReply(buf), nil
}

// Read reply into structure from buffer for XineramaQueryScreens
func xineramaQueryScreensReply(buf []byte) *XineramaQueryScreensReply {
	v := new(XineramaQueryScreensReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Number = Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.ScreenInfo = make([]XineramaScreenInfo, v.Number)
	b += ReadXineramaScreenInfoList(buf[b:], v.ScreenInfo)

	return v
}

func (cook XineramaQueryScreensCookie) Check() error {
	return cook.check()
}

// Write request to wire for XineramaQueryScreens
func (c *Conn) xineramaQueryScreensRequest() []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINERAMA"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}
