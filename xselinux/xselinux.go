package xselinux

/*
	This file was generated by xselinux.xml on May 10 2012 4:20:29pm EDT.
	This file is automatically generated. Edit at your peril!
*/

import (
	"github.com/BurntSushi/xgb"

	"github.com/BurntSushi/xgb/xproto"
)

// Init must be called before using the SELinux extension.
func Init(c *xgb.Conn) error {
	reply, err := xproto.QueryExtension(c, 7, "SELinux").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return xgb.Errorf("No extension named SELinux could be found on on the server.")
	}

	xgb.ExtLock.Lock()
	c.Extensions["SELinux"] = reply.MajorOpcode
	for evNum, fun := range xgb.NewExtEventFuncs["SELinux"] {
		xgb.NewEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range xgb.NewExtErrorFuncs["SELinux"] {
		xgb.NewErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	xgb.ExtLock.Unlock()

	return nil
}

func init() {
	xgb.NewExtEventFuncs["SELinux"] = make(map[int]xgb.NewEventFun)
	xgb.NewExtErrorFuncs["SELinux"] = make(map[int]xgb.NewErrorFun)
}

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Card8'

// 'ListItem' struct definition
// Size: ((12 + xgb.Pad((int(ObjectContextLen) * 1))) + xgb.Pad((int(DataContextLen) * 1)))
type ListItem struct {
	Name             xproto.Atom
	ObjectContextLen uint32
	DataContextLen   uint32
	ObjectContext    string // size: xgb.Pad((int(ObjectContextLen) * 1))
	DataContext      string // size: xgb.Pad((int(DataContextLen) * 1))
}

// Struct read ListItem
func ListItemRead(buf []byte, v *ListItem) int {
	b := 0

	v.Name = xproto.Atom(xgb.Get32(buf[b:]))
	b += 4

	v.ObjectContextLen = xgb.Get32(buf[b:])
	b += 4

	v.DataContextLen = xgb.Get32(buf[b:])
	b += 4

	{
		byteString := make([]byte, v.ObjectContextLen)
		copy(byteString[:v.ObjectContextLen], buf[b:])
		v.ObjectContext = string(byteString)
		b += xgb.Pad(int(v.ObjectContextLen))
	}

	{
		byteString := make([]byte, v.DataContextLen)
		copy(byteString[:v.DataContextLen], buf[b:])
		v.DataContext = string(byteString)
		b += xgb.Pad(int(v.DataContextLen))
	}

	return b
}

// Struct list read ListItem
func ListItemReadList(buf []byte, dest []ListItem) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ListItem{}
		b += ListItemRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write ListItem
func (v ListItem) Bytes() []byte {
	buf := make([]byte, ((12 + xgb.Pad((int(v.ObjectContextLen) * 1))) + xgb.Pad((int(v.DataContextLen) * 1))))
	b := 0

	xgb.Put32(buf[b:], uint32(v.Name))
	b += 4

	xgb.Put32(buf[b:], v.ObjectContextLen)
	b += 4

	xgb.Put32(buf[b:], v.DataContextLen)
	b += 4

	copy(buf[b:], v.ObjectContext[:v.ObjectContextLen])
	b += xgb.Pad(int(v.ObjectContextLen))

	copy(buf[b:], v.DataContext[:v.DataContextLen])
	b += xgb.Pad(int(v.DataContextLen))

	return buf
}

// Write struct list ListItem
func ListItemListBytes(buf []byte, list []ListItem) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size ListItem
func ListItemListSize(list []ListItem) int {
	size := 0
	for _, item := range list {
		size += ((12 + xgb.Pad((int(item.ObjectContextLen) * 1))) + xgb.Pad((int(item.DataContextLen) * 1)))
	}
	return size
}

// Request QueryVersion
// size: 8
type QueryVersionCookie struct {
	*xgb.Cookie
}

func QueryVersion(c *xgb.Conn, ClientMajor byte, ClientMinor byte) QueryVersionCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryVersionRequest(c, ClientMajor, ClientMinor), cookie)
	return QueryVersionCookie{cookie}
}

func QueryVersionUnchecked(c *xgb.Conn, ClientMajor byte, ClientMinor byte) QueryVersionCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryVersionRequest(c, ClientMajor, ClientMinor), cookie)
	return QueryVersionCookie{cookie}
}

// Request reply for QueryVersion
// size: 12
type QueryVersionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ServerMajor uint16
	ServerMinor uint16
}

// Waits and reads reply data from request QueryVersion
func (cook QueryVersionCookie) Reply() (*QueryVersionReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryVersionReply(buf), nil
}

// Read reply into structure from buffer for QueryVersion
func queryVersionReply(buf []byte) *QueryVersionReply {
	v := new(QueryVersionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ServerMajor = xgb.Get16(buf[b:])
	b += 2

	v.ServerMinor = xgb.Get16(buf[b:])
	b += 2

	return v
}

// Write request to wire for QueryVersion
func queryVersionRequest(c *xgb.Conn, ClientMajor byte, ClientMinor byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 0 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = ClientMajor
	b += 1

	buf[b] = ClientMinor
	b += 1

	return buf
}

// Request SetDeviceCreateContext
// size: xgb.Pad((8 + xgb.Pad((int(ContextLen) * 1))))
type SetDeviceCreateContextCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetDeviceCreateContext
func SetDeviceCreateContext(c *xgb.Conn, ContextLen uint32, Context string) SetDeviceCreateContextCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setDeviceCreateContextRequest(c, ContextLen, Context), cookie)
	return SetDeviceCreateContextCookie{cookie}
}

func SetDeviceCreateContextChecked(c *xgb.Conn, ContextLen uint32, Context string) SetDeviceCreateContextCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setDeviceCreateContextRequest(c, ContextLen, Context), cookie)
	return SetDeviceCreateContextCookie{cookie}
}

func (cook SetDeviceCreateContextCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetDeviceCreateContext
func setDeviceCreateContextRequest(c *xgb.Conn, ContextLen uint32, Context string) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(ContextLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], ContextLen)
	b += 4

	copy(buf[b:], Context[:ContextLen])
	b += xgb.Pad(int(ContextLen))

	return buf
}

// Request GetDeviceCreateContext
// size: 4
type GetDeviceCreateContextCookie struct {
	*xgb.Cookie
}

func GetDeviceCreateContext(c *xgb.Conn) GetDeviceCreateContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceCreateContextRequest(c), cookie)
	return GetDeviceCreateContextCookie{cookie}
}

func GetDeviceCreateContextUnchecked(c *xgb.Conn) GetDeviceCreateContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceCreateContextRequest(c), cookie)
	return GetDeviceCreateContextCookie{cookie}
}

// Request reply for GetDeviceCreateContext
// size: (32 + xgb.Pad((int(ContextLen) * 1)))
type GetDeviceCreateContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: xgb.Pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request GetDeviceCreateContext
func (cook GetDeviceCreateContextCookie) Reply() (*GetDeviceCreateContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceCreateContextReply(buf), nil
}

// Read reply into structure from buffer for GetDeviceCreateContext
func getDeviceCreateContextReply(buf []byte) *GetDeviceCreateContextReply {
	v := new(GetDeviceCreateContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += xgb.Pad(int(v.ContextLen))
	}

	return v
}

// Write request to wire for GetDeviceCreateContext
func getDeviceCreateContextRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request SetDeviceContext
// size: xgb.Pad((12 + xgb.Pad((int(ContextLen) * 1))))
type SetDeviceContextCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetDeviceContext
func SetDeviceContext(c *xgb.Conn, Device uint32, ContextLen uint32, Context string) SetDeviceContextCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setDeviceContextRequest(c, Device, ContextLen, Context), cookie)
	return SetDeviceContextCookie{cookie}
}

func SetDeviceContextChecked(c *xgb.Conn, Device uint32, ContextLen uint32, Context string) SetDeviceContextCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setDeviceContextRequest(c, Device, ContextLen, Context), cookie)
	return SetDeviceContextCookie{cookie}
}

func (cook SetDeviceContextCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetDeviceContext
func setDeviceContextRequest(c *xgb.Conn, Device uint32, ContextLen uint32, Context string) []byte {
	size := xgb.Pad((12 + xgb.Pad((int(ContextLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Device)
	b += 4

	xgb.Put32(buf[b:], ContextLen)
	b += 4

	copy(buf[b:], Context[:ContextLen])
	b += xgb.Pad(int(ContextLen))

	return buf
}

// Request GetDeviceContext
// size: 8
type GetDeviceContextCookie struct {
	*xgb.Cookie
}

func GetDeviceContext(c *xgb.Conn, Device uint32) GetDeviceContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceContextRequest(c, Device), cookie)
	return GetDeviceContextCookie{cookie}
}

func GetDeviceContextUnchecked(c *xgb.Conn, Device uint32) GetDeviceContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceContextRequest(c, Device), cookie)
	return GetDeviceContextCookie{cookie}
}

// Request reply for GetDeviceContext
// size: (32 + xgb.Pad((int(ContextLen) * 1)))
type GetDeviceContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: xgb.Pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request GetDeviceContext
func (cook GetDeviceContextCookie) Reply() (*GetDeviceContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceContextReply(buf), nil
}

// Read reply into structure from buffer for GetDeviceContext
func getDeviceContextReply(buf []byte) *GetDeviceContextReply {
	v := new(GetDeviceContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += xgb.Pad(int(v.ContextLen))
	}

	return v
}

// Write request to wire for GetDeviceContext
func getDeviceContextRequest(c *xgb.Conn, Device uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Device)
	b += 4

	return buf
}

// Request SetWindowCreateContext
// size: xgb.Pad((8 + xgb.Pad((int(ContextLen) * 1))))
type SetWindowCreateContextCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetWindowCreateContext
func SetWindowCreateContext(c *xgb.Conn, ContextLen uint32, Context string) SetWindowCreateContextCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setWindowCreateContextRequest(c, ContextLen, Context), cookie)
	return SetWindowCreateContextCookie{cookie}
}

func SetWindowCreateContextChecked(c *xgb.Conn, ContextLen uint32, Context string) SetWindowCreateContextCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setWindowCreateContextRequest(c, ContextLen, Context), cookie)
	return SetWindowCreateContextCookie{cookie}
}

func (cook SetWindowCreateContextCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetWindowCreateContext
func setWindowCreateContextRequest(c *xgb.Conn, ContextLen uint32, Context string) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(ContextLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], ContextLen)
	b += 4

	copy(buf[b:], Context[:ContextLen])
	b += xgb.Pad(int(ContextLen))

	return buf
}

// Request GetWindowCreateContext
// size: 4
type GetWindowCreateContextCookie struct {
	*xgb.Cookie
}

func GetWindowCreateContext(c *xgb.Conn) GetWindowCreateContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getWindowCreateContextRequest(c), cookie)
	return GetWindowCreateContextCookie{cookie}
}

func GetWindowCreateContextUnchecked(c *xgb.Conn) GetWindowCreateContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getWindowCreateContextRequest(c), cookie)
	return GetWindowCreateContextCookie{cookie}
}

// Request reply for GetWindowCreateContext
// size: (32 + xgb.Pad((int(ContextLen) * 1)))
type GetWindowCreateContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: xgb.Pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request GetWindowCreateContext
func (cook GetWindowCreateContextCookie) Reply() (*GetWindowCreateContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getWindowCreateContextReply(buf), nil
}

// Read reply into structure from buffer for GetWindowCreateContext
func getWindowCreateContextReply(buf []byte) *GetWindowCreateContextReply {
	v := new(GetWindowCreateContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += xgb.Pad(int(v.ContextLen))
	}

	return v
}

// Write request to wire for GetWindowCreateContext
func getWindowCreateContextRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request GetWindowContext
// size: 8
type GetWindowContextCookie struct {
	*xgb.Cookie
}

func GetWindowContext(c *xgb.Conn, Window xproto.Window) GetWindowContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getWindowContextRequest(c, Window), cookie)
	return GetWindowContextCookie{cookie}
}

func GetWindowContextUnchecked(c *xgb.Conn, Window xproto.Window) GetWindowContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getWindowContextRequest(c, Window), cookie)
	return GetWindowContextCookie{cookie}
}

// Request reply for GetWindowContext
// size: (32 + xgb.Pad((int(ContextLen) * 1)))
type GetWindowContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: xgb.Pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request GetWindowContext
func (cook GetWindowContextCookie) Reply() (*GetWindowContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getWindowContextReply(buf), nil
}

// Read reply into structure from buffer for GetWindowContext
func getWindowContextReply(buf []byte) *GetWindowContextReply {
	v := new(GetWindowContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += xgb.Pad(int(v.ContextLen))
	}

	return v
}

// Write request to wire for GetWindowContext
func getWindowContextRequest(c *xgb.Conn, Window xproto.Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request SetPropertyCreateContext
// size: xgb.Pad((8 + xgb.Pad((int(ContextLen) * 1))))
type SetPropertyCreateContextCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetPropertyCreateContext
func SetPropertyCreateContext(c *xgb.Conn, ContextLen uint32, Context string) SetPropertyCreateContextCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setPropertyCreateContextRequest(c, ContextLen, Context), cookie)
	return SetPropertyCreateContextCookie{cookie}
}

func SetPropertyCreateContextChecked(c *xgb.Conn, ContextLen uint32, Context string) SetPropertyCreateContextCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setPropertyCreateContextRequest(c, ContextLen, Context), cookie)
	return SetPropertyCreateContextCookie{cookie}
}

func (cook SetPropertyCreateContextCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetPropertyCreateContext
func setPropertyCreateContextRequest(c *xgb.Conn, ContextLen uint32, Context string) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(ContextLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 8 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], ContextLen)
	b += 4

	copy(buf[b:], Context[:ContextLen])
	b += xgb.Pad(int(ContextLen))

	return buf
}

// Request GetPropertyCreateContext
// size: 4
type GetPropertyCreateContextCookie struct {
	*xgb.Cookie
}

func GetPropertyCreateContext(c *xgb.Conn) GetPropertyCreateContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getPropertyCreateContextRequest(c), cookie)
	return GetPropertyCreateContextCookie{cookie}
}

func GetPropertyCreateContextUnchecked(c *xgb.Conn) GetPropertyCreateContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getPropertyCreateContextRequest(c), cookie)
	return GetPropertyCreateContextCookie{cookie}
}

// Request reply for GetPropertyCreateContext
// size: (32 + xgb.Pad((int(ContextLen) * 1)))
type GetPropertyCreateContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: xgb.Pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request GetPropertyCreateContext
func (cook GetPropertyCreateContextCookie) Reply() (*GetPropertyCreateContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getPropertyCreateContextReply(buf), nil
}

// Read reply into structure from buffer for GetPropertyCreateContext
func getPropertyCreateContextReply(buf []byte) *GetPropertyCreateContextReply {
	v := new(GetPropertyCreateContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += xgb.Pad(int(v.ContextLen))
	}

	return v
}

// Write request to wire for GetPropertyCreateContext
func getPropertyCreateContextRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 9 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request SetPropertyUseContext
// size: xgb.Pad((8 + xgb.Pad((int(ContextLen) * 1))))
type SetPropertyUseContextCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetPropertyUseContext
func SetPropertyUseContext(c *xgb.Conn, ContextLen uint32, Context string) SetPropertyUseContextCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setPropertyUseContextRequest(c, ContextLen, Context), cookie)
	return SetPropertyUseContextCookie{cookie}
}

func SetPropertyUseContextChecked(c *xgb.Conn, ContextLen uint32, Context string) SetPropertyUseContextCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setPropertyUseContextRequest(c, ContextLen, Context), cookie)
	return SetPropertyUseContextCookie{cookie}
}

func (cook SetPropertyUseContextCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetPropertyUseContext
func setPropertyUseContextRequest(c *xgb.Conn, ContextLen uint32, Context string) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(ContextLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 10 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], ContextLen)
	b += 4

	copy(buf[b:], Context[:ContextLen])
	b += xgb.Pad(int(ContextLen))

	return buf
}

// Request GetPropertyUseContext
// size: 4
type GetPropertyUseContextCookie struct {
	*xgb.Cookie
}

func GetPropertyUseContext(c *xgb.Conn) GetPropertyUseContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getPropertyUseContextRequest(c), cookie)
	return GetPropertyUseContextCookie{cookie}
}

func GetPropertyUseContextUnchecked(c *xgb.Conn) GetPropertyUseContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getPropertyUseContextRequest(c), cookie)
	return GetPropertyUseContextCookie{cookie}
}

// Request reply for GetPropertyUseContext
// size: (32 + xgb.Pad((int(ContextLen) * 1)))
type GetPropertyUseContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: xgb.Pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request GetPropertyUseContext
func (cook GetPropertyUseContextCookie) Reply() (*GetPropertyUseContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getPropertyUseContextReply(buf), nil
}

// Read reply into structure from buffer for GetPropertyUseContext
func getPropertyUseContextReply(buf []byte) *GetPropertyUseContextReply {
	v := new(GetPropertyUseContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += xgb.Pad(int(v.ContextLen))
	}

	return v
}

// Write request to wire for GetPropertyUseContext
func getPropertyUseContextRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 11 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request GetPropertyContext
// size: 12
type GetPropertyContextCookie struct {
	*xgb.Cookie
}

func GetPropertyContext(c *xgb.Conn, Window xproto.Window, Property xproto.Atom) GetPropertyContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getPropertyContextRequest(c, Window, Property), cookie)
	return GetPropertyContextCookie{cookie}
}

func GetPropertyContextUnchecked(c *xgb.Conn, Window xproto.Window, Property xproto.Atom) GetPropertyContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getPropertyContextRequest(c, Window, Property), cookie)
	return GetPropertyContextCookie{cookie}
}

// Request reply for GetPropertyContext
// size: (32 + xgb.Pad((int(ContextLen) * 1)))
type GetPropertyContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: xgb.Pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request GetPropertyContext
func (cook GetPropertyContextCookie) Reply() (*GetPropertyContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getPropertyContextReply(buf), nil
}

// Read reply into structure from buffer for GetPropertyContext
func getPropertyContextReply(buf []byte) *GetPropertyContextReply {
	v := new(GetPropertyContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += xgb.Pad(int(v.ContextLen))
	}

	return v
}

// Write request to wire for GetPropertyContext
func getPropertyContextRequest(c *xgb.Conn, Window xproto.Window, Property xproto.Atom) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 12 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put32(buf[b:], uint32(Property))
	b += 4

	return buf
}

// Request GetPropertyDataContext
// size: 12
type GetPropertyDataContextCookie struct {
	*xgb.Cookie
}

func GetPropertyDataContext(c *xgb.Conn, Window xproto.Window, Property xproto.Atom) GetPropertyDataContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getPropertyDataContextRequest(c, Window, Property), cookie)
	return GetPropertyDataContextCookie{cookie}
}

func GetPropertyDataContextUnchecked(c *xgb.Conn, Window xproto.Window, Property xproto.Atom) GetPropertyDataContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getPropertyDataContextRequest(c, Window, Property), cookie)
	return GetPropertyDataContextCookie{cookie}
}

// Request reply for GetPropertyDataContext
// size: (32 + xgb.Pad((int(ContextLen) * 1)))
type GetPropertyDataContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: xgb.Pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request GetPropertyDataContext
func (cook GetPropertyDataContextCookie) Reply() (*GetPropertyDataContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getPropertyDataContextReply(buf), nil
}

// Read reply into structure from buffer for GetPropertyDataContext
func getPropertyDataContextReply(buf []byte) *GetPropertyDataContextReply {
	v := new(GetPropertyDataContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += xgb.Pad(int(v.ContextLen))
	}

	return v
}

// Write request to wire for GetPropertyDataContext
func getPropertyDataContextRequest(c *xgb.Conn, Window xproto.Window, Property xproto.Atom) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 13 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put32(buf[b:], uint32(Property))
	b += 4

	return buf
}

// Request ListProperties
// size: 8
type ListPropertiesCookie struct {
	*xgb.Cookie
}

func ListProperties(c *xgb.Conn, Window xproto.Window) ListPropertiesCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(listPropertiesRequest(c, Window), cookie)
	return ListPropertiesCookie{cookie}
}

func ListPropertiesUnchecked(c *xgb.Conn, Window xproto.Window) ListPropertiesCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(listPropertiesRequest(c, Window), cookie)
	return ListPropertiesCookie{cookie}
}

// Request reply for ListProperties
// size: (32 + ListItemListSize(Properties))
type ListPropertiesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	PropertiesLen uint32
	// padding: 20 bytes
	Properties []ListItem // size: ListItemListSize(Properties)
}

// Waits and reads reply data from request ListProperties
func (cook ListPropertiesCookie) Reply() (*ListPropertiesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listPropertiesReply(buf), nil
}

// Read reply into structure from buffer for ListProperties
func listPropertiesReply(buf []byte) *ListPropertiesReply {
	v := new(ListPropertiesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.PropertiesLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.Properties = make([]ListItem, v.PropertiesLen)
	b += ListItemReadList(buf[b:], v.Properties)

	return v
}

// Write request to wire for ListProperties
func listPropertiesRequest(c *xgb.Conn, Window xproto.Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 14 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request SetSelectionCreateContext
// size: xgb.Pad((8 + xgb.Pad((int(ContextLen) * 1))))
type SetSelectionCreateContextCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetSelectionCreateContext
func SetSelectionCreateContext(c *xgb.Conn, ContextLen uint32, Context string) SetSelectionCreateContextCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setSelectionCreateContextRequest(c, ContextLen, Context), cookie)
	return SetSelectionCreateContextCookie{cookie}
}

func SetSelectionCreateContextChecked(c *xgb.Conn, ContextLen uint32, Context string) SetSelectionCreateContextCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setSelectionCreateContextRequest(c, ContextLen, Context), cookie)
	return SetSelectionCreateContextCookie{cookie}
}

func (cook SetSelectionCreateContextCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetSelectionCreateContext
func setSelectionCreateContextRequest(c *xgb.Conn, ContextLen uint32, Context string) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(ContextLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 15 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], ContextLen)
	b += 4

	copy(buf[b:], Context[:ContextLen])
	b += xgb.Pad(int(ContextLen))

	return buf
}

// Request GetSelectionCreateContext
// size: 4
type GetSelectionCreateContextCookie struct {
	*xgb.Cookie
}

func GetSelectionCreateContext(c *xgb.Conn) GetSelectionCreateContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getSelectionCreateContextRequest(c), cookie)
	return GetSelectionCreateContextCookie{cookie}
}

func GetSelectionCreateContextUnchecked(c *xgb.Conn) GetSelectionCreateContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getSelectionCreateContextRequest(c), cookie)
	return GetSelectionCreateContextCookie{cookie}
}

// Request reply for GetSelectionCreateContext
// size: (32 + xgb.Pad((int(ContextLen) * 1)))
type GetSelectionCreateContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: xgb.Pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request GetSelectionCreateContext
func (cook GetSelectionCreateContextCookie) Reply() (*GetSelectionCreateContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getSelectionCreateContextReply(buf), nil
}

// Read reply into structure from buffer for GetSelectionCreateContext
func getSelectionCreateContextReply(buf []byte) *GetSelectionCreateContextReply {
	v := new(GetSelectionCreateContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += xgb.Pad(int(v.ContextLen))
	}

	return v
}

// Write request to wire for GetSelectionCreateContext
func getSelectionCreateContextRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 16 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request SetSelectionUseContext
// size: xgb.Pad((8 + xgb.Pad((int(ContextLen) * 1))))
type SetSelectionUseContextCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetSelectionUseContext
func SetSelectionUseContext(c *xgb.Conn, ContextLen uint32, Context string) SetSelectionUseContextCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setSelectionUseContextRequest(c, ContextLen, Context), cookie)
	return SetSelectionUseContextCookie{cookie}
}

func SetSelectionUseContextChecked(c *xgb.Conn, ContextLen uint32, Context string) SetSelectionUseContextCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setSelectionUseContextRequest(c, ContextLen, Context), cookie)
	return SetSelectionUseContextCookie{cookie}
}

func (cook SetSelectionUseContextCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetSelectionUseContext
func setSelectionUseContextRequest(c *xgb.Conn, ContextLen uint32, Context string) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(ContextLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 17 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], ContextLen)
	b += 4

	copy(buf[b:], Context[:ContextLen])
	b += xgb.Pad(int(ContextLen))

	return buf
}

// Request GetSelectionUseContext
// size: 4
type GetSelectionUseContextCookie struct {
	*xgb.Cookie
}

func GetSelectionUseContext(c *xgb.Conn) GetSelectionUseContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getSelectionUseContextRequest(c), cookie)
	return GetSelectionUseContextCookie{cookie}
}

func GetSelectionUseContextUnchecked(c *xgb.Conn) GetSelectionUseContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getSelectionUseContextRequest(c), cookie)
	return GetSelectionUseContextCookie{cookie}
}

// Request reply for GetSelectionUseContext
// size: (32 + xgb.Pad((int(ContextLen) * 1)))
type GetSelectionUseContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: xgb.Pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request GetSelectionUseContext
func (cook GetSelectionUseContextCookie) Reply() (*GetSelectionUseContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getSelectionUseContextReply(buf), nil
}

// Read reply into structure from buffer for GetSelectionUseContext
func getSelectionUseContextReply(buf []byte) *GetSelectionUseContextReply {
	v := new(GetSelectionUseContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += xgb.Pad(int(v.ContextLen))
	}

	return v
}

// Write request to wire for GetSelectionUseContext
func getSelectionUseContextRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 18 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request GetSelectionContext
// size: 8
type GetSelectionContextCookie struct {
	*xgb.Cookie
}

func GetSelectionContext(c *xgb.Conn, Selection xproto.Atom) GetSelectionContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getSelectionContextRequest(c, Selection), cookie)
	return GetSelectionContextCookie{cookie}
}

func GetSelectionContextUnchecked(c *xgb.Conn, Selection xproto.Atom) GetSelectionContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getSelectionContextRequest(c, Selection), cookie)
	return GetSelectionContextCookie{cookie}
}

// Request reply for GetSelectionContext
// size: (32 + xgb.Pad((int(ContextLen) * 1)))
type GetSelectionContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: xgb.Pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request GetSelectionContext
func (cook GetSelectionContextCookie) Reply() (*GetSelectionContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getSelectionContextReply(buf), nil
}

// Read reply into structure from buffer for GetSelectionContext
func getSelectionContextReply(buf []byte) *GetSelectionContextReply {
	v := new(GetSelectionContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += xgb.Pad(int(v.ContextLen))
	}

	return v
}

// Write request to wire for GetSelectionContext
func getSelectionContextRequest(c *xgb.Conn, Selection xproto.Atom) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 19 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Selection))
	b += 4

	return buf
}

// Request GetSelectionDataContext
// size: 8
type GetSelectionDataContextCookie struct {
	*xgb.Cookie
}

func GetSelectionDataContext(c *xgb.Conn, Selection xproto.Atom) GetSelectionDataContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getSelectionDataContextRequest(c, Selection), cookie)
	return GetSelectionDataContextCookie{cookie}
}

func GetSelectionDataContextUnchecked(c *xgb.Conn, Selection xproto.Atom) GetSelectionDataContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getSelectionDataContextRequest(c, Selection), cookie)
	return GetSelectionDataContextCookie{cookie}
}

// Request reply for GetSelectionDataContext
// size: (32 + xgb.Pad((int(ContextLen) * 1)))
type GetSelectionDataContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: xgb.Pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request GetSelectionDataContext
func (cook GetSelectionDataContextCookie) Reply() (*GetSelectionDataContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getSelectionDataContextReply(buf), nil
}

// Read reply into structure from buffer for GetSelectionDataContext
func getSelectionDataContextReply(buf []byte) *GetSelectionDataContextReply {
	v := new(GetSelectionDataContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += xgb.Pad(int(v.ContextLen))
	}

	return v
}

// Write request to wire for GetSelectionDataContext
func getSelectionDataContextRequest(c *xgb.Conn, Selection xproto.Atom) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 20 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Selection))
	b += 4

	return buf
}

// Request ListSelections
// size: 4
type ListSelectionsCookie struct {
	*xgb.Cookie
}

func ListSelections(c *xgb.Conn) ListSelectionsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(listSelectionsRequest(c), cookie)
	return ListSelectionsCookie{cookie}
}

func ListSelectionsUnchecked(c *xgb.Conn) ListSelectionsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(listSelectionsRequest(c), cookie)
	return ListSelectionsCookie{cookie}
}

// Request reply for ListSelections
// size: (32 + ListItemListSize(Selections))
type ListSelectionsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	SelectionsLen uint32
	// padding: 20 bytes
	Selections []ListItem // size: ListItemListSize(Selections)
}

// Waits and reads reply data from request ListSelections
func (cook ListSelectionsCookie) Reply() (*ListSelectionsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listSelectionsReply(buf), nil
}

// Read reply into structure from buffer for ListSelections
func listSelectionsReply(buf []byte) *ListSelectionsReply {
	v := new(ListSelectionsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.SelectionsLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.Selections = make([]ListItem, v.SelectionsLen)
	b += ListItemReadList(buf[b:], v.Selections)

	return v
}

// Write request to wire for ListSelections
func listSelectionsRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 21 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request GetClientContext
// size: 8
type GetClientContextCookie struct {
	*xgb.Cookie
}

func GetClientContext(c *xgb.Conn, Resource uint32) GetClientContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getClientContextRequest(c, Resource), cookie)
	return GetClientContextCookie{cookie}
}

func GetClientContextUnchecked(c *xgb.Conn, Resource uint32) GetClientContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getClientContextRequest(c, Resource), cookie)
	return GetClientContextCookie{cookie}
}

// Request reply for GetClientContext
// size: (32 + xgb.Pad((int(ContextLen) * 1)))
type GetClientContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: xgb.Pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request GetClientContext
func (cook GetClientContextCookie) Reply() (*GetClientContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getClientContextReply(buf), nil
}

// Read reply into structure from buffer for GetClientContext
func getClientContextReply(buf []byte) *GetClientContextReply {
	v := new(GetClientContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += xgb.Pad(int(v.ContextLen))
	}

	return v
}

// Write request to wire for GetClientContext
func getClientContextRequest(c *xgb.Conn, Resource uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SELINUX"]
	b += 1

	buf[b] = 22 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Resource)
	b += 4

	return buf
}
