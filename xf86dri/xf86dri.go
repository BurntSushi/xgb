// Package xf86dri is the X client API for the XFree86-DRI extension.
package xf86dri

/*
	This file was generated by xf86dri.xml on May 10 2012 8:04:32pm EDT.
	This file is automatically generated. Edit at your peril!
*/

import (
	"github.com/BurntSushi/xgb"

	"github.com/BurntSushi/xgb/xproto"
)

// Init must be called before using the XFree86-DRI extension.
func Init(c *xgb.Conn) error {
	reply, err := xproto.QueryExtension(c, 11, "XFree86-DRI").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return xgb.Errorf("No extension named XFree86-DRI could be found on on the server.")
	}

	xgb.ExtLock.Lock()
	c.Extensions["XFree86-DRI"] = reply.MajorOpcode
	for evNum, fun := range xgb.NewExtEventFuncs["XFree86-DRI"] {
		xgb.NewEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range xgb.NewExtErrorFuncs["XFree86-DRI"] {
		xgb.NewErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	xgb.ExtLock.Unlock()

	return nil
}

func init() {
	xgb.NewExtEventFuncs["XFree86-DRI"] = make(map[int]xgb.NewEventFun)
	xgb.NewExtErrorFuncs["XFree86-DRI"] = make(map[int]xgb.NewErrorFun)
}

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// 'DrmClipRect' struct definition
// Size: 8
type DrmClipRect struct {
	X1 int16
	Y1 int16
	X2 int16
	X3 int16
}

// Struct read DrmClipRect
func DrmClipRectRead(buf []byte, v *DrmClipRect) int {
	b := 0

	v.X1 = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Y1 = int16(xgb.Get16(buf[b:]))
	b += 2

	v.X2 = int16(xgb.Get16(buf[b:]))
	b += 2

	v.X3 = int16(xgb.Get16(buf[b:]))
	b += 2

	return b
}

// Struct list read DrmClipRect
func DrmClipRectReadList(buf []byte, dest []DrmClipRect) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DrmClipRect{}
		b += DrmClipRectRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write DrmClipRect
func (v DrmClipRect) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put16(buf[b:], uint16(v.X1))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Y1))
	b += 2

	xgb.Put16(buf[b:], uint16(v.X2))
	b += 2

	xgb.Put16(buf[b:], uint16(v.X3))
	b += 2

	return buf
}

// Write struct list DrmClipRect
func DrmClipRectListBytes(buf []byte, list []DrmClipRect) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Request QueryVersion
// size: 4
type QueryVersionCookie struct {
	*xgb.Cookie
}

func QueryVersion(c *xgb.Conn) QueryVersionCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryVersionRequest(c), cookie)
	return QueryVersionCookie{cookie}
}

func QueryVersionUnchecked(c *xgb.Conn) QueryVersionCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryVersionRequest(c), cookie)
	return QueryVersionCookie{cookie}
}

// Request reply for QueryVersion
// size: 16
type QueryVersionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	DriMajorVersion uint16
	DriMinorVersion uint16
	DriMinorPatch   uint32
}

// Waits and reads reply data from request QueryVersion
func (cook QueryVersionCookie) Reply() (*QueryVersionReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryVersionReply(buf), nil
}

// Read reply into structure from buffer for QueryVersion
func queryVersionReply(buf []byte) *QueryVersionReply {
	v := new(QueryVersionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.DriMajorVersion = xgb.Get16(buf[b:])
	b += 2

	v.DriMinorVersion = xgb.Get16(buf[b:])
	b += 2

	v.DriMinorPatch = xgb.Get32(buf[b:])
	b += 4

	return v
}

// Write request to wire for QueryVersion
func queryVersionRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XFREE86-DRI"]
	b += 1

	buf[b] = 0 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request QueryDirectRenderingCapable
// size: 8
type QueryDirectRenderingCapableCookie struct {
	*xgb.Cookie
}

func QueryDirectRenderingCapable(c *xgb.Conn, Screen uint32) QueryDirectRenderingCapableCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryDirectRenderingCapableRequest(c, Screen), cookie)
	return QueryDirectRenderingCapableCookie{cookie}
}

func QueryDirectRenderingCapableUnchecked(c *xgb.Conn, Screen uint32) QueryDirectRenderingCapableCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryDirectRenderingCapableRequest(c, Screen), cookie)
	return QueryDirectRenderingCapableCookie{cookie}
}

// Request reply for QueryDirectRenderingCapable
// size: 9
type QueryDirectRenderingCapableReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	IsCapable bool
}

// Waits and reads reply data from request QueryDirectRenderingCapable
func (cook QueryDirectRenderingCapableCookie) Reply() (*QueryDirectRenderingCapableReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryDirectRenderingCapableReply(buf), nil
}

// Read reply into structure from buffer for QueryDirectRenderingCapable
func queryDirectRenderingCapableReply(buf []byte) *QueryDirectRenderingCapableReply {
	v := new(QueryDirectRenderingCapableReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	if buf[b] == 1 {
		v.IsCapable = true
	} else {
		v.IsCapable = false
	}
	b += 1

	return v
}

// Write request to wire for QueryDirectRenderingCapable
func queryDirectRenderingCapableRequest(c *xgb.Conn, Screen uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XFREE86-DRI"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	return buf
}

// Request OpenConnection
// size: 8
type OpenConnectionCookie struct {
	*xgb.Cookie
}

func OpenConnection(c *xgb.Conn, Screen uint32) OpenConnectionCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(openConnectionRequest(c, Screen), cookie)
	return OpenConnectionCookie{cookie}
}

func OpenConnectionUnchecked(c *xgb.Conn, Screen uint32) OpenConnectionCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(openConnectionRequest(c, Screen), cookie)
	return OpenConnectionCookie{cookie}
}

// Request reply for OpenConnection
// size: (32 + xgb.Pad((int(BusIdLen) * 1)))
type OpenConnectionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	SareaHandleLow  uint32
	SareaHandleHigh uint32
	BusIdLen        uint32
	// padding: 12 bytes
	BusId string // size: xgb.Pad((int(BusIdLen) * 1))
}

// Waits and reads reply data from request OpenConnection
func (cook OpenConnectionCookie) Reply() (*OpenConnectionReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return openConnectionReply(buf), nil
}

// Read reply into structure from buffer for OpenConnection
func openConnectionReply(buf []byte) *OpenConnectionReply {
	v := new(OpenConnectionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.SareaHandleLow = xgb.Get32(buf[b:])
	b += 4

	v.SareaHandleHigh = xgb.Get32(buf[b:])
	b += 4

	v.BusIdLen = xgb.Get32(buf[b:])
	b += 4

	b += 12 // padding

	{
		byteString := make([]byte, v.BusIdLen)
		copy(byteString[:v.BusIdLen], buf[b:])
		v.BusId = string(byteString)
		b += xgb.Pad(int(v.BusIdLen))
	}

	return v
}

// Write request to wire for OpenConnection
func openConnectionRequest(c *xgb.Conn, Screen uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XFREE86-DRI"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	return buf
}

// Request CloseConnection
// size: 8
type CloseConnectionCookie struct {
	*xgb.Cookie
}

// Write request to wire for CloseConnection
func CloseConnection(c *xgb.Conn, Screen uint32) CloseConnectionCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(closeConnectionRequest(c, Screen), cookie)
	return CloseConnectionCookie{cookie}
}

func CloseConnectionChecked(c *xgb.Conn, Screen uint32) CloseConnectionCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(closeConnectionRequest(c, Screen), cookie)
	return CloseConnectionCookie{cookie}
}

func (cook CloseConnectionCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CloseConnection
func closeConnectionRequest(c *xgb.Conn, Screen uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XFREE86-DRI"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	return buf
}

// Request GetClientDriverName
// size: 8
type GetClientDriverNameCookie struct {
	*xgb.Cookie
}

func GetClientDriverName(c *xgb.Conn, Screen uint32) GetClientDriverNameCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getClientDriverNameRequest(c, Screen), cookie)
	return GetClientDriverNameCookie{cookie}
}

func GetClientDriverNameUnchecked(c *xgb.Conn, Screen uint32) GetClientDriverNameCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getClientDriverNameRequest(c, Screen), cookie)
	return GetClientDriverNameCookie{cookie}
}

// Request reply for GetClientDriverName
// size: (32 + xgb.Pad((int(ClientDriverNameLen) * 1)))
type GetClientDriverNameReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ClientDriverMajorVersion uint32
	ClientDriverMinorVersion uint32
	ClientDriverPatchVersion uint32
	ClientDriverNameLen      uint32
	// padding: 8 bytes
	ClientDriverName string // size: xgb.Pad((int(ClientDriverNameLen) * 1))
}

// Waits and reads reply data from request GetClientDriverName
func (cook GetClientDriverNameCookie) Reply() (*GetClientDriverNameReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getClientDriverNameReply(buf), nil
}

// Read reply into structure from buffer for GetClientDriverName
func getClientDriverNameReply(buf []byte) *GetClientDriverNameReply {
	v := new(GetClientDriverNameReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ClientDriverMajorVersion = xgb.Get32(buf[b:])
	b += 4

	v.ClientDriverMinorVersion = xgb.Get32(buf[b:])
	b += 4

	v.ClientDriverPatchVersion = xgb.Get32(buf[b:])
	b += 4

	v.ClientDriverNameLen = xgb.Get32(buf[b:])
	b += 4

	b += 8 // padding

	{
		byteString := make([]byte, v.ClientDriverNameLen)
		copy(byteString[:v.ClientDriverNameLen], buf[b:])
		v.ClientDriverName = string(byteString)
		b += xgb.Pad(int(v.ClientDriverNameLen))
	}

	return v
}

// Write request to wire for GetClientDriverName
func getClientDriverNameRequest(c *xgb.Conn, Screen uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XFREE86-DRI"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	return buf
}

// Request CreateContext
// size: 16
type CreateContextCookie struct {
	*xgb.Cookie
}

func CreateContext(c *xgb.Conn, Screen uint32, Visual uint32, Context uint32) CreateContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(createContextRequest(c, Screen, Visual, Context), cookie)
	return CreateContextCookie{cookie}
}

func CreateContextUnchecked(c *xgb.Conn, Screen uint32, Visual uint32, Context uint32) CreateContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(createContextRequest(c, Screen, Visual, Context), cookie)
	return CreateContextCookie{cookie}
}

// Request reply for CreateContext
// size: 12
type CreateContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	HwContext uint32
}

// Waits and reads reply data from request CreateContext
func (cook CreateContextCookie) Reply() (*CreateContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return createContextReply(buf), nil
}

// Read reply into structure from buffer for CreateContext
func createContextReply(buf []byte) *CreateContextReply {
	v := new(CreateContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.HwContext = xgb.Get32(buf[b:])
	b += 4

	return v
}

// Write request to wire for CreateContext
func createContextRequest(c *xgb.Conn, Screen uint32, Visual uint32, Context uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XFREE86-DRI"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	xgb.Put32(buf[b:], Visual)
	b += 4

	xgb.Put32(buf[b:], Context)
	b += 4

	return buf
}

// Request DestroyContext
// size: 12
type DestroyContextCookie struct {
	*xgb.Cookie
}

// Write request to wire for DestroyContext
func DestroyContext(c *xgb.Conn, Screen uint32, Context uint32) DestroyContextCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroyContextRequest(c, Screen, Context), cookie)
	return DestroyContextCookie{cookie}
}

func DestroyContextChecked(c *xgb.Conn, Screen uint32, Context uint32) DestroyContextCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroyContextRequest(c, Screen, Context), cookie)
	return DestroyContextCookie{cookie}
}

func (cook DestroyContextCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroyContext
func destroyContextRequest(c *xgb.Conn, Screen uint32, Context uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XFREE86-DRI"]
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	xgb.Put32(buf[b:], Context)
	b += 4

	return buf
}

// Request CreateDrawable
// size: 12
type CreateDrawableCookie struct {
	*xgb.Cookie
}

func CreateDrawable(c *xgb.Conn, Screen uint32, Drawable uint32) CreateDrawableCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(createDrawableRequest(c, Screen, Drawable), cookie)
	return CreateDrawableCookie{cookie}
}

func CreateDrawableUnchecked(c *xgb.Conn, Screen uint32, Drawable uint32) CreateDrawableCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(createDrawableRequest(c, Screen, Drawable), cookie)
	return CreateDrawableCookie{cookie}
}

// Request reply for CreateDrawable
// size: 12
type CreateDrawableReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	HwDrawableHandle uint32
}

// Waits and reads reply data from request CreateDrawable
func (cook CreateDrawableCookie) Reply() (*CreateDrawableReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return createDrawableReply(buf), nil
}

// Read reply into structure from buffer for CreateDrawable
func createDrawableReply(buf []byte) *CreateDrawableReply {
	v := new(CreateDrawableReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.HwDrawableHandle = xgb.Get32(buf[b:])
	b += 4

	return v
}

// Write request to wire for CreateDrawable
func createDrawableRequest(c *xgb.Conn, Screen uint32, Drawable uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XFREE86-DRI"]
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	xgb.Put32(buf[b:], Drawable)
	b += 4

	return buf
}

// Request DestroyDrawable
// size: 12
type DestroyDrawableCookie struct {
	*xgb.Cookie
}

// Write request to wire for DestroyDrawable
func DestroyDrawable(c *xgb.Conn, Screen uint32, Drawable uint32) DestroyDrawableCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroyDrawableRequest(c, Screen, Drawable), cookie)
	return DestroyDrawableCookie{cookie}
}

func DestroyDrawableChecked(c *xgb.Conn, Screen uint32, Drawable uint32) DestroyDrawableCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroyDrawableRequest(c, Screen, Drawable), cookie)
	return DestroyDrawableCookie{cookie}
}

func (cook DestroyDrawableCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroyDrawable
func destroyDrawableRequest(c *xgb.Conn, Screen uint32, Drawable uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XFREE86-DRI"]
	b += 1

	buf[b] = 8 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	xgb.Put32(buf[b:], Drawable)
	b += 4

	return buf
}

// Request GetDrawableInfo
// size: 12
type GetDrawableInfoCookie struct {
	*xgb.Cookie
}

func GetDrawableInfo(c *xgb.Conn, Screen uint32, Drawable uint32) GetDrawableInfoCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDrawableInfoRequest(c, Screen, Drawable), cookie)
	return GetDrawableInfoCookie{cookie}
}

func GetDrawableInfoUnchecked(c *xgb.Conn, Screen uint32, Drawable uint32) GetDrawableInfoCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDrawableInfoRequest(c, Screen, Drawable), cookie)
	return GetDrawableInfoCookie{cookie}
}

// Request reply for GetDrawableInfo
// size: ((36 + xgb.Pad((int(NumClipRects) * 8))) + xgb.Pad((int(NumBackClipRects) * 8)))
type GetDrawableInfoReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	DrawableTableIndex uint32
	DrawableTableStamp uint32
	DrawableOriginX    int16
	DrawableOriginY    int16
	DrawableSizeW      int16
	DrawableSizeH      int16
	NumClipRects       uint32
	BackX              int16
	BackY              int16
	NumBackClipRects   uint32
	ClipRects          []DrmClipRect // size: xgb.Pad((int(NumClipRects) * 8))
	BackClipRects      []DrmClipRect // size: xgb.Pad((int(NumBackClipRects) * 8))
}

// Waits and reads reply data from request GetDrawableInfo
func (cook GetDrawableInfoCookie) Reply() (*GetDrawableInfoReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDrawableInfoReply(buf), nil
}

// Read reply into structure from buffer for GetDrawableInfo
func getDrawableInfoReply(buf []byte) *GetDrawableInfoReply {
	v := new(GetDrawableInfoReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.DrawableTableIndex = xgb.Get32(buf[b:])
	b += 4

	v.DrawableTableStamp = xgb.Get32(buf[b:])
	b += 4

	v.DrawableOriginX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.DrawableOriginY = int16(xgb.Get16(buf[b:]))
	b += 2

	v.DrawableSizeW = int16(xgb.Get16(buf[b:]))
	b += 2

	v.DrawableSizeH = int16(xgb.Get16(buf[b:]))
	b += 2

	v.NumClipRects = xgb.Get32(buf[b:])
	b += 4

	v.BackX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.BackY = int16(xgb.Get16(buf[b:]))
	b += 2

	v.NumBackClipRects = xgb.Get32(buf[b:])
	b += 4

	v.ClipRects = make([]DrmClipRect, v.NumClipRects)
	b += DrmClipRectReadList(buf[b:], v.ClipRects)

	v.BackClipRects = make([]DrmClipRect, v.NumBackClipRects)
	b += DrmClipRectReadList(buf[b:], v.BackClipRects)

	return v
}

// Write request to wire for GetDrawableInfo
func getDrawableInfoRequest(c *xgb.Conn, Screen uint32, Drawable uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XFREE86-DRI"]
	b += 1

	buf[b] = 9 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	xgb.Put32(buf[b:], Drawable)
	b += 4

	return buf
}

// Request GetDeviceInfo
// size: 8
type GetDeviceInfoCookie struct {
	*xgb.Cookie
}

func GetDeviceInfo(c *xgb.Conn, Screen uint32) GetDeviceInfoCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getDeviceInfoRequest(c, Screen), cookie)
	return GetDeviceInfoCookie{cookie}
}

func GetDeviceInfoUnchecked(c *xgb.Conn, Screen uint32) GetDeviceInfoCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getDeviceInfoRequest(c, Screen), cookie)
	return GetDeviceInfoCookie{cookie}
}

// Request reply for GetDeviceInfo
// size: (32 + xgb.Pad((int(DevicePrivateSize) * 4)))
type GetDeviceInfoReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	FramebufferHandleLow    uint32
	FramebufferHandleHigh   uint32
	FramebufferOriginOffset uint32
	FramebufferSize         uint32
	FramebufferStride       uint32
	DevicePrivateSize       uint32
	DevicePrivate           []uint32 // size: xgb.Pad((int(DevicePrivateSize) * 4))
}

// Waits and reads reply data from request GetDeviceInfo
func (cook GetDeviceInfoCookie) Reply() (*GetDeviceInfoReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getDeviceInfoReply(buf), nil
}

// Read reply into structure from buffer for GetDeviceInfo
func getDeviceInfoReply(buf []byte) *GetDeviceInfoReply {
	v := new(GetDeviceInfoReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.FramebufferHandleLow = xgb.Get32(buf[b:])
	b += 4

	v.FramebufferHandleHigh = xgb.Get32(buf[b:])
	b += 4

	v.FramebufferOriginOffset = xgb.Get32(buf[b:])
	b += 4

	v.FramebufferSize = xgb.Get32(buf[b:])
	b += 4

	v.FramebufferStride = xgb.Get32(buf[b:])
	b += 4

	v.DevicePrivateSize = xgb.Get32(buf[b:])
	b += 4

	v.DevicePrivate = make([]uint32, v.DevicePrivateSize)
	for i := 0; i < int(v.DevicePrivateSize); i++ {
		v.DevicePrivate[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetDeviceInfo
func getDeviceInfoRequest(c *xgb.Conn, Screen uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XFREE86-DRI"]
	b += 1

	buf[b] = 10 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	return buf
}

// Request AuthConnection
// size: 12
type AuthConnectionCookie struct {
	*xgb.Cookie
}

func AuthConnection(c *xgb.Conn, Screen uint32, Magic uint32) AuthConnectionCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(authConnectionRequest(c, Screen, Magic), cookie)
	return AuthConnectionCookie{cookie}
}

func AuthConnectionUnchecked(c *xgb.Conn, Screen uint32, Magic uint32) AuthConnectionCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(authConnectionRequest(c, Screen, Magic), cookie)
	return AuthConnectionCookie{cookie}
}

// Request reply for AuthConnection
// size: 12
type AuthConnectionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Authenticated uint32
}

// Waits and reads reply data from request AuthConnection
func (cook AuthConnectionCookie) Reply() (*AuthConnectionReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return authConnectionReply(buf), nil
}

// Read reply into structure from buffer for AuthConnection
func authConnectionReply(buf []byte) *AuthConnectionReply {
	v := new(AuthConnectionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Authenticated = xgb.Get32(buf[b:])
	b += 4

	return v
}

// Write request to wire for AuthConnection
func authConnectionRequest(c *xgb.Conn, Screen uint32, Magic uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XFREE86-DRI"]
	b += 1

	buf[b] = 11 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Screen)
	b += 4

	xgb.Put32(buf[b:], Magic)
	b += 4

	return buf
}
