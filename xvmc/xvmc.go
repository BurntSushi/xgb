// Package xvmc is the X client API for the XVideo-MotionCompensation extension.
package xvmc

/*
	This file was generated by xvmc.xml on May 10 2012 8:04:33pm EDT.
	This file is automatically generated. Edit at your peril!
*/

import (
	"github.com/BurntSushi/xgb"

	"github.com/BurntSushi/xgb/xproto"
	"github.com/BurntSushi/xgb/xv"
)

// Init must be called before using the XVideo-MotionCompensation extension.
func Init(c *xgb.Conn) error {
	reply, err := xproto.QueryExtension(c, 25, "XVideo-MotionCompensation").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return xgb.Errorf("No extension named XVideo-MotionCompensation could be found on on the server.")
	}

	xgb.ExtLock.Lock()
	c.Extensions["XVideo-MotionCompensation"] = reply.MajorOpcode
	for evNum, fun := range xgb.NewExtEventFuncs["XVideo-MotionCompensation"] {
		xgb.NewEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range xgb.NewExtErrorFuncs["XVideo-MotionCompensation"] {
		xgb.NewErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	xgb.ExtLock.Unlock()

	return nil
}

func init() {
	xgb.NewExtEventFuncs["XVideo-MotionCompensation"] = make(map[int]xgb.NewEventFun)
	xgb.NewExtErrorFuncs["XVideo-MotionCompensation"] = make(map[int]xgb.NewErrorFun)
}

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

type Context uint32

func NewContextId(c *xgb.Conn) (Context, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Context(id), nil
}

type Surface uint32

func NewSurfaceId(c *xgb.Conn) (Surface, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Surface(id), nil
}

type Subpicture uint32

func NewSubpictureId(c *xgb.Conn) (Subpicture, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Subpicture(id), nil
}

// 'SurfaceInfo' struct definition
// Size: 24
type SurfaceInfo struct {
	Id                  Surface
	ChromaFormat        uint16
	Pad0                uint16
	MaxWidth            uint16
	MaxHeight           uint16
	SubpictureMaxWidth  uint16
	SubpictureMaxHeight uint16
	McType              uint32
	Flags               uint32
}

// Struct read SurfaceInfo
func SurfaceInfoRead(buf []byte, v *SurfaceInfo) int {
	b := 0

	v.Id = Surface(xgb.Get32(buf[b:]))
	b += 4

	v.ChromaFormat = xgb.Get16(buf[b:])
	b += 2

	v.Pad0 = xgb.Get16(buf[b:])
	b += 2

	v.MaxWidth = xgb.Get16(buf[b:])
	b += 2

	v.MaxHeight = xgb.Get16(buf[b:])
	b += 2

	v.SubpictureMaxWidth = xgb.Get16(buf[b:])
	b += 2

	v.SubpictureMaxHeight = xgb.Get16(buf[b:])
	b += 2

	v.McType = xgb.Get32(buf[b:])
	b += 4

	v.Flags = xgb.Get32(buf[b:])
	b += 4

	return b
}

// Struct list read SurfaceInfo
func SurfaceInfoReadList(buf []byte, dest []SurfaceInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SurfaceInfo{}
		b += SurfaceInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write SurfaceInfo
func (v SurfaceInfo) Bytes() []byte {
	buf := make([]byte, 24)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Id))
	b += 4

	xgb.Put16(buf[b:], v.ChromaFormat)
	b += 2

	xgb.Put16(buf[b:], v.Pad0)
	b += 2

	xgb.Put16(buf[b:], v.MaxWidth)
	b += 2

	xgb.Put16(buf[b:], v.MaxHeight)
	b += 2

	xgb.Put16(buf[b:], v.SubpictureMaxWidth)
	b += 2

	xgb.Put16(buf[b:], v.SubpictureMaxHeight)
	b += 2

	xgb.Put32(buf[b:], v.McType)
	b += 4

	xgb.Put32(buf[b:], v.Flags)
	b += 4

	return buf
}

// Write struct list SurfaceInfo
func SurfaceInfoListBytes(buf []byte, list []SurfaceInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Request QueryVersion
// size: 4
type QueryVersionCookie struct {
	*xgb.Cookie
}

func QueryVersion(c *xgb.Conn) QueryVersionCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryVersionRequest(c), cookie)
	return QueryVersionCookie{cookie}
}

func QueryVersionUnchecked(c *xgb.Conn) QueryVersionCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryVersionRequest(c), cookie)
	return QueryVersionCookie{cookie}
}

// Request reply for QueryVersion
// size: 16
type QueryVersionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Major uint32
	Minor uint32
}

// Waits and reads reply data from request QueryVersion
func (cook QueryVersionCookie) Reply() (*QueryVersionReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryVersionReply(buf), nil
}

// Read reply into structure from buffer for QueryVersion
func queryVersionReply(buf []byte) *QueryVersionReply {
	v := new(QueryVersionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Major = xgb.Get32(buf[b:])
	b += 4

	v.Minor = xgb.Get32(buf[b:])
	b += 4

	return v
}

// Write request to wire for QueryVersion
func queryVersionRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO-MOTIONCOMPENSATION"]
	b += 1

	buf[b] = 0 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request ListSurfaceTypes
// size: 8
type ListSurfaceTypesCookie struct {
	*xgb.Cookie
}

func ListSurfaceTypes(c *xgb.Conn, PortId xv.Port) ListSurfaceTypesCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(listSurfaceTypesRequest(c, PortId), cookie)
	return ListSurfaceTypesCookie{cookie}
}

func ListSurfaceTypesUnchecked(c *xgb.Conn, PortId xv.Port) ListSurfaceTypesCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(listSurfaceTypesRequest(c, PortId), cookie)
	return ListSurfaceTypesCookie{cookie}
}

// Request reply for ListSurfaceTypes
// size: (32 + xgb.Pad((int(Num) * 24)))
type ListSurfaceTypesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Num uint32
	// padding: 20 bytes
	Surfaces []SurfaceInfo // size: xgb.Pad((int(Num) * 24))
}

// Waits and reads reply data from request ListSurfaceTypes
func (cook ListSurfaceTypesCookie) Reply() (*ListSurfaceTypesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listSurfaceTypesReply(buf), nil
}

// Read reply into structure from buffer for ListSurfaceTypes
func listSurfaceTypesReply(buf []byte) *ListSurfaceTypesReply {
	v := new(ListSurfaceTypesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Num = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.Surfaces = make([]SurfaceInfo, v.Num)
	b += SurfaceInfoReadList(buf[b:], v.Surfaces)

	return v
}

// Write request to wire for ListSurfaceTypes
func listSurfaceTypesRequest(c *xgb.Conn, PortId xv.Port) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO-MOTIONCOMPENSATION"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(PortId))
	b += 4

	return buf
}

// Request CreateContext
// size: 24
type CreateContextCookie struct {
	*xgb.Cookie
}

func CreateContext(c *xgb.Conn, ContextId Context, PortId xv.Port, SurfaceId Surface, Width uint16, Height uint16, Flags uint32) CreateContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(createContextRequest(c, ContextId, PortId, SurfaceId, Width, Height, Flags), cookie)
	return CreateContextCookie{cookie}
}

func CreateContextUnchecked(c *xgb.Conn, ContextId Context, PortId xv.Port, SurfaceId Surface, Width uint16, Height uint16, Flags uint32) CreateContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(createContextRequest(c, ContextId, PortId, SurfaceId, Width, Height, Flags), cookie)
	return CreateContextCookie{cookie}
}

// Request reply for CreateContext
// size: (36 + xgb.Pad((int(Length) * 4)))
type CreateContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	WidthActual  uint16
	HeightActual uint16
	FlagsReturn  uint32
	// padding: 20 bytes
	PrivData []uint32 // size: xgb.Pad((int(Length) * 4))
}

// Waits and reads reply data from request CreateContext
func (cook CreateContextCookie) Reply() (*CreateContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return createContextReply(buf), nil
}

// Read reply into structure from buffer for CreateContext
func createContextReply(buf []byte) *CreateContextReply {
	v := new(CreateContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.WidthActual = xgb.Get16(buf[b:])
	b += 2

	v.HeightActual = xgb.Get16(buf[b:])
	b += 2

	v.FlagsReturn = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.PrivData = make([]uint32, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.PrivData[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for CreateContext
func createContextRequest(c *xgb.Conn, ContextId Context, PortId xv.Port, SurfaceId Surface, Width uint16, Height uint16, Flags uint32) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO-MOTIONCOMPENSATION"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextId))
	b += 4

	xgb.Put32(buf[b:], uint32(PortId))
	b += 4

	xgb.Put32(buf[b:], uint32(SurfaceId))
	b += 4

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	xgb.Put32(buf[b:], Flags)
	b += 4

	return buf
}

// Request DestroyContext
// size: 8
type DestroyContextCookie struct {
	*xgb.Cookie
}

// Write request to wire for DestroyContext
func DestroyContext(c *xgb.Conn, ContextId Context) DestroyContextCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroyContextRequest(c, ContextId), cookie)
	return DestroyContextCookie{cookie}
}

func DestroyContextChecked(c *xgb.Conn, ContextId Context) DestroyContextCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroyContextRequest(c, ContextId), cookie)
	return DestroyContextCookie{cookie}
}

func (cook DestroyContextCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroyContext
func destroyContextRequest(c *xgb.Conn, ContextId Context) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO-MOTIONCOMPENSATION"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(ContextId))
	b += 4

	return buf
}

// Request CreateSurface
// size: 12
type CreateSurfaceCookie struct {
	*xgb.Cookie
}

func CreateSurface(c *xgb.Conn, SurfaceId Surface, ContextId Context) CreateSurfaceCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(createSurfaceRequest(c, SurfaceId, ContextId), cookie)
	return CreateSurfaceCookie{cookie}
}

func CreateSurfaceUnchecked(c *xgb.Conn, SurfaceId Surface, ContextId Context) CreateSurfaceCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(createSurfaceRequest(c, SurfaceId, ContextId), cookie)
	return CreateSurfaceCookie{cookie}
}

// Request reply for CreateSurface
// size: (32 + xgb.Pad((int(Length) * 4)))
type CreateSurfaceReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
	PrivData []uint32 // size: xgb.Pad((int(Length) * 4))
}

// Waits and reads reply data from request CreateSurface
func (cook CreateSurfaceCookie) Reply() (*CreateSurfaceReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return createSurfaceReply(buf), nil
}

// Read reply into structure from buffer for CreateSurface
func createSurfaceReply(buf []byte) *CreateSurfaceReply {
	v := new(CreateSurfaceReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.PrivData = make([]uint32, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.PrivData[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for CreateSurface
func createSurfaceRequest(c *xgb.Conn, SurfaceId Surface, ContextId Context) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO-MOTIONCOMPENSATION"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(SurfaceId))
	b += 4

	xgb.Put32(buf[b:], uint32(ContextId))
	b += 4

	return buf
}

// Request DestroySurface
// size: 8
type DestroySurfaceCookie struct {
	*xgb.Cookie
}

// Write request to wire for DestroySurface
func DestroySurface(c *xgb.Conn, SurfaceId Surface) DestroySurfaceCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroySurfaceRequest(c, SurfaceId), cookie)
	return DestroySurfaceCookie{cookie}
}

func DestroySurfaceChecked(c *xgb.Conn, SurfaceId Surface) DestroySurfaceCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroySurfaceRequest(c, SurfaceId), cookie)
	return DestroySurfaceCookie{cookie}
}

func (cook DestroySurfaceCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroySurface
func destroySurfaceRequest(c *xgb.Conn, SurfaceId Surface) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO-MOTIONCOMPENSATION"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(SurfaceId))
	b += 4

	return buf
}

// Request CreateSubpicture
// size: 20
type CreateSubpictureCookie struct {
	*xgb.Cookie
}

func CreateSubpicture(c *xgb.Conn, SubpictureId Subpicture, Context Context, XvimageId uint32, Width uint16, Height uint16) CreateSubpictureCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(createSubpictureRequest(c, SubpictureId, Context, XvimageId, Width, Height), cookie)
	return CreateSubpictureCookie{cookie}
}

func CreateSubpictureUnchecked(c *xgb.Conn, SubpictureId Subpicture, Context Context, XvimageId uint32, Width uint16, Height uint16) CreateSubpictureCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(createSubpictureRequest(c, SubpictureId, Context, XvimageId, Width, Height), cookie)
	return CreateSubpictureCookie{cookie}
}

// Request reply for CreateSubpicture
// size: (32 + xgb.Pad((int(Length) * 4)))
type CreateSubpictureReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	WidthActual       uint16
	HeightActual      uint16
	NumPaletteEntries uint16
	EntryBytes        uint16
	ComponentOrder    []byte // size: 4
	// padding: 12 bytes
	PrivData []uint32 // size: xgb.Pad((int(Length) * 4))
}

// Waits and reads reply data from request CreateSubpicture
func (cook CreateSubpictureCookie) Reply() (*CreateSubpictureReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return createSubpictureReply(buf), nil
}

// Read reply into structure from buffer for CreateSubpicture
func createSubpictureReply(buf []byte) *CreateSubpictureReply {
	v := new(CreateSubpictureReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.WidthActual = xgb.Get16(buf[b:])
	b += 2

	v.HeightActual = xgb.Get16(buf[b:])
	b += 2

	v.NumPaletteEntries = xgb.Get16(buf[b:])
	b += 2

	v.EntryBytes = xgb.Get16(buf[b:])
	b += 2

	v.ComponentOrder = make([]byte, 4)
	copy(v.ComponentOrder[:4], buf[b:])
	b += xgb.Pad(int(4))

	b += 12 // padding

	v.PrivData = make([]uint32, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.PrivData[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for CreateSubpicture
func createSubpictureRequest(c *xgb.Conn, SubpictureId Subpicture, Context Context, XvimageId uint32, Width uint16, Height uint16) []byte {
	size := 20
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO-MOTIONCOMPENSATION"]
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(SubpictureId))
	b += 4

	xgb.Put32(buf[b:], uint32(Context))
	b += 4

	xgb.Put32(buf[b:], XvimageId)
	b += 4

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	return buf
}

// Request DestroySubpicture
// size: 8
type DestroySubpictureCookie struct {
	*xgb.Cookie
}

// Write request to wire for DestroySubpicture
func DestroySubpicture(c *xgb.Conn, SubpictureId Subpicture) DestroySubpictureCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroySubpictureRequest(c, SubpictureId), cookie)
	return DestroySubpictureCookie{cookie}
}

func DestroySubpictureChecked(c *xgb.Conn, SubpictureId Subpicture) DestroySubpictureCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroySubpictureRequest(c, SubpictureId), cookie)
	return DestroySubpictureCookie{cookie}
}

func (cook DestroySubpictureCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroySubpicture
func destroySubpictureRequest(c *xgb.Conn, SubpictureId Subpicture) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO-MOTIONCOMPENSATION"]
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(SubpictureId))
	b += 4

	return buf
}

// Request ListSubpictureTypes
// size: 12
type ListSubpictureTypesCookie struct {
	*xgb.Cookie
}

func ListSubpictureTypes(c *xgb.Conn, PortId xv.Port, SurfaceId Surface) ListSubpictureTypesCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(listSubpictureTypesRequest(c, PortId, SurfaceId), cookie)
	return ListSubpictureTypesCookie{cookie}
}

func ListSubpictureTypesUnchecked(c *xgb.Conn, PortId xv.Port, SurfaceId Surface) ListSubpictureTypesCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(listSubpictureTypesRequest(c, PortId, SurfaceId), cookie)
	return ListSubpictureTypesCookie{cookie}
}

// Request reply for ListSubpictureTypes
// size: (32 + xv.ImageFormatInfoListSize(Types))
type ListSubpictureTypesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Num uint32
	// padding: 20 bytes
	Types []xv.ImageFormatInfo // size: xv.ImageFormatInfoListSize(Types)
}

// Waits and reads reply data from request ListSubpictureTypes
func (cook ListSubpictureTypesCookie) Reply() (*ListSubpictureTypesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listSubpictureTypesReply(buf), nil
}

// Read reply into structure from buffer for ListSubpictureTypes
func listSubpictureTypesReply(buf []byte) *ListSubpictureTypesReply {
	v := new(ListSubpictureTypesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Num = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.Types = make([]xv.ImageFormatInfo, v.Num)
	b += xv.ImageFormatInfoReadList(buf[b:], v.Types)

	return v
}

// Write request to wire for ListSubpictureTypes
func listSubpictureTypesRequest(c *xgb.Conn, PortId xv.Port, SurfaceId Surface) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["XVIDEO-MOTIONCOMPENSATION"]
	b += 1

	buf[b] = 8 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(PortId))
	b += 4

	xgb.Put32(buf[b:], uint32(SurfaceId))
	b += 4

	return buf
}
