package xgb

/*
	This file was generated by xv.xml on May 10 2012 12:39:35pm EDT.
	This file is automatically generated. Edit at your peril!
*/

// Imports are not necessary for XGB because everything is 
// in one package. They are still listed here for reference.
// import "xproto"
// import "shm"

// XvInit must be called before using the XVideo extension.
func (c *Conn) XvInit() error {
	reply, err := c.QueryExtension(6, "XVideo").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return errorf("No extension named XVideo could be found on on the server.")
	}

	c.extLock.Lock()
	c.extensions["XVideo"] = reply.MajorOpcode
	for evNum, fun := range newExtEventFuncs["XVideo"] {
		newEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range newExtErrorFuncs["XVideo"] {
		newErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	c.extLock.Unlock()

	return nil
}

func init() {
	newExtEventFuncs["XVideo"] = make(map[int]newEventFun)
	newExtErrorFuncs["XVideo"] = make(map[int]newErrorFun)
}

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

const (
	XvTypeInputMask  = 1
	XvTypeOutputMask = 2
	XvTypeVideoMask  = 4
	XvTypeStillMask  = 8
	XvTypeImageMask  = 16
)

const (
	XvImageFormatInfoTypeRgb = 0
	XvImageFormatInfoTypeYuv = 1
)

const (
	XvImageFormatInfoFormatPacked = 0
	XvImageFormatInfoFormatPlanar = 1
)

const (
	XvAttributeFlagGettable = 1
	XvAttributeFlagSettable = 2
)

const (
	XvVideoNotifyReasonStarted   = 0
	XvVideoNotifyReasonStopped   = 1
	XvVideoNotifyReasonBusy      = 2
	XvVideoNotifyReasonPreempted = 3
	XvVideoNotifyReasonHardError = 4
)

const (
	XvScanlineOrderTopToBottom = 0
	XvScanlineOrderBottomToTop = 1
)

const (
	XvGrabPortStatusSuccess        = 0
	XvGrabPortStatusBadExtension   = 1
	XvGrabPortStatusAlreadyGrabbed = 2
	XvGrabPortStatusInvalidTime    = 3
	XvGrabPortStatusBadReply       = 4
	XvGrabPortStatusBadAlloc       = 5
)

type XvPort uint32

func (c *Conn) NewXvPortId() (XvPort, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return XvPort(id), nil
}

type XvEncoding uint32

func (c *Conn) NewXvEncodingId() (XvEncoding, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return XvEncoding(id), nil
}

// 'XvRational' struct definition
// Size: 8
type XvRational struct {
	Numerator   int32
	Denominator int32
}

// Struct read XvRational
func ReadXvRational(buf []byte, v *XvRational) int {
	b := 0

	v.Numerator = int32(Get32(buf[b:]))
	b += 4

	v.Denominator = int32(Get32(buf[b:]))
	b += 4

	return b
}

// Struct list read XvRational
func ReadXvRationalList(buf []byte, dest []XvRational) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XvRational{}
		b += ReadXvRational(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XvRational
func (v XvRational) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	Put32(buf[b:], uint32(v.Numerator))
	b += 4

	Put32(buf[b:], uint32(v.Denominator))
	b += 4

	return buf
}

// Write struct list XvRational
func XvRationalListBytes(buf []byte, list []XvRational) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XvFormat' struct definition
// Size: 8
type XvFormat struct {
	Visual Visualid
	Depth  byte
	// padding: 3 bytes
}

// Struct read XvFormat
func ReadXvFormat(buf []byte, v *XvFormat) int {
	b := 0

	v.Visual = Visualid(Get32(buf[b:]))
	b += 4

	v.Depth = buf[b]
	b += 1

	b += 3 // padding

	return b
}

// Struct list read XvFormat
func ReadXvFormatList(buf []byte, dest []XvFormat) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XvFormat{}
		b += ReadXvFormat(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XvFormat
func (v XvFormat) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	Put32(buf[b:], uint32(v.Visual))
	b += 4

	buf[b] = v.Depth
	b += 1

	b += 3 // padding

	return buf
}

// Write struct list XvFormat
func XvFormatListBytes(buf []byte, list []XvFormat) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XvAdaptorInfo' struct definition
// Size: ((12 + pad((int(NameSize) * 1))) + pad((int(NumFormats) * 8)))
type XvAdaptorInfo struct {
	BaseId     XvPort
	NameSize   uint16
	NumPorts   uint16
	NumFormats uint16
	Type       byte
	// padding: 1 bytes
	Name    string     // size: pad((int(NameSize) * 1))
	Formats []XvFormat // size: pad((int(NumFormats) * 8))
}

// Struct read XvAdaptorInfo
func ReadXvAdaptorInfo(buf []byte, v *XvAdaptorInfo) int {
	b := 0

	v.BaseId = XvPort(Get32(buf[b:]))
	b += 4

	v.NameSize = Get16(buf[b:])
	b += 2

	v.NumPorts = Get16(buf[b:])
	b += 2

	v.NumFormats = Get16(buf[b:])
	b += 2

	v.Type = buf[b]
	b += 1

	b += 1 // padding

	{
		byteString := make([]byte, v.NameSize)
		copy(byteString[:v.NameSize], buf[b:])
		v.Name = string(byteString)
		b += pad(int(v.NameSize))
	}

	v.Formats = make([]XvFormat, v.NumFormats)
	b += ReadXvFormatList(buf[b:], v.Formats)

	return b
}

// Struct list read XvAdaptorInfo
func ReadXvAdaptorInfoList(buf []byte, dest []XvAdaptorInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XvAdaptorInfo{}
		b += ReadXvAdaptorInfo(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XvAdaptorInfo
func (v XvAdaptorInfo) Bytes() []byte {
	buf := make([]byte, ((12 + pad((int(v.NameSize) * 1))) + pad((int(v.NumFormats) * 8))))
	b := 0

	Put32(buf[b:], uint32(v.BaseId))
	b += 4

	Put16(buf[b:], v.NameSize)
	b += 2

	Put16(buf[b:], v.NumPorts)
	b += 2

	Put16(buf[b:], v.NumFormats)
	b += 2

	buf[b] = v.Type
	b += 1

	b += 1 // padding

	copy(buf[b:], v.Name[:v.NameSize])
	b += pad(int(v.NameSize))

	b += XvFormatListBytes(buf[b:], v.Formats)

	return buf
}

// Write struct list XvAdaptorInfo
func XvAdaptorInfoListBytes(buf []byte, list []XvAdaptorInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Struct list size XvAdaptorInfo
func XvAdaptorInfoListSize(list []XvAdaptorInfo) int {
	size := 0
	for _, item := range list {
		size += ((12 + pad((int(item.NameSize) * 1))) + pad((int(item.NumFormats) * 8)))
	}
	return size
}

// 'XvEncodingInfo' struct definition
// Size: (20 + pad((int(NameSize) * 1)))
type XvEncodingInfo struct {
	Encoding XvEncoding
	NameSize uint16
	Width    uint16
	Height   uint16
	// padding: 2 bytes
	Rate XvRational
	Name string // size: pad((int(NameSize) * 1))
}

// Struct read XvEncodingInfo
func ReadXvEncodingInfo(buf []byte, v *XvEncodingInfo) int {
	b := 0

	v.Encoding = XvEncoding(Get32(buf[b:]))
	b += 4

	v.NameSize = Get16(buf[b:])
	b += 2

	v.Width = Get16(buf[b:])
	b += 2

	v.Height = Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.Rate = XvRational{}
	b += ReadXvRational(buf[b:], &v.Rate)

	{
		byteString := make([]byte, v.NameSize)
		copy(byteString[:v.NameSize], buf[b:])
		v.Name = string(byteString)
		b += pad(int(v.NameSize))
	}

	return b
}

// Struct list read XvEncodingInfo
func ReadXvEncodingInfoList(buf []byte, dest []XvEncodingInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XvEncodingInfo{}
		b += ReadXvEncodingInfo(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XvEncodingInfo
func (v XvEncodingInfo) Bytes() []byte {
	buf := make([]byte, (20 + pad((int(v.NameSize) * 1))))
	b := 0

	Put32(buf[b:], uint32(v.Encoding))
	b += 4

	Put16(buf[b:], v.NameSize)
	b += 2

	Put16(buf[b:], v.Width)
	b += 2

	Put16(buf[b:], v.Height)
	b += 2

	b += 2 // padding

	{
		structBytes := v.Rate.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}

	copy(buf[b:], v.Name[:v.NameSize])
	b += pad(int(v.NameSize))

	return buf
}

// Write struct list XvEncodingInfo
func XvEncodingInfoListBytes(buf []byte, list []XvEncodingInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Struct list size XvEncodingInfo
func XvEncodingInfoListSize(list []XvEncodingInfo) int {
	size := 0
	for _, item := range list {
		size += (20 + pad((int(item.NameSize) * 1)))
	}
	return size
}

// 'XvImage' struct definition
// Size: (((16 + pad((int(NumPlanes) * 4))) + pad((int(NumPlanes) * 4))) + pad((int(DataSize) * 1)))
type XvImage struct {
	Id        uint32
	Width     uint16
	Height    uint16
	DataSize  uint32
	NumPlanes uint32
	Pitches   []uint32 // size: pad((int(NumPlanes) * 4))
	Offsets   []uint32 // size: pad((int(NumPlanes) * 4))
	Data      []byte   // size: pad((int(DataSize) * 1))
}

// Struct read XvImage
func ReadXvImage(buf []byte, v *XvImage) int {
	b := 0

	v.Id = Get32(buf[b:])
	b += 4

	v.Width = Get16(buf[b:])
	b += 2

	v.Height = Get16(buf[b:])
	b += 2

	v.DataSize = Get32(buf[b:])
	b += 4

	v.NumPlanes = Get32(buf[b:])
	b += 4

	v.Pitches = make([]uint32, v.NumPlanes)
	for i := 0; i < int(v.NumPlanes); i++ {
		v.Pitches[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	v.Offsets = make([]uint32, v.NumPlanes)
	for i := 0; i < int(v.NumPlanes); i++ {
		v.Offsets[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	v.Data = make([]byte, v.DataSize)
	copy(v.Data[:v.DataSize], buf[b:])
	b += pad(int(v.DataSize))

	return b
}

// Struct list read XvImage
func ReadXvImageList(buf []byte, dest []XvImage) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XvImage{}
		b += ReadXvImage(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XvImage
func (v XvImage) Bytes() []byte {
	buf := make([]byte, (((16 + pad((int(v.NumPlanes) * 4))) + pad((int(v.NumPlanes) * 4))) + pad((int(v.DataSize) * 1))))
	b := 0

	Put32(buf[b:], v.Id)
	b += 4

	Put16(buf[b:], v.Width)
	b += 2

	Put16(buf[b:], v.Height)
	b += 2

	Put32(buf[b:], v.DataSize)
	b += 4

	Put32(buf[b:], v.NumPlanes)
	b += 4

	for i := 0; i < int(v.NumPlanes); i++ {
		Put32(buf[b:], v.Pitches[i])
		b += 4
	}
	b = pad(b)

	for i := 0; i < int(v.NumPlanes); i++ {
		Put32(buf[b:], v.Offsets[i])
		b += 4
	}
	b = pad(b)

	copy(buf[b:], v.Data[:v.DataSize])
	b += pad(int(v.DataSize))

	return buf
}

// Write struct list XvImage
func XvImageListBytes(buf []byte, list []XvImage) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Struct list size XvImage
func XvImageListSize(list []XvImage) int {
	size := 0
	for _, item := range list {
		size += (((16 + pad((int(item.NumPlanes) * 4))) + pad((int(item.NumPlanes) * 4))) + pad((int(item.DataSize) * 1)))
	}
	return size
}

// 'XvAttributeInfo' struct definition
// Size: (16 + pad((int(Size) * 1)))
type XvAttributeInfo struct {
	Flags uint32
	Min   int32
	Max   int32
	Size  uint32
	Name  string // size: pad((int(Size) * 1))
}

// Struct read XvAttributeInfo
func ReadXvAttributeInfo(buf []byte, v *XvAttributeInfo) int {
	b := 0

	v.Flags = Get32(buf[b:])
	b += 4

	v.Min = int32(Get32(buf[b:]))
	b += 4

	v.Max = int32(Get32(buf[b:]))
	b += 4

	v.Size = Get32(buf[b:])
	b += 4

	{
		byteString := make([]byte, v.Size)
		copy(byteString[:v.Size], buf[b:])
		v.Name = string(byteString)
		b += pad(int(v.Size))
	}

	return b
}

// Struct list read XvAttributeInfo
func ReadXvAttributeInfoList(buf []byte, dest []XvAttributeInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XvAttributeInfo{}
		b += ReadXvAttributeInfo(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XvAttributeInfo
func (v XvAttributeInfo) Bytes() []byte {
	buf := make([]byte, (16 + pad((int(v.Size) * 1))))
	b := 0

	Put32(buf[b:], v.Flags)
	b += 4

	Put32(buf[b:], uint32(v.Min))
	b += 4

	Put32(buf[b:], uint32(v.Max))
	b += 4

	Put32(buf[b:], v.Size)
	b += 4

	copy(buf[b:], v.Name[:v.Size])
	b += pad(int(v.Size))

	return buf
}

// Write struct list XvAttributeInfo
func XvAttributeInfoListBytes(buf []byte, list []XvAttributeInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Struct list size XvAttributeInfo
func XvAttributeInfoListSize(list []XvAttributeInfo) int {
	size := 0
	for _, item := range list {
		size += (16 + pad((int(item.Size) * 1)))
	}
	return size
}

// 'XvImageFormatInfo' struct definition
// Size: 128
type XvImageFormatInfo struct {
	Id        uint32
	Type      byte
	ByteOrder byte
	// padding: 2 bytes
	Guid      []byte // size: 16
	Bpp       byte
	NumPlanes byte
	// padding: 2 bytes
	Depth byte
	// padding: 3 bytes
	RedMask   uint32
	GreenMask uint32
	BlueMask  uint32
	Format    byte
	// padding: 3 bytes
	YSampleBits    uint32
	USampleBits    uint32
	VSampleBits    uint32
	VhorzYPeriod   uint32
	VhorzUPeriod   uint32
	VhorzVPeriod   uint32
	VvertYPeriod   uint32
	VvertUPeriod   uint32
	VvertVPeriod   uint32
	VcompOrder     []byte // size: 32
	VscanlineOrder byte
	// padding: 11 bytes
}

// Struct read XvImageFormatInfo
func ReadXvImageFormatInfo(buf []byte, v *XvImageFormatInfo) int {
	b := 0

	v.Id = Get32(buf[b:])
	b += 4

	v.Type = buf[b]
	b += 1

	v.ByteOrder = buf[b]
	b += 1

	b += 2 // padding

	v.Guid = make([]byte, 16)
	copy(v.Guid[:16], buf[b:])
	b += pad(int(16))

	v.Bpp = buf[b]
	b += 1

	v.NumPlanes = buf[b]
	b += 1

	b += 2 // padding

	v.Depth = buf[b]
	b += 1

	b += 3 // padding

	v.RedMask = Get32(buf[b:])
	b += 4

	v.GreenMask = Get32(buf[b:])
	b += 4

	v.BlueMask = Get32(buf[b:])
	b += 4

	v.Format = buf[b]
	b += 1

	b += 3 // padding

	v.YSampleBits = Get32(buf[b:])
	b += 4

	v.USampleBits = Get32(buf[b:])
	b += 4

	v.VSampleBits = Get32(buf[b:])
	b += 4

	v.VhorzYPeriod = Get32(buf[b:])
	b += 4

	v.VhorzUPeriod = Get32(buf[b:])
	b += 4

	v.VhorzVPeriod = Get32(buf[b:])
	b += 4

	v.VvertYPeriod = Get32(buf[b:])
	b += 4

	v.VvertUPeriod = Get32(buf[b:])
	b += 4

	v.VvertVPeriod = Get32(buf[b:])
	b += 4

	v.VcompOrder = make([]byte, 32)
	copy(v.VcompOrder[:32], buf[b:])
	b += pad(int(32))

	v.VscanlineOrder = buf[b]
	b += 1

	b += 11 // padding

	return b
}

// Struct list read XvImageFormatInfo
func ReadXvImageFormatInfoList(buf []byte, dest []XvImageFormatInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XvImageFormatInfo{}
		b += ReadXvImageFormatInfo(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XvImageFormatInfo
func (v XvImageFormatInfo) Bytes() []byte {
	buf := make([]byte, 128)
	b := 0

	Put32(buf[b:], v.Id)
	b += 4

	buf[b] = v.Type
	b += 1

	buf[b] = v.ByteOrder
	b += 1

	b += 2 // padding

	copy(buf[b:], v.Guid[:16])
	b += pad(int(16))

	buf[b] = v.Bpp
	b += 1

	buf[b] = v.NumPlanes
	b += 1

	b += 2 // padding

	buf[b] = v.Depth
	b += 1

	b += 3 // padding

	Put32(buf[b:], v.RedMask)
	b += 4

	Put32(buf[b:], v.GreenMask)
	b += 4

	Put32(buf[b:], v.BlueMask)
	b += 4

	buf[b] = v.Format
	b += 1

	b += 3 // padding

	Put32(buf[b:], v.YSampleBits)
	b += 4

	Put32(buf[b:], v.USampleBits)
	b += 4

	Put32(buf[b:], v.VSampleBits)
	b += 4

	Put32(buf[b:], v.VhorzYPeriod)
	b += 4

	Put32(buf[b:], v.VhorzUPeriod)
	b += 4

	Put32(buf[b:], v.VhorzVPeriod)
	b += 4

	Put32(buf[b:], v.VvertYPeriod)
	b += 4

	Put32(buf[b:], v.VvertUPeriod)
	b += 4

	Put32(buf[b:], v.VvertVPeriod)
	b += 4

	copy(buf[b:], v.VcompOrder[:32])
	b += pad(int(32))

	buf[b] = v.VscanlineOrder
	b += 1

	b += 11 // padding

	return buf
}

// Write struct list XvImageFormatInfo
func XvImageFormatInfoListBytes(buf []byte, list []XvImageFormatInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Struct list size XvImageFormatInfo
func XvImageFormatInfoListSize(list []XvImageFormatInfo) int {
	size := 0
	for _ = range list {
		size += 128
	}
	return size
}

// Event definition XvVideoNotify (0)
// Size: 32

const XvVideoNotify = 0

type XvVideoNotifyEvent struct {
	Sequence uint16
	Reason   byte
	Time     Timestamp
	Drawable Drawable
	Port     XvPort
}

// Event read XvVideoNotify
func NewXvVideoNotifyEvent(buf []byte) Event {
	v := XvVideoNotifyEvent{}
	b := 1 // don't read event number

	v.Reason = buf[b]
	b += 1

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Time = Timestamp(Get32(buf[b:]))
	b += 4

	v.Drawable = Drawable(Get32(buf[b:]))
	b += 4

	v.Port = XvPort(Get32(buf[b:]))
	b += 4

	return v
}

// Event write XvVideoNotify
func (v XvVideoNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 0
	b += 1

	buf[b] = v.Reason
	b += 1

	b += 2 // skip sequence number

	Put32(buf[b:], uint32(v.Time))
	b += 4

	Put32(buf[b:], uint32(v.Drawable))
	b += 4

	Put32(buf[b:], uint32(v.Port))
	b += 4

	return buf
}

func (v XvVideoNotifyEvent) ImplementsEvent() {}

func (v XvVideoNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XvVideoNotifyEvent) String() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("Reason: %d", v.Reason))
	fieldVals = append(fieldVals, sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, sprintf("Drawable: %d", v.Drawable))
	fieldVals = append(fieldVals, sprintf("Port: %d", v.Port))
	return "XvVideoNotify {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XVideo"][0] = NewXvVideoNotifyEvent
}

// Event definition XvPortNotify (1)
// Size: 32

const XvPortNotify = 1

type XvPortNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Time      Timestamp
	Port      XvPort
	Attribute Atom
	Value     int32
}

// Event read XvPortNotify
func NewXvPortNotifyEvent(buf []byte) Event {
	v := XvPortNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Time = Timestamp(Get32(buf[b:]))
	b += 4

	v.Port = XvPort(Get32(buf[b:]))
	b += 4

	v.Attribute = Atom(Get32(buf[b:]))
	b += 4

	v.Value = int32(Get32(buf[b:]))
	b += 4

	return v
}

// Event write XvPortNotify
func (v XvPortNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 1
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	Put32(buf[b:], uint32(v.Time))
	b += 4

	Put32(buf[b:], uint32(v.Port))
	b += 4

	Put32(buf[b:], uint32(v.Attribute))
	b += 4

	Put32(buf[b:], uint32(v.Value))
	b += 4

	return buf
}

func (v XvPortNotifyEvent) ImplementsEvent() {}

func (v XvPortNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XvPortNotifyEvent) String() string {
	fieldVals := make([]string, 0, 5)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, sprintf("Port: %d", v.Port))
	fieldVals = append(fieldVals, sprintf("Attribute: %d", v.Attribute))
	fieldVals = append(fieldVals, sprintf("Value: %d", v.Value))
	return "XvPortNotify {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XVideo"][1] = NewXvPortNotifyEvent
}

// Error definition XvBadPort (0)
// Size: 32

const BadXvBadPort = 0

type XvBadPortError struct {
	Sequence uint16
	NiceName string
}

// Error read XvBadPort
func NewXvBadPortError(buf []byte) Error {
	v := XvBadPortError{}
	v.NiceName = "XvBadPort"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = Get16(buf[b:])
	b += 2

	return v
}

func (err XvBadPortError) ImplementsError() {}

func (err XvBadPortError) SequenceId() uint16 {
	return err.Sequence
}

func (err XvBadPortError) BadId() uint32 {
	return 0
}

func (err XvBadPortError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	return "BadXvBadPort {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["XVideo"][0] = NewXvBadPortError
}

// Error definition XvBadEncoding (1)
// Size: 32

const BadXvBadEncoding = 1

type XvBadEncodingError struct {
	Sequence uint16
	NiceName string
}

// Error read XvBadEncoding
func NewXvBadEncodingError(buf []byte) Error {
	v := XvBadEncodingError{}
	v.NiceName = "XvBadEncoding"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = Get16(buf[b:])
	b += 2

	return v
}

func (err XvBadEncodingError) ImplementsError() {}

func (err XvBadEncodingError) SequenceId() uint16 {
	return err.Sequence
}

func (err XvBadEncodingError) BadId() uint32 {
	return 0
}

func (err XvBadEncodingError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	return "BadXvBadEncoding {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["XVideo"][1] = NewXvBadEncodingError
}

// Error definition XvBadControl (2)
// Size: 32

const BadXvBadControl = 2

type XvBadControlError struct {
	Sequence uint16
	NiceName string
}

// Error read XvBadControl
func NewXvBadControlError(buf []byte) Error {
	v := XvBadControlError{}
	v.NiceName = "XvBadControl"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = Get16(buf[b:])
	b += 2

	return v
}

func (err XvBadControlError) ImplementsError() {}

func (err XvBadControlError) SequenceId() uint16 {
	return err.Sequence
}

func (err XvBadControlError) BadId() uint32 {
	return 0
}

func (err XvBadControlError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	return "BadXvBadControl {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["XVideo"][2] = NewXvBadControlError
}

// Request XvQueryExtension
// size: 4
type XvQueryExtensionCookie struct {
	*cookie
}

func (c *Conn) XvQueryExtension() XvQueryExtensionCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xvQueryExtensionRequest(), cookie)
	return XvQueryExtensionCookie{cookie}
}

func (c *Conn) XvQueryExtensionUnchecked() XvQueryExtensionCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xvQueryExtensionRequest(), cookie)
	return XvQueryExtensionCookie{cookie}
}

// Request reply for XvQueryExtension
// size: 12
type XvQueryExtensionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Major uint16
	Minor uint16
}

// Waits and reads reply data from request XvQueryExtension
func (cook XvQueryExtensionCookie) Reply() (*XvQueryExtensionReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xvQueryExtensionReply(buf), nil
}

// Read reply into structure from buffer for XvQueryExtension
func xvQueryExtensionReply(buf []byte) *XvQueryExtensionReply {
	v := new(XvQueryExtensionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Major = Get16(buf[b:])
	b += 2

	v.Minor = Get16(buf[b:])
	b += 2

	return v
}

func (cook XvQueryExtensionCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvQueryExtension
func (c *Conn) xvQueryExtensionRequest() []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 0 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request XvQueryAdaptors
// size: 8
type XvQueryAdaptorsCookie struct {
	*cookie
}

func (c *Conn) XvQueryAdaptors(Window Window) XvQueryAdaptorsCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xvQueryAdaptorsRequest(Window), cookie)
	return XvQueryAdaptorsCookie{cookie}
}

func (c *Conn) XvQueryAdaptorsUnchecked(Window Window) XvQueryAdaptorsCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xvQueryAdaptorsRequest(Window), cookie)
	return XvQueryAdaptorsCookie{cookie}
}

// Request reply for XvQueryAdaptors
// size: (32 + XvAdaptorInfoListSize(Info))
type XvQueryAdaptorsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumAdaptors uint16
	// padding: 22 bytes
	Info []XvAdaptorInfo // size: XvAdaptorInfoListSize(Info)
}

// Waits and reads reply data from request XvQueryAdaptors
func (cook XvQueryAdaptorsCookie) Reply() (*XvQueryAdaptorsReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xvQueryAdaptorsReply(buf), nil
}

// Read reply into structure from buffer for XvQueryAdaptors
func xvQueryAdaptorsReply(buf []byte) *XvQueryAdaptorsReply {
	v := new(XvQueryAdaptorsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumAdaptors = Get16(buf[b:])
	b += 2

	b += 22 // padding

	v.Info = make([]XvAdaptorInfo, v.NumAdaptors)
	b += ReadXvAdaptorInfoList(buf[b:], v.Info)

	return v
}

func (cook XvQueryAdaptorsCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvQueryAdaptors
func (c *Conn) xvQueryAdaptorsRequest(Window Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request XvQueryEncodings
// size: 8
type XvQueryEncodingsCookie struct {
	*cookie
}

func (c *Conn) XvQueryEncodings(Port XvPort) XvQueryEncodingsCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xvQueryEncodingsRequest(Port), cookie)
	return XvQueryEncodingsCookie{cookie}
}

func (c *Conn) XvQueryEncodingsUnchecked(Port XvPort) XvQueryEncodingsCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xvQueryEncodingsRequest(Port), cookie)
	return XvQueryEncodingsCookie{cookie}
}

// Request reply for XvQueryEncodings
// size: (32 + XvEncodingInfoListSize(Info))
type XvQueryEncodingsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumEncodings uint16
	// padding: 22 bytes
	Info []XvEncodingInfo // size: XvEncodingInfoListSize(Info)
}

// Waits and reads reply data from request XvQueryEncodings
func (cook XvQueryEncodingsCookie) Reply() (*XvQueryEncodingsReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xvQueryEncodingsReply(buf), nil
}

// Read reply into structure from buffer for XvQueryEncodings
func xvQueryEncodingsReply(buf []byte) *XvQueryEncodingsReply {
	v := new(XvQueryEncodingsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumEncodings = Get16(buf[b:])
	b += 2

	b += 22 // padding

	v.Info = make([]XvEncodingInfo, v.NumEncodings)
	b += ReadXvEncodingInfoList(buf[b:], v.Info)

	return v
}

func (cook XvQueryEncodingsCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvQueryEncodings
func (c *Conn) xvQueryEncodingsRequest(Port XvPort) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	return buf
}

// Request XvGrabPort
// size: 12
type XvGrabPortCookie struct {
	*cookie
}

func (c *Conn) XvGrabPort(Port XvPort, Time Timestamp) XvGrabPortCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xvGrabPortRequest(Port, Time), cookie)
	return XvGrabPortCookie{cookie}
}

func (c *Conn) XvGrabPortUnchecked(Port XvPort, Time Timestamp) XvGrabPortCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xvGrabPortRequest(Port, Time), cookie)
	return XvGrabPortCookie{cookie}
}

// Request reply for XvGrabPort
// size: 8
type XvGrabPortReply struct {
	Sequence uint16
	Length   uint32
	Result   byte
}

// Waits and reads reply data from request XvGrabPort
func (cook XvGrabPortCookie) Reply() (*XvGrabPortReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xvGrabPortReply(buf), nil
}

// Read reply into structure from buffer for XvGrabPort
func xvGrabPortReply(buf []byte) *XvGrabPortReply {
	v := new(XvGrabPortReply)
	b := 1 // skip reply determinant

	v.Result = buf[b]
	b += 1

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	return v
}

func (cook XvGrabPortCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvGrabPort
func (c *Conn) xvGrabPortRequest(Port XvPort, Time Timestamp) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	Put32(buf[b:], uint32(Time))
	b += 4

	return buf
}

// Request XvUngrabPort
// size: 12
type XvUngrabPortCookie struct {
	*cookie
}

// Write request to wire for XvUngrabPort
func (c *Conn) XvUngrabPort(Port XvPort, Time Timestamp) XvUngrabPortCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xvUngrabPortRequest(Port, Time), cookie)
	return XvUngrabPortCookie{cookie}
}

func (c *Conn) XvUngrabPortChecked(Port XvPort, Time Timestamp) XvUngrabPortCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xvUngrabPortRequest(Port, Time), cookie)
	return XvUngrabPortCookie{cookie}
}

func (cook XvUngrabPortCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvUngrabPort
func (c *Conn) xvUngrabPortRequest(Port XvPort, Time Timestamp) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	Put32(buf[b:], uint32(Time))
	b += 4

	return buf
}

// Request XvPutVideo
// size: 32
type XvPutVideoCookie struct {
	*cookie
}

// Write request to wire for XvPutVideo
func (c *Conn) XvPutVideo(Port XvPort, Drawable Drawable, Gc Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) XvPutVideoCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xvPutVideoRequest(Port, Drawable, Gc, VidX, VidY, VidW, VidH, DrwX, DrwY, DrwW, DrwH), cookie)
	return XvPutVideoCookie{cookie}
}

func (c *Conn) XvPutVideoChecked(Port XvPort, Drawable Drawable, Gc Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) XvPutVideoCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xvPutVideoRequest(Port, Drawable, Gc, VidX, VidY, VidW, VidH, DrwX, DrwY, DrwW, DrwH), cookie)
	return XvPutVideoCookie{cookie}
}

func (cook XvPutVideoCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvPutVideo
func (c *Conn) xvPutVideoRequest(Port XvPort, Drawable Drawable, Gc Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) []byte {
	size := 32
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	Put32(buf[b:], uint32(Drawable))
	b += 4

	Put32(buf[b:], uint32(Gc))
	b += 4

	Put16(buf[b:], uint16(VidX))
	b += 2

	Put16(buf[b:], uint16(VidY))
	b += 2

	Put16(buf[b:], VidW)
	b += 2

	Put16(buf[b:], VidH)
	b += 2

	Put16(buf[b:], uint16(DrwX))
	b += 2

	Put16(buf[b:], uint16(DrwY))
	b += 2

	Put16(buf[b:], DrwW)
	b += 2

	Put16(buf[b:], DrwH)
	b += 2

	return buf
}

// Request XvPutStill
// size: 32
type XvPutStillCookie struct {
	*cookie
}

// Write request to wire for XvPutStill
func (c *Conn) XvPutStill(Port XvPort, Drawable Drawable, Gc Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) XvPutStillCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xvPutStillRequest(Port, Drawable, Gc, VidX, VidY, VidW, VidH, DrwX, DrwY, DrwW, DrwH), cookie)
	return XvPutStillCookie{cookie}
}

func (c *Conn) XvPutStillChecked(Port XvPort, Drawable Drawable, Gc Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) XvPutStillCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xvPutStillRequest(Port, Drawable, Gc, VidX, VidY, VidW, VidH, DrwX, DrwY, DrwW, DrwH), cookie)
	return XvPutStillCookie{cookie}
}

func (cook XvPutStillCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvPutStill
func (c *Conn) xvPutStillRequest(Port XvPort, Drawable Drawable, Gc Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) []byte {
	size := 32
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	Put32(buf[b:], uint32(Drawable))
	b += 4

	Put32(buf[b:], uint32(Gc))
	b += 4

	Put16(buf[b:], uint16(VidX))
	b += 2

	Put16(buf[b:], uint16(VidY))
	b += 2

	Put16(buf[b:], VidW)
	b += 2

	Put16(buf[b:], VidH)
	b += 2

	Put16(buf[b:], uint16(DrwX))
	b += 2

	Put16(buf[b:], uint16(DrwY))
	b += 2

	Put16(buf[b:], DrwW)
	b += 2

	Put16(buf[b:], DrwH)
	b += 2

	return buf
}

// Request XvGetVideo
// size: 32
type XvGetVideoCookie struct {
	*cookie
}

// Write request to wire for XvGetVideo
func (c *Conn) XvGetVideo(Port XvPort, Drawable Drawable, Gc Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) XvGetVideoCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xvGetVideoRequest(Port, Drawable, Gc, VidX, VidY, VidW, VidH, DrwX, DrwY, DrwW, DrwH), cookie)
	return XvGetVideoCookie{cookie}
}

func (c *Conn) XvGetVideoChecked(Port XvPort, Drawable Drawable, Gc Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) XvGetVideoCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xvGetVideoRequest(Port, Drawable, Gc, VidX, VidY, VidW, VidH, DrwX, DrwY, DrwW, DrwH), cookie)
	return XvGetVideoCookie{cookie}
}

func (cook XvGetVideoCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvGetVideo
func (c *Conn) xvGetVideoRequest(Port XvPort, Drawable Drawable, Gc Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) []byte {
	size := 32
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	Put32(buf[b:], uint32(Drawable))
	b += 4

	Put32(buf[b:], uint32(Gc))
	b += 4

	Put16(buf[b:], uint16(VidX))
	b += 2

	Put16(buf[b:], uint16(VidY))
	b += 2

	Put16(buf[b:], VidW)
	b += 2

	Put16(buf[b:], VidH)
	b += 2

	Put16(buf[b:], uint16(DrwX))
	b += 2

	Put16(buf[b:], uint16(DrwY))
	b += 2

	Put16(buf[b:], DrwW)
	b += 2

	Put16(buf[b:], DrwH)
	b += 2

	return buf
}

// Request XvGetStill
// size: 32
type XvGetStillCookie struct {
	*cookie
}

// Write request to wire for XvGetStill
func (c *Conn) XvGetStill(Port XvPort, Drawable Drawable, Gc Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) XvGetStillCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xvGetStillRequest(Port, Drawable, Gc, VidX, VidY, VidW, VidH, DrwX, DrwY, DrwW, DrwH), cookie)
	return XvGetStillCookie{cookie}
}

func (c *Conn) XvGetStillChecked(Port XvPort, Drawable Drawable, Gc Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) XvGetStillCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xvGetStillRequest(Port, Drawable, Gc, VidX, VidY, VidW, VidH, DrwX, DrwY, DrwW, DrwH), cookie)
	return XvGetStillCookie{cookie}
}

func (cook XvGetStillCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvGetStill
func (c *Conn) xvGetStillRequest(Port XvPort, Drawable Drawable, Gc Gcontext, VidX int16, VidY int16, VidW uint16, VidH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16) []byte {
	size := 32
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 8 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	Put32(buf[b:], uint32(Drawable))
	b += 4

	Put32(buf[b:], uint32(Gc))
	b += 4

	Put16(buf[b:], uint16(VidX))
	b += 2

	Put16(buf[b:], uint16(VidY))
	b += 2

	Put16(buf[b:], VidW)
	b += 2

	Put16(buf[b:], VidH)
	b += 2

	Put16(buf[b:], uint16(DrwX))
	b += 2

	Put16(buf[b:], uint16(DrwY))
	b += 2

	Put16(buf[b:], DrwW)
	b += 2

	Put16(buf[b:], DrwH)
	b += 2

	return buf
}

// Request XvStopVideo
// size: 12
type XvStopVideoCookie struct {
	*cookie
}

// Write request to wire for XvStopVideo
func (c *Conn) XvStopVideo(Port XvPort, Drawable Drawable) XvStopVideoCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xvStopVideoRequest(Port, Drawable), cookie)
	return XvStopVideoCookie{cookie}
}

func (c *Conn) XvStopVideoChecked(Port XvPort, Drawable Drawable) XvStopVideoCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xvStopVideoRequest(Port, Drawable), cookie)
	return XvStopVideoCookie{cookie}
}

func (cook XvStopVideoCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvStopVideo
func (c *Conn) xvStopVideoRequest(Port XvPort, Drawable Drawable) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 9 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	Put32(buf[b:], uint32(Drawable))
	b += 4

	return buf
}

// Request XvSelectVideoNotify
// size: 12
type XvSelectVideoNotifyCookie struct {
	*cookie
}

// Write request to wire for XvSelectVideoNotify
func (c *Conn) XvSelectVideoNotify(Drawable Drawable, Onoff bool) XvSelectVideoNotifyCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xvSelectVideoNotifyRequest(Drawable, Onoff), cookie)
	return XvSelectVideoNotifyCookie{cookie}
}

func (c *Conn) XvSelectVideoNotifyChecked(Drawable Drawable, Onoff bool) XvSelectVideoNotifyCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xvSelectVideoNotifyRequest(Drawable, Onoff), cookie)
	return XvSelectVideoNotifyCookie{cookie}
}

func (cook XvSelectVideoNotifyCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvSelectVideoNotify
func (c *Conn) xvSelectVideoNotifyRequest(Drawable Drawable, Onoff bool) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 10 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Drawable))
	b += 4

	if Onoff {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 3 // padding

	return buf
}

// Request XvSelectPortNotify
// size: 12
type XvSelectPortNotifyCookie struct {
	*cookie
}

// Write request to wire for XvSelectPortNotify
func (c *Conn) XvSelectPortNotify(Port XvPort, Onoff bool) XvSelectPortNotifyCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xvSelectPortNotifyRequest(Port, Onoff), cookie)
	return XvSelectPortNotifyCookie{cookie}
}

func (c *Conn) XvSelectPortNotifyChecked(Port XvPort, Onoff bool) XvSelectPortNotifyCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xvSelectPortNotifyRequest(Port, Onoff), cookie)
	return XvSelectPortNotifyCookie{cookie}
}

func (cook XvSelectPortNotifyCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvSelectPortNotify
func (c *Conn) xvSelectPortNotifyRequest(Port XvPort, Onoff bool) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 11 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	if Onoff {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 3 // padding

	return buf
}

// Request XvQueryBestSize
// size: 20
type XvQueryBestSizeCookie struct {
	*cookie
}

func (c *Conn) XvQueryBestSize(Port XvPort, VidW uint16, VidH uint16, DrwW uint16, DrwH uint16, Motion bool) XvQueryBestSizeCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xvQueryBestSizeRequest(Port, VidW, VidH, DrwW, DrwH, Motion), cookie)
	return XvQueryBestSizeCookie{cookie}
}

func (c *Conn) XvQueryBestSizeUnchecked(Port XvPort, VidW uint16, VidH uint16, DrwW uint16, DrwH uint16, Motion bool) XvQueryBestSizeCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xvQueryBestSizeRequest(Port, VidW, VidH, DrwW, DrwH, Motion), cookie)
	return XvQueryBestSizeCookie{cookie}
}

// Request reply for XvQueryBestSize
// size: 12
type XvQueryBestSizeReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ActualWidth  uint16
	ActualHeight uint16
}

// Waits and reads reply data from request XvQueryBestSize
func (cook XvQueryBestSizeCookie) Reply() (*XvQueryBestSizeReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xvQueryBestSizeReply(buf), nil
}

// Read reply into structure from buffer for XvQueryBestSize
func xvQueryBestSizeReply(buf []byte) *XvQueryBestSizeReply {
	v := new(XvQueryBestSizeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ActualWidth = Get16(buf[b:])
	b += 2

	v.ActualHeight = Get16(buf[b:])
	b += 2

	return v
}

func (cook XvQueryBestSizeCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvQueryBestSize
func (c *Conn) xvQueryBestSizeRequest(Port XvPort, VidW uint16, VidH uint16, DrwW uint16, DrwH uint16, Motion bool) []byte {
	size := 20
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 12 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	Put16(buf[b:], VidW)
	b += 2

	Put16(buf[b:], VidH)
	b += 2

	Put16(buf[b:], DrwW)
	b += 2

	Put16(buf[b:], DrwH)
	b += 2

	if Motion {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 3 // padding

	return buf
}

// Request XvSetPortAttribute
// size: 16
type XvSetPortAttributeCookie struct {
	*cookie
}

// Write request to wire for XvSetPortAttribute
func (c *Conn) XvSetPortAttribute(Port XvPort, Attribute Atom, Value int32) XvSetPortAttributeCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xvSetPortAttributeRequest(Port, Attribute, Value), cookie)
	return XvSetPortAttributeCookie{cookie}
}

func (c *Conn) XvSetPortAttributeChecked(Port XvPort, Attribute Atom, Value int32) XvSetPortAttributeCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xvSetPortAttributeRequest(Port, Attribute, Value), cookie)
	return XvSetPortAttributeCookie{cookie}
}

func (cook XvSetPortAttributeCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvSetPortAttribute
func (c *Conn) xvSetPortAttributeRequest(Port XvPort, Attribute Atom, Value int32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 13 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	Put32(buf[b:], uint32(Attribute))
	b += 4

	Put32(buf[b:], uint32(Value))
	b += 4

	return buf
}

// Request XvGetPortAttribute
// size: 12
type XvGetPortAttributeCookie struct {
	*cookie
}

func (c *Conn) XvGetPortAttribute(Port XvPort, Attribute Atom) XvGetPortAttributeCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xvGetPortAttributeRequest(Port, Attribute), cookie)
	return XvGetPortAttributeCookie{cookie}
}

func (c *Conn) XvGetPortAttributeUnchecked(Port XvPort, Attribute Atom) XvGetPortAttributeCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xvGetPortAttributeRequest(Port, Attribute), cookie)
	return XvGetPortAttributeCookie{cookie}
}

// Request reply for XvGetPortAttribute
// size: 12
type XvGetPortAttributeReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Value int32
}

// Waits and reads reply data from request XvGetPortAttribute
func (cook XvGetPortAttributeCookie) Reply() (*XvGetPortAttributeReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xvGetPortAttributeReply(buf), nil
}

// Read reply into structure from buffer for XvGetPortAttribute
func xvGetPortAttributeReply(buf []byte) *XvGetPortAttributeReply {
	v := new(XvGetPortAttributeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Value = int32(Get32(buf[b:]))
	b += 4

	return v
}

func (cook XvGetPortAttributeCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvGetPortAttribute
func (c *Conn) xvGetPortAttributeRequest(Port XvPort, Attribute Atom) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 14 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	Put32(buf[b:], uint32(Attribute))
	b += 4

	return buf
}

// Request XvQueryPortAttributes
// size: 8
type XvQueryPortAttributesCookie struct {
	*cookie
}

func (c *Conn) XvQueryPortAttributes(Port XvPort) XvQueryPortAttributesCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xvQueryPortAttributesRequest(Port), cookie)
	return XvQueryPortAttributesCookie{cookie}
}

func (c *Conn) XvQueryPortAttributesUnchecked(Port XvPort) XvQueryPortAttributesCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xvQueryPortAttributesRequest(Port), cookie)
	return XvQueryPortAttributesCookie{cookie}
}

// Request reply for XvQueryPortAttributes
// size: (32 + XvAttributeInfoListSize(Attributes))
type XvQueryPortAttributesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumAttributes uint32
	TextSize      uint32
	// padding: 16 bytes
	Attributes []XvAttributeInfo // size: XvAttributeInfoListSize(Attributes)
}

// Waits and reads reply data from request XvQueryPortAttributes
func (cook XvQueryPortAttributesCookie) Reply() (*XvQueryPortAttributesReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xvQueryPortAttributesReply(buf), nil
}

// Read reply into structure from buffer for XvQueryPortAttributes
func xvQueryPortAttributesReply(buf []byte) *XvQueryPortAttributesReply {
	v := new(XvQueryPortAttributesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumAttributes = Get32(buf[b:])
	b += 4

	v.TextSize = Get32(buf[b:])
	b += 4

	b += 16 // padding

	v.Attributes = make([]XvAttributeInfo, v.NumAttributes)
	b += ReadXvAttributeInfoList(buf[b:], v.Attributes)

	return v
}

func (cook XvQueryPortAttributesCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvQueryPortAttributes
func (c *Conn) xvQueryPortAttributesRequest(Port XvPort) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 15 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	return buf
}

// Request XvListImageFormats
// size: 8
type XvListImageFormatsCookie struct {
	*cookie
}

func (c *Conn) XvListImageFormats(Port XvPort) XvListImageFormatsCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xvListImageFormatsRequest(Port), cookie)
	return XvListImageFormatsCookie{cookie}
}

func (c *Conn) XvListImageFormatsUnchecked(Port XvPort) XvListImageFormatsCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xvListImageFormatsRequest(Port), cookie)
	return XvListImageFormatsCookie{cookie}
}

// Request reply for XvListImageFormats
// size: (32 + XvImageFormatInfoListSize(Format))
type XvListImageFormatsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumFormats uint32
	// padding: 20 bytes
	Format []XvImageFormatInfo // size: XvImageFormatInfoListSize(Format)
}

// Waits and reads reply data from request XvListImageFormats
func (cook XvListImageFormatsCookie) Reply() (*XvListImageFormatsReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xvListImageFormatsReply(buf), nil
}

// Read reply into structure from buffer for XvListImageFormats
func xvListImageFormatsReply(buf []byte) *XvListImageFormatsReply {
	v := new(XvListImageFormatsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumFormats = Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.Format = make([]XvImageFormatInfo, v.NumFormats)
	b += ReadXvImageFormatInfoList(buf[b:], v.Format)

	return v
}

func (cook XvListImageFormatsCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvListImageFormats
func (c *Conn) xvListImageFormatsRequest(Port XvPort) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 16 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	return buf
}

// Request XvQueryImageAttributes
// size: 16
type XvQueryImageAttributesCookie struct {
	*cookie
}

func (c *Conn) XvQueryImageAttributes(Port XvPort, Id uint32, Width uint16, Height uint16) XvQueryImageAttributesCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xvQueryImageAttributesRequest(Port, Id, Width, Height), cookie)
	return XvQueryImageAttributesCookie{cookie}
}

func (c *Conn) XvQueryImageAttributesUnchecked(Port XvPort, Id uint32, Width uint16, Height uint16) XvQueryImageAttributesCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xvQueryImageAttributesRequest(Port, Id, Width, Height), cookie)
	return XvQueryImageAttributesCookie{cookie}
}

// Request reply for XvQueryImageAttributes
// size: ((32 + pad((int(NumPlanes) * 4))) + pad((int(NumPlanes) * 4)))
type XvQueryImageAttributesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumPlanes uint32
	DataSize  uint32
	Width     uint16
	Height    uint16
	// padding: 12 bytes
	Pitches []uint32 // size: pad((int(NumPlanes) * 4))
	Offsets []uint32 // size: pad((int(NumPlanes) * 4))
}

// Waits and reads reply data from request XvQueryImageAttributes
func (cook XvQueryImageAttributesCookie) Reply() (*XvQueryImageAttributesReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xvQueryImageAttributesReply(buf), nil
}

// Read reply into structure from buffer for XvQueryImageAttributes
func xvQueryImageAttributesReply(buf []byte) *XvQueryImageAttributesReply {
	v := new(XvQueryImageAttributesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumPlanes = Get32(buf[b:])
	b += 4

	v.DataSize = Get32(buf[b:])
	b += 4

	v.Width = Get16(buf[b:])
	b += 2

	v.Height = Get16(buf[b:])
	b += 2

	b += 12 // padding

	v.Pitches = make([]uint32, v.NumPlanes)
	for i := 0; i < int(v.NumPlanes); i++ {
		v.Pitches[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	v.Offsets = make([]uint32, v.NumPlanes)
	for i := 0; i < int(v.NumPlanes); i++ {
		v.Offsets[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	return v
}

func (cook XvQueryImageAttributesCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvQueryImageAttributes
func (c *Conn) xvQueryImageAttributesRequest(Port XvPort, Id uint32, Width uint16, Height uint16) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 17 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	Put32(buf[b:], Id)
	b += 4

	Put16(buf[b:], Width)
	b += 2

	Put16(buf[b:], Height)
	b += 2

	return buf
}

// Request XvPutImage
// size: pad((40 + pad((len(Data) * 1))))
type XvPutImageCookie struct {
	*cookie
}

// Write request to wire for XvPutImage
func (c *Conn) XvPutImage(Port XvPort, Drawable Drawable, Gc Gcontext, Id uint32, SrcX int16, SrcY int16, SrcW uint16, SrcH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16, Width uint16, Height uint16, Data []byte) XvPutImageCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xvPutImageRequest(Port, Drawable, Gc, Id, SrcX, SrcY, SrcW, SrcH, DrwX, DrwY, DrwW, DrwH, Width, Height, Data), cookie)
	return XvPutImageCookie{cookie}
}

func (c *Conn) XvPutImageChecked(Port XvPort, Drawable Drawable, Gc Gcontext, Id uint32, SrcX int16, SrcY int16, SrcW uint16, SrcH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16, Width uint16, Height uint16, Data []byte) XvPutImageCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xvPutImageRequest(Port, Drawable, Gc, Id, SrcX, SrcY, SrcW, SrcH, DrwX, DrwY, DrwW, DrwH, Width, Height, Data), cookie)
	return XvPutImageCookie{cookie}
}

func (cook XvPutImageCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvPutImage
func (c *Conn) xvPutImageRequest(Port XvPort, Drawable Drawable, Gc Gcontext, Id uint32, SrcX int16, SrcY int16, SrcW uint16, SrcH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16, Width uint16, Height uint16, Data []byte) []byte {
	size := pad((40 + pad((len(Data) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 18 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	Put32(buf[b:], uint32(Drawable))
	b += 4

	Put32(buf[b:], uint32(Gc))
	b += 4

	Put32(buf[b:], Id)
	b += 4

	Put16(buf[b:], uint16(SrcX))
	b += 2

	Put16(buf[b:], uint16(SrcY))
	b += 2

	Put16(buf[b:], SrcW)
	b += 2

	Put16(buf[b:], SrcH)
	b += 2

	Put16(buf[b:], uint16(DrwX))
	b += 2

	Put16(buf[b:], uint16(DrwY))
	b += 2

	Put16(buf[b:], DrwW)
	b += 2

	Put16(buf[b:], DrwH)
	b += 2

	Put16(buf[b:], Width)
	b += 2

	Put16(buf[b:], Height)
	b += 2

	copy(buf[b:], Data[:len(Data)])
	b += pad(int(len(Data)))

	return buf
}

// Request XvShmPutImage
// size: 52
type XvShmPutImageCookie struct {
	*cookie
}

// Write request to wire for XvShmPutImage
func (c *Conn) XvShmPutImage(Port XvPort, Drawable Drawable, Gc Gcontext, Shmseg ShmSeg, Id uint32, Offset uint32, SrcX int16, SrcY int16, SrcW uint16, SrcH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16, Width uint16, Height uint16, SendEvent byte) XvShmPutImageCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xvShmPutImageRequest(Port, Drawable, Gc, Shmseg, Id, Offset, SrcX, SrcY, SrcW, SrcH, DrwX, DrwY, DrwW, DrwH, Width, Height, SendEvent), cookie)
	return XvShmPutImageCookie{cookie}
}

func (c *Conn) XvShmPutImageChecked(Port XvPort, Drawable Drawable, Gc Gcontext, Shmseg ShmSeg, Id uint32, Offset uint32, SrcX int16, SrcY int16, SrcW uint16, SrcH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16, Width uint16, Height uint16, SendEvent byte) XvShmPutImageCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xvShmPutImageRequest(Port, Drawable, Gc, Shmseg, Id, Offset, SrcX, SrcY, SrcW, SrcH, DrwX, DrwY, DrwW, DrwH, Width, Height, SendEvent), cookie)
	return XvShmPutImageCookie{cookie}
}

func (cook XvShmPutImageCookie) Check() error {
	return cook.check()
}

// Write request to wire for XvShmPutImage
func (c *Conn) xvShmPutImageRequest(Port XvPort, Drawable Drawable, Gc Gcontext, Shmseg ShmSeg, Id uint32, Offset uint32, SrcX int16, SrcY int16, SrcW uint16, SrcH uint16, DrwX int16, DrwY int16, DrwW uint16, DrwH uint16, Width uint16, Height uint16, SendEvent byte) []byte {
	size := 52
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XVIDEO"]
	b += 1

	buf[b] = 19 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Port))
	b += 4

	Put32(buf[b:], uint32(Drawable))
	b += 4

	Put32(buf[b:], uint32(Gc))
	b += 4

	Put32(buf[b:], uint32(Shmseg))
	b += 4

	Put32(buf[b:], Id)
	b += 4

	Put32(buf[b:], Offset)
	b += 4

	Put16(buf[b:], uint16(SrcX))
	b += 2

	Put16(buf[b:], uint16(SrcY))
	b += 2

	Put16(buf[b:], SrcW)
	b += 2

	Put16(buf[b:], SrcH)
	b += 2

	Put16(buf[b:], uint16(DrwX))
	b += 2

	Put16(buf[b:], uint16(DrwY))
	b += 2

	Put16(buf[b:], DrwW)
	b += 2

	Put16(buf[b:], DrwH)
	b += 2

	Put16(buf[b:], Width)
	b += 2

	Put16(buf[b:], Height)
	b += 2

	buf[b] = SendEvent
	b += 1

	b += 3 // padding

	return buf
}
