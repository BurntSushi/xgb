package xgb

/*
	This file was generated by xselinux.xml on May 8 2012 11:03:25pm EDT.
	This file is automatically generated. Edit at your peril!
*/

// Imports are not necessary for XGB because everything is 
// in one package. They are still listed here for reference.
// import "xproto"

// XselinuxInit must be called before using the SELinux extension.
func (c *Conn) XselinuxInit() error {
	reply, err := c.QueryExtension(7, "SELinux").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return errorf("No extension named SELinux could be found on on the server.")
	}

	c.extLock.Lock()
	c.extensions["SELinux"] = reply.MajorOpcode
	for evNum, fun := range newExtEventFuncs["SELinux"] {
		newEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range newExtErrorFuncs["SELinux"] {
		newErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	c.extLock.Unlock()

	return nil
}

func init() {
	newExtEventFuncs["SELinux"] = make(map[int]newEventFun)
	newExtErrorFuncs["SELinux"] = make(map[int]newErrorFun)
}

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Id'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// 'XselinuxListItem' struct definition
// Size: ((12 + pad((int(ObjectContextLen) * 1))) + pad((int(DataContextLen) * 1)))
type XselinuxListItem struct {
	Name             Id
	ObjectContextLen uint32
	DataContextLen   uint32
	ObjectContext    string // size: pad((int(ObjectContextLen) * 1))
	DataContext      string // size: pad((int(DataContextLen) * 1))
}

// Struct read XselinuxListItem
func ReadXselinuxListItem(buf []byte, v *XselinuxListItem) int {
	b := 0

	v.Name = Id(Get32(buf[b:]))
	b += 4

	v.ObjectContextLen = Get32(buf[b:])
	b += 4

	v.DataContextLen = Get32(buf[b:])
	b += 4

	{
		byteString := make([]byte, v.ObjectContextLen)
		copy(byteString[:v.ObjectContextLen], buf[b:])
		v.ObjectContext = string(byteString)
		b += pad(int(v.ObjectContextLen))
	}

	{
		byteString := make([]byte, v.DataContextLen)
		copy(byteString[:v.DataContextLen], buf[b:])
		v.DataContext = string(byteString)
		b += pad(int(v.DataContextLen))
	}

	return b
}

// Struct list read XselinuxListItem
func ReadXselinuxListItemList(buf []byte, dest []XselinuxListItem) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XselinuxListItem{}
		b += ReadXselinuxListItem(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XselinuxListItem
func (v XselinuxListItem) Bytes() []byte {
	buf := make([]byte, ((12 + pad((int(v.ObjectContextLen) * 1))) + pad((int(v.DataContextLen) * 1))))
	b := 0

	Put32(buf[b:], uint32(v.Name))
	b += 4

	Put32(buf[b:], v.ObjectContextLen)
	b += 4

	Put32(buf[b:], v.DataContextLen)
	b += 4

	copy(buf[b:], v.ObjectContext[:v.ObjectContextLen])
	b += pad(int(v.ObjectContextLen))

	copy(buf[b:], v.DataContext[:v.DataContextLen])
	b += pad(int(v.DataContextLen))

	return buf
}

// Write struct list XselinuxListItem
func XselinuxListItemListBytes(buf []byte, list []XselinuxListItem) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Struct list size XselinuxListItem
func XselinuxListItemListSize(list []XselinuxListItem) int {
	size := 0
	for _, item := range list {
		size += ((12 + pad((int(item.ObjectContextLen) * 1))) + pad((int(item.DataContextLen) * 1)))
	}
	return size
}

// Request XselinuxQueryVersion
// size: 8
type XselinuxQueryVersionCookie struct {
	*cookie
}

func (c *Conn) XselinuxQueryVersion(ClientMajor byte, ClientMinor byte) XselinuxQueryVersionCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xselinuxQueryVersionRequest(ClientMajor, ClientMinor), cookie)
	return XselinuxQueryVersionCookie{cookie}
}

func (c *Conn) XselinuxQueryVersionUnchecked(ClientMajor byte, ClientMinor byte) XselinuxQueryVersionCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xselinuxQueryVersionRequest(ClientMajor, ClientMinor), cookie)
	return XselinuxQueryVersionCookie{cookie}
}

// Request reply for XselinuxQueryVersion
// size: 12
type XselinuxQueryVersionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ServerMajor uint16
	ServerMinor uint16
}

// Waits and reads reply data from request XselinuxQueryVersion
func (cook XselinuxQueryVersionCookie) Reply() (*XselinuxQueryVersionReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xselinuxQueryVersionReply(buf), nil
}

// Read reply into structure from buffer for XselinuxQueryVersion
func xselinuxQueryVersionReply(buf []byte) *XselinuxQueryVersionReply {
	v := new(XselinuxQueryVersionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ServerMajor = Get16(buf[b:])
	b += 2

	v.ServerMinor = Get16(buf[b:])
	b += 2

	return v
}

func (cook XselinuxQueryVersionCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxQueryVersion
func (c *Conn) xselinuxQueryVersionRequest(ClientMajor byte, ClientMinor byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 0 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = ClientMajor
	b += 1

	buf[b] = ClientMinor
	b += 1

	return buf
}

// Request XselinuxSetDeviceCreateContext
// size: pad((8 + pad((int(ContextLen) * 1))))
type XselinuxSetDeviceCreateContextCookie struct {
	*cookie
}

// Write request to wire for XselinuxSetDeviceCreateContext
func (c *Conn) XselinuxSetDeviceCreateContext(ContextLen uint32, Context string) XselinuxSetDeviceCreateContextCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xselinuxSetDeviceCreateContextRequest(ContextLen, Context), cookie)
	return XselinuxSetDeviceCreateContextCookie{cookie}
}

func (c *Conn) XselinuxSetDeviceCreateContextChecked(ContextLen uint32, Context string) XselinuxSetDeviceCreateContextCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xselinuxSetDeviceCreateContextRequest(ContextLen, Context), cookie)
	return XselinuxSetDeviceCreateContextCookie{cookie}
}

func (cook XselinuxSetDeviceCreateContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxSetDeviceCreateContext
func (c *Conn) xselinuxSetDeviceCreateContextRequest(ContextLen uint32, Context string) []byte {
	size := pad((8 + pad((int(ContextLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], ContextLen)
	b += 4

	copy(buf[b:], Context[:ContextLen])
	b += pad(int(ContextLen))

	return buf
}

// Request XselinuxGetDeviceCreateContext
// size: 4
type XselinuxGetDeviceCreateContextCookie struct {
	*cookie
}

func (c *Conn) XselinuxGetDeviceCreateContext() XselinuxGetDeviceCreateContextCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xselinuxGetDeviceCreateContextRequest(), cookie)
	return XselinuxGetDeviceCreateContextCookie{cookie}
}

func (c *Conn) XselinuxGetDeviceCreateContextUnchecked() XselinuxGetDeviceCreateContextCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xselinuxGetDeviceCreateContextRequest(), cookie)
	return XselinuxGetDeviceCreateContextCookie{cookie}
}

// Request reply for XselinuxGetDeviceCreateContext
// size: (32 + pad((int(ContextLen) * 1)))
type XselinuxGetDeviceCreateContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request XselinuxGetDeviceCreateContext
func (cook XselinuxGetDeviceCreateContextCookie) Reply() (*XselinuxGetDeviceCreateContextReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xselinuxGetDeviceCreateContextReply(buf), nil
}

// Read reply into structure from buffer for XselinuxGetDeviceCreateContext
func xselinuxGetDeviceCreateContextReply(buf []byte) *XselinuxGetDeviceCreateContextReply {
	v := new(XselinuxGetDeviceCreateContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += pad(int(v.ContextLen))
	}

	return v
}

func (cook XselinuxGetDeviceCreateContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxGetDeviceCreateContext
func (c *Conn) xselinuxGetDeviceCreateContextRequest() []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request XselinuxSetDeviceContext
// size: pad((12 + pad((int(ContextLen) * 1))))
type XselinuxSetDeviceContextCookie struct {
	*cookie
}

// Write request to wire for XselinuxSetDeviceContext
func (c *Conn) XselinuxSetDeviceContext(Device uint32, ContextLen uint32, Context string) XselinuxSetDeviceContextCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xselinuxSetDeviceContextRequest(Device, ContextLen, Context), cookie)
	return XselinuxSetDeviceContextCookie{cookie}
}

func (c *Conn) XselinuxSetDeviceContextChecked(Device uint32, ContextLen uint32, Context string) XselinuxSetDeviceContextCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xselinuxSetDeviceContextRequest(Device, ContextLen, Context), cookie)
	return XselinuxSetDeviceContextCookie{cookie}
}

func (cook XselinuxSetDeviceContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxSetDeviceContext
func (c *Conn) xselinuxSetDeviceContextRequest(Device uint32, ContextLen uint32, Context string) []byte {
	size := pad((12 + pad((int(ContextLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], Device)
	b += 4

	Put32(buf[b:], ContextLen)
	b += 4

	copy(buf[b:], Context[:ContextLen])
	b += pad(int(ContextLen))

	return buf
}

// Request XselinuxGetDeviceContext
// size: 8
type XselinuxGetDeviceContextCookie struct {
	*cookie
}

func (c *Conn) XselinuxGetDeviceContext(Device uint32) XselinuxGetDeviceContextCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xselinuxGetDeviceContextRequest(Device), cookie)
	return XselinuxGetDeviceContextCookie{cookie}
}

func (c *Conn) XselinuxGetDeviceContextUnchecked(Device uint32) XselinuxGetDeviceContextCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xselinuxGetDeviceContextRequest(Device), cookie)
	return XselinuxGetDeviceContextCookie{cookie}
}

// Request reply for XselinuxGetDeviceContext
// size: (32 + pad((int(ContextLen) * 1)))
type XselinuxGetDeviceContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request XselinuxGetDeviceContext
func (cook XselinuxGetDeviceContextCookie) Reply() (*XselinuxGetDeviceContextReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xselinuxGetDeviceContextReply(buf), nil
}

// Read reply into structure from buffer for XselinuxGetDeviceContext
func xselinuxGetDeviceContextReply(buf []byte) *XselinuxGetDeviceContextReply {
	v := new(XselinuxGetDeviceContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += pad(int(v.ContextLen))
	}

	return v
}

func (cook XselinuxGetDeviceContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxGetDeviceContext
func (c *Conn) xselinuxGetDeviceContextRequest(Device uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], Device)
	b += 4

	return buf
}

// Request XselinuxSetWindowCreateContext
// size: pad((8 + pad((int(ContextLen) * 1))))
type XselinuxSetWindowCreateContextCookie struct {
	*cookie
}

// Write request to wire for XselinuxSetWindowCreateContext
func (c *Conn) XselinuxSetWindowCreateContext(ContextLen uint32, Context string) XselinuxSetWindowCreateContextCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xselinuxSetWindowCreateContextRequest(ContextLen, Context), cookie)
	return XselinuxSetWindowCreateContextCookie{cookie}
}

func (c *Conn) XselinuxSetWindowCreateContextChecked(ContextLen uint32, Context string) XselinuxSetWindowCreateContextCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xselinuxSetWindowCreateContextRequest(ContextLen, Context), cookie)
	return XselinuxSetWindowCreateContextCookie{cookie}
}

func (cook XselinuxSetWindowCreateContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxSetWindowCreateContext
func (c *Conn) xselinuxSetWindowCreateContextRequest(ContextLen uint32, Context string) []byte {
	size := pad((8 + pad((int(ContextLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], ContextLen)
	b += 4

	copy(buf[b:], Context[:ContextLen])
	b += pad(int(ContextLen))

	return buf
}

// Request XselinuxGetWindowCreateContext
// size: 4
type XselinuxGetWindowCreateContextCookie struct {
	*cookie
}

func (c *Conn) XselinuxGetWindowCreateContext() XselinuxGetWindowCreateContextCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xselinuxGetWindowCreateContextRequest(), cookie)
	return XselinuxGetWindowCreateContextCookie{cookie}
}

func (c *Conn) XselinuxGetWindowCreateContextUnchecked() XselinuxGetWindowCreateContextCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xselinuxGetWindowCreateContextRequest(), cookie)
	return XselinuxGetWindowCreateContextCookie{cookie}
}

// Request reply for XselinuxGetWindowCreateContext
// size: (32 + pad((int(ContextLen) * 1)))
type XselinuxGetWindowCreateContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request XselinuxGetWindowCreateContext
func (cook XselinuxGetWindowCreateContextCookie) Reply() (*XselinuxGetWindowCreateContextReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xselinuxGetWindowCreateContextReply(buf), nil
}

// Read reply into structure from buffer for XselinuxGetWindowCreateContext
func xselinuxGetWindowCreateContextReply(buf []byte) *XselinuxGetWindowCreateContextReply {
	v := new(XselinuxGetWindowCreateContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += pad(int(v.ContextLen))
	}

	return v
}

func (cook XselinuxGetWindowCreateContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxGetWindowCreateContext
func (c *Conn) xselinuxGetWindowCreateContextRequest() []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request XselinuxGetWindowContext
// size: 8
type XselinuxGetWindowContextCookie struct {
	*cookie
}

func (c *Conn) XselinuxGetWindowContext(Window Id) XselinuxGetWindowContextCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xselinuxGetWindowContextRequest(Window), cookie)
	return XselinuxGetWindowContextCookie{cookie}
}

func (c *Conn) XselinuxGetWindowContextUnchecked(Window Id) XselinuxGetWindowContextCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xselinuxGetWindowContextRequest(Window), cookie)
	return XselinuxGetWindowContextCookie{cookie}
}

// Request reply for XselinuxGetWindowContext
// size: (32 + pad((int(ContextLen) * 1)))
type XselinuxGetWindowContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request XselinuxGetWindowContext
func (cook XselinuxGetWindowContextCookie) Reply() (*XselinuxGetWindowContextReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xselinuxGetWindowContextReply(buf), nil
}

// Read reply into structure from buffer for XselinuxGetWindowContext
func xselinuxGetWindowContextReply(buf []byte) *XselinuxGetWindowContextReply {
	v := new(XselinuxGetWindowContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += pad(int(v.ContextLen))
	}

	return v
}

func (cook XselinuxGetWindowContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxGetWindowContext
func (c *Conn) xselinuxGetWindowContextRequest(Window Id) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request XselinuxSetPropertyCreateContext
// size: pad((8 + pad((int(ContextLen) * 1))))
type XselinuxSetPropertyCreateContextCookie struct {
	*cookie
}

// Write request to wire for XselinuxSetPropertyCreateContext
func (c *Conn) XselinuxSetPropertyCreateContext(ContextLen uint32, Context string) XselinuxSetPropertyCreateContextCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xselinuxSetPropertyCreateContextRequest(ContextLen, Context), cookie)
	return XselinuxSetPropertyCreateContextCookie{cookie}
}

func (c *Conn) XselinuxSetPropertyCreateContextChecked(ContextLen uint32, Context string) XselinuxSetPropertyCreateContextCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xselinuxSetPropertyCreateContextRequest(ContextLen, Context), cookie)
	return XselinuxSetPropertyCreateContextCookie{cookie}
}

func (cook XselinuxSetPropertyCreateContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxSetPropertyCreateContext
func (c *Conn) xselinuxSetPropertyCreateContextRequest(ContextLen uint32, Context string) []byte {
	size := pad((8 + pad((int(ContextLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 8 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], ContextLen)
	b += 4

	copy(buf[b:], Context[:ContextLen])
	b += pad(int(ContextLen))

	return buf
}

// Request XselinuxGetPropertyCreateContext
// size: 4
type XselinuxGetPropertyCreateContextCookie struct {
	*cookie
}

func (c *Conn) XselinuxGetPropertyCreateContext() XselinuxGetPropertyCreateContextCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xselinuxGetPropertyCreateContextRequest(), cookie)
	return XselinuxGetPropertyCreateContextCookie{cookie}
}

func (c *Conn) XselinuxGetPropertyCreateContextUnchecked() XselinuxGetPropertyCreateContextCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xselinuxGetPropertyCreateContextRequest(), cookie)
	return XselinuxGetPropertyCreateContextCookie{cookie}
}

// Request reply for XselinuxGetPropertyCreateContext
// size: (32 + pad((int(ContextLen) * 1)))
type XselinuxGetPropertyCreateContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request XselinuxGetPropertyCreateContext
func (cook XselinuxGetPropertyCreateContextCookie) Reply() (*XselinuxGetPropertyCreateContextReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xselinuxGetPropertyCreateContextReply(buf), nil
}

// Read reply into structure from buffer for XselinuxGetPropertyCreateContext
func xselinuxGetPropertyCreateContextReply(buf []byte) *XselinuxGetPropertyCreateContextReply {
	v := new(XselinuxGetPropertyCreateContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += pad(int(v.ContextLen))
	}

	return v
}

func (cook XselinuxGetPropertyCreateContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxGetPropertyCreateContext
func (c *Conn) xselinuxGetPropertyCreateContextRequest() []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 9 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request XselinuxSetPropertyUseContext
// size: pad((8 + pad((int(ContextLen) * 1))))
type XselinuxSetPropertyUseContextCookie struct {
	*cookie
}

// Write request to wire for XselinuxSetPropertyUseContext
func (c *Conn) XselinuxSetPropertyUseContext(ContextLen uint32, Context string) XselinuxSetPropertyUseContextCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xselinuxSetPropertyUseContextRequest(ContextLen, Context), cookie)
	return XselinuxSetPropertyUseContextCookie{cookie}
}

func (c *Conn) XselinuxSetPropertyUseContextChecked(ContextLen uint32, Context string) XselinuxSetPropertyUseContextCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xselinuxSetPropertyUseContextRequest(ContextLen, Context), cookie)
	return XselinuxSetPropertyUseContextCookie{cookie}
}

func (cook XselinuxSetPropertyUseContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxSetPropertyUseContext
func (c *Conn) xselinuxSetPropertyUseContextRequest(ContextLen uint32, Context string) []byte {
	size := pad((8 + pad((int(ContextLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 10 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], ContextLen)
	b += 4

	copy(buf[b:], Context[:ContextLen])
	b += pad(int(ContextLen))

	return buf
}

// Request XselinuxGetPropertyUseContext
// size: 4
type XselinuxGetPropertyUseContextCookie struct {
	*cookie
}

func (c *Conn) XselinuxGetPropertyUseContext() XselinuxGetPropertyUseContextCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xselinuxGetPropertyUseContextRequest(), cookie)
	return XselinuxGetPropertyUseContextCookie{cookie}
}

func (c *Conn) XselinuxGetPropertyUseContextUnchecked() XselinuxGetPropertyUseContextCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xselinuxGetPropertyUseContextRequest(), cookie)
	return XselinuxGetPropertyUseContextCookie{cookie}
}

// Request reply for XselinuxGetPropertyUseContext
// size: (32 + pad((int(ContextLen) * 1)))
type XselinuxGetPropertyUseContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request XselinuxGetPropertyUseContext
func (cook XselinuxGetPropertyUseContextCookie) Reply() (*XselinuxGetPropertyUseContextReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xselinuxGetPropertyUseContextReply(buf), nil
}

// Read reply into structure from buffer for XselinuxGetPropertyUseContext
func xselinuxGetPropertyUseContextReply(buf []byte) *XselinuxGetPropertyUseContextReply {
	v := new(XselinuxGetPropertyUseContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += pad(int(v.ContextLen))
	}

	return v
}

func (cook XselinuxGetPropertyUseContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxGetPropertyUseContext
func (c *Conn) xselinuxGetPropertyUseContextRequest() []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 11 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request XselinuxGetPropertyContext
// size: 12
type XselinuxGetPropertyContextCookie struct {
	*cookie
}

func (c *Conn) XselinuxGetPropertyContext(Window Id, Property Id) XselinuxGetPropertyContextCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xselinuxGetPropertyContextRequest(Window, Property), cookie)
	return XselinuxGetPropertyContextCookie{cookie}
}

func (c *Conn) XselinuxGetPropertyContextUnchecked(Window Id, Property Id) XselinuxGetPropertyContextCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xselinuxGetPropertyContextRequest(Window, Property), cookie)
	return XselinuxGetPropertyContextCookie{cookie}
}

// Request reply for XselinuxGetPropertyContext
// size: (32 + pad((int(ContextLen) * 1)))
type XselinuxGetPropertyContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request XselinuxGetPropertyContext
func (cook XselinuxGetPropertyContextCookie) Reply() (*XselinuxGetPropertyContextReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xselinuxGetPropertyContextReply(buf), nil
}

// Read reply into structure from buffer for XselinuxGetPropertyContext
func xselinuxGetPropertyContextReply(buf []byte) *XselinuxGetPropertyContextReply {
	v := new(XselinuxGetPropertyContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += pad(int(v.ContextLen))
	}

	return v
}

func (cook XselinuxGetPropertyContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxGetPropertyContext
func (c *Conn) xselinuxGetPropertyContextRequest(Window Id, Property Id) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 12 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Window))
	b += 4

	Put32(buf[b:], uint32(Property))
	b += 4

	return buf
}

// Request XselinuxGetPropertyDataContext
// size: 12
type XselinuxGetPropertyDataContextCookie struct {
	*cookie
}

func (c *Conn) XselinuxGetPropertyDataContext(Window Id, Property Id) XselinuxGetPropertyDataContextCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xselinuxGetPropertyDataContextRequest(Window, Property), cookie)
	return XselinuxGetPropertyDataContextCookie{cookie}
}

func (c *Conn) XselinuxGetPropertyDataContextUnchecked(Window Id, Property Id) XselinuxGetPropertyDataContextCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xselinuxGetPropertyDataContextRequest(Window, Property), cookie)
	return XselinuxGetPropertyDataContextCookie{cookie}
}

// Request reply for XselinuxGetPropertyDataContext
// size: (32 + pad((int(ContextLen) * 1)))
type XselinuxGetPropertyDataContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request XselinuxGetPropertyDataContext
func (cook XselinuxGetPropertyDataContextCookie) Reply() (*XselinuxGetPropertyDataContextReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xselinuxGetPropertyDataContextReply(buf), nil
}

// Read reply into structure from buffer for XselinuxGetPropertyDataContext
func xselinuxGetPropertyDataContextReply(buf []byte) *XselinuxGetPropertyDataContextReply {
	v := new(XselinuxGetPropertyDataContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += pad(int(v.ContextLen))
	}

	return v
}

func (cook XselinuxGetPropertyDataContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxGetPropertyDataContext
func (c *Conn) xselinuxGetPropertyDataContextRequest(Window Id, Property Id) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 13 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Window))
	b += 4

	Put32(buf[b:], uint32(Property))
	b += 4

	return buf
}

// Request XselinuxListProperties
// size: 8
type XselinuxListPropertiesCookie struct {
	*cookie
}

func (c *Conn) XselinuxListProperties(Window Id) XselinuxListPropertiesCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xselinuxListPropertiesRequest(Window), cookie)
	return XselinuxListPropertiesCookie{cookie}
}

func (c *Conn) XselinuxListPropertiesUnchecked(Window Id) XselinuxListPropertiesCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xselinuxListPropertiesRequest(Window), cookie)
	return XselinuxListPropertiesCookie{cookie}
}

// Request reply for XselinuxListProperties
// size: (32 + XselinuxListItemListSize(Properties))
type XselinuxListPropertiesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	PropertiesLen uint32
	// padding: 20 bytes
	Properties []XselinuxListItem // size: XselinuxListItemListSize(Properties)
}

// Waits and reads reply data from request XselinuxListProperties
func (cook XselinuxListPropertiesCookie) Reply() (*XselinuxListPropertiesReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xselinuxListPropertiesReply(buf), nil
}

// Read reply into structure from buffer for XselinuxListProperties
func xselinuxListPropertiesReply(buf []byte) *XselinuxListPropertiesReply {
	v := new(XselinuxListPropertiesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.PropertiesLen = Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.Properties = make([]XselinuxListItem, v.PropertiesLen)
	b += ReadXselinuxListItemList(buf[b:], v.Properties)

	return v
}

func (cook XselinuxListPropertiesCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxListProperties
func (c *Conn) xselinuxListPropertiesRequest(Window Id) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 14 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request XselinuxSetSelectionCreateContext
// size: pad((8 + pad((int(ContextLen) * 1))))
type XselinuxSetSelectionCreateContextCookie struct {
	*cookie
}

// Write request to wire for XselinuxSetSelectionCreateContext
func (c *Conn) XselinuxSetSelectionCreateContext(ContextLen uint32, Context string) XselinuxSetSelectionCreateContextCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xselinuxSetSelectionCreateContextRequest(ContextLen, Context), cookie)
	return XselinuxSetSelectionCreateContextCookie{cookie}
}

func (c *Conn) XselinuxSetSelectionCreateContextChecked(ContextLen uint32, Context string) XselinuxSetSelectionCreateContextCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xselinuxSetSelectionCreateContextRequest(ContextLen, Context), cookie)
	return XselinuxSetSelectionCreateContextCookie{cookie}
}

func (cook XselinuxSetSelectionCreateContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxSetSelectionCreateContext
func (c *Conn) xselinuxSetSelectionCreateContextRequest(ContextLen uint32, Context string) []byte {
	size := pad((8 + pad((int(ContextLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 15 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], ContextLen)
	b += 4

	copy(buf[b:], Context[:ContextLen])
	b += pad(int(ContextLen))

	return buf
}

// Request XselinuxGetSelectionCreateContext
// size: 4
type XselinuxGetSelectionCreateContextCookie struct {
	*cookie
}

func (c *Conn) XselinuxGetSelectionCreateContext() XselinuxGetSelectionCreateContextCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xselinuxGetSelectionCreateContextRequest(), cookie)
	return XselinuxGetSelectionCreateContextCookie{cookie}
}

func (c *Conn) XselinuxGetSelectionCreateContextUnchecked() XselinuxGetSelectionCreateContextCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xselinuxGetSelectionCreateContextRequest(), cookie)
	return XselinuxGetSelectionCreateContextCookie{cookie}
}

// Request reply for XselinuxGetSelectionCreateContext
// size: (32 + pad((int(ContextLen) * 1)))
type XselinuxGetSelectionCreateContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request XselinuxGetSelectionCreateContext
func (cook XselinuxGetSelectionCreateContextCookie) Reply() (*XselinuxGetSelectionCreateContextReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xselinuxGetSelectionCreateContextReply(buf), nil
}

// Read reply into structure from buffer for XselinuxGetSelectionCreateContext
func xselinuxGetSelectionCreateContextReply(buf []byte) *XselinuxGetSelectionCreateContextReply {
	v := new(XselinuxGetSelectionCreateContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += pad(int(v.ContextLen))
	}

	return v
}

func (cook XselinuxGetSelectionCreateContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxGetSelectionCreateContext
func (c *Conn) xselinuxGetSelectionCreateContextRequest() []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 16 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request XselinuxSetSelectionUseContext
// size: pad((8 + pad((int(ContextLen) * 1))))
type XselinuxSetSelectionUseContextCookie struct {
	*cookie
}

// Write request to wire for XselinuxSetSelectionUseContext
func (c *Conn) XselinuxSetSelectionUseContext(ContextLen uint32, Context string) XselinuxSetSelectionUseContextCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xselinuxSetSelectionUseContextRequest(ContextLen, Context), cookie)
	return XselinuxSetSelectionUseContextCookie{cookie}
}

func (c *Conn) XselinuxSetSelectionUseContextChecked(ContextLen uint32, Context string) XselinuxSetSelectionUseContextCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xselinuxSetSelectionUseContextRequest(ContextLen, Context), cookie)
	return XselinuxSetSelectionUseContextCookie{cookie}
}

func (cook XselinuxSetSelectionUseContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxSetSelectionUseContext
func (c *Conn) xselinuxSetSelectionUseContextRequest(ContextLen uint32, Context string) []byte {
	size := pad((8 + pad((int(ContextLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 17 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], ContextLen)
	b += 4

	copy(buf[b:], Context[:ContextLen])
	b += pad(int(ContextLen))

	return buf
}

// Request XselinuxGetSelectionUseContext
// size: 4
type XselinuxGetSelectionUseContextCookie struct {
	*cookie
}

func (c *Conn) XselinuxGetSelectionUseContext() XselinuxGetSelectionUseContextCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xselinuxGetSelectionUseContextRequest(), cookie)
	return XselinuxGetSelectionUseContextCookie{cookie}
}

func (c *Conn) XselinuxGetSelectionUseContextUnchecked() XselinuxGetSelectionUseContextCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xselinuxGetSelectionUseContextRequest(), cookie)
	return XselinuxGetSelectionUseContextCookie{cookie}
}

// Request reply for XselinuxGetSelectionUseContext
// size: (32 + pad((int(ContextLen) * 1)))
type XselinuxGetSelectionUseContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request XselinuxGetSelectionUseContext
func (cook XselinuxGetSelectionUseContextCookie) Reply() (*XselinuxGetSelectionUseContextReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xselinuxGetSelectionUseContextReply(buf), nil
}

// Read reply into structure from buffer for XselinuxGetSelectionUseContext
func xselinuxGetSelectionUseContextReply(buf []byte) *XselinuxGetSelectionUseContextReply {
	v := new(XselinuxGetSelectionUseContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += pad(int(v.ContextLen))
	}

	return v
}

func (cook XselinuxGetSelectionUseContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxGetSelectionUseContext
func (c *Conn) xselinuxGetSelectionUseContextRequest() []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 18 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request XselinuxGetSelectionContext
// size: 8
type XselinuxGetSelectionContextCookie struct {
	*cookie
}

func (c *Conn) XselinuxGetSelectionContext(Selection Id) XselinuxGetSelectionContextCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xselinuxGetSelectionContextRequest(Selection), cookie)
	return XselinuxGetSelectionContextCookie{cookie}
}

func (c *Conn) XselinuxGetSelectionContextUnchecked(Selection Id) XselinuxGetSelectionContextCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xselinuxGetSelectionContextRequest(Selection), cookie)
	return XselinuxGetSelectionContextCookie{cookie}
}

// Request reply for XselinuxGetSelectionContext
// size: (32 + pad((int(ContextLen) * 1)))
type XselinuxGetSelectionContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request XselinuxGetSelectionContext
func (cook XselinuxGetSelectionContextCookie) Reply() (*XselinuxGetSelectionContextReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xselinuxGetSelectionContextReply(buf), nil
}

// Read reply into structure from buffer for XselinuxGetSelectionContext
func xselinuxGetSelectionContextReply(buf []byte) *XselinuxGetSelectionContextReply {
	v := new(XselinuxGetSelectionContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += pad(int(v.ContextLen))
	}

	return v
}

func (cook XselinuxGetSelectionContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxGetSelectionContext
func (c *Conn) xselinuxGetSelectionContextRequest(Selection Id) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 19 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Selection))
	b += 4

	return buf
}

// Request XselinuxGetSelectionDataContext
// size: 8
type XselinuxGetSelectionDataContextCookie struct {
	*cookie
}

func (c *Conn) XselinuxGetSelectionDataContext(Selection Id) XselinuxGetSelectionDataContextCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xselinuxGetSelectionDataContextRequest(Selection), cookie)
	return XselinuxGetSelectionDataContextCookie{cookie}
}

func (c *Conn) XselinuxGetSelectionDataContextUnchecked(Selection Id) XselinuxGetSelectionDataContextCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xselinuxGetSelectionDataContextRequest(Selection), cookie)
	return XselinuxGetSelectionDataContextCookie{cookie}
}

// Request reply for XselinuxGetSelectionDataContext
// size: (32 + pad((int(ContextLen) * 1)))
type XselinuxGetSelectionDataContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request XselinuxGetSelectionDataContext
func (cook XselinuxGetSelectionDataContextCookie) Reply() (*XselinuxGetSelectionDataContextReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xselinuxGetSelectionDataContextReply(buf), nil
}

// Read reply into structure from buffer for XselinuxGetSelectionDataContext
func xselinuxGetSelectionDataContextReply(buf []byte) *XselinuxGetSelectionDataContextReply {
	v := new(XselinuxGetSelectionDataContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += pad(int(v.ContextLen))
	}

	return v
}

func (cook XselinuxGetSelectionDataContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxGetSelectionDataContext
func (c *Conn) xselinuxGetSelectionDataContextRequest(Selection Id) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 20 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Selection))
	b += 4

	return buf
}

// Request XselinuxListSelections
// size: 4
type XselinuxListSelectionsCookie struct {
	*cookie
}

func (c *Conn) XselinuxListSelections() XselinuxListSelectionsCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xselinuxListSelectionsRequest(), cookie)
	return XselinuxListSelectionsCookie{cookie}
}

func (c *Conn) XselinuxListSelectionsUnchecked() XselinuxListSelectionsCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xselinuxListSelectionsRequest(), cookie)
	return XselinuxListSelectionsCookie{cookie}
}

// Request reply for XselinuxListSelections
// size: (32 + XselinuxListItemListSize(Selections))
type XselinuxListSelectionsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	SelectionsLen uint32
	// padding: 20 bytes
	Selections []XselinuxListItem // size: XselinuxListItemListSize(Selections)
}

// Waits and reads reply data from request XselinuxListSelections
func (cook XselinuxListSelectionsCookie) Reply() (*XselinuxListSelectionsReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xselinuxListSelectionsReply(buf), nil
}

// Read reply into structure from buffer for XselinuxListSelections
func xselinuxListSelectionsReply(buf []byte) *XselinuxListSelectionsReply {
	v := new(XselinuxListSelectionsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.SelectionsLen = Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.Selections = make([]XselinuxListItem, v.SelectionsLen)
	b += ReadXselinuxListItemList(buf[b:], v.Selections)

	return v
}

func (cook XselinuxListSelectionsCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxListSelections
func (c *Conn) xselinuxListSelectionsRequest() []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 21 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request XselinuxGetClientContext
// size: 8
type XselinuxGetClientContextCookie struct {
	*cookie
}

func (c *Conn) XselinuxGetClientContext(Resource uint32) XselinuxGetClientContextCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xselinuxGetClientContextRequest(Resource), cookie)
	return XselinuxGetClientContextCookie{cookie}
}

func (c *Conn) XselinuxGetClientContextUnchecked(Resource uint32) XselinuxGetClientContextCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xselinuxGetClientContextRequest(Resource), cookie)
	return XselinuxGetClientContextCookie{cookie}
}

// Request reply for XselinuxGetClientContext
// size: (32 + pad((int(ContextLen) * 1)))
type XselinuxGetClientContextReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ContextLen uint32
	// padding: 20 bytes
	Context string // size: pad((int(ContextLen) * 1))
}

// Waits and reads reply data from request XselinuxGetClientContext
func (cook XselinuxGetClientContextCookie) Reply() (*XselinuxGetClientContextReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xselinuxGetClientContextReply(buf), nil
}

// Read reply into structure from buffer for XselinuxGetClientContext
func xselinuxGetClientContextReply(buf []byte) *XselinuxGetClientContextReply {
	v := new(XselinuxGetClientContextReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ContextLen = Get32(buf[b:])
	b += 4

	b += 20 // padding

	{
		byteString := make([]byte, v.ContextLen)
		copy(byteString[:v.ContextLen], buf[b:])
		v.Context = string(byteString)
		b += pad(int(v.ContextLen))
	}

	return v
}

func (cook XselinuxGetClientContextCookie) Check() error {
	return cook.check()
}

// Write request to wire for XselinuxGetClientContext
func (c *Conn) xselinuxGetClientContextRequest(Resource uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["SELINUX"]
	b += 1

	buf[b] = 22 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], Resource)
	b += 4

	return buf
}
