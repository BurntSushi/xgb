package xgb

/*
	This file was generated by xinput.xml on May 7 2012 11:34:26pm EDT.
	This file is automatically generated. Edit at your peril!
*/

// Imports are not necessary for XGB because everything is 
// in one package. They are still listed here for reference.
// import "xproto"

// XinputInit must be called before using the XInputExtension extension.
func (c *Conn) XinputInit() error {
	reply, err := c.QueryExtension(15, "XInputExtension").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return errorf("No extension named XInputExtension could be found on on the server.")
	}

	c.extLock.Lock()
	c.extensions["XInputExtension"] = reply.MajorOpcode
	for evNum, fun := range newExtEventFuncs["XInputExtension"] {
		newEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range newExtErrorFuncs["XInputExtension"] {
		newErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	c.extLock.Unlock()

	return nil
}

func init() {
	newExtEventFuncs["XInputExtension"] = make(map[int]newEventFun)
	newExtErrorFuncs["XInputExtension"] = make(map[int]newErrorFun)
}

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Id'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

const (
	XinputValuatorModeRelative = 0
	XinputValuatorModeAbsolute = 1
)

const (
	XinputPropagateModeAddToList      = 0
	XinputPropagateModeDeleteFromList = 1
)

const (
	XinputDeviceUseIsXPointer           = 0
	XinputDeviceUseIsXKeyboard          = 1
	XinputDeviceUseIsXExtensionDevice   = 2
	XinputDeviceUseIsXExtensionKeyboard = 3
	XinputDeviceUseIsXExtensionPointer  = 4
)

const (
	XinputInputClassKey       = 0
	XinputInputClassButton    = 1
	XinputInputClassValuator  = 2
	XinputInputClassFeedback  = 3
	XinputInputClassProximity = 4
	XinputInputClassFocus     = 5
	XinputInputClassOther     = 6
)

const (
	XinputDeviceInputModeAsyncThisDevice   = 0
	XinputDeviceInputModeSyncThisDevice    = 1
	XinputDeviceInputModeReplayThisDevice  = 2
	XinputDeviceInputModeAsyncOtherDevices = 3
	XinputDeviceInputModeAsyncAll          = 4
	XinputDeviceInputModeSyncAll           = 5
)

const (
	XinputFeedbackClassKeyboard = 0
	XinputFeedbackClassPointer  = 1
	XinputFeedbackClassString   = 2
	XinputFeedbackClassInteger  = 3
	XinputFeedbackClassLed      = 4
	XinputFeedbackClassBell     = 5
)

type XinputKeyCode byte

type XinputEventClass uint32

// 'XinputDeviceInfo' struct definition
// Size: 8
type XinputDeviceInfo struct {
	DeviceType   Id
	DeviceId     byte
	NumClassInfo byte
	DeviceUse    byte
	// padding: 1 bytes
}

// Struct read XinputDeviceInfo
func ReadXinputDeviceInfo(buf []byte, v *XinputDeviceInfo) int {
	b := 0

	v.DeviceType = Id(Get32(buf[b:]))
	b += 4

	v.DeviceId = buf[b]
	b += 1

	v.NumClassInfo = buf[b]
	b += 1

	v.DeviceUse = buf[b]
	b += 1

	b += 1 // padding

	return b
}

// Struct list read XinputDeviceInfo
func ReadXinputDeviceInfoList(buf []byte, dest []XinputDeviceInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputDeviceInfo{}
		b += ReadXinputDeviceInfo(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputDeviceInfo
func (v XinputDeviceInfo) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	Put32(buf[b:], uint32(v.DeviceType))
	b += 4

	buf[b] = v.DeviceId
	b += 1

	buf[b] = v.NumClassInfo
	b += 1

	buf[b] = v.DeviceUse
	b += 1

	b += 1 // padding

	return buf
}

// Write struct list XinputDeviceInfo
func XinputDeviceInfoListBytes(buf []byte, list []XinputDeviceInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputInputInfo' struct definition
// Size: 2
type XinputInputInfo struct {
	ClassId byte
	Len     byte
}

// Struct read XinputInputInfo
func ReadXinputInputInfo(buf []byte, v *XinputInputInfo) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	return b
}

// Struct list read XinputInputInfo
func ReadXinputInputInfoList(buf []byte, dest []XinputInputInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputInputInfo{}
		b += ReadXinputInputInfo(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputInputInfo
func (v XinputInputInfo) Bytes() []byte {
	buf := make([]byte, 2)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	return buf
}

// Write struct list XinputInputInfo
func XinputInputInfoListBytes(buf []byte, list []XinputInputInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputKeyInfo' struct definition
// Size: 8
type XinputKeyInfo struct {
	ClassId    byte
	Len        byte
	MinKeycode XinputKeyCode
	MaxKeycode XinputKeyCode
	NumKeys    uint16
	// padding: 2 bytes
}

// Struct read XinputKeyInfo
func ReadXinputKeyInfo(buf []byte, v *XinputKeyInfo) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.MinKeycode = XinputKeyCode(buf[b])
	b += 1

	v.MaxKeycode = XinputKeyCode(buf[b])
	b += 1

	v.NumKeys = Get16(buf[b:])
	b += 2

	b += 2 // padding

	return b
}

// Struct list read XinputKeyInfo
func ReadXinputKeyInfoList(buf []byte, dest []XinputKeyInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputKeyInfo{}
		b += ReadXinputKeyInfo(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputKeyInfo
func (v XinputKeyInfo) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = byte(v.MinKeycode)
	b += 1

	buf[b] = byte(v.MaxKeycode)
	b += 1

	Put16(buf[b:], v.NumKeys)
	b += 2

	b += 2 // padding

	return buf
}

// Write struct list XinputKeyInfo
func XinputKeyInfoListBytes(buf []byte, list []XinputKeyInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputButtonInfo' struct definition
// Size: 4
type XinputButtonInfo struct {
	ClassId    byte
	Len        byte
	NumButtons uint16
}

// Struct read XinputButtonInfo
func ReadXinputButtonInfo(buf []byte, v *XinputButtonInfo) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.NumButtons = Get16(buf[b:])
	b += 2

	return b
}

// Struct list read XinputButtonInfo
func ReadXinputButtonInfoList(buf []byte, dest []XinputButtonInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputButtonInfo{}
		b += ReadXinputButtonInfo(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputButtonInfo
func (v XinputButtonInfo) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	Put16(buf[b:], v.NumButtons)
	b += 2

	return buf
}

// Write struct list XinputButtonInfo
func XinputButtonInfoListBytes(buf []byte, list []XinputButtonInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputAxisInfo' struct definition
// Size: 12
type XinputAxisInfo struct {
	Resolution uint32
	Minimum    int32
	Maximum    int32
}

// Struct read XinputAxisInfo
func ReadXinputAxisInfo(buf []byte, v *XinputAxisInfo) int {
	b := 0

	v.Resolution = Get32(buf[b:])
	b += 4

	v.Minimum = int32(Get32(buf[b:]))
	b += 4

	v.Maximum = int32(Get32(buf[b:]))
	b += 4

	return b
}

// Struct list read XinputAxisInfo
func ReadXinputAxisInfoList(buf []byte, dest []XinputAxisInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputAxisInfo{}
		b += ReadXinputAxisInfo(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputAxisInfo
func (v XinputAxisInfo) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	Put32(buf[b:], v.Resolution)
	b += 4

	Put32(buf[b:], uint32(v.Minimum))
	b += 4

	Put32(buf[b:], uint32(v.Maximum))
	b += 4

	return buf
}

// Write struct list XinputAxisInfo
func XinputAxisInfoListBytes(buf []byte, list []XinputAxisInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputValuatorInfo' struct definition
// Size: (8 + pad((int(AxesLen) * 12)))
type XinputValuatorInfo struct {
	ClassId    byte
	Len        byte
	AxesLen    byte
	Mode       byte
	MotionSize uint32
	Axes       []XinputAxisInfo // size: pad((int(AxesLen) * 12))
}

// Struct read XinputValuatorInfo
func ReadXinputValuatorInfo(buf []byte, v *XinputValuatorInfo) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.AxesLen = buf[b]
	b += 1

	v.Mode = buf[b]
	b += 1

	v.MotionSize = Get32(buf[b:])
	b += 4

	v.Axes = make([]XinputAxisInfo, v.AxesLen)
	b += ReadXinputAxisInfoList(buf[b:], v.Axes)

	return b
}

// Struct list read XinputValuatorInfo
func ReadXinputValuatorInfoList(buf []byte, dest []XinputValuatorInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputValuatorInfo{}
		b += ReadXinputValuatorInfo(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputValuatorInfo
func (v XinputValuatorInfo) Bytes() []byte {
	buf := make([]byte, (8 + pad((int(v.AxesLen) * 12))))
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = v.AxesLen
	b += 1

	buf[b] = v.Mode
	b += 1

	Put32(buf[b:], v.MotionSize)
	b += 4

	b += XinputAxisInfoListBytes(buf[b:], v.Axes)

	return buf
}

// Write struct list XinputValuatorInfo
func XinputValuatorInfoListBytes(buf []byte, list []XinputValuatorInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Struct list size XinputValuatorInfo
func XinputValuatorInfoListSize(list []XinputValuatorInfo) int {
	size := 0
	for _, item := range list {
		size += (8 + pad((int(item.AxesLen) * 12)))
	}
	return size
}

// 'XinputInputClassInfo' struct definition
// Size: 2
type XinputInputClassInfo struct {
	ClassId       byte
	EventTypeBase byte
}

// Struct read XinputInputClassInfo
func ReadXinputInputClassInfo(buf []byte, v *XinputInputClassInfo) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.EventTypeBase = buf[b]
	b += 1

	return b
}

// Struct list read XinputInputClassInfo
func ReadXinputInputClassInfoList(buf []byte, dest []XinputInputClassInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputInputClassInfo{}
		b += ReadXinputInputClassInfo(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputInputClassInfo
func (v XinputInputClassInfo) Bytes() []byte {
	buf := make([]byte, 2)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.EventTypeBase
	b += 1

	return buf
}

// Write struct list XinputInputClassInfo
func XinputInputClassInfoListBytes(buf []byte, list []XinputInputClassInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputDeviceTimeCoord' struct definition
// Size: 4
type XinputDeviceTimeCoord struct {
	Time Timestamp
}

// Struct read XinputDeviceTimeCoord
func ReadXinputDeviceTimeCoord(buf []byte, v *XinputDeviceTimeCoord) int {
	b := 0

	v.Time = Timestamp(Get32(buf[b:]))
	b += 4

	return b
}

// Struct list read XinputDeviceTimeCoord
func ReadXinputDeviceTimeCoordList(buf []byte, dest []XinputDeviceTimeCoord) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputDeviceTimeCoord{}
		b += ReadXinputDeviceTimeCoord(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputDeviceTimeCoord
func (v XinputDeviceTimeCoord) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	Put32(buf[b:], uint32(v.Time))
	b += 4

	return buf
}

// Write struct list XinputDeviceTimeCoord
func XinputDeviceTimeCoordListBytes(buf []byte, list []XinputDeviceTimeCoord) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputFeedbackState' struct definition
// Size: 4
type XinputFeedbackState struct {
	ClassId byte
	Id      byte
	Len     uint16
}

// Struct read XinputFeedbackState
func ReadXinputFeedbackState(buf []byte, v *XinputFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = Get16(buf[b:])
	b += 2

	return b
}

// Struct list read XinputFeedbackState
func ReadXinputFeedbackStateList(buf []byte, dest []XinputFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputFeedbackState{}
		b += ReadXinputFeedbackState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputFeedbackState
func (v XinputFeedbackState) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	Put16(buf[b:], v.Len)
	b += 2

	return buf
}

// Write struct list XinputFeedbackState
func XinputFeedbackStateListBytes(buf []byte, list []XinputFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputKbdFeedbackState' struct definition
// Size: 52
type XinputKbdFeedbackState struct {
	ClassId          byte
	Id               byte
	Len              uint16
	Pitch            uint16
	Duration         uint16
	LedMask          uint32
	LedValues        uint32
	GlobalAutoRepeat bool
	Click            byte
	Percent          byte
	// padding: 1 bytes
	AutoRepeats []byte // size: 32
}

// Struct read XinputKbdFeedbackState
func ReadXinputKbdFeedbackState(buf []byte, v *XinputKbdFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = Get16(buf[b:])
	b += 2

	v.Pitch = Get16(buf[b:])
	b += 2

	v.Duration = Get16(buf[b:])
	b += 2

	v.LedMask = Get32(buf[b:])
	b += 4

	v.LedValues = Get32(buf[b:])
	b += 4

	if buf[b] == 1 {
		v.GlobalAutoRepeat = true
	} else {
		v.GlobalAutoRepeat = false
	}
	b += 1

	v.Click = buf[b]
	b += 1

	v.Percent = buf[b]
	b += 1

	b += 1 // padding

	v.AutoRepeats = make([]byte, 32)
	copy(v.AutoRepeats[:32], buf[b:])
	b += pad(int(32))

	return b
}

// Struct list read XinputKbdFeedbackState
func ReadXinputKbdFeedbackStateList(buf []byte, dest []XinputKbdFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputKbdFeedbackState{}
		b += ReadXinputKbdFeedbackState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputKbdFeedbackState
func (v XinputKbdFeedbackState) Bytes() []byte {
	buf := make([]byte, 52)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	Put16(buf[b:], v.Len)
	b += 2

	Put16(buf[b:], v.Pitch)
	b += 2

	Put16(buf[b:], v.Duration)
	b += 2

	Put32(buf[b:], v.LedMask)
	b += 4

	Put32(buf[b:], v.LedValues)
	b += 4

	if v.GlobalAutoRepeat {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	buf[b] = v.Click
	b += 1

	buf[b] = v.Percent
	b += 1

	b += 1 // padding

	copy(buf[b:], v.AutoRepeats[:32])
	b += pad(int(32))

	return buf
}

// Write struct list XinputKbdFeedbackState
func XinputKbdFeedbackStateListBytes(buf []byte, list []XinputKbdFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Struct list size XinputKbdFeedbackState
func XinputKbdFeedbackStateListSize(list []XinputKbdFeedbackState) int {
	size := 0
	for _ = range list {
		size += 52
	}
	return size
}

// 'XinputPtrFeedbackState' struct definition
// Size: 12
type XinputPtrFeedbackState struct {
	ClassId byte
	Id      byte
	Len     uint16
	// padding: 2 bytes
	AccelNum   uint16
	AccelDenom uint16
	Threshold  uint16
}

// Struct read XinputPtrFeedbackState
func ReadXinputPtrFeedbackState(buf []byte, v *XinputPtrFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.AccelNum = Get16(buf[b:])
	b += 2

	v.AccelDenom = Get16(buf[b:])
	b += 2

	v.Threshold = Get16(buf[b:])
	b += 2

	return b
}

// Struct list read XinputPtrFeedbackState
func ReadXinputPtrFeedbackStateList(buf []byte, dest []XinputPtrFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputPtrFeedbackState{}
		b += ReadXinputPtrFeedbackState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputPtrFeedbackState
func (v XinputPtrFeedbackState) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	Put16(buf[b:], v.Len)
	b += 2

	b += 2 // padding

	Put16(buf[b:], v.AccelNum)
	b += 2

	Put16(buf[b:], v.AccelDenom)
	b += 2

	Put16(buf[b:], v.Threshold)
	b += 2

	return buf
}

// Write struct list XinputPtrFeedbackState
func XinputPtrFeedbackStateListBytes(buf []byte, list []XinputPtrFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputIntegerFeedbackState' struct definition
// Size: 16
type XinputIntegerFeedbackState struct {
	ClassId    byte
	Id         byte
	Len        uint16
	Resolution uint32
	MinValue   int32
	MaxValue   int32
}

// Struct read XinputIntegerFeedbackState
func ReadXinputIntegerFeedbackState(buf []byte, v *XinputIntegerFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = Get16(buf[b:])
	b += 2

	v.Resolution = Get32(buf[b:])
	b += 4

	v.MinValue = int32(Get32(buf[b:]))
	b += 4

	v.MaxValue = int32(Get32(buf[b:]))
	b += 4

	return b
}

// Struct list read XinputIntegerFeedbackState
func ReadXinputIntegerFeedbackStateList(buf []byte, dest []XinputIntegerFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputIntegerFeedbackState{}
		b += ReadXinputIntegerFeedbackState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputIntegerFeedbackState
func (v XinputIntegerFeedbackState) Bytes() []byte {
	buf := make([]byte, 16)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	Put16(buf[b:], v.Len)
	b += 2

	Put32(buf[b:], v.Resolution)
	b += 4

	Put32(buf[b:], uint32(v.MinValue))
	b += 4

	Put32(buf[b:], uint32(v.MaxValue))
	b += 4

	return buf
}

// Write struct list XinputIntegerFeedbackState
func XinputIntegerFeedbackStateListBytes(buf []byte, list []XinputIntegerFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputStringFeedbackState' struct definition
// Size: (8 + pad((int(NumKeysyms) * 4)))
type XinputStringFeedbackState struct {
	ClassId    byte
	Id         byte
	Len        uint16
	MaxSymbols uint16
	NumKeysyms uint16
	Keysyms    []Keysym // size: pad((int(NumKeysyms) * 4))
}

// Struct read XinputStringFeedbackState
func ReadXinputStringFeedbackState(buf []byte, v *XinputStringFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = Get16(buf[b:])
	b += 2

	v.MaxSymbols = Get16(buf[b:])
	b += 2

	v.NumKeysyms = Get16(buf[b:])
	b += 2

	v.Keysyms = make([]Keysym, v.NumKeysyms)
	for i := 0; i < int(v.NumKeysyms); i++ {
		v.Keysyms[i] = Keysym(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return b
}

// Struct list read XinputStringFeedbackState
func ReadXinputStringFeedbackStateList(buf []byte, dest []XinputStringFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputStringFeedbackState{}
		b += ReadXinputStringFeedbackState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputStringFeedbackState
func (v XinputStringFeedbackState) Bytes() []byte {
	buf := make([]byte, (8 + pad((int(v.NumKeysyms) * 4))))
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	Put16(buf[b:], v.Len)
	b += 2

	Put16(buf[b:], v.MaxSymbols)
	b += 2

	Put16(buf[b:], v.NumKeysyms)
	b += 2

	for i := 0; i < int(v.NumKeysyms); i++ {
		Put32(buf[b:], uint32(v.Keysyms[i]))
		b += 4
	}
	b = pad(b)

	return buf
}

// Write struct list XinputStringFeedbackState
func XinputStringFeedbackStateListBytes(buf []byte, list []XinputStringFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Struct list size XinputStringFeedbackState
func XinputStringFeedbackStateListSize(list []XinputStringFeedbackState) int {
	size := 0
	for _, item := range list {
		size += (8 + pad((int(item.NumKeysyms) * 4)))
	}
	return size
}

// 'XinputBellFeedbackState' struct definition
// Size: 12
type XinputBellFeedbackState struct {
	ClassId byte
	Id      byte
	Len     uint16
	Percent byte
	// padding: 3 bytes
	Pitch    uint16
	Duration uint16
}

// Struct read XinputBellFeedbackState
func ReadXinputBellFeedbackState(buf []byte, v *XinputBellFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = Get16(buf[b:])
	b += 2

	v.Percent = buf[b]
	b += 1

	b += 3 // padding

	v.Pitch = Get16(buf[b:])
	b += 2

	v.Duration = Get16(buf[b:])
	b += 2

	return b
}

// Struct list read XinputBellFeedbackState
func ReadXinputBellFeedbackStateList(buf []byte, dest []XinputBellFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputBellFeedbackState{}
		b += ReadXinputBellFeedbackState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputBellFeedbackState
func (v XinputBellFeedbackState) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.Percent
	b += 1

	b += 3 // padding

	Put16(buf[b:], v.Pitch)
	b += 2

	Put16(buf[b:], v.Duration)
	b += 2

	return buf
}

// Write struct list XinputBellFeedbackState
func XinputBellFeedbackStateListBytes(buf []byte, list []XinputBellFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputLedFeedbackState' struct definition
// Size: 12
type XinputLedFeedbackState struct {
	ClassId   byte
	Id        byte
	Len       uint16
	LedMask   uint32
	LedValues uint32
}

// Struct read XinputLedFeedbackState
func ReadXinputLedFeedbackState(buf []byte, v *XinputLedFeedbackState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = Get16(buf[b:])
	b += 2

	v.LedMask = Get32(buf[b:])
	b += 4

	v.LedValues = Get32(buf[b:])
	b += 4

	return b
}

// Struct list read XinputLedFeedbackState
func ReadXinputLedFeedbackStateList(buf []byte, dest []XinputLedFeedbackState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputLedFeedbackState{}
		b += ReadXinputLedFeedbackState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputLedFeedbackState
func (v XinputLedFeedbackState) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	Put16(buf[b:], v.Len)
	b += 2

	Put32(buf[b:], v.LedMask)
	b += 4

	Put32(buf[b:], v.LedValues)
	b += 4

	return buf
}

// Write struct list XinputLedFeedbackState
func XinputLedFeedbackStateListBytes(buf []byte, list []XinputLedFeedbackState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputFeedbackCtl' struct definition
// Size: 4
type XinputFeedbackCtl struct {
	ClassId byte
	Id      byte
	Len     uint16
}

// Struct read XinputFeedbackCtl
func ReadXinputFeedbackCtl(buf []byte, v *XinputFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = Get16(buf[b:])
	b += 2

	return b
}

// Struct list read XinputFeedbackCtl
func ReadXinputFeedbackCtlList(buf []byte, dest []XinputFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputFeedbackCtl{}
		b += ReadXinputFeedbackCtl(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputFeedbackCtl
func (v XinputFeedbackCtl) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	Put16(buf[b:], v.Len)
	b += 2

	return buf
}

// Write struct list XinputFeedbackCtl
func XinputFeedbackCtlListBytes(buf []byte, list []XinputFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputKbdFeedbackCtl' struct definition
// Size: 20
type XinputKbdFeedbackCtl struct {
	ClassId         byte
	Id              byte
	Len             uint16
	Key             XinputKeyCode
	AutoRepeatMode  byte
	KeyClickPercent int8
	BellPercent     int8
	BellPitch       int16
	BellDuration    int16
	LedMask         uint32
	LedValues       uint32
}

// Struct read XinputKbdFeedbackCtl
func ReadXinputKbdFeedbackCtl(buf []byte, v *XinputKbdFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = Get16(buf[b:])
	b += 2

	v.Key = XinputKeyCode(buf[b])
	b += 1

	v.AutoRepeatMode = buf[b]
	b += 1

	v.KeyClickPercent = int8(buf[b])
	b += 1

	v.BellPercent = int8(buf[b])
	b += 1

	v.BellPitch = int16(Get16(buf[b:]))
	b += 2

	v.BellDuration = int16(Get16(buf[b:]))
	b += 2

	v.LedMask = Get32(buf[b:])
	b += 4

	v.LedValues = Get32(buf[b:])
	b += 4

	return b
}

// Struct list read XinputKbdFeedbackCtl
func ReadXinputKbdFeedbackCtlList(buf []byte, dest []XinputKbdFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputKbdFeedbackCtl{}
		b += ReadXinputKbdFeedbackCtl(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputKbdFeedbackCtl
func (v XinputKbdFeedbackCtl) Bytes() []byte {
	buf := make([]byte, 20)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	Put16(buf[b:], v.Len)
	b += 2

	buf[b] = byte(v.Key)
	b += 1

	buf[b] = v.AutoRepeatMode
	b += 1

	buf[b] = byte(v.KeyClickPercent)
	b += 1

	buf[b] = byte(v.BellPercent)
	b += 1

	Put16(buf[b:], uint16(v.BellPitch))
	b += 2

	Put16(buf[b:], uint16(v.BellDuration))
	b += 2

	Put32(buf[b:], v.LedMask)
	b += 4

	Put32(buf[b:], v.LedValues)
	b += 4

	return buf
}

// Write struct list XinputKbdFeedbackCtl
func XinputKbdFeedbackCtlListBytes(buf []byte, list []XinputKbdFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputPtrFeedbackCtl' struct definition
// Size: 12
type XinputPtrFeedbackCtl struct {
	ClassId byte
	Id      byte
	Len     uint16
	// padding: 2 bytes
	Num       int16
	Denom     int16
	Threshold int16
}

// Struct read XinputPtrFeedbackCtl
func ReadXinputPtrFeedbackCtl(buf []byte, v *XinputPtrFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.Num = int16(Get16(buf[b:]))
	b += 2

	v.Denom = int16(Get16(buf[b:]))
	b += 2

	v.Threshold = int16(Get16(buf[b:]))
	b += 2

	return b
}

// Struct list read XinputPtrFeedbackCtl
func ReadXinputPtrFeedbackCtlList(buf []byte, dest []XinputPtrFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputPtrFeedbackCtl{}
		b += ReadXinputPtrFeedbackCtl(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputPtrFeedbackCtl
func (v XinputPtrFeedbackCtl) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	Put16(buf[b:], v.Len)
	b += 2

	b += 2 // padding

	Put16(buf[b:], uint16(v.Num))
	b += 2

	Put16(buf[b:], uint16(v.Denom))
	b += 2

	Put16(buf[b:], uint16(v.Threshold))
	b += 2

	return buf
}

// Write struct list XinputPtrFeedbackCtl
func XinputPtrFeedbackCtlListBytes(buf []byte, list []XinputPtrFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputIntegerFeedbackCtl' struct definition
// Size: 8
type XinputIntegerFeedbackCtl struct {
	ClassId      byte
	Id           byte
	Len          uint16
	IntToDisplay int32
}

// Struct read XinputIntegerFeedbackCtl
func ReadXinputIntegerFeedbackCtl(buf []byte, v *XinputIntegerFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = Get16(buf[b:])
	b += 2

	v.IntToDisplay = int32(Get32(buf[b:]))
	b += 4

	return b
}

// Struct list read XinputIntegerFeedbackCtl
func ReadXinputIntegerFeedbackCtlList(buf []byte, dest []XinputIntegerFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputIntegerFeedbackCtl{}
		b += ReadXinputIntegerFeedbackCtl(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputIntegerFeedbackCtl
func (v XinputIntegerFeedbackCtl) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	Put16(buf[b:], v.Len)
	b += 2

	Put32(buf[b:], uint32(v.IntToDisplay))
	b += 4

	return buf
}

// Write struct list XinputIntegerFeedbackCtl
func XinputIntegerFeedbackCtlListBytes(buf []byte, list []XinputIntegerFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputStringFeedbackCtl' struct definition
// Size: (8 + pad((int(NumKeysyms) * 4)))
type XinputStringFeedbackCtl struct {
	ClassId byte
	Id      byte
	Len     uint16
	// padding: 2 bytes
	NumKeysyms uint16
	Keysyms    []Keysym // size: pad((int(NumKeysyms) * 4))
}

// Struct read XinputStringFeedbackCtl
func ReadXinputStringFeedbackCtl(buf []byte, v *XinputStringFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.NumKeysyms = Get16(buf[b:])
	b += 2

	v.Keysyms = make([]Keysym, v.NumKeysyms)
	for i := 0; i < int(v.NumKeysyms); i++ {
		v.Keysyms[i] = Keysym(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return b
}

// Struct list read XinputStringFeedbackCtl
func ReadXinputStringFeedbackCtlList(buf []byte, dest []XinputStringFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputStringFeedbackCtl{}
		b += ReadXinputStringFeedbackCtl(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputStringFeedbackCtl
func (v XinputStringFeedbackCtl) Bytes() []byte {
	buf := make([]byte, (8 + pad((int(v.NumKeysyms) * 4))))
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	Put16(buf[b:], v.Len)
	b += 2

	b += 2 // padding

	Put16(buf[b:], v.NumKeysyms)
	b += 2

	for i := 0; i < int(v.NumKeysyms); i++ {
		Put32(buf[b:], uint32(v.Keysyms[i]))
		b += 4
	}
	b = pad(b)

	return buf
}

// Write struct list XinputStringFeedbackCtl
func XinputStringFeedbackCtlListBytes(buf []byte, list []XinputStringFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Struct list size XinputStringFeedbackCtl
func XinputStringFeedbackCtlListSize(list []XinputStringFeedbackCtl) int {
	size := 0
	for _, item := range list {
		size += (8 + pad((int(item.NumKeysyms) * 4)))
	}
	return size
}

// 'XinputBellFeedbackCtl' struct definition
// Size: 12
type XinputBellFeedbackCtl struct {
	ClassId byte
	Id      byte
	Len     uint16
	Percent int8
	// padding: 3 bytes
	Pitch    int16
	Duration int16
}

// Struct read XinputBellFeedbackCtl
func ReadXinputBellFeedbackCtl(buf []byte, v *XinputBellFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = Get16(buf[b:])
	b += 2

	v.Percent = int8(buf[b])
	b += 1

	b += 3 // padding

	v.Pitch = int16(Get16(buf[b:]))
	b += 2

	v.Duration = int16(Get16(buf[b:]))
	b += 2

	return b
}

// Struct list read XinputBellFeedbackCtl
func ReadXinputBellFeedbackCtlList(buf []byte, dest []XinputBellFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputBellFeedbackCtl{}
		b += ReadXinputBellFeedbackCtl(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputBellFeedbackCtl
func (v XinputBellFeedbackCtl) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	Put16(buf[b:], v.Len)
	b += 2

	buf[b] = byte(v.Percent)
	b += 1

	b += 3 // padding

	Put16(buf[b:], uint16(v.Pitch))
	b += 2

	Put16(buf[b:], uint16(v.Duration))
	b += 2

	return buf
}

// Write struct list XinputBellFeedbackCtl
func XinputBellFeedbackCtlListBytes(buf []byte, list []XinputBellFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputLedFeedbackCtl' struct definition
// Size: 12
type XinputLedFeedbackCtl struct {
	ClassId   byte
	Id        byte
	Len       uint16
	LedMask   uint32
	LedValues uint32
}

// Struct read XinputLedFeedbackCtl
func ReadXinputLedFeedbackCtl(buf []byte, v *XinputLedFeedbackCtl) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Id = buf[b]
	b += 1

	v.Len = Get16(buf[b:])
	b += 2

	v.LedMask = Get32(buf[b:])
	b += 4

	v.LedValues = Get32(buf[b:])
	b += 4

	return b
}

// Struct list read XinputLedFeedbackCtl
func ReadXinputLedFeedbackCtlList(buf []byte, dest []XinputLedFeedbackCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputLedFeedbackCtl{}
		b += ReadXinputLedFeedbackCtl(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputLedFeedbackCtl
func (v XinputLedFeedbackCtl) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Id
	b += 1

	Put16(buf[b:], v.Len)
	b += 2

	Put32(buf[b:], v.LedMask)
	b += 4

	Put32(buf[b:], v.LedValues)
	b += 4

	return buf
}

// Write struct list XinputLedFeedbackCtl
func XinputLedFeedbackCtlListBytes(buf []byte, list []XinputLedFeedbackCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputInputState' struct definition
// Size: 3
type XinputInputState struct {
	ClassId  byte
	Len      byte
	NumItems byte
}

// Struct read XinputInputState
func ReadXinputInputState(buf []byte, v *XinputInputState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.NumItems = buf[b]
	b += 1

	return b
}

// Struct list read XinputInputState
func ReadXinputInputStateList(buf []byte, dest []XinputInputState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputInputState{}
		b += ReadXinputInputState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputInputState
func (v XinputInputState) Bytes() []byte {
	buf := make([]byte, 3)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = v.NumItems
	b += 1

	return buf
}

// Write struct list XinputInputState
func XinputInputStateListBytes(buf []byte, list []XinputInputState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputKeyState' struct definition
// Size: 36
type XinputKeyState struct {
	ClassId byte
	Len     byte
	NumKeys byte
	// padding: 1 bytes
	Keys []byte // size: 32
}

// Struct read XinputKeyState
func ReadXinputKeyState(buf []byte, v *XinputKeyState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.NumKeys = buf[b]
	b += 1

	b += 1 // padding

	v.Keys = make([]byte, 32)
	copy(v.Keys[:32], buf[b:])
	b += pad(int(32))

	return b
}

// Struct list read XinputKeyState
func ReadXinputKeyStateList(buf []byte, dest []XinputKeyState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputKeyState{}
		b += ReadXinputKeyState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputKeyState
func (v XinputKeyState) Bytes() []byte {
	buf := make([]byte, 36)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = v.NumKeys
	b += 1

	b += 1 // padding

	copy(buf[b:], v.Keys[:32])
	b += pad(int(32))

	return buf
}

// Write struct list XinputKeyState
func XinputKeyStateListBytes(buf []byte, list []XinputKeyState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Struct list size XinputKeyState
func XinputKeyStateListSize(list []XinputKeyState) int {
	size := 0
	for _ = range list {
		size += 36
	}
	return size
}

// 'XinputButtonState' struct definition
// Size: 36
type XinputButtonState struct {
	ClassId    byte
	Len        byte
	NumButtons byte
	// padding: 1 bytes
	Buttons []byte // size: 32
}

// Struct read XinputButtonState
func ReadXinputButtonState(buf []byte, v *XinputButtonState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.NumButtons = buf[b]
	b += 1

	b += 1 // padding

	v.Buttons = make([]byte, 32)
	copy(v.Buttons[:32], buf[b:])
	b += pad(int(32))

	return b
}

// Struct list read XinputButtonState
func ReadXinputButtonStateList(buf []byte, dest []XinputButtonState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputButtonState{}
		b += ReadXinputButtonState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputButtonState
func (v XinputButtonState) Bytes() []byte {
	buf := make([]byte, 36)
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = v.NumButtons
	b += 1

	b += 1 // padding

	copy(buf[b:], v.Buttons[:32])
	b += pad(int(32))

	return buf
}

// Write struct list XinputButtonState
func XinputButtonStateListBytes(buf []byte, list []XinputButtonState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Struct list size XinputButtonState
func XinputButtonStateListSize(list []XinputButtonState) int {
	size := 0
	for _ = range list {
		size += 36
	}
	return size
}

// 'XinputValuatorState' struct definition
// Size: (4 + pad((int(NumValuators) * 4)))
type XinputValuatorState struct {
	ClassId      byte
	Len          byte
	NumValuators byte
	Mode         byte
	Valuators    []uint32 // size: pad((int(NumValuators) * 4))
}

// Struct read XinputValuatorState
func ReadXinputValuatorState(buf []byte, v *XinputValuatorState) int {
	b := 0

	v.ClassId = buf[b]
	b += 1

	v.Len = buf[b]
	b += 1

	v.NumValuators = buf[b]
	b += 1

	v.Mode = buf[b]
	b += 1

	v.Valuators = make([]uint32, v.NumValuators)
	for i := 0; i < int(v.NumValuators); i++ {
		v.Valuators[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	return b
}

// Struct list read XinputValuatorState
func ReadXinputValuatorStateList(buf []byte, dest []XinputValuatorState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputValuatorState{}
		b += ReadXinputValuatorState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputValuatorState
func (v XinputValuatorState) Bytes() []byte {
	buf := make([]byte, (4 + pad((int(v.NumValuators) * 4))))
	b := 0

	buf[b] = v.ClassId
	b += 1

	buf[b] = v.Len
	b += 1

	buf[b] = v.NumValuators
	b += 1

	buf[b] = v.Mode
	b += 1

	for i := 0; i < int(v.NumValuators); i++ {
		Put32(buf[b:], v.Valuators[i])
		b += 4
	}
	b = pad(b)

	return buf
}

// Write struct list XinputValuatorState
func XinputValuatorStateListBytes(buf []byte, list []XinputValuatorState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Struct list size XinputValuatorState
func XinputValuatorStateListSize(list []XinputValuatorState) int {
	size := 0
	for _, item := range list {
		size += (4 + pad((int(item.NumValuators) * 4)))
	}
	return size
}

// 'XinputDeviceState' struct definition
// Size: 4
type XinputDeviceState struct {
	ControlId uint16
	Len       uint16
}

// Struct read XinputDeviceState
func ReadXinputDeviceState(buf []byte, v *XinputDeviceState) int {
	b := 0

	v.ControlId = Get16(buf[b:])
	b += 2

	v.Len = Get16(buf[b:])
	b += 2

	return b
}

// Struct list read XinputDeviceState
func ReadXinputDeviceStateList(buf []byte, dest []XinputDeviceState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputDeviceState{}
		b += ReadXinputDeviceState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputDeviceState
func (v XinputDeviceState) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	Put16(buf[b:], v.ControlId)
	b += 2

	Put16(buf[b:], v.Len)
	b += 2

	return buf
}

// Write struct list XinputDeviceState
func XinputDeviceStateListBytes(buf []byte, list []XinputDeviceState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputDeviceResolutionState' struct definition
// Size: (((8 + pad((int(NumValuators) * 4))) + pad((int(NumValuators) * 4))) + pad((int(NumValuators) * 4)))
type XinputDeviceResolutionState struct {
	ControlId        uint16
	Len              uint16
	NumValuators     uint32
	ResolutionValues []uint32 // size: pad((int(NumValuators) * 4))
	ResolutionMin    []uint32 // size: pad((int(NumValuators) * 4))
	ResolutionMax    []uint32 // size: pad((int(NumValuators) * 4))
}

// Struct read XinputDeviceResolutionState
func ReadXinputDeviceResolutionState(buf []byte, v *XinputDeviceResolutionState) int {
	b := 0

	v.ControlId = Get16(buf[b:])
	b += 2

	v.Len = Get16(buf[b:])
	b += 2

	v.NumValuators = Get32(buf[b:])
	b += 4

	v.ResolutionValues = make([]uint32, v.NumValuators)
	for i := 0; i < int(v.NumValuators); i++ {
		v.ResolutionValues[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	v.ResolutionMin = make([]uint32, v.NumValuators)
	for i := 0; i < int(v.NumValuators); i++ {
		v.ResolutionMin[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	v.ResolutionMax = make([]uint32, v.NumValuators)
	for i := 0; i < int(v.NumValuators); i++ {
		v.ResolutionMax[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	return b
}

// Struct list read XinputDeviceResolutionState
func ReadXinputDeviceResolutionStateList(buf []byte, dest []XinputDeviceResolutionState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputDeviceResolutionState{}
		b += ReadXinputDeviceResolutionState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputDeviceResolutionState
func (v XinputDeviceResolutionState) Bytes() []byte {
	buf := make([]byte, (((8 + pad((int(v.NumValuators) * 4))) + pad((int(v.NumValuators) * 4))) + pad((int(v.NumValuators) * 4))))
	b := 0

	Put16(buf[b:], v.ControlId)
	b += 2

	Put16(buf[b:], v.Len)
	b += 2

	Put32(buf[b:], v.NumValuators)
	b += 4

	for i := 0; i < int(v.NumValuators); i++ {
		Put32(buf[b:], v.ResolutionValues[i])
		b += 4
	}
	b = pad(b)

	for i := 0; i < int(v.NumValuators); i++ {
		Put32(buf[b:], v.ResolutionMin[i])
		b += 4
	}
	b = pad(b)

	for i := 0; i < int(v.NumValuators); i++ {
		Put32(buf[b:], v.ResolutionMax[i])
		b += 4
	}
	b = pad(b)

	return buf
}

// Write struct list XinputDeviceResolutionState
func XinputDeviceResolutionStateListBytes(buf []byte, list []XinputDeviceResolutionState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Struct list size XinputDeviceResolutionState
func XinputDeviceResolutionStateListSize(list []XinputDeviceResolutionState) int {
	size := 0
	for _, item := range list {
		size += (((8 + pad((int(item.NumValuators) * 4))) + pad((int(item.NumValuators) * 4))) + pad((int(item.NumValuators) * 4)))
	}
	return size
}

// 'XinputDeviceAbsCalibState' struct definition
// Size: 36
type XinputDeviceAbsCalibState struct {
	ControlId       uint16
	Len             uint16
	MinX            int32
	MaxX            int32
	MinY            int32
	MaxY            int32
	FlipX           uint32
	FlipY           uint32
	Rotation        uint32
	ButtonThreshold uint32
}

// Struct read XinputDeviceAbsCalibState
func ReadXinputDeviceAbsCalibState(buf []byte, v *XinputDeviceAbsCalibState) int {
	b := 0

	v.ControlId = Get16(buf[b:])
	b += 2

	v.Len = Get16(buf[b:])
	b += 2

	v.MinX = int32(Get32(buf[b:]))
	b += 4

	v.MaxX = int32(Get32(buf[b:]))
	b += 4

	v.MinY = int32(Get32(buf[b:]))
	b += 4

	v.MaxY = int32(Get32(buf[b:]))
	b += 4

	v.FlipX = Get32(buf[b:])
	b += 4

	v.FlipY = Get32(buf[b:])
	b += 4

	v.Rotation = Get32(buf[b:])
	b += 4

	v.ButtonThreshold = Get32(buf[b:])
	b += 4

	return b
}

// Struct list read XinputDeviceAbsCalibState
func ReadXinputDeviceAbsCalibStateList(buf []byte, dest []XinputDeviceAbsCalibState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputDeviceAbsCalibState{}
		b += ReadXinputDeviceAbsCalibState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputDeviceAbsCalibState
func (v XinputDeviceAbsCalibState) Bytes() []byte {
	buf := make([]byte, 36)
	b := 0

	Put16(buf[b:], v.ControlId)
	b += 2

	Put16(buf[b:], v.Len)
	b += 2

	Put32(buf[b:], uint32(v.MinX))
	b += 4

	Put32(buf[b:], uint32(v.MaxX))
	b += 4

	Put32(buf[b:], uint32(v.MinY))
	b += 4

	Put32(buf[b:], uint32(v.MaxY))
	b += 4

	Put32(buf[b:], v.FlipX)
	b += 4

	Put32(buf[b:], v.FlipY)
	b += 4

	Put32(buf[b:], v.Rotation)
	b += 4

	Put32(buf[b:], v.ButtonThreshold)
	b += 4

	return buf
}

// Write struct list XinputDeviceAbsCalibState
func XinputDeviceAbsCalibStateListBytes(buf []byte, list []XinputDeviceAbsCalibState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputDeviceAbsAreaState' struct definition
// Size: 28
type XinputDeviceAbsAreaState struct {
	ControlId uint16
	Len       uint16
	OffsetX   uint32
	OffsetY   uint32
	Width     uint32
	Height    uint32
	Screen    uint32
	Following uint32
}

// Struct read XinputDeviceAbsAreaState
func ReadXinputDeviceAbsAreaState(buf []byte, v *XinputDeviceAbsAreaState) int {
	b := 0

	v.ControlId = Get16(buf[b:])
	b += 2

	v.Len = Get16(buf[b:])
	b += 2

	v.OffsetX = Get32(buf[b:])
	b += 4

	v.OffsetY = Get32(buf[b:])
	b += 4

	v.Width = Get32(buf[b:])
	b += 4

	v.Height = Get32(buf[b:])
	b += 4

	v.Screen = Get32(buf[b:])
	b += 4

	v.Following = Get32(buf[b:])
	b += 4

	return b
}

// Struct list read XinputDeviceAbsAreaState
func ReadXinputDeviceAbsAreaStateList(buf []byte, dest []XinputDeviceAbsAreaState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputDeviceAbsAreaState{}
		b += ReadXinputDeviceAbsAreaState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputDeviceAbsAreaState
func (v XinputDeviceAbsAreaState) Bytes() []byte {
	buf := make([]byte, 28)
	b := 0

	Put16(buf[b:], v.ControlId)
	b += 2

	Put16(buf[b:], v.Len)
	b += 2

	Put32(buf[b:], v.OffsetX)
	b += 4

	Put32(buf[b:], v.OffsetY)
	b += 4

	Put32(buf[b:], v.Width)
	b += 4

	Put32(buf[b:], v.Height)
	b += 4

	Put32(buf[b:], v.Screen)
	b += 4

	Put32(buf[b:], v.Following)
	b += 4

	return buf
}

// Write struct list XinputDeviceAbsAreaState
func XinputDeviceAbsAreaStateListBytes(buf []byte, list []XinputDeviceAbsAreaState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputDeviceCoreState' struct definition
// Size: 8
type XinputDeviceCoreState struct {
	ControlId uint16
	Len       uint16
	Status    byte
	Iscore    byte
	// padding: 2 bytes
}

// Struct read XinputDeviceCoreState
func ReadXinputDeviceCoreState(buf []byte, v *XinputDeviceCoreState) int {
	b := 0

	v.ControlId = Get16(buf[b:])
	b += 2

	v.Len = Get16(buf[b:])
	b += 2

	v.Status = buf[b]
	b += 1

	v.Iscore = buf[b]
	b += 1

	b += 2 // padding

	return b
}

// Struct list read XinputDeviceCoreState
func ReadXinputDeviceCoreStateList(buf []byte, dest []XinputDeviceCoreState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputDeviceCoreState{}
		b += ReadXinputDeviceCoreState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputDeviceCoreState
func (v XinputDeviceCoreState) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	Put16(buf[b:], v.ControlId)
	b += 2

	Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.Status
	b += 1

	buf[b] = v.Iscore
	b += 1

	b += 2 // padding

	return buf
}

// Write struct list XinputDeviceCoreState
func XinputDeviceCoreStateListBytes(buf []byte, list []XinputDeviceCoreState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputDeviceEnableState' struct definition
// Size: 8
type XinputDeviceEnableState struct {
	ControlId uint16
	Len       uint16
	Enable    byte
	// padding: 3 bytes
}

// Struct read XinputDeviceEnableState
func ReadXinputDeviceEnableState(buf []byte, v *XinputDeviceEnableState) int {
	b := 0

	v.ControlId = Get16(buf[b:])
	b += 2

	v.Len = Get16(buf[b:])
	b += 2

	v.Enable = buf[b]
	b += 1

	b += 3 // padding

	return b
}

// Struct list read XinputDeviceEnableState
func ReadXinputDeviceEnableStateList(buf []byte, dest []XinputDeviceEnableState) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputDeviceEnableState{}
		b += ReadXinputDeviceEnableState(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputDeviceEnableState
func (v XinputDeviceEnableState) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	Put16(buf[b:], v.ControlId)
	b += 2

	Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.Enable
	b += 1

	b += 3 // padding

	return buf
}

// Write struct list XinputDeviceEnableState
func XinputDeviceEnableStateListBytes(buf []byte, list []XinputDeviceEnableState) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputDeviceCtl' struct definition
// Size: 4
type XinputDeviceCtl struct {
	ControlId uint16
	Len       uint16
}

// Struct read XinputDeviceCtl
func ReadXinputDeviceCtl(buf []byte, v *XinputDeviceCtl) int {
	b := 0

	v.ControlId = Get16(buf[b:])
	b += 2

	v.Len = Get16(buf[b:])
	b += 2

	return b
}

// Struct list read XinputDeviceCtl
func ReadXinputDeviceCtlList(buf []byte, dest []XinputDeviceCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputDeviceCtl{}
		b += ReadXinputDeviceCtl(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputDeviceCtl
func (v XinputDeviceCtl) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	Put16(buf[b:], v.ControlId)
	b += 2

	Put16(buf[b:], v.Len)
	b += 2

	return buf
}

// Write struct list XinputDeviceCtl
func XinputDeviceCtlListBytes(buf []byte, list []XinputDeviceCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputDeviceResolutionCtl' struct definition
// Size: (6 + pad((int(NumValuators) * 4)))
type XinputDeviceResolutionCtl struct {
	ControlId        uint16
	Len              uint16
	FirstValuator    byte
	NumValuators     byte
	ResolutionValues []uint32 // size: pad((int(NumValuators) * 4))
}

// Struct read XinputDeviceResolutionCtl
func ReadXinputDeviceResolutionCtl(buf []byte, v *XinputDeviceResolutionCtl) int {
	b := 0

	v.ControlId = Get16(buf[b:])
	b += 2

	v.Len = Get16(buf[b:])
	b += 2

	v.FirstValuator = buf[b]
	b += 1

	v.NumValuators = buf[b]
	b += 1

	v.ResolutionValues = make([]uint32, v.NumValuators)
	for i := 0; i < int(v.NumValuators); i++ {
		v.ResolutionValues[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	return b
}

// Struct list read XinputDeviceResolutionCtl
func ReadXinputDeviceResolutionCtlList(buf []byte, dest []XinputDeviceResolutionCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputDeviceResolutionCtl{}
		b += ReadXinputDeviceResolutionCtl(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputDeviceResolutionCtl
func (v XinputDeviceResolutionCtl) Bytes() []byte {
	buf := make([]byte, (6 + pad((int(v.NumValuators) * 4))))
	b := 0

	Put16(buf[b:], v.ControlId)
	b += 2

	Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.FirstValuator
	b += 1

	buf[b] = v.NumValuators
	b += 1

	for i := 0; i < int(v.NumValuators); i++ {
		Put32(buf[b:], v.ResolutionValues[i])
		b += 4
	}
	b = pad(b)

	return buf
}

// Write struct list XinputDeviceResolutionCtl
func XinputDeviceResolutionCtlListBytes(buf []byte, list []XinputDeviceResolutionCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Struct list size XinputDeviceResolutionCtl
func XinputDeviceResolutionCtlListSize(list []XinputDeviceResolutionCtl) int {
	size := 0
	for _, item := range list {
		size += (6 + pad((int(item.NumValuators) * 4)))
	}
	return size
}

// 'XinputDeviceAbsCalibCtl' struct definition
// Size: 36
type XinputDeviceAbsCalibCtl struct {
	ControlId       uint16
	Len             uint16
	MinX            int32
	MaxX            int32
	MinY            int32
	MaxY            int32
	FlipX           uint32
	FlipY           uint32
	Rotation        uint32
	ButtonThreshold uint32
}

// Struct read XinputDeviceAbsCalibCtl
func ReadXinputDeviceAbsCalibCtl(buf []byte, v *XinputDeviceAbsCalibCtl) int {
	b := 0

	v.ControlId = Get16(buf[b:])
	b += 2

	v.Len = Get16(buf[b:])
	b += 2

	v.MinX = int32(Get32(buf[b:]))
	b += 4

	v.MaxX = int32(Get32(buf[b:]))
	b += 4

	v.MinY = int32(Get32(buf[b:]))
	b += 4

	v.MaxY = int32(Get32(buf[b:]))
	b += 4

	v.FlipX = Get32(buf[b:])
	b += 4

	v.FlipY = Get32(buf[b:])
	b += 4

	v.Rotation = Get32(buf[b:])
	b += 4

	v.ButtonThreshold = Get32(buf[b:])
	b += 4

	return b
}

// Struct list read XinputDeviceAbsCalibCtl
func ReadXinputDeviceAbsCalibCtlList(buf []byte, dest []XinputDeviceAbsCalibCtl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputDeviceAbsCalibCtl{}
		b += ReadXinputDeviceAbsCalibCtl(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputDeviceAbsCalibCtl
func (v XinputDeviceAbsCalibCtl) Bytes() []byte {
	buf := make([]byte, 36)
	b := 0

	Put16(buf[b:], v.ControlId)
	b += 2

	Put16(buf[b:], v.Len)
	b += 2

	Put32(buf[b:], uint32(v.MinX))
	b += 4

	Put32(buf[b:], uint32(v.MaxX))
	b += 4

	Put32(buf[b:], uint32(v.MinY))
	b += 4

	Put32(buf[b:], uint32(v.MaxY))
	b += 4

	Put32(buf[b:], v.FlipX)
	b += 4

	Put32(buf[b:], v.FlipY)
	b += 4

	Put32(buf[b:], v.Rotation)
	b += 4

	Put32(buf[b:], v.ButtonThreshold)
	b += 4

	return buf
}

// Write struct list XinputDeviceAbsCalibCtl
func XinputDeviceAbsCalibCtlListBytes(buf []byte, list []XinputDeviceAbsCalibCtl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputDeviceAbsAreaCtrl' struct definition
// Size: 28
type XinputDeviceAbsAreaCtrl struct {
	ControlId uint16
	Len       uint16
	OffsetX   uint32
	OffsetY   uint32
	Width     int32
	Height    int32
	Screen    int32
	Following uint32
}

// Struct read XinputDeviceAbsAreaCtrl
func ReadXinputDeviceAbsAreaCtrl(buf []byte, v *XinputDeviceAbsAreaCtrl) int {
	b := 0

	v.ControlId = Get16(buf[b:])
	b += 2

	v.Len = Get16(buf[b:])
	b += 2

	v.OffsetX = Get32(buf[b:])
	b += 4

	v.OffsetY = Get32(buf[b:])
	b += 4

	v.Width = int32(Get32(buf[b:]))
	b += 4

	v.Height = int32(Get32(buf[b:]))
	b += 4

	v.Screen = int32(Get32(buf[b:]))
	b += 4

	v.Following = Get32(buf[b:])
	b += 4

	return b
}

// Struct list read XinputDeviceAbsAreaCtrl
func ReadXinputDeviceAbsAreaCtrlList(buf []byte, dest []XinputDeviceAbsAreaCtrl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputDeviceAbsAreaCtrl{}
		b += ReadXinputDeviceAbsAreaCtrl(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputDeviceAbsAreaCtrl
func (v XinputDeviceAbsAreaCtrl) Bytes() []byte {
	buf := make([]byte, 28)
	b := 0

	Put16(buf[b:], v.ControlId)
	b += 2

	Put16(buf[b:], v.Len)
	b += 2

	Put32(buf[b:], v.OffsetX)
	b += 4

	Put32(buf[b:], v.OffsetY)
	b += 4

	Put32(buf[b:], uint32(v.Width))
	b += 4

	Put32(buf[b:], uint32(v.Height))
	b += 4

	Put32(buf[b:], uint32(v.Screen))
	b += 4

	Put32(buf[b:], v.Following)
	b += 4

	return buf
}

// Write struct list XinputDeviceAbsAreaCtrl
func XinputDeviceAbsAreaCtrlListBytes(buf []byte, list []XinputDeviceAbsAreaCtrl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputDeviceCoreCtrl' struct definition
// Size: 8
type XinputDeviceCoreCtrl struct {
	ControlId uint16
	Len       uint16
	Status    byte
	// padding: 3 bytes
}

// Struct read XinputDeviceCoreCtrl
func ReadXinputDeviceCoreCtrl(buf []byte, v *XinputDeviceCoreCtrl) int {
	b := 0

	v.ControlId = Get16(buf[b:])
	b += 2

	v.Len = Get16(buf[b:])
	b += 2

	v.Status = buf[b]
	b += 1

	b += 3 // padding

	return b
}

// Struct list read XinputDeviceCoreCtrl
func ReadXinputDeviceCoreCtrlList(buf []byte, dest []XinputDeviceCoreCtrl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputDeviceCoreCtrl{}
		b += ReadXinputDeviceCoreCtrl(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputDeviceCoreCtrl
func (v XinputDeviceCoreCtrl) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	Put16(buf[b:], v.ControlId)
	b += 2

	Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.Status
	b += 1

	b += 3 // padding

	return buf
}

// Write struct list XinputDeviceCoreCtrl
func XinputDeviceCoreCtrlListBytes(buf []byte, list []XinputDeviceCoreCtrl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// 'XinputDeviceEnableCtrl' struct definition
// Size: 8
type XinputDeviceEnableCtrl struct {
	ControlId uint16
	Len       uint16
	Enable    byte
	// padding: 3 bytes
}

// Struct read XinputDeviceEnableCtrl
func ReadXinputDeviceEnableCtrl(buf []byte, v *XinputDeviceEnableCtrl) int {
	b := 0

	v.ControlId = Get16(buf[b:])
	b += 2

	v.Len = Get16(buf[b:])
	b += 2

	v.Enable = buf[b]
	b += 1

	b += 3 // padding

	return b
}

// Struct list read XinputDeviceEnableCtrl
func ReadXinputDeviceEnableCtrlList(buf []byte, dest []XinputDeviceEnableCtrl) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XinputDeviceEnableCtrl{}
		b += ReadXinputDeviceEnableCtrl(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XinputDeviceEnableCtrl
func (v XinputDeviceEnableCtrl) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	Put16(buf[b:], v.ControlId)
	b += 2

	Put16(buf[b:], v.Len)
	b += 2

	buf[b] = v.Enable
	b += 1

	b += 3 // padding

	return buf
}

// Write struct list XinputDeviceEnableCtrl
func XinputDeviceEnableCtrlListBytes(buf []byte, list []XinputDeviceEnableCtrl) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Event definition XinputDeviceValuator (0)
// Size: 32

const XinputDeviceValuator = 0

type XinputDeviceValuatorEvent struct {
	Sequence      uint16
	DeviceId      byte
	DeviceState   uint16
	NumValuators  byte
	FirstValuator byte
	Valuators     []int32 // size: 24
}

// Event read XinputDeviceValuator
func NewXinputDeviceValuatorEvent(buf []byte) Event {
	v := XinputDeviceValuatorEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = Get16(buf[b:])
	b += 2

	v.DeviceState = Get16(buf[b:])
	b += 2

	v.NumValuators = buf[b]
	b += 1

	v.FirstValuator = buf[b]
	b += 1

	v.Valuators = make([]int32, 6)
	for i := 0; i < int(6); i++ {
		v.Valuators[i] = int32(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

// Event write XinputDeviceValuator
func (v XinputDeviceValuatorEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 0
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	Put16(buf[b:], v.DeviceState)
	b += 2

	buf[b] = v.NumValuators
	b += 1

	buf[b] = v.FirstValuator
	b += 1

	for i := 0; i < int(6); i++ {
		Put32(buf[b:], uint32(v.Valuators[i]))
		b += 4
	}
	b = pad(b)

	return buf
}

func (v XinputDeviceValuatorEvent) ImplementsEvent() {}

func (v XinputDeviceValuatorEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XinputDeviceValuatorEvent) String() string {
	fieldVals := make([]string, 0, 5)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("DeviceId: %d", v.DeviceId))
	fieldVals = append(fieldVals, sprintf("DeviceState: %d", v.DeviceState))
	fieldVals = append(fieldVals, sprintf("NumValuators: %d", v.NumValuators))
	fieldVals = append(fieldVals, sprintf("FirstValuator: %d", v.FirstValuator))
	return "XinputDeviceValuator {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XInputExtension"][0] = NewXinputDeviceValuatorEvent
}

// Event definition XinputDeviceKeyPress (1)
// Size: 32

const XinputDeviceKeyPress = 1

type XinputDeviceKeyPressEvent struct {
	Sequence   uint16
	Detail     byte
	Time       Timestamp
	Root       Id
	Event      Id
	Child      Id
	RootX      int16
	RootY      int16
	EventX     int16
	EventY     int16
	State      uint16
	SameScreen bool
	DeviceId   byte
}

// Event read XinputDeviceKeyPress
func NewXinputDeviceKeyPressEvent(buf []byte) Event {
	v := XinputDeviceKeyPressEvent{}
	b := 1 // don't read event number

	v.Detail = buf[b]
	b += 1

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Time = Timestamp(Get32(buf[b:]))
	b += 4

	v.Root = Id(Get32(buf[b:]))
	b += 4

	v.Event = Id(Get32(buf[b:]))
	b += 4

	v.Child = Id(Get32(buf[b:]))
	b += 4

	v.RootX = int16(Get16(buf[b:]))
	b += 2

	v.RootY = int16(Get16(buf[b:]))
	b += 2

	v.EventX = int16(Get16(buf[b:]))
	b += 2

	v.EventY = int16(Get16(buf[b:]))
	b += 2

	v.State = Get16(buf[b:])
	b += 2

	if buf[b] == 1 {
		v.SameScreen = true
	} else {
		v.SameScreen = false
	}
	b += 1

	v.DeviceId = buf[b]
	b += 1

	return v
}

// Event write XinputDeviceKeyPress
func (v XinputDeviceKeyPressEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 1
	b += 1

	buf[b] = v.Detail
	b += 1

	b += 2 // skip sequence number

	Put32(buf[b:], uint32(v.Time))
	b += 4

	Put32(buf[b:], uint32(v.Root))
	b += 4

	Put32(buf[b:], uint32(v.Event))
	b += 4

	Put32(buf[b:], uint32(v.Child))
	b += 4

	Put16(buf[b:], uint16(v.RootX))
	b += 2

	Put16(buf[b:], uint16(v.RootY))
	b += 2

	Put16(buf[b:], uint16(v.EventX))
	b += 2

	Put16(buf[b:], uint16(v.EventY))
	b += 2

	Put16(buf[b:], v.State)
	b += 2

	if v.SameScreen {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	buf[b] = v.DeviceId
	b += 1

	return buf
}

func (v XinputDeviceKeyPressEvent) ImplementsEvent() {}

func (v XinputDeviceKeyPressEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XinputDeviceKeyPressEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, sprintf("DeviceId: %d", v.DeviceId))
	return "XinputDeviceKeyPress {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XInputExtension"][1] = NewXinputDeviceKeyPressEvent
}

// Event definition XinputFocusIn (6)
// Size: 32

const XinputFocusIn = 6

type XinputFocusInEvent struct {
	Sequence uint16
	Detail   byte
	Time     Timestamp
	Window   Id
	Mode     byte
	DeviceId byte
	// padding: 18 bytes
}

// Event read XinputFocusIn
func NewXinputFocusInEvent(buf []byte) Event {
	v := XinputFocusInEvent{}
	b := 1 // don't read event number

	v.Detail = buf[b]
	b += 1

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Time = Timestamp(Get32(buf[b:]))
	b += 4

	v.Window = Id(Get32(buf[b:]))
	b += 4

	v.Mode = buf[b]
	b += 1

	v.DeviceId = buf[b]
	b += 1

	b += 18 // padding

	return v
}

// Event write XinputFocusIn
func (v XinputFocusInEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 6
	b += 1

	buf[b] = v.Detail
	b += 1

	b += 2 // skip sequence number

	Put32(buf[b:], uint32(v.Time))
	b += 4

	Put32(buf[b:], uint32(v.Window))
	b += 4

	buf[b] = v.Mode
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 18 // padding

	return buf
}

func (v XinputFocusInEvent) ImplementsEvent() {}

func (v XinputFocusInEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XinputFocusInEvent) String() string {
	fieldVals := make([]string, 0, 6)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, sprintf("Mode: %d", v.Mode))
	fieldVals = append(fieldVals, sprintf("DeviceId: %d", v.DeviceId))
	return "XinputFocusIn {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XInputExtension"][6] = NewXinputFocusInEvent
}

// Event definition XinputDeviceStateNotify (10)
// Size: 32

const XinputDeviceStateNotify = 10

type XinputDeviceStateNotifyEvent struct {
	Sequence        uint16
	DeviceId        byte
	Time            Timestamp
	NumKeys         byte
	NumButtons      byte
	NumValuators    byte
	ClassesReported byte
	Buttons         []byte   // size: 4
	Keys            []byte   // size: 4
	Valuators       []uint32 // size: 12
}

// Event read XinputDeviceStateNotify
func NewXinputDeviceStateNotifyEvent(buf []byte) Event {
	v := XinputDeviceStateNotifyEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Time = Timestamp(Get32(buf[b:]))
	b += 4

	v.NumKeys = buf[b]
	b += 1

	v.NumButtons = buf[b]
	b += 1

	v.NumValuators = buf[b]
	b += 1

	v.ClassesReported = buf[b]
	b += 1

	v.Buttons = make([]byte, 4)
	copy(v.Buttons[:4], buf[b:])
	b += pad(int(4))

	v.Keys = make([]byte, 4)
	copy(v.Keys[:4], buf[b:])
	b += pad(int(4))

	v.Valuators = make([]uint32, 3)
	for i := 0; i < int(3); i++ {
		v.Valuators[i] = Get32(buf[b:])
		b += 4
	}
	b = pad(b)

	return v
}

// Event write XinputDeviceStateNotify
func (v XinputDeviceStateNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 10
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.NumKeys
	b += 1

	buf[b] = v.NumButtons
	b += 1

	buf[b] = v.NumValuators
	b += 1

	buf[b] = v.ClassesReported
	b += 1

	copy(buf[b:], v.Buttons[:4])
	b += pad(int(4))

	copy(buf[b:], v.Keys[:4])
	b += pad(int(4))

	for i := 0; i < int(3); i++ {
		Put32(buf[b:], v.Valuators[i])
		b += 4
	}
	b = pad(b)

	return buf
}

func (v XinputDeviceStateNotifyEvent) ImplementsEvent() {}

func (v XinputDeviceStateNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XinputDeviceStateNotifyEvent) String() string {
	fieldVals := make([]string, 0, 9)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("DeviceId: %d", v.DeviceId))
	fieldVals = append(fieldVals, sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, sprintf("NumKeys: %d", v.NumKeys))
	fieldVals = append(fieldVals, sprintf("NumButtons: %d", v.NumButtons))
	fieldVals = append(fieldVals, sprintf("NumValuators: %d", v.NumValuators))
	fieldVals = append(fieldVals, sprintf("ClassesReported: %d", v.ClassesReported))
	return "XinputDeviceStateNotify {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XInputExtension"][10] = NewXinputDeviceStateNotifyEvent
}

// Event definition XinputDeviceMappingNotify (11)
// Size: 32

const XinputDeviceMappingNotify = 11

type XinputDeviceMappingNotifyEvent struct {
	Sequence     uint16
	DeviceId     byte
	Request      byte
	FirstKeycode XinputKeyCode
	Count        byte
	// padding: 1 bytes
	Time Timestamp
	// padding: 20 bytes
}

// Event read XinputDeviceMappingNotify
func NewXinputDeviceMappingNotifyEvent(buf []byte) Event {
	v := XinputDeviceMappingNotifyEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Request = buf[b]
	b += 1

	v.FirstKeycode = XinputKeyCode(buf[b])
	b += 1

	v.Count = buf[b]
	b += 1

	b += 1 // padding

	v.Time = Timestamp(Get32(buf[b:]))
	b += 4

	b += 20 // padding

	return v
}

// Event write XinputDeviceMappingNotify
func (v XinputDeviceMappingNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 11
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	buf[b] = v.Request
	b += 1

	buf[b] = byte(v.FirstKeycode)
	b += 1

	buf[b] = v.Count
	b += 1

	b += 1 // padding

	Put32(buf[b:], uint32(v.Time))
	b += 4

	b += 20 // padding

	return buf
}

func (v XinputDeviceMappingNotifyEvent) ImplementsEvent() {}

func (v XinputDeviceMappingNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XinputDeviceMappingNotifyEvent) String() string {
	fieldVals := make([]string, 0, 7)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("DeviceId: %d", v.DeviceId))
	fieldVals = append(fieldVals, sprintf("Request: %d", v.Request))
	fieldVals = append(fieldVals, sprintf("FirstKeycode: %d", v.FirstKeycode))
	fieldVals = append(fieldVals, sprintf("Count: %d", v.Count))
	fieldVals = append(fieldVals, sprintf("Time: %d", v.Time))
	return "XinputDeviceMappingNotify {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XInputExtension"][11] = NewXinputDeviceMappingNotifyEvent
}

// Event definition XinputChangeDeviceNotify (12)
// Size: 32

const XinputChangeDeviceNotify = 12

type XinputChangeDeviceNotifyEvent struct {
	Sequence uint16
	DeviceId byte
	Time     Timestamp
	Request  byte
	// padding: 23 bytes
}

// Event read XinputChangeDeviceNotify
func NewXinputChangeDeviceNotifyEvent(buf []byte) Event {
	v := XinputChangeDeviceNotifyEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Time = Timestamp(Get32(buf[b:]))
	b += 4

	v.Request = buf[b]
	b += 1

	b += 23 // padding

	return v
}

// Event write XinputChangeDeviceNotify
func (v XinputChangeDeviceNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 12
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.Request
	b += 1

	b += 23 // padding

	return buf
}

func (v XinputChangeDeviceNotifyEvent) ImplementsEvent() {}

func (v XinputChangeDeviceNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XinputChangeDeviceNotifyEvent) String() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("DeviceId: %d", v.DeviceId))
	fieldVals = append(fieldVals, sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, sprintf("Request: %d", v.Request))
	return "XinputChangeDeviceNotify {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XInputExtension"][12] = NewXinputChangeDeviceNotifyEvent
}

// Event definition XinputDeviceKeyStateNotify (13)
// Size: 32

const XinputDeviceKeyStateNotify = 13

type XinputDeviceKeyStateNotifyEvent struct {
	Sequence uint16
	DeviceId byte
	Keys     []byte // size: 28
}

// Event read XinputDeviceKeyStateNotify
func NewXinputDeviceKeyStateNotifyEvent(buf []byte) Event {
	v := XinputDeviceKeyStateNotifyEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Keys = make([]byte, 28)
	copy(v.Keys[:28], buf[b:])
	b += pad(int(28))

	return v
}

// Event write XinputDeviceKeyStateNotify
func (v XinputDeviceKeyStateNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 13
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	copy(buf[b:], v.Keys[:28])
	b += pad(int(28))

	return buf
}

func (v XinputDeviceKeyStateNotifyEvent) ImplementsEvent() {}

func (v XinputDeviceKeyStateNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XinputDeviceKeyStateNotifyEvent) String() string {
	fieldVals := make([]string, 0, 2)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("DeviceId: %d", v.DeviceId))
	return "XinputDeviceKeyStateNotify {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XInputExtension"][13] = NewXinputDeviceKeyStateNotifyEvent
}

// Event definition XinputDeviceButtonStateNotify (14)
// Size: 32

const XinputDeviceButtonStateNotify = 14

type XinputDeviceButtonStateNotifyEvent struct {
	Sequence uint16
	DeviceId byte
	Buttons  []byte // size: 28
}

// Event read XinputDeviceButtonStateNotify
func NewXinputDeviceButtonStateNotifyEvent(buf []byte) Event {
	v := XinputDeviceButtonStateNotifyEvent{}
	b := 1 // don't read event number

	v.DeviceId = buf[b]
	b += 1

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Buttons = make([]byte, 28)
	copy(v.Buttons[:28], buf[b:])
	b += pad(int(28))

	return v
}

// Event write XinputDeviceButtonStateNotify
func (v XinputDeviceButtonStateNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 14
	b += 1

	buf[b] = v.DeviceId
	b += 1

	b += 2 // skip sequence number

	copy(buf[b:], v.Buttons[:28])
	b += pad(int(28))

	return buf
}

func (v XinputDeviceButtonStateNotifyEvent) ImplementsEvent() {}

func (v XinputDeviceButtonStateNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XinputDeviceButtonStateNotifyEvent) String() string {
	fieldVals := make([]string, 0, 2)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("DeviceId: %d", v.DeviceId))
	return "XinputDeviceButtonStateNotify {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XInputExtension"][14] = NewXinputDeviceButtonStateNotifyEvent
}

// Event definition XinputDevicePresenceNotify (15)
// Size: 32

const XinputDevicePresenceNotify = 15

type XinputDevicePresenceNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Time      Timestamp
	Devchange byte
	DeviceId  byte
	Control   uint16
	// padding: 20 bytes
}

// Event read XinputDevicePresenceNotify
func NewXinputDevicePresenceNotifyEvent(buf []byte) Event {
	v := XinputDevicePresenceNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Time = Timestamp(Get32(buf[b:]))
	b += 4

	v.Devchange = buf[b]
	b += 1

	v.DeviceId = buf[b]
	b += 1

	v.Control = Get16(buf[b:])
	b += 2

	b += 20 // padding

	return v
}

// Event write XinputDevicePresenceNotify
func (v XinputDevicePresenceNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 15
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.Devchange
	b += 1

	buf[b] = v.DeviceId
	b += 1

	Put16(buf[b:], v.Control)
	b += 2

	b += 20 // padding

	return buf
}

func (v XinputDevicePresenceNotifyEvent) ImplementsEvent() {}

func (v XinputDevicePresenceNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XinputDevicePresenceNotifyEvent) String() string {
	fieldVals := make([]string, 0, 6)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, sprintf("Devchange: %d", v.Devchange))
	fieldVals = append(fieldVals, sprintf("DeviceId: %d", v.DeviceId))
	fieldVals = append(fieldVals, sprintf("Control: %d", v.Control))
	return "XinputDevicePresenceNotify {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XInputExtension"][15] = NewXinputDevicePresenceNotifyEvent
}

// EventCopy definition XinputDeviceKeyRelease (2)

const XinputDeviceKeyRelease = 2

type XinputDeviceKeyReleaseEvent XinputDeviceKeyPressEvent

func NewXinputDeviceKeyReleaseEvent(buf []byte) Event {
	return XinputDeviceKeyReleaseEvent(NewXinputDeviceKeyPressEvent(buf).(XinputDeviceKeyPressEvent))
}

func (v XinputDeviceKeyReleaseEvent) Bytes() []byte {
	return XinputDeviceKeyPressEvent(v).Bytes()
}

func (v XinputDeviceKeyReleaseEvent) ImplementsEvent() {}

func (v XinputDeviceKeyReleaseEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XinputDeviceKeyReleaseEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, sprintf("DeviceId: %d", v.DeviceId))
	return "XinputDeviceKeyRelease {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XInputExtension"][2] = NewXinputDeviceKeyReleaseEvent
}

// EventCopy definition XinputDeviceButtonPress (3)

const XinputDeviceButtonPress = 3

type XinputDeviceButtonPressEvent XinputDeviceKeyPressEvent

func NewXinputDeviceButtonPressEvent(buf []byte) Event {
	return XinputDeviceButtonPressEvent(NewXinputDeviceKeyPressEvent(buf).(XinputDeviceKeyPressEvent))
}

func (v XinputDeviceButtonPressEvent) Bytes() []byte {
	return XinputDeviceKeyPressEvent(v).Bytes()
}

func (v XinputDeviceButtonPressEvent) ImplementsEvent() {}

func (v XinputDeviceButtonPressEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XinputDeviceButtonPressEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, sprintf("DeviceId: %d", v.DeviceId))
	return "XinputDeviceButtonPress {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XInputExtension"][3] = NewXinputDeviceButtonPressEvent
}

// EventCopy definition XinputDeviceButtonRelease (4)

const XinputDeviceButtonRelease = 4

type XinputDeviceButtonReleaseEvent XinputDeviceKeyPressEvent

func NewXinputDeviceButtonReleaseEvent(buf []byte) Event {
	return XinputDeviceButtonReleaseEvent(NewXinputDeviceKeyPressEvent(buf).(XinputDeviceKeyPressEvent))
}

func (v XinputDeviceButtonReleaseEvent) Bytes() []byte {
	return XinputDeviceKeyPressEvent(v).Bytes()
}

func (v XinputDeviceButtonReleaseEvent) ImplementsEvent() {}

func (v XinputDeviceButtonReleaseEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XinputDeviceButtonReleaseEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, sprintf("DeviceId: %d", v.DeviceId))
	return "XinputDeviceButtonRelease {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XInputExtension"][4] = NewXinputDeviceButtonReleaseEvent
}

// EventCopy definition XinputDeviceMotionNotify (5)

const XinputDeviceMotionNotify = 5

type XinputDeviceMotionNotifyEvent XinputDeviceKeyPressEvent

func NewXinputDeviceMotionNotifyEvent(buf []byte) Event {
	return XinputDeviceMotionNotifyEvent(NewXinputDeviceKeyPressEvent(buf).(XinputDeviceKeyPressEvent))
}

func (v XinputDeviceMotionNotifyEvent) Bytes() []byte {
	return XinputDeviceKeyPressEvent(v).Bytes()
}

func (v XinputDeviceMotionNotifyEvent) ImplementsEvent() {}

func (v XinputDeviceMotionNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XinputDeviceMotionNotifyEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, sprintf("DeviceId: %d", v.DeviceId))
	return "XinputDeviceMotionNotify {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XInputExtension"][5] = NewXinputDeviceMotionNotifyEvent
}

// EventCopy definition XinputProximityIn (8)

const XinputProximityIn = 8

type XinputProximityInEvent XinputDeviceKeyPressEvent

func NewXinputProximityInEvent(buf []byte) Event {
	return XinputProximityInEvent(NewXinputDeviceKeyPressEvent(buf).(XinputDeviceKeyPressEvent))
}

func (v XinputProximityInEvent) Bytes() []byte {
	return XinputDeviceKeyPressEvent(v).Bytes()
}

func (v XinputProximityInEvent) ImplementsEvent() {}

func (v XinputProximityInEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XinputProximityInEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, sprintf("DeviceId: %d", v.DeviceId))
	return "XinputProximityIn {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XInputExtension"][8] = NewXinputProximityInEvent
}

// EventCopy definition XinputProximityOut (9)

const XinputProximityOut = 9

type XinputProximityOutEvent XinputDeviceKeyPressEvent

func NewXinputProximityOutEvent(buf []byte) Event {
	return XinputProximityOutEvent(NewXinputDeviceKeyPressEvent(buf).(XinputDeviceKeyPressEvent))
}

func (v XinputProximityOutEvent) Bytes() []byte {
	return XinputDeviceKeyPressEvent(v).Bytes()
}

func (v XinputProximityOutEvent) ImplementsEvent() {}

func (v XinputProximityOutEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XinputProximityOutEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, sprintf("SameScreen: %t", v.SameScreen))
	fieldVals = append(fieldVals, sprintf("DeviceId: %d", v.DeviceId))
	return "XinputProximityOut {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XInputExtension"][9] = NewXinputProximityOutEvent
}

// EventCopy definition XinputFocusOut (7)

const XinputFocusOut = 7

type XinputFocusOutEvent XinputFocusInEvent

func NewXinputFocusOutEvent(buf []byte) Event {
	return XinputFocusOutEvent(NewXinputFocusInEvent(buf).(XinputFocusInEvent))
}

func (v XinputFocusOutEvent) Bytes() []byte {
	return XinputFocusInEvent(v).Bytes()
}

func (v XinputFocusOutEvent) ImplementsEvent() {}

func (v XinputFocusOutEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v XinputFocusOutEvent) String() string {
	fieldVals := make([]string, 0, 6)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, sprintf("Mode: %d", v.Mode))
	fieldVals = append(fieldVals, sprintf("DeviceId: %d", v.DeviceId))
	return "XinputFocusOut {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtEventFuncs["XInputExtension"][7] = NewXinputFocusOutEvent
}

// Error definition XinputDevice (0)
// Size: 32

const BadXinputDevice = 0

type XinputDeviceError struct {
	Sequence uint16
	NiceName string
}

// Error read XinputDevice
func NewXinputDeviceError(buf []byte) Error {
	v := XinputDeviceError{}
	v.NiceName = "XinputDevice"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = Get16(buf[b:])
	b += 2

	return v
}

func (err XinputDeviceError) ImplementsError() {}

func (err XinputDeviceError) SequenceId() uint16 {
	return err.Sequence
}

func (err XinputDeviceError) BadId() Id {
	return 0
}

func (err XinputDeviceError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	return "BadXinputDevice {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["XInputExtension"][0] = NewXinputDeviceError
}

// Error definition XinputEvent (1)
// Size: 32

const BadXinputEvent = 1

type XinputEventError struct {
	Sequence uint16
	NiceName string
}

// Error read XinputEvent
func NewXinputEventError(buf []byte) Error {
	v := XinputEventError{}
	v.NiceName = "XinputEvent"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = Get16(buf[b:])
	b += 2

	return v
}

func (err XinputEventError) ImplementsError() {}

func (err XinputEventError) SequenceId() uint16 {
	return err.Sequence
}

func (err XinputEventError) BadId() Id {
	return 0
}

func (err XinputEventError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	return "BadXinputEvent {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["XInputExtension"][1] = NewXinputEventError
}

// Error definition XinputMode (2)
// Size: 32

const BadXinputMode = 2

type XinputModeError struct {
	Sequence uint16
	NiceName string
}

// Error read XinputMode
func NewXinputModeError(buf []byte) Error {
	v := XinputModeError{}
	v.NiceName = "XinputMode"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = Get16(buf[b:])
	b += 2

	return v
}

func (err XinputModeError) ImplementsError() {}

func (err XinputModeError) SequenceId() uint16 {
	return err.Sequence
}

func (err XinputModeError) BadId() Id {
	return 0
}

func (err XinputModeError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	return "BadXinputMode {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["XInputExtension"][2] = NewXinputModeError
}

// Error definition XinputDeviceBusy (3)
// Size: 32

const BadXinputDeviceBusy = 3

type XinputDeviceBusyError struct {
	Sequence uint16
	NiceName string
}

// Error read XinputDeviceBusy
func NewXinputDeviceBusyError(buf []byte) Error {
	v := XinputDeviceBusyError{}
	v.NiceName = "XinputDeviceBusy"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = Get16(buf[b:])
	b += 2

	return v
}

func (err XinputDeviceBusyError) ImplementsError() {}

func (err XinputDeviceBusyError) SequenceId() uint16 {
	return err.Sequence
}

func (err XinputDeviceBusyError) BadId() Id {
	return 0
}

func (err XinputDeviceBusyError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	return "BadXinputDeviceBusy {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["XInputExtension"][3] = NewXinputDeviceBusyError
}

// Error definition XinputClass (4)
// Size: 32

const BadXinputClass = 4

type XinputClassError struct {
	Sequence uint16
	NiceName string
}

// Error read XinputClass
func NewXinputClassError(buf []byte) Error {
	v := XinputClassError{}
	v.NiceName = "XinputClass"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = Get16(buf[b:])
	b += 2

	return v
}

func (err XinputClassError) ImplementsError() {}

func (err XinputClassError) SequenceId() uint16 {
	return err.Sequence
}

func (err XinputClassError) BadId() Id {
	return 0
}

func (err XinputClassError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, sprintf("Sequence: %d", err.Sequence))
	return "BadXinputClass {" + stringsJoin(fieldVals, ", ") + "}"
}

func init() {
	newExtErrorFuncs["XInputExtension"][4] = NewXinputClassError
}

// Request XinputGetExtensionVersion
// size: pad((8 + pad((int(NameLen) * 1))))
type XinputGetExtensionVersionCookie struct {
	*cookie
}

func (c *Conn) XinputGetExtensionVersion(NameLen uint16, Name string) XinputGetExtensionVersionCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputGetExtensionVersionRequest(NameLen, Name), cookie)
	return XinputGetExtensionVersionCookie{cookie}
}

func (c *Conn) XinputGetExtensionVersionUnchecked(NameLen uint16, Name string) XinputGetExtensionVersionCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputGetExtensionVersionRequest(NameLen, Name), cookie)
	return XinputGetExtensionVersionCookie{cookie}
}

// Request reply for XinputGetExtensionVersion
// size: 32
type XinputGetExtensionVersionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ServerMajor uint16
	ServerMinor uint16
	Present     bool
	// padding: 19 bytes
}

// Waits and reads reply data from request XinputGetExtensionVersion
func (cook XinputGetExtensionVersionCookie) Reply() (*XinputGetExtensionVersionReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputGetExtensionVersionReply(buf), nil
}

// Read reply into structure from buffer for XinputGetExtensionVersion
func xinputGetExtensionVersionReply(buf []byte) *XinputGetExtensionVersionReply {
	v := new(XinputGetExtensionVersionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ServerMajor = Get16(buf[b:])
	b += 2

	v.ServerMinor = Get16(buf[b:])
	b += 2

	if buf[b] == 1 {
		v.Present = true
	} else {
		v.Present = false
	}
	b += 1

	b += 19 // padding

	return v
}

func (cook XinputGetExtensionVersionCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputGetExtensionVersion
func (c *Conn) xinputGetExtensionVersionRequest(NameLen uint16, Name string) []byte {
	size := pad((8 + pad((int(NameLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put16(buf[b:], NameLen)
	b += 2

	b += 2 // padding

	copy(buf[b:], Name[:NameLen])
	b += pad(int(NameLen))

	return buf
}

// Request XinputListInputDevices
// size: 4
type XinputListInputDevicesCookie struct {
	*cookie
}

func (c *Conn) XinputListInputDevices() XinputListInputDevicesCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputListInputDevicesRequest(), cookie)
	return XinputListInputDevicesCookie{cookie}
}

func (c *Conn) XinputListInputDevicesUnchecked() XinputListInputDevicesCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputListInputDevicesRequest(), cookie)
	return XinputListInputDevicesCookie{cookie}
}

// Request reply for XinputListInputDevices
// size: (32 + pad((int(DevicesLen) * 8)))
type XinputListInputDevicesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	DevicesLen byte
	// padding: 23 bytes
	Devices []XinputDeviceInfo // size: pad((int(DevicesLen) * 8))
}

// Waits and reads reply data from request XinputListInputDevices
func (cook XinputListInputDevicesCookie) Reply() (*XinputListInputDevicesReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputListInputDevicesReply(buf), nil
}

// Read reply into structure from buffer for XinputListInputDevices
func xinputListInputDevicesReply(buf []byte) *XinputListInputDevicesReply {
	v := new(XinputListInputDevicesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.DevicesLen = buf[b]
	b += 1

	b += 23 // padding

	v.Devices = make([]XinputDeviceInfo, v.DevicesLen)
	b += ReadXinputDeviceInfoList(buf[b:], v.Devices)

	return v
}

func (cook XinputListInputDevicesCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputListInputDevices
func (c *Conn) xinputListInputDevicesRequest() []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request XinputOpenDevice
// size: 8
type XinputOpenDeviceCookie struct {
	*cookie
}

func (c *Conn) XinputOpenDevice(DeviceId byte) XinputOpenDeviceCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputOpenDeviceRequest(DeviceId), cookie)
	return XinputOpenDeviceCookie{cookie}
}

func (c *Conn) XinputOpenDeviceUnchecked(DeviceId byte) XinputOpenDeviceCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputOpenDeviceRequest(DeviceId), cookie)
	return XinputOpenDeviceCookie{cookie}
}

// Request reply for XinputOpenDevice
// size: (32 + pad((int(NumClasses) * 2)))
type XinputOpenDeviceReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumClasses byte
	// padding: 23 bytes
	ClassInfo []XinputInputClassInfo // size: pad((int(NumClasses) * 2))
}

// Waits and reads reply data from request XinputOpenDevice
func (cook XinputOpenDeviceCookie) Reply() (*XinputOpenDeviceReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputOpenDeviceReply(buf), nil
}

// Read reply into structure from buffer for XinputOpenDevice
func xinputOpenDeviceReply(buf []byte) *XinputOpenDeviceReply {
	v := new(XinputOpenDeviceReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumClasses = buf[b]
	b += 1

	b += 23 // padding

	v.ClassInfo = make([]XinputInputClassInfo, v.NumClasses)
	b += ReadXinputInputClassInfoList(buf[b:], v.ClassInfo)

	return v
}

func (cook XinputOpenDeviceCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputOpenDevice
func (c *Conn) xinputOpenDeviceRequest(DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// Request XinputCloseDevice
// size: 8
type XinputCloseDeviceCookie struct {
	*cookie
}

// Write request to wire for XinputCloseDevice
func (c *Conn) XinputCloseDevice(DeviceId byte) XinputCloseDeviceCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xinputCloseDeviceRequest(DeviceId), cookie)
	return XinputCloseDeviceCookie{cookie}
}

func (c *Conn) XinputCloseDeviceChecked(DeviceId byte) XinputCloseDeviceCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xinputCloseDeviceRequest(DeviceId), cookie)
	return XinputCloseDeviceCookie{cookie}
}

func (cook XinputCloseDeviceCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputCloseDevice
func (c *Conn) xinputCloseDeviceRequest(DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// Request XinputSetDeviceMode
// size: 8
type XinputSetDeviceModeCookie struct {
	*cookie
}

func (c *Conn) XinputSetDeviceMode(DeviceId byte, Mode byte) XinputSetDeviceModeCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputSetDeviceModeRequest(DeviceId, Mode), cookie)
	return XinputSetDeviceModeCookie{cookie}
}

func (c *Conn) XinputSetDeviceModeUnchecked(DeviceId byte, Mode byte) XinputSetDeviceModeCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputSetDeviceModeRequest(DeviceId, Mode), cookie)
	return XinputSetDeviceModeCookie{cookie}
}

// Request reply for XinputSetDeviceMode
// size: 32
type XinputSetDeviceModeReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Waits and reads reply data from request XinputSetDeviceMode
func (cook XinputSetDeviceModeCookie) Reply() (*XinputSetDeviceModeReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputSetDeviceModeReply(buf), nil
}

// Read reply into structure from buffer for XinputSetDeviceMode
func xinputSetDeviceModeReply(buf []byte) *XinputSetDeviceModeReply {
	v := new(XinputSetDeviceModeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

func (cook XinputSetDeviceModeCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputSetDeviceMode
func (c *Conn) xinputSetDeviceModeRequest(DeviceId byte, Mode byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = Mode
	b += 1

	b += 2 // padding

	return buf
}

// Request XinputSelectExtensionEvent
// size: pad((12 + pad((int(NumClasses) * 4))))
type XinputSelectExtensionEventCookie struct {
	*cookie
}

// Write request to wire for XinputSelectExtensionEvent
func (c *Conn) XinputSelectExtensionEvent(Window Id, NumClasses uint16, Classes []XinputEventClass) XinputSelectExtensionEventCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xinputSelectExtensionEventRequest(Window, NumClasses, Classes), cookie)
	return XinputSelectExtensionEventCookie{cookie}
}

func (c *Conn) XinputSelectExtensionEventChecked(Window Id, NumClasses uint16, Classes []XinputEventClass) XinputSelectExtensionEventCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xinputSelectExtensionEventRequest(Window, NumClasses, Classes), cookie)
	return XinputSelectExtensionEventCookie{cookie}
}

func (cook XinputSelectExtensionEventCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputSelectExtensionEvent
func (c *Conn) xinputSelectExtensionEventRequest(Window Id, NumClasses uint16, Classes []XinputEventClass) []byte {
	size := pad((12 + pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Window))
	b += 4

	Put16(buf[b:], NumClasses)
	b += 2

	b += 2 // padding

	for i := 0; i < int(NumClasses); i++ {
		Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = pad(b)

	return buf
}

// Request XinputGetSelectedExtensionEvents
// size: 8
type XinputGetSelectedExtensionEventsCookie struct {
	*cookie
}

func (c *Conn) XinputGetSelectedExtensionEvents(Window Id) XinputGetSelectedExtensionEventsCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputGetSelectedExtensionEventsRequest(Window), cookie)
	return XinputGetSelectedExtensionEventsCookie{cookie}
}

func (c *Conn) XinputGetSelectedExtensionEventsUnchecked(Window Id) XinputGetSelectedExtensionEventsCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputGetSelectedExtensionEventsRequest(Window), cookie)
	return XinputGetSelectedExtensionEventsCookie{cookie}
}

// Request reply for XinputGetSelectedExtensionEvents
// size: ((32 + pad((int(NumThisClasses) * 4))) + pad((int(NumAllClasses) * 4)))
type XinputGetSelectedExtensionEventsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumThisClasses uint16
	NumAllClasses  uint16
	// padding: 20 bytes
	ThisClasses []XinputEventClass // size: pad((int(NumThisClasses) * 4))
	AllClasses  []XinputEventClass // size: pad((int(NumAllClasses) * 4))
}

// Waits and reads reply data from request XinputGetSelectedExtensionEvents
func (cook XinputGetSelectedExtensionEventsCookie) Reply() (*XinputGetSelectedExtensionEventsReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputGetSelectedExtensionEventsReply(buf), nil
}

// Read reply into structure from buffer for XinputGetSelectedExtensionEvents
func xinputGetSelectedExtensionEventsReply(buf []byte) *XinputGetSelectedExtensionEventsReply {
	v := new(XinputGetSelectedExtensionEventsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumThisClasses = Get16(buf[b:])
	b += 2

	v.NumAllClasses = Get16(buf[b:])
	b += 2

	b += 20 // padding

	v.ThisClasses = make([]XinputEventClass, v.NumThisClasses)
	for i := 0; i < int(v.NumThisClasses); i++ {
		v.ThisClasses[i] = XinputEventClass(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	v.AllClasses = make([]XinputEventClass, v.NumAllClasses)
	for i := 0; i < int(v.NumAllClasses); i++ {
		v.AllClasses[i] = XinputEventClass(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook XinputGetSelectedExtensionEventsCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputGetSelectedExtensionEvents
func (c *Conn) xinputGetSelectedExtensionEventsRequest(Window Id) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request XinputChangeDeviceDontPropagateList
// size: pad((12 + pad((int(NumClasses) * 4))))
type XinputChangeDeviceDontPropagateListCookie struct {
	*cookie
}

// Write request to wire for XinputChangeDeviceDontPropagateList
func (c *Conn) XinputChangeDeviceDontPropagateList(Window Id, NumClasses uint16, Mode byte, Classes []XinputEventClass) XinputChangeDeviceDontPropagateListCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xinputChangeDeviceDontPropagateListRequest(Window, NumClasses, Mode, Classes), cookie)
	return XinputChangeDeviceDontPropagateListCookie{cookie}
}

func (c *Conn) XinputChangeDeviceDontPropagateListChecked(Window Id, NumClasses uint16, Mode byte, Classes []XinputEventClass) XinputChangeDeviceDontPropagateListCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xinputChangeDeviceDontPropagateListRequest(Window, NumClasses, Mode, Classes), cookie)
	return XinputChangeDeviceDontPropagateListCookie{cookie}
}

func (cook XinputChangeDeviceDontPropagateListCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputChangeDeviceDontPropagateList
func (c *Conn) xinputChangeDeviceDontPropagateListRequest(Window Id, NumClasses uint16, Mode byte, Classes []XinputEventClass) []byte {
	size := pad((12 + pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 8 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Window))
	b += 4

	Put16(buf[b:], NumClasses)
	b += 2

	buf[b] = Mode
	b += 1

	b += 1 // padding

	for i := 0; i < int(NumClasses); i++ {
		Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = pad(b)

	return buf
}

// Request XinputGetDeviceDontPropagateList
// size: 8
type XinputGetDeviceDontPropagateListCookie struct {
	*cookie
}

func (c *Conn) XinputGetDeviceDontPropagateList(Window Id) XinputGetDeviceDontPropagateListCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputGetDeviceDontPropagateListRequest(Window), cookie)
	return XinputGetDeviceDontPropagateListCookie{cookie}
}

func (c *Conn) XinputGetDeviceDontPropagateListUnchecked(Window Id) XinputGetDeviceDontPropagateListCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputGetDeviceDontPropagateListRequest(Window), cookie)
	return XinputGetDeviceDontPropagateListCookie{cookie}
}

// Request reply for XinputGetDeviceDontPropagateList
// size: (32 + pad((int(NumClasses) * 4)))
type XinputGetDeviceDontPropagateListReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumClasses uint16
	// padding: 22 bytes
	Classes []XinputEventClass // size: pad((int(NumClasses) * 4))
}

// Waits and reads reply data from request XinputGetDeviceDontPropagateList
func (cook XinputGetDeviceDontPropagateListCookie) Reply() (*XinputGetDeviceDontPropagateListReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputGetDeviceDontPropagateListReply(buf), nil
}

// Read reply into structure from buffer for XinputGetDeviceDontPropagateList
func xinputGetDeviceDontPropagateListReply(buf []byte) *XinputGetDeviceDontPropagateListReply {
	v := new(XinputGetDeviceDontPropagateListReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumClasses = Get16(buf[b:])
	b += 2

	b += 22 // padding

	v.Classes = make([]XinputEventClass, v.NumClasses)
	for i := 0; i < int(v.NumClasses); i++ {
		v.Classes[i] = XinputEventClass(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook XinputGetDeviceDontPropagateListCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputGetDeviceDontPropagateList
func (c *Conn) xinputGetDeviceDontPropagateListRequest(Window Id) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 9 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request XinputGetDeviceMotionEvents
// size: 16
type XinputGetDeviceMotionEventsCookie struct {
	*cookie
}

func (c *Conn) XinputGetDeviceMotionEvents(Start Timestamp, Stop Timestamp, DeviceId byte) XinputGetDeviceMotionEventsCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputGetDeviceMotionEventsRequest(Start, Stop, DeviceId), cookie)
	return XinputGetDeviceMotionEventsCookie{cookie}
}

func (c *Conn) XinputGetDeviceMotionEventsUnchecked(Start Timestamp, Stop Timestamp, DeviceId byte) XinputGetDeviceMotionEventsCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputGetDeviceMotionEventsRequest(Start, Stop, DeviceId), cookie)
	return XinputGetDeviceMotionEventsCookie{cookie}
}

// Request reply for XinputGetDeviceMotionEvents
// size: 32
type XinputGetDeviceMotionEventsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumCoords  uint32
	NumAxes    byte
	DeviceMode byte
	// padding: 18 bytes
}

// Waits and reads reply data from request XinputGetDeviceMotionEvents
func (cook XinputGetDeviceMotionEventsCookie) Reply() (*XinputGetDeviceMotionEventsReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputGetDeviceMotionEventsReply(buf), nil
}

// Read reply into structure from buffer for XinputGetDeviceMotionEvents
func xinputGetDeviceMotionEventsReply(buf []byte) *XinputGetDeviceMotionEventsReply {
	v := new(XinputGetDeviceMotionEventsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumCoords = Get32(buf[b:])
	b += 4

	v.NumAxes = buf[b]
	b += 1

	v.DeviceMode = buf[b]
	b += 1

	b += 18 // padding

	return v
}

func (cook XinputGetDeviceMotionEventsCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputGetDeviceMotionEvents
func (c *Conn) xinputGetDeviceMotionEventsRequest(Start Timestamp, Stop Timestamp, DeviceId byte) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 10 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Start))
	b += 4

	Put32(buf[b:], uint32(Stop))
	b += 4

	buf[b] = DeviceId
	b += 1

	return buf
}

// Request XinputChangeKeyboardDevice
// size: 8
type XinputChangeKeyboardDeviceCookie struct {
	*cookie
}

func (c *Conn) XinputChangeKeyboardDevice(DeviceId byte) XinputChangeKeyboardDeviceCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputChangeKeyboardDeviceRequest(DeviceId), cookie)
	return XinputChangeKeyboardDeviceCookie{cookie}
}

func (c *Conn) XinputChangeKeyboardDeviceUnchecked(DeviceId byte) XinputChangeKeyboardDeviceCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputChangeKeyboardDeviceRequest(DeviceId), cookie)
	return XinputChangeKeyboardDeviceCookie{cookie}
}

// Request reply for XinputChangeKeyboardDevice
// size: 32
type XinputChangeKeyboardDeviceReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Waits and reads reply data from request XinputChangeKeyboardDevice
func (cook XinputChangeKeyboardDeviceCookie) Reply() (*XinputChangeKeyboardDeviceReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputChangeKeyboardDeviceReply(buf), nil
}

// Read reply into structure from buffer for XinputChangeKeyboardDevice
func xinputChangeKeyboardDeviceReply(buf []byte) *XinputChangeKeyboardDeviceReply {
	v := new(XinputChangeKeyboardDeviceReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

func (cook XinputChangeKeyboardDeviceCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputChangeKeyboardDevice
func (c *Conn) xinputChangeKeyboardDeviceRequest(DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 11 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// Request XinputChangePointerDevice
// size: 8
type XinputChangePointerDeviceCookie struct {
	*cookie
}

func (c *Conn) XinputChangePointerDevice(XAxis byte, YAxis byte, DeviceId byte) XinputChangePointerDeviceCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputChangePointerDeviceRequest(XAxis, YAxis, DeviceId), cookie)
	return XinputChangePointerDeviceCookie{cookie}
}

func (c *Conn) XinputChangePointerDeviceUnchecked(XAxis byte, YAxis byte, DeviceId byte) XinputChangePointerDeviceCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputChangePointerDeviceRequest(XAxis, YAxis, DeviceId), cookie)
	return XinputChangePointerDeviceCookie{cookie}
}

// Request reply for XinputChangePointerDevice
// size: 32
type XinputChangePointerDeviceReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Waits and reads reply data from request XinputChangePointerDevice
func (cook XinputChangePointerDeviceCookie) Reply() (*XinputChangePointerDeviceReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputChangePointerDeviceReply(buf), nil
}

// Read reply into structure from buffer for XinputChangePointerDevice
func xinputChangePointerDeviceReply(buf []byte) *XinputChangePointerDeviceReply {
	v := new(XinputChangePointerDeviceReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

func (cook XinputChangePointerDeviceCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputChangePointerDevice
func (c *Conn) xinputChangePointerDeviceRequest(XAxis byte, YAxis byte, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 12 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = XAxis
	b += 1

	buf[b] = YAxis
	b += 1

	buf[b] = DeviceId
	b += 1

	b += 1 // padding

	return buf
}

// Request XinputGrabDevice
// size: pad((20 + pad((int(NumClasses) * 4))))
type XinputGrabDeviceCookie struct {
	*cookie
}

func (c *Conn) XinputGrabDevice(GrabWindow Id, Time Timestamp, NumClasses uint16, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, DeviceId byte, Classes []XinputEventClass) XinputGrabDeviceCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputGrabDeviceRequest(GrabWindow, Time, NumClasses, ThisDeviceMode, OtherDeviceMode, OwnerEvents, DeviceId, Classes), cookie)
	return XinputGrabDeviceCookie{cookie}
}

func (c *Conn) XinputGrabDeviceUnchecked(GrabWindow Id, Time Timestamp, NumClasses uint16, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, DeviceId byte, Classes []XinputEventClass) XinputGrabDeviceCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputGrabDeviceRequest(GrabWindow, Time, NumClasses, ThisDeviceMode, OtherDeviceMode, OwnerEvents, DeviceId, Classes), cookie)
	return XinputGrabDeviceCookie{cookie}
}

// Request reply for XinputGrabDevice
// size: 32
type XinputGrabDeviceReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Waits and reads reply data from request XinputGrabDevice
func (cook XinputGrabDeviceCookie) Reply() (*XinputGrabDeviceReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputGrabDeviceReply(buf), nil
}

// Read reply into structure from buffer for XinputGrabDevice
func xinputGrabDeviceReply(buf []byte) *XinputGrabDeviceReply {
	v := new(XinputGrabDeviceReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

func (cook XinputGrabDeviceCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputGrabDevice
func (c *Conn) xinputGrabDeviceRequest(GrabWindow Id, Time Timestamp, NumClasses uint16, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, DeviceId byte, Classes []XinputEventClass) []byte {
	size := pad((20 + pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 13 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(GrabWindow))
	b += 4

	Put32(buf[b:], uint32(Time))
	b += 4

	Put16(buf[b:], NumClasses)
	b += 2

	buf[b] = ThisDeviceMode
	b += 1

	buf[b] = OtherDeviceMode
	b += 1

	if OwnerEvents {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	buf[b] = DeviceId
	b += 1

	b += 2 // padding

	for i := 0; i < int(NumClasses); i++ {
		Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = pad(b)

	return buf
}

// Request XinputUngrabDevice
// size: 12
type XinputUngrabDeviceCookie struct {
	*cookie
}

// Write request to wire for XinputUngrabDevice
func (c *Conn) XinputUngrabDevice(Time Timestamp, DeviceId byte) XinputUngrabDeviceCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xinputUngrabDeviceRequest(Time, DeviceId), cookie)
	return XinputUngrabDeviceCookie{cookie}
}

func (c *Conn) XinputUngrabDeviceChecked(Time Timestamp, DeviceId byte) XinputUngrabDeviceCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xinputUngrabDeviceRequest(Time, DeviceId), cookie)
	return XinputUngrabDeviceCookie{cookie}
}

func (cook XinputUngrabDeviceCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputUngrabDevice
func (c *Conn) xinputUngrabDeviceRequest(Time Timestamp, DeviceId byte) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 14 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Time))
	b += 4

	buf[b] = DeviceId
	b += 1

	return buf
}

// Request XinputGrabDeviceKey
// size: pad((20 + pad((int(NumClasses) * 4))))
type XinputGrabDeviceKeyCookie struct {
	*cookie
}

// Write request to wire for XinputGrabDeviceKey
func (c *Conn) XinputGrabDeviceKey(GrabWindow Id, NumClasses uint16, Modifiers uint16, ModifierDevice byte, GrabbedDevice byte, Key byte, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, Classes []XinputEventClass) XinputGrabDeviceKeyCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xinputGrabDeviceKeyRequest(GrabWindow, NumClasses, Modifiers, ModifierDevice, GrabbedDevice, Key, ThisDeviceMode, OtherDeviceMode, OwnerEvents, Classes), cookie)
	return XinputGrabDeviceKeyCookie{cookie}
}

func (c *Conn) XinputGrabDeviceKeyChecked(GrabWindow Id, NumClasses uint16, Modifiers uint16, ModifierDevice byte, GrabbedDevice byte, Key byte, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, Classes []XinputEventClass) XinputGrabDeviceKeyCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xinputGrabDeviceKeyRequest(GrabWindow, NumClasses, Modifiers, ModifierDevice, GrabbedDevice, Key, ThisDeviceMode, OtherDeviceMode, OwnerEvents, Classes), cookie)
	return XinputGrabDeviceKeyCookie{cookie}
}

func (cook XinputGrabDeviceKeyCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputGrabDeviceKey
func (c *Conn) xinputGrabDeviceKeyRequest(GrabWindow Id, NumClasses uint16, Modifiers uint16, ModifierDevice byte, GrabbedDevice byte, Key byte, ThisDeviceMode byte, OtherDeviceMode byte, OwnerEvents bool, Classes []XinputEventClass) []byte {
	size := pad((20 + pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 15 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(GrabWindow))
	b += 4

	Put16(buf[b:], NumClasses)
	b += 2

	Put16(buf[b:], Modifiers)
	b += 2

	buf[b] = ModifierDevice
	b += 1

	buf[b] = GrabbedDevice
	b += 1

	buf[b] = Key
	b += 1

	buf[b] = ThisDeviceMode
	b += 1

	buf[b] = OtherDeviceMode
	b += 1

	if OwnerEvents {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 2 // padding

	for i := 0; i < int(NumClasses); i++ {
		Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = pad(b)

	return buf
}

// Request XinputUngrabDeviceKey
// size: 16
type XinputUngrabDeviceKeyCookie struct {
	*cookie
}

// Write request to wire for XinputUngrabDeviceKey
func (c *Conn) XinputUngrabDeviceKey(GrabWindow Id, Modifiers uint16, ModifierDevice byte, Key byte, GrabbedDevice byte) XinputUngrabDeviceKeyCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xinputUngrabDeviceKeyRequest(GrabWindow, Modifiers, ModifierDevice, Key, GrabbedDevice), cookie)
	return XinputUngrabDeviceKeyCookie{cookie}
}

func (c *Conn) XinputUngrabDeviceKeyChecked(GrabWindow Id, Modifiers uint16, ModifierDevice byte, Key byte, GrabbedDevice byte) XinputUngrabDeviceKeyCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xinputUngrabDeviceKeyRequest(GrabWindow, Modifiers, ModifierDevice, Key, GrabbedDevice), cookie)
	return XinputUngrabDeviceKeyCookie{cookie}
}

func (cook XinputUngrabDeviceKeyCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputUngrabDeviceKey
func (c *Conn) xinputUngrabDeviceKeyRequest(GrabWindow Id, Modifiers uint16, ModifierDevice byte, Key byte, GrabbedDevice byte) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 16 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(GrabWindow))
	b += 4

	Put16(buf[b:], Modifiers)
	b += 2

	buf[b] = ModifierDevice
	b += 1

	buf[b] = Key
	b += 1

	buf[b] = GrabbedDevice
	b += 1

	return buf
}

// Request XinputGrabDeviceButton
// size: pad((20 + pad((int(NumClasses) * 4))))
type XinputGrabDeviceButtonCookie struct {
	*cookie
}

// Write request to wire for XinputGrabDeviceButton
func (c *Conn) XinputGrabDeviceButton(GrabWindow Id, GrabbedDevice byte, ModifierDevice byte, NumClasses uint16, Modifiers uint16, ThisDeviceMode byte, OtherDeviceMode byte, Button byte, OwnerEvents byte, Classes []XinputEventClass) XinputGrabDeviceButtonCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xinputGrabDeviceButtonRequest(GrabWindow, GrabbedDevice, ModifierDevice, NumClasses, Modifiers, ThisDeviceMode, OtherDeviceMode, Button, OwnerEvents, Classes), cookie)
	return XinputGrabDeviceButtonCookie{cookie}
}

func (c *Conn) XinputGrabDeviceButtonChecked(GrabWindow Id, GrabbedDevice byte, ModifierDevice byte, NumClasses uint16, Modifiers uint16, ThisDeviceMode byte, OtherDeviceMode byte, Button byte, OwnerEvents byte, Classes []XinputEventClass) XinputGrabDeviceButtonCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xinputGrabDeviceButtonRequest(GrabWindow, GrabbedDevice, ModifierDevice, NumClasses, Modifiers, ThisDeviceMode, OtherDeviceMode, Button, OwnerEvents, Classes), cookie)
	return XinputGrabDeviceButtonCookie{cookie}
}

func (cook XinputGrabDeviceButtonCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputGrabDeviceButton
func (c *Conn) xinputGrabDeviceButtonRequest(GrabWindow Id, GrabbedDevice byte, ModifierDevice byte, NumClasses uint16, Modifiers uint16, ThisDeviceMode byte, OtherDeviceMode byte, Button byte, OwnerEvents byte, Classes []XinputEventClass) []byte {
	size := pad((20 + pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 17 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(GrabWindow))
	b += 4

	buf[b] = GrabbedDevice
	b += 1

	buf[b] = ModifierDevice
	b += 1

	Put16(buf[b:], NumClasses)
	b += 2

	Put16(buf[b:], Modifiers)
	b += 2

	buf[b] = ThisDeviceMode
	b += 1

	buf[b] = OtherDeviceMode
	b += 1

	buf[b] = Button
	b += 1

	buf[b] = OwnerEvents
	b += 1

	b += 2 // padding

	for i := 0; i < int(NumClasses); i++ {
		Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = pad(b)

	return buf
}

// Request XinputUngrabDeviceButton
// size: 16
type XinputUngrabDeviceButtonCookie struct {
	*cookie
}

// Write request to wire for XinputUngrabDeviceButton
func (c *Conn) XinputUngrabDeviceButton(GrabWindow Id, Modifiers uint16, ModifierDevice byte, Button byte, GrabbedDevice byte) XinputUngrabDeviceButtonCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xinputUngrabDeviceButtonRequest(GrabWindow, Modifiers, ModifierDevice, Button, GrabbedDevice), cookie)
	return XinputUngrabDeviceButtonCookie{cookie}
}

func (c *Conn) XinputUngrabDeviceButtonChecked(GrabWindow Id, Modifiers uint16, ModifierDevice byte, Button byte, GrabbedDevice byte) XinputUngrabDeviceButtonCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xinputUngrabDeviceButtonRequest(GrabWindow, Modifiers, ModifierDevice, Button, GrabbedDevice), cookie)
	return XinputUngrabDeviceButtonCookie{cookie}
}

func (cook XinputUngrabDeviceButtonCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputUngrabDeviceButton
func (c *Conn) xinputUngrabDeviceButtonRequest(GrabWindow Id, Modifiers uint16, ModifierDevice byte, Button byte, GrabbedDevice byte) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 18 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(GrabWindow))
	b += 4

	Put16(buf[b:], Modifiers)
	b += 2

	buf[b] = ModifierDevice
	b += 1

	buf[b] = Button
	b += 1

	buf[b] = GrabbedDevice
	b += 1

	return buf
}

// Request XinputAllowDeviceEvents
// size: 12
type XinputAllowDeviceEventsCookie struct {
	*cookie
}

// Write request to wire for XinputAllowDeviceEvents
func (c *Conn) XinputAllowDeviceEvents(Time Timestamp, Mode byte, DeviceId byte) XinputAllowDeviceEventsCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xinputAllowDeviceEventsRequest(Time, Mode, DeviceId), cookie)
	return XinputAllowDeviceEventsCookie{cookie}
}

func (c *Conn) XinputAllowDeviceEventsChecked(Time Timestamp, Mode byte, DeviceId byte) XinputAllowDeviceEventsCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xinputAllowDeviceEventsRequest(Time, Mode, DeviceId), cookie)
	return XinputAllowDeviceEventsCookie{cookie}
}

func (cook XinputAllowDeviceEventsCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputAllowDeviceEvents
func (c *Conn) xinputAllowDeviceEventsRequest(Time Timestamp, Mode byte, DeviceId byte) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 19 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Time))
	b += 4

	buf[b] = Mode
	b += 1

	buf[b] = DeviceId
	b += 1

	return buf
}

// Request XinputGetDeviceFocus
// size: 8
type XinputGetDeviceFocusCookie struct {
	*cookie
}

func (c *Conn) XinputGetDeviceFocus(DeviceId byte) XinputGetDeviceFocusCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputGetDeviceFocusRequest(DeviceId), cookie)
	return XinputGetDeviceFocusCookie{cookie}
}

func (c *Conn) XinputGetDeviceFocusUnchecked(DeviceId byte) XinputGetDeviceFocusCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputGetDeviceFocusRequest(DeviceId), cookie)
	return XinputGetDeviceFocusCookie{cookie}
}

// Request reply for XinputGetDeviceFocus
// size: 32
type XinputGetDeviceFocusReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Focus    Id
	Time     Timestamp
	RevertTo byte
	// padding: 15 bytes
}

// Waits and reads reply data from request XinputGetDeviceFocus
func (cook XinputGetDeviceFocusCookie) Reply() (*XinputGetDeviceFocusReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputGetDeviceFocusReply(buf), nil
}

// Read reply into structure from buffer for XinputGetDeviceFocus
func xinputGetDeviceFocusReply(buf []byte) *XinputGetDeviceFocusReply {
	v := new(XinputGetDeviceFocusReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Focus = Id(Get32(buf[b:]))
	b += 4

	v.Time = Timestamp(Get32(buf[b:]))
	b += 4

	v.RevertTo = buf[b]
	b += 1

	b += 15 // padding

	return v
}

func (cook XinputGetDeviceFocusCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputGetDeviceFocus
func (c *Conn) xinputGetDeviceFocusRequest(DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 20 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// Request XinputSetDeviceFocus
// size: 16
type XinputSetDeviceFocusCookie struct {
	*cookie
}

// Write request to wire for XinputSetDeviceFocus
func (c *Conn) XinputSetDeviceFocus(Focus Id, Time Timestamp, RevertTo byte, DeviceId byte) XinputSetDeviceFocusCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xinputSetDeviceFocusRequest(Focus, Time, RevertTo, DeviceId), cookie)
	return XinputSetDeviceFocusCookie{cookie}
}

func (c *Conn) XinputSetDeviceFocusChecked(Focus Id, Time Timestamp, RevertTo byte, DeviceId byte) XinputSetDeviceFocusCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xinputSetDeviceFocusRequest(Focus, Time, RevertTo, DeviceId), cookie)
	return XinputSetDeviceFocusCookie{cookie}
}

func (cook XinputSetDeviceFocusCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputSetDeviceFocus
func (c *Conn) xinputSetDeviceFocusRequest(Focus Id, Time Timestamp, RevertTo byte, DeviceId byte) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 21 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Focus))
	b += 4

	Put32(buf[b:], uint32(Time))
	b += 4

	buf[b] = RevertTo
	b += 1

	buf[b] = DeviceId
	b += 1

	return buf
}

// Request XinputGetFeedbackControl
// size: 8
type XinputGetFeedbackControlCookie struct {
	*cookie
}

func (c *Conn) XinputGetFeedbackControl(DeviceId byte) XinputGetFeedbackControlCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputGetFeedbackControlRequest(DeviceId), cookie)
	return XinputGetFeedbackControlCookie{cookie}
}

func (c *Conn) XinputGetFeedbackControlUnchecked(DeviceId byte) XinputGetFeedbackControlCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputGetFeedbackControlRequest(DeviceId), cookie)
	return XinputGetFeedbackControlCookie{cookie}
}

// Request reply for XinputGetFeedbackControl
// size: 32
type XinputGetFeedbackControlReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumFeedback uint16
	// padding: 22 bytes
}

// Waits and reads reply data from request XinputGetFeedbackControl
func (cook XinputGetFeedbackControlCookie) Reply() (*XinputGetFeedbackControlReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputGetFeedbackControlReply(buf), nil
}

// Read reply into structure from buffer for XinputGetFeedbackControl
func xinputGetFeedbackControlReply(buf []byte) *XinputGetFeedbackControlReply {
	v := new(XinputGetFeedbackControlReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumFeedback = Get16(buf[b:])
	b += 2

	b += 22 // padding

	return v
}

func (cook XinputGetFeedbackControlCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputGetFeedbackControl
func (c *Conn) xinputGetFeedbackControlRequest(DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 22 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// Request XinputGetDeviceKeyMapping
// size: 8
type XinputGetDeviceKeyMappingCookie struct {
	*cookie
}

func (c *Conn) XinputGetDeviceKeyMapping(DeviceId byte, FirstKeycode XinputKeyCode, Count byte) XinputGetDeviceKeyMappingCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputGetDeviceKeyMappingRequest(DeviceId, FirstKeycode, Count), cookie)
	return XinputGetDeviceKeyMappingCookie{cookie}
}

func (c *Conn) XinputGetDeviceKeyMappingUnchecked(DeviceId byte, FirstKeycode XinputKeyCode, Count byte) XinputGetDeviceKeyMappingCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputGetDeviceKeyMappingRequest(DeviceId, FirstKeycode, Count), cookie)
	return XinputGetDeviceKeyMappingCookie{cookie}
}

// Request reply for XinputGetDeviceKeyMapping
// size: (32 + pad((int(Length) * 4)))
type XinputGetDeviceKeyMappingReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	KeysymsPerKeycode byte
	// padding: 23 bytes
	Keysyms []Keysym // size: pad((int(Length) * 4))
}

// Waits and reads reply data from request XinputGetDeviceKeyMapping
func (cook XinputGetDeviceKeyMappingCookie) Reply() (*XinputGetDeviceKeyMappingReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputGetDeviceKeyMappingReply(buf), nil
}

// Read reply into structure from buffer for XinputGetDeviceKeyMapping
func xinputGetDeviceKeyMappingReply(buf []byte) *XinputGetDeviceKeyMappingReply {
	v := new(XinputGetDeviceKeyMappingReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.KeysymsPerKeycode = buf[b]
	b += 1

	b += 23 // padding

	v.Keysyms = make([]Keysym, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.Keysyms[i] = Keysym(Get32(buf[b:]))
		b += 4
	}
	b = pad(b)

	return v
}

func (cook XinputGetDeviceKeyMappingCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputGetDeviceKeyMapping
func (c *Conn) xinputGetDeviceKeyMappingRequest(DeviceId byte, FirstKeycode XinputKeyCode, Count byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 24 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = byte(FirstKeycode)
	b += 1

	buf[b] = Count
	b += 1

	return buf
}

// Request XinputChangeDeviceKeyMapping
// size: pad((8 + pad(((int(KeycodeCount) * int(KeysymsPerKeycode)) * 4))))
type XinputChangeDeviceKeyMappingCookie struct {
	*cookie
}

// Write request to wire for XinputChangeDeviceKeyMapping
func (c *Conn) XinputChangeDeviceKeyMapping(DeviceId byte, FirstKeycode XinputKeyCode, KeysymsPerKeycode byte, KeycodeCount byte, Keysyms []Keysym) XinputChangeDeviceKeyMappingCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xinputChangeDeviceKeyMappingRequest(DeviceId, FirstKeycode, KeysymsPerKeycode, KeycodeCount, Keysyms), cookie)
	return XinputChangeDeviceKeyMappingCookie{cookie}
}

func (c *Conn) XinputChangeDeviceKeyMappingChecked(DeviceId byte, FirstKeycode XinputKeyCode, KeysymsPerKeycode byte, KeycodeCount byte, Keysyms []Keysym) XinputChangeDeviceKeyMappingCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xinputChangeDeviceKeyMappingRequest(DeviceId, FirstKeycode, KeysymsPerKeycode, KeycodeCount, Keysyms), cookie)
	return XinputChangeDeviceKeyMappingCookie{cookie}
}

func (cook XinputChangeDeviceKeyMappingCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputChangeDeviceKeyMapping
func (c *Conn) xinputChangeDeviceKeyMappingRequest(DeviceId byte, FirstKeycode XinputKeyCode, KeysymsPerKeycode byte, KeycodeCount byte, Keysyms []Keysym) []byte {
	size := pad((8 + pad(((int(KeycodeCount) * int(KeysymsPerKeycode)) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 25 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = byte(FirstKeycode)
	b += 1

	buf[b] = KeysymsPerKeycode
	b += 1

	buf[b] = KeycodeCount
	b += 1

	for i := 0; i < int((int(KeycodeCount) * int(KeysymsPerKeycode))); i++ {
		Put32(buf[b:], uint32(Keysyms[i]))
		b += 4
	}
	b = pad(b)

	return buf
}

// Request XinputGetDeviceModifierMapping
// size: 8
type XinputGetDeviceModifierMappingCookie struct {
	*cookie
}

func (c *Conn) XinputGetDeviceModifierMapping(DeviceId byte) XinputGetDeviceModifierMappingCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputGetDeviceModifierMappingRequest(DeviceId), cookie)
	return XinputGetDeviceModifierMappingCookie{cookie}
}

func (c *Conn) XinputGetDeviceModifierMappingUnchecked(DeviceId byte) XinputGetDeviceModifierMappingCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputGetDeviceModifierMappingRequest(DeviceId), cookie)
	return XinputGetDeviceModifierMappingCookie{cookie}
}

// Request reply for XinputGetDeviceModifierMapping
// size: (32 + pad(((int(KeycodesPerModifier) * 8) * 1)))
type XinputGetDeviceModifierMappingReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	KeycodesPerModifier byte
	// padding: 23 bytes
	Keymaps []byte // size: pad(((int(KeycodesPerModifier) * 8) * 1))
}

// Waits and reads reply data from request XinputGetDeviceModifierMapping
func (cook XinputGetDeviceModifierMappingCookie) Reply() (*XinputGetDeviceModifierMappingReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputGetDeviceModifierMappingReply(buf), nil
}

// Read reply into structure from buffer for XinputGetDeviceModifierMapping
func xinputGetDeviceModifierMappingReply(buf []byte) *XinputGetDeviceModifierMappingReply {
	v := new(XinputGetDeviceModifierMappingReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.KeycodesPerModifier = buf[b]
	b += 1

	b += 23 // padding

	v.Keymaps = make([]byte, (int(v.KeycodesPerModifier) * 8))
	copy(v.Keymaps[:(int(v.KeycodesPerModifier)*8)], buf[b:])
	b += pad(int((int(v.KeycodesPerModifier) * 8)))

	return v
}

func (cook XinputGetDeviceModifierMappingCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputGetDeviceModifierMapping
func (c *Conn) xinputGetDeviceModifierMappingRequest(DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 26 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// Request XinputSetDeviceModifierMapping
// size: pad((7 + pad(((int(KeycodesPerModifier) * 8) * 1))))
type XinputSetDeviceModifierMappingCookie struct {
	*cookie
}

func (c *Conn) XinputSetDeviceModifierMapping(DeviceId byte, KeycodesPerModifier byte, Keymaps []byte) XinputSetDeviceModifierMappingCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputSetDeviceModifierMappingRequest(DeviceId, KeycodesPerModifier, Keymaps), cookie)
	return XinputSetDeviceModifierMappingCookie{cookie}
}

func (c *Conn) XinputSetDeviceModifierMappingUnchecked(DeviceId byte, KeycodesPerModifier byte, Keymaps []byte) XinputSetDeviceModifierMappingCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputSetDeviceModifierMappingRequest(DeviceId, KeycodesPerModifier, Keymaps), cookie)
	return XinputSetDeviceModifierMappingCookie{cookie}
}

// Request reply for XinputSetDeviceModifierMapping
// size: 32
type XinputSetDeviceModifierMappingReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Waits and reads reply data from request XinputSetDeviceModifierMapping
func (cook XinputSetDeviceModifierMappingCookie) Reply() (*XinputSetDeviceModifierMappingReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputSetDeviceModifierMappingReply(buf), nil
}

// Read reply into structure from buffer for XinputSetDeviceModifierMapping
func xinputSetDeviceModifierMappingReply(buf []byte) *XinputSetDeviceModifierMappingReply {
	v := new(XinputSetDeviceModifierMappingReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

func (cook XinputSetDeviceModifierMappingCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputSetDeviceModifierMapping
func (c *Conn) xinputSetDeviceModifierMappingRequest(DeviceId byte, KeycodesPerModifier byte, Keymaps []byte) []byte {
	size := pad((7 + pad(((int(KeycodesPerModifier) * 8) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 27 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = KeycodesPerModifier
	b += 1

	b += 1 // padding

	copy(buf[b:], Keymaps[:(int(KeycodesPerModifier)*8)])
	b += pad(int((int(KeycodesPerModifier) * 8)))

	return buf
}

// Request XinputGetDeviceButtonMapping
// size: 8
type XinputGetDeviceButtonMappingCookie struct {
	*cookie
}

func (c *Conn) XinputGetDeviceButtonMapping(DeviceId byte) XinputGetDeviceButtonMappingCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputGetDeviceButtonMappingRequest(DeviceId), cookie)
	return XinputGetDeviceButtonMappingCookie{cookie}
}

func (c *Conn) XinputGetDeviceButtonMappingUnchecked(DeviceId byte) XinputGetDeviceButtonMappingCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputGetDeviceButtonMappingRequest(DeviceId), cookie)
	return XinputGetDeviceButtonMappingCookie{cookie}
}

// Request reply for XinputGetDeviceButtonMapping
// size: (32 + pad((int(MapSize) * 1)))
type XinputGetDeviceButtonMappingReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	MapSize byte
	// padding: 23 bytes
	Map []byte // size: pad((int(MapSize) * 1))
}

// Waits and reads reply data from request XinputGetDeviceButtonMapping
func (cook XinputGetDeviceButtonMappingCookie) Reply() (*XinputGetDeviceButtonMappingReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputGetDeviceButtonMappingReply(buf), nil
}

// Read reply into structure from buffer for XinputGetDeviceButtonMapping
func xinputGetDeviceButtonMappingReply(buf []byte) *XinputGetDeviceButtonMappingReply {
	v := new(XinputGetDeviceButtonMappingReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.MapSize = buf[b]
	b += 1

	b += 23 // padding

	v.Map = make([]byte, v.MapSize)
	copy(v.Map[:v.MapSize], buf[b:])
	b += pad(int(v.MapSize))

	return v
}

func (cook XinputGetDeviceButtonMappingCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputGetDeviceButtonMapping
func (c *Conn) xinputGetDeviceButtonMappingRequest(DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 28 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// Request XinputSetDeviceButtonMapping
// size: pad((8 + pad((int(MapSize) * 1))))
type XinputSetDeviceButtonMappingCookie struct {
	*cookie
}

func (c *Conn) XinputSetDeviceButtonMapping(DeviceId byte, MapSize byte, Map []byte) XinputSetDeviceButtonMappingCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputSetDeviceButtonMappingRequest(DeviceId, MapSize, Map), cookie)
	return XinputSetDeviceButtonMappingCookie{cookie}
}

func (c *Conn) XinputSetDeviceButtonMappingUnchecked(DeviceId byte, MapSize byte, Map []byte) XinputSetDeviceButtonMappingCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputSetDeviceButtonMappingRequest(DeviceId, MapSize, Map), cookie)
	return XinputSetDeviceButtonMappingCookie{cookie}
}

// Request reply for XinputSetDeviceButtonMapping
// size: 32
type XinputSetDeviceButtonMappingReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Waits and reads reply data from request XinputSetDeviceButtonMapping
func (cook XinputSetDeviceButtonMappingCookie) Reply() (*XinputSetDeviceButtonMappingReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputSetDeviceButtonMappingReply(buf), nil
}

// Read reply into structure from buffer for XinputSetDeviceButtonMapping
func xinputSetDeviceButtonMappingReply(buf []byte) *XinputSetDeviceButtonMappingReply {
	v := new(XinputSetDeviceButtonMappingReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

func (cook XinputSetDeviceButtonMappingCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputSetDeviceButtonMapping
func (c *Conn) xinputSetDeviceButtonMappingRequest(DeviceId byte, MapSize byte, Map []byte) []byte {
	size := pad((8 + pad((int(MapSize) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 29 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = MapSize
	b += 1

	b += 2 // padding

	copy(buf[b:], Map[:MapSize])
	b += pad(int(MapSize))

	return buf
}

// Request XinputQueryDeviceState
// size: 8
type XinputQueryDeviceStateCookie struct {
	*cookie
}

func (c *Conn) XinputQueryDeviceState(DeviceId byte) XinputQueryDeviceStateCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputQueryDeviceStateRequest(DeviceId), cookie)
	return XinputQueryDeviceStateCookie{cookie}
}

func (c *Conn) XinputQueryDeviceStateUnchecked(DeviceId byte) XinputQueryDeviceStateCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputQueryDeviceStateRequest(DeviceId), cookie)
	return XinputQueryDeviceStateCookie{cookie}
}

// Request reply for XinputQueryDeviceState
// size: 32
type XinputQueryDeviceStateReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumClasses byte
	// padding: 23 bytes
}

// Waits and reads reply data from request XinputQueryDeviceState
func (cook XinputQueryDeviceStateCookie) Reply() (*XinputQueryDeviceStateReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputQueryDeviceStateReply(buf), nil
}

// Read reply into structure from buffer for XinputQueryDeviceState
func xinputQueryDeviceStateReply(buf []byte) *XinputQueryDeviceStateReply {
	v := new(XinputQueryDeviceStateReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumClasses = buf[b]
	b += 1

	b += 23 // padding

	return v
}

func (cook XinputQueryDeviceStateCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputQueryDeviceState
func (c *Conn) xinputQueryDeviceStateRequest(DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 30 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 3 // padding

	return buf
}

// Request XinputSendExtensionEvent
// size: pad(((16 + pad(((int(NumEvents) * 32) * 1))) + pad((int(NumClasses) * 4))))
type XinputSendExtensionEventCookie struct {
	*cookie
}

// Write request to wire for XinputSendExtensionEvent
func (c *Conn) XinputSendExtensionEvent(Destination Id, DeviceId byte, Propagate bool, NumClasses uint16, NumEvents byte, Events string, Classes []XinputEventClass) XinputSendExtensionEventCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xinputSendExtensionEventRequest(Destination, DeviceId, Propagate, NumClasses, NumEvents, Events, Classes), cookie)
	return XinputSendExtensionEventCookie{cookie}
}

func (c *Conn) XinputSendExtensionEventChecked(Destination Id, DeviceId byte, Propagate bool, NumClasses uint16, NumEvents byte, Events string, Classes []XinputEventClass) XinputSendExtensionEventCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xinputSendExtensionEventRequest(Destination, DeviceId, Propagate, NumClasses, NumEvents, Events, Classes), cookie)
	return XinputSendExtensionEventCookie{cookie}
}

func (cook XinputSendExtensionEventCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputSendExtensionEvent
func (c *Conn) xinputSendExtensionEventRequest(Destination Id, DeviceId byte, Propagate bool, NumClasses uint16, NumEvents byte, Events string, Classes []XinputEventClass) []byte {
	size := pad(((16 + pad(((int(NumEvents) * 32) * 1))) + pad((int(NumClasses) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 31 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], uint32(Destination))
	b += 4

	buf[b] = DeviceId
	b += 1

	if Propagate {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	Put16(buf[b:], NumClasses)
	b += 2

	buf[b] = NumEvents
	b += 1

	b += 3 // padding

	copy(buf[b:], Events[:(int(NumEvents)*32)])
	b += pad(int((int(NumEvents) * 32)))

	for i := 0; i < int(NumClasses); i++ {
		Put32(buf[b:], uint32(Classes[i]))
		b += 4
	}
	b = pad(b)

	return buf
}

// Request XinputDeviceBell
// size: 8
type XinputDeviceBellCookie struct {
	*cookie
}

// Write request to wire for XinputDeviceBell
func (c *Conn) XinputDeviceBell(DeviceId byte, FeedbackId byte, FeedbackClass byte, Percent int8) XinputDeviceBellCookie {
	cookie := c.newCookie(false, false)
	c.newRequest(c.xinputDeviceBellRequest(DeviceId, FeedbackId, FeedbackClass, Percent), cookie)
	return XinputDeviceBellCookie{cookie}
}

func (c *Conn) XinputDeviceBellChecked(DeviceId byte, FeedbackId byte, FeedbackClass byte, Percent int8) XinputDeviceBellCookie {
	cookie := c.newCookie(true, false)
	c.newRequest(c.xinputDeviceBellRequest(DeviceId, FeedbackId, FeedbackClass, Percent), cookie)
	return XinputDeviceBellCookie{cookie}
}

func (cook XinputDeviceBellCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputDeviceBell
func (c *Conn) xinputDeviceBellRequest(DeviceId byte, FeedbackId byte, FeedbackClass byte, Percent int8) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 32 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = FeedbackId
	b += 1

	buf[b] = FeedbackClass
	b += 1

	buf[b] = byte(Percent)
	b += 1

	return buf
}

// Request XinputSetDeviceValuators
// size: pad((8 + pad((int(NumValuators) * 4))))
type XinputSetDeviceValuatorsCookie struct {
	*cookie
}

func (c *Conn) XinputSetDeviceValuators(DeviceId byte, FirstValuator byte, NumValuators byte, Valuators []int32) XinputSetDeviceValuatorsCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputSetDeviceValuatorsRequest(DeviceId, FirstValuator, NumValuators, Valuators), cookie)
	return XinputSetDeviceValuatorsCookie{cookie}
}

func (c *Conn) XinputSetDeviceValuatorsUnchecked(DeviceId byte, FirstValuator byte, NumValuators byte, Valuators []int32) XinputSetDeviceValuatorsCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputSetDeviceValuatorsRequest(DeviceId, FirstValuator, NumValuators, Valuators), cookie)
	return XinputSetDeviceValuatorsCookie{cookie}
}

// Request reply for XinputSetDeviceValuators
// size: 32
type XinputSetDeviceValuatorsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Waits and reads reply data from request XinputSetDeviceValuators
func (cook XinputSetDeviceValuatorsCookie) Reply() (*XinputSetDeviceValuatorsReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputSetDeviceValuatorsReply(buf), nil
}

// Read reply into structure from buffer for XinputSetDeviceValuators
func xinputSetDeviceValuatorsReply(buf []byte) *XinputSetDeviceValuatorsReply {
	v := new(XinputSetDeviceValuatorsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

func (cook XinputSetDeviceValuatorsCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputSetDeviceValuators
func (c *Conn) xinputSetDeviceValuatorsRequest(DeviceId byte, FirstValuator byte, NumValuators byte, Valuators []int32) []byte {
	size := pad((8 + pad((int(NumValuators) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 33 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DeviceId
	b += 1

	buf[b] = FirstValuator
	b += 1

	buf[b] = NumValuators
	b += 1

	b += 1 // padding

	for i := 0; i < int(NumValuators); i++ {
		Put32(buf[b:], uint32(Valuators[i]))
		b += 4
	}
	b = pad(b)

	return buf
}

// Request XinputGetDeviceControl
// size: 8
type XinputGetDeviceControlCookie struct {
	*cookie
}

func (c *Conn) XinputGetDeviceControl(ControlId uint16, DeviceId byte) XinputGetDeviceControlCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xinputGetDeviceControlRequest(ControlId, DeviceId), cookie)
	return XinputGetDeviceControlCookie{cookie}
}

func (c *Conn) XinputGetDeviceControlUnchecked(ControlId uint16, DeviceId byte) XinputGetDeviceControlCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xinputGetDeviceControlRequest(ControlId, DeviceId), cookie)
	return XinputGetDeviceControlCookie{cookie}
}

// Request reply for XinputGetDeviceControl
// size: 32
type XinputGetDeviceControlReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Status byte
	// padding: 23 bytes
}

// Waits and reads reply data from request XinputGetDeviceControl
func (cook XinputGetDeviceControlCookie) Reply() (*XinputGetDeviceControlReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xinputGetDeviceControlReply(buf), nil
}

// Read reply into structure from buffer for XinputGetDeviceControl
func xinputGetDeviceControlReply(buf []byte) *XinputGetDeviceControlReply {
	v := new(XinputGetDeviceControlReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.Status = buf[b]
	b += 1

	b += 23 // padding

	return v
}

func (cook XinputGetDeviceControlCookie) Check() error {
	return cook.check()
}

// Write request to wire for XinputGetDeviceControl
func (c *Conn) xinputGetDeviceControlRequest(ControlId uint16, DeviceId byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XINPUTEXTENSION"]
	b += 1

	buf[b] = 34 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put16(buf[b:], ControlId)
	b += 2

	buf[b] = DeviceId
	b += 1

	b += 1 // padding

	return buf
}
