package record

/*
	This file was generated by record.xml on May 10 2012 4:20:28pm EDT.
	This file is automatically generated. Edit at your peril!
*/

import (
	"github.com/BurntSushi/xgb"

	"github.com/BurntSushi/xgb/xproto"
)

// Init must be called before using the RECORD extension.
func Init(c *xgb.Conn) error {
	reply, err := xproto.QueryExtension(c, 6, "RECORD").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return xgb.Errorf("No extension named RECORD could be found on on the server.")
	}

	xgb.ExtLock.Lock()
	c.Extensions["RECORD"] = reply.MajorOpcode
	for evNum, fun := range xgb.NewExtEventFuncs["RECORD"] {
		xgb.NewEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range xgb.NewExtErrorFuncs["RECORD"] {
		xgb.NewErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	xgb.ExtLock.Unlock()

	return nil
}

func init() {
	xgb.NewExtEventFuncs["RECORD"] = make(map[int]xgb.NewEventFun)
	xgb.NewExtErrorFuncs["RECORD"] = make(map[int]xgb.NewErrorFun)
}

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Card8'

const (
	HTypeFromServerTime     = 1
	HTypeFromClientTime     = 2
	HTypeFromClientSequence = 4
)

const (
	CsCurrentClients = 1
	CsFutureClients  = 2
	CsAllClients     = 3
)

type Context uint32

func NewContextId(c *xgb.Conn) (Context, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Context(id), nil
}

type ElementHeader byte

type ClientSpec uint32

// 'Range8' struct definition
// Size: 2
type Range8 struct {
	First byte
	Last  byte
}

// Struct read Range8
func Range8Read(buf []byte, v *Range8) int {
	b := 0

	v.First = buf[b]
	b += 1

	v.Last = buf[b]
	b += 1

	return b
}

// Struct list read Range8
func Range8ReadList(buf []byte, dest []Range8) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Range8{}
		b += Range8Read(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Range8
func (v Range8) Bytes() []byte {
	buf := make([]byte, 2)
	b := 0

	buf[b] = v.First
	b += 1

	buf[b] = v.Last
	b += 1

	return buf
}

// Write struct list Range8
func Range8ListBytes(buf []byte, list []Range8) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Range16' struct definition
// Size: 4
type Range16 struct {
	First uint16
	Last  uint16
}

// Struct read Range16
func Range16Read(buf []byte, v *Range16) int {
	b := 0

	v.First = xgb.Get16(buf[b:])
	b += 2

	v.Last = xgb.Get16(buf[b:])
	b += 2

	return b
}

// Struct list read Range16
func Range16ReadList(buf []byte, dest []Range16) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Range16{}
		b += Range16Read(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Range16
func (v Range16) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	xgb.Put16(buf[b:], v.First)
	b += 2

	xgb.Put16(buf[b:], v.Last)
	b += 2

	return buf
}

// Write struct list Range16
func Range16ListBytes(buf []byte, list []Range16) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'ExtRange' struct definition
// Size: 6
type ExtRange struct {
	Major Range8
	Minor Range16
}

// Struct read ExtRange
func ExtRangeRead(buf []byte, v *ExtRange) int {
	b := 0

	v.Major = Range8{}
	b += Range8Read(buf[b:], &v.Major)

	v.Minor = Range16{}
	b += Range16Read(buf[b:], &v.Minor)

	return b
}

// Struct list read ExtRange
func ExtRangeReadList(buf []byte, dest []ExtRange) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ExtRange{}
		b += ExtRangeRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write ExtRange
func (v ExtRange) Bytes() []byte {
	buf := make([]byte, 6)
	b := 0

	{
		structBytes := v.Major.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.Minor.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	return buf
}

// Write struct list ExtRange
func ExtRangeListBytes(buf []byte, list []ExtRange) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Range' struct definition
// Size: 24
type Range struct {
	CoreRequests    Range8
	CoreReplies     Range8
	ExtRequests     ExtRange
	ExtReplies      ExtRange
	DeliveredEvents Range8
	DeviceEvents    Range8
	Errors          Range8
	ClientStarted   bool
	ClientDied      bool
}

// Struct read Range
func RangeRead(buf []byte, v *Range) int {
	b := 0

	v.CoreRequests = Range8{}
	b += Range8Read(buf[b:], &v.CoreRequests)

	v.CoreReplies = Range8{}
	b += Range8Read(buf[b:], &v.CoreReplies)

	v.ExtRequests = ExtRange{}
	b += ExtRangeRead(buf[b:], &v.ExtRequests)

	v.ExtReplies = ExtRange{}
	b += ExtRangeRead(buf[b:], &v.ExtReplies)

	v.DeliveredEvents = Range8{}
	b += Range8Read(buf[b:], &v.DeliveredEvents)

	v.DeviceEvents = Range8{}
	b += Range8Read(buf[b:], &v.DeviceEvents)

	v.Errors = Range8{}
	b += Range8Read(buf[b:], &v.Errors)

	if buf[b] == 1 {
		v.ClientStarted = true
	} else {
		v.ClientStarted = false
	}
	b += 1

	if buf[b] == 1 {
		v.ClientDied = true
	} else {
		v.ClientDied = false
	}
	b += 1

	return b
}

// Struct list read Range
func RangeReadList(buf []byte, dest []Range) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Range{}
		b += RangeRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Range
func (v Range) Bytes() []byte {
	buf := make([]byte, 24)
	b := 0

	{
		structBytes := v.CoreRequests.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.CoreReplies.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.ExtRequests.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.ExtReplies.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.DeliveredEvents.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.DeviceEvents.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.Errors.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	if v.ClientStarted {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	if v.ClientDied {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Write struct list Range
func RangeListBytes(buf []byte, list []Range) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'ClientInfo' struct definition
// Size: (8 + xgb.Pad((int(NumRanges) * 24)))
type ClientInfo struct {
	ClientResource ClientSpec
	NumRanges      uint32
	Ranges         []Range // size: xgb.Pad((int(NumRanges) * 24))
}

// Struct read ClientInfo
func ClientInfoRead(buf []byte, v *ClientInfo) int {
	b := 0

	v.ClientResource = ClientSpec(xgb.Get32(buf[b:]))
	b += 4

	v.NumRanges = xgb.Get32(buf[b:])
	b += 4

	v.Ranges = make([]Range, v.NumRanges)
	b += RangeReadList(buf[b:], v.Ranges)

	return b
}

// Struct list read ClientInfo
func ClientInfoReadList(buf []byte, dest []ClientInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ClientInfo{}
		b += ClientInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write ClientInfo
func (v ClientInfo) Bytes() []byte {
	buf := make([]byte, (8 + xgb.Pad((int(v.NumRanges) * 24))))
	b := 0

	xgb.Put32(buf[b:], uint32(v.ClientResource))
	b += 4

	xgb.Put32(buf[b:], v.NumRanges)
	b += 4

	b += RangeListBytes(buf[b:], v.Ranges)

	return buf
}

// Write struct list ClientInfo
func ClientInfoListBytes(buf []byte, list []ClientInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size ClientInfo
func ClientInfoListSize(list []ClientInfo) int {
	size := 0
	for _, item := range list {
		size += (8 + xgb.Pad((int(item.NumRanges) * 24)))
	}
	return size
}

// Error definition BadContext (0)
// Size: 32

const BadBadContext = 0

type BadContextError struct {
	Sequence      uint16
	NiceName      string
	InvalidRecord uint32
}

// Error read BadContext
func BadContextErrorNew(buf []byte) xgb.Error {
	v := BadContextError{}
	v.NiceName = "BadContext"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.InvalidRecord = xgb.Get32(buf[b:])
	b += 4

	return v
}

func (err BadContextError) ImplementsError() {}

func (err BadContextError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadContextError) BadId() uint32 {
	return 0
}

func (err BadContextError) Error() string {
	fieldVals := make([]string, 0, 1)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("InvalidRecord: %d", err.InvalidRecord))
	return "BadBadContext {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["RECORD"][0] = BadContextErrorNew
}

// Request QueryVersion
// size: 8
type QueryVersionCookie struct {
	*xgb.Cookie
}

func QueryVersion(c *xgb.Conn, MajorVersion uint16, MinorVersion uint16) QueryVersionCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryVersionRequest(c, MajorVersion, MinorVersion), cookie)
	return QueryVersionCookie{cookie}
}

func QueryVersionUnchecked(c *xgb.Conn, MajorVersion uint16, MinorVersion uint16) QueryVersionCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryVersionRequest(c, MajorVersion, MinorVersion), cookie)
	return QueryVersionCookie{cookie}
}

// Request reply for QueryVersion
// size: 12
type QueryVersionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	MajorVersion uint16
	MinorVersion uint16
}

// Waits and reads reply data from request QueryVersion
func (cook QueryVersionCookie) Reply() (*QueryVersionReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryVersionReply(buf), nil
}

// Read reply into structure from buffer for QueryVersion
func queryVersionReply(buf []byte) *QueryVersionReply {
	v := new(QueryVersionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.MajorVersion = xgb.Get16(buf[b:])
	b += 2

	v.MinorVersion = xgb.Get16(buf[b:])
	b += 2

	return v
}

// Write request to wire for QueryVersion
func queryVersionRequest(c *xgb.Conn, MajorVersion uint16, MinorVersion uint16) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RECORD"]
	b += 1

	buf[b] = 0 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], MajorVersion)
	b += 2

	xgb.Put16(buf[b:], MinorVersion)
	b += 2

	return buf
}

// Request CreateContext
// size: xgb.Pad(((20 + xgb.Pad((int(NumClientSpecs) * 4))) + xgb.Pad((int(NumRanges) * 24))))
type CreateContextCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateContext
func CreateContext(c *xgb.Conn, Context Context, ElementHeader ElementHeader, NumClientSpecs uint32, NumRanges uint32, ClientSpecs []ClientSpec, Ranges []Range) CreateContextCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createContextRequest(c, Context, ElementHeader, NumClientSpecs, NumRanges, ClientSpecs, Ranges), cookie)
	return CreateContextCookie{cookie}
}

func CreateContextChecked(c *xgb.Conn, Context Context, ElementHeader ElementHeader, NumClientSpecs uint32, NumRanges uint32, ClientSpecs []ClientSpec, Ranges []Range) CreateContextCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createContextRequest(c, Context, ElementHeader, NumClientSpecs, NumRanges, ClientSpecs, Ranges), cookie)
	return CreateContextCookie{cookie}
}

func (cook CreateContextCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateContext
func createContextRequest(c *xgb.Conn, Context Context, ElementHeader ElementHeader, NumClientSpecs uint32, NumRanges uint32, ClientSpecs []ClientSpec, Ranges []Range) []byte {
	size := xgb.Pad(((20 + xgb.Pad((int(NumClientSpecs) * 4))) + xgb.Pad((int(NumRanges) * 24))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RECORD"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Context))
	b += 4

	buf[b] = byte(ElementHeader)
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], NumClientSpecs)
	b += 4

	xgb.Put32(buf[b:], NumRanges)
	b += 4

	for i := 0; i < int(NumClientSpecs); i++ {
		xgb.Put32(buf[b:], uint32(ClientSpecs[i]))
		b += 4
	}
	b = xgb.Pad(b)

	b += RangeListBytes(buf[b:], Ranges)

	return buf
}

// Request RegisterClients
// size: xgb.Pad(((20 + xgb.Pad((int(NumClientSpecs) * 4))) + xgb.Pad((int(NumRanges) * 24))))
type RegisterClientsCookie struct {
	*xgb.Cookie
}

// Write request to wire for RegisterClients
func RegisterClients(c *xgb.Conn, Context Context, ElementHeader ElementHeader, NumClientSpecs uint32, NumRanges uint32, ClientSpecs []ClientSpec, Ranges []Range) RegisterClientsCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(registerClientsRequest(c, Context, ElementHeader, NumClientSpecs, NumRanges, ClientSpecs, Ranges), cookie)
	return RegisterClientsCookie{cookie}
}

func RegisterClientsChecked(c *xgb.Conn, Context Context, ElementHeader ElementHeader, NumClientSpecs uint32, NumRanges uint32, ClientSpecs []ClientSpec, Ranges []Range) RegisterClientsCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(registerClientsRequest(c, Context, ElementHeader, NumClientSpecs, NumRanges, ClientSpecs, Ranges), cookie)
	return RegisterClientsCookie{cookie}
}

func (cook RegisterClientsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for RegisterClients
func registerClientsRequest(c *xgb.Conn, Context Context, ElementHeader ElementHeader, NumClientSpecs uint32, NumRanges uint32, ClientSpecs []ClientSpec, Ranges []Range) []byte {
	size := xgb.Pad(((20 + xgb.Pad((int(NumClientSpecs) * 4))) + xgb.Pad((int(NumRanges) * 24))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RECORD"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Context))
	b += 4

	buf[b] = byte(ElementHeader)
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], NumClientSpecs)
	b += 4

	xgb.Put32(buf[b:], NumRanges)
	b += 4

	for i := 0; i < int(NumClientSpecs); i++ {
		xgb.Put32(buf[b:], uint32(ClientSpecs[i]))
		b += 4
	}
	b = xgb.Pad(b)

	b += RangeListBytes(buf[b:], Ranges)

	return buf
}

// Request UnregisterClients
// size: xgb.Pad((12 + xgb.Pad((int(NumClientSpecs) * 4))))
type UnregisterClientsCookie struct {
	*xgb.Cookie
}

// Write request to wire for UnregisterClients
func UnregisterClients(c *xgb.Conn, Context Context, NumClientSpecs uint32, ClientSpecs []ClientSpec) UnregisterClientsCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(unregisterClientsRequest(c, Context, NumClientSpecs, ClientSpecs), cookie)
	return UnregisterClientsCookie{cookie}
}

func UnregisterClientsChecked(c *xgb.Conn, Context Context, NumClientSpecs uint32, ClientSpecs []ClientSpec) UnregisterClientsCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(unregisterClientsRequest(c, Context, NumClientSpecs, ClientSpecs), cookie)
	return UnregisterClientsCookie{cookie}
}

func (cook UnregisterClientsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UnregisterClients
func unregisterClientsRequest(c *xgb.Conn, Context Context, NumClientSpecs uint32, ClientSpecs []ClientSpec) []byte {
	size := xgb.Pad((12 + xgb.Pad((int(NumClientSpecs) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RECORD"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Context))
	b += 4

	xgb.Put32(buf[b:], NumClientSpecs)
	b += 4

	for i := 0; i < int(NumClientSpecs); i++ {
		xgb.Put32(buf[b:], uint32(ClientSpecs[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request GetContext
// size: 8
type GetContextCookie struct {
	*xgb.Cookie
}

func GetContext(c *xgb.Conn, Context Context) GetContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getContextRequest(c, Context), cookie)
	return GetContextCookie{cookie}
}

func GetContextUnchecked(c *xgb.Conn, Context Context) GetContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getContextRequest(c, Context), cookie)
	return GetContextCookie{cookie}
}

// Request reply for GetContext
// size: (32 + ClientInfoListSize(InterceptedClients))
type GetContextReply struct {
	Sequence      uint16
	Length        uint32
	Enabled       bool
	ElementHeader ElementHeader
	// padding: 3 bytes
	NumInterceptedClients uint32
	// padding: 16 bytes
	InterceptedClients []ClientInfo // size: ClientInfoListSize(InterceptedClients)
}

// Waits and reads reply data from request GetContext
func (cook GetContextCookie) Reply() (*GetContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getContextReply(buf), nil
}

// Read reply into structure from buffer for GetContext
func getContextReply(buf []byte) *GetContextReply {
	v := new(GetContextReply)
	b := 1 // skip reply determinant

	if buf[b] == 1 {
		v.Enabled = true
	} else {
		v.Enabled = false
	}
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ElementHeader = ElementHeader(buf[b])
	b += 1

	b += 3 // padding

	v.NumInterceptedClients = xgb.Get32(buf[b:])
	b += 4

	b += 16 // padding

	v.InterceptedClients = make([]ClientInfo, v.NumInterceptedClients)
	b += ClientInfoReadList(buf[b:], v.InterceptedClients)

	return v
}

// Write request to wire for GetContext
func getContextRequest(c *xgb.Conn, Context Context) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RECORD"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Context))
	b += 4

	return buf
}

// Request EnableContext
// size: 8
type EnableContextCookie struct {
	*xgb.Cookie
}

func EnableContext(c *xgb.Conn, Context Context) EnableContextCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(enableContextRequest(c, Context), cookie)
	return EnableContextCookie{cookie}
}

func EnableContextUnchecked(c *xgb.Conn, Context Context) EnableContextCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(enableContextRequest(c, Context), cookie)
	return EnableContextCookie{cookie}
}

// Request reply for EnableContext
// size: (32 + xgb.Pad(((int(Length) * 4) * 1)))
type EnableContextReply struct {
	Sequence      uint16
	Length        uint32
	Category      byte
	ElementHeader ElementHeader
	ClientSwapped bool
	// padding: 2 bytes
	XidBase        uint32
	ServerTime     uint32
	RecSequenceNum uint32
	// padding: 8 bytes
	Data []byte // size: xgb.Pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request EnableContext
func (cook EnableContextCookie) Reply() (*EnableContextReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return enableContextReply(buf), nil
}

// Read reply into structure from buffer for EnableContext
func enableContextReply(buf []byte) *EnableContextReply {
	v := new(EnableContextReply)
	b := 1 // skip reply determinant

	v.Category = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ElementHeader = ElementHeader(buf[b])
	b += 1

	if buf[b] == 1 {
		v.ClientSwapped = true
	} else {
		v.ClientSwapped = false
	}
	b += 1

	b += 2 // padding

	v.XidBase = xgb.Get32(buf[b:])
	b += 4

	v.ServerTime = xgb.Get32(buf[b:])
	b += 4

	v.RecSequenceNum = xgb.Get32(buf[b:])
	b += 4

	b += 8 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += xgb.Pad(int((int(v.Length) * 4)))

	return v
}

// Write request to wire for EnableContext
func enableContextRequest(c *xgb.Conn, Context Context) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RECORD"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Context))
	b += 4

	return buf
}

// Request DisableContext
// size: 8
type DisableContextCookie struct {
	*xgb.Cookie
}

// Write request to wire for DisableContext
func DisableContext(c *xgb.Conn, Context Context) DisableContextCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(disableContextRequest(c, Context), cookie)
	return DisableContextCookie{cookie}
}

func DisableContextChecked(c *xgb.Conn, Context Context) DisableContextCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(disableContextRequest(c, Context), cookie)
	return DisableContextCookie{cookie}
}

func (cook DisableContextCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DisableContext
func disableContextRequest(c *xgb.Conn, Context Context) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RECORD"]
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Context))
	b += 4

	return buf
}

// Request FreeContext
// size: 8
type FreeContextCookie struct {
	*xgb.Cookie
}

// Write request to wire for FreeContext
func FreeContext(c *xgb.Conn, Context Context) FreeContextCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(freeContextRequest(c, Context), cookie)
	return FreeContextCookie{cookie}
}

func FreeContextChecked(c *xgb.Conn, Context Context) FreeContextCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(freeContextRequest(c, Context), cookie)
	return FreeContextCookie{cookie}
}

func (cook FreeContextCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for FreeContext
func freeContextRequest(c *xgb.Conn, Context Context) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RECORD"]
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Context))
	b += 4

	return buf
}
