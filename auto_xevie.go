package xgb

/*
	This file was generated by xevie.xml on May 6 2012 5:48:47pm EDT.
	This file is automatically generated. Edit at your peril!
*/

// XevieInit must be called before using the XEVIE extension.
func (c *Conn) XevieInit() error {
	reply, err := c.QueryExtension(5, "XEVIE").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return newError("No extension named XEVIE could be found on on the server.")
	}

	c.extLock.Lock()
	c.extensions["XEVIE"] = reply.MajorOpcode
	for evNum, fun := range newExtEventFuncs["XEVIE"] {
		newEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	c.extLock.Unlock()

	return nil
}

func init() {
	newExtEventFuncs["XEVIE"] = make(map[int]newEventFun)
}

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Id'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

const (
	XevieDatatypeUnmodified = 0
	XevieDatatypeModified   = 1
)

// 'XevieEvent' struct definition
// Size: 32
type XevieEvent struct {
	// padding: 32 bytes
}

// Struct read XevieEvent
func ReadXevieEvent(buf []byte, v *XevieEvent) int {
	b := 0

	b += 32 // padding

	return b
}

// Struct list read XevieEvent
func ReadXevieEventList(buf []byte, dest []XevieEvent) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = XevieEvent{}
		b += ReadXevieEvent(buf[b:], &dest[i])
	}
	return pad(b)
}

// Struct write XevieEvent
func (v XevieEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	b += 32 // padding

	return buf
}

// Write struct list XevieEvent
func XevieEventListBytes(buf []byte, list []XevieEvent) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}
	return b
}

// Request XevieQueryVersion
// size: 8
type XevieQueryVersionCookie struct {
	*cookie
}

func (c *Conn) XevieQueryVersion(ClientMajorVersion uint16, ClientMinorVersion uint16) XevieQueryVersionCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xevieQueryVersionRequest(ClientMajorVersion, ClientMinorVersion), cookie)
	return XevieQueryVersionCookie{cookie}
}

func (c *Conn) XevieQueryVersionUnchecked(ClientMajorVersion uint16, ClientMinorVersion uint16) XevieQueryVersionCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xevieQueryVersionRequest(ClientMajorVersion, ClientMinorVersion), cookie)
	return XevieQueryVersionCookie{cookie}
}

// Request reply for XevieQueryVersion
// size: 32
type XevieQueryVersionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ServerMajorVersion uint16
	ServerMinorVersion uint16
	// padding: 20 bytes
}

// Waits and reads reply data from request XevieQueryVersion
func (cook XevieQueryVersionCookie) Reply() (*XevieQueryVersionReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xevieQueryVersionReply(buf), nil
}

// Read reply into structure from buffer for XevieQueryVersion
func xevieQueryVersionReply(buf []byte) *XevieQueryVersionReply {
	v := new(XevieQueryVersionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	v.ServerMajorVersion = Get16(buf[b:])
	b += 2

	v.ServerMinorVersion = Get16(buf[b:])
	b += 2

	b += 20 // padding

	return v
}

func (cook XevieQueryVersionCookie) Check() error {
	return cook.check()
}

// Write request to wire for XevieQueryVersion
func (c *Conn) xevieQueryVersionRequest(ClientMajorVersion uint16, ClientMinorVersion uint16) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XEVIE"]
	b += 1

	buf[b] = 0 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put16(buf[b:], ClientMajorVersion)
	b += 2

	Put16(buf[b:], ClientMinorVersion)
	b += 2

	return buf
}

// Request XevieStart
// size: 8
type XevieStartCookie struct {
	*cookie
}

func (c *Conn) XevieStart(Screen uint32) XevieStartCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xevieStartRequest(Screen), cookie)
	return XevieStartCookie{cookie}
}

func (c *Conn) XevieStartUnchecked(Screen uint32) XevieStartCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xevieStartRequest(Screen), cookie)
	return XevieStartCookie{cookie}
}

// Request reply for XevieStart
// size: 32
type XevieStartReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
}

// Waits and reads reply data from request XevieStart
func (cook XevieStartCookie) Reply() (*XevieStartReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xevieStartReply(buf), nil
}

// Read reply into structure from buffer for XevieStart
func xevieStartReply(buf []byte) *XevieStartReply {
	v := new(XevieStartReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	return v
}

func (cook XevieStartCookie) Check() error {
	return cook.check()
}

// Write request to wire for XevieStart
func (c *Conn) xevieStartRequest(Screen uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XEVIE"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], Screen)
	b += 4

	return buf
}

// Request XevieEnd
// size: 8
type XevieEndCookie struct {
	*cookie
}

func (c *Conn) XevieEnd(Cmap uint32) XevieEndCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xevieEndRequest(Cmap), cookie)
	return XevieEndCookie{cookie}
}

func (c *Conn) XevieEndUnchecked(Cmap uint32) XevieEndCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xevieEndRequest(Cmap), cookie)
	return XevieEndCookie{cookie}
}

// Request reply for XevieEnd
// size: 32
type XevieEndReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
}

// Waits and reads reply data from request XevieEnd
func (cook XevieEndCookie) Reply() (*XevieEndReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xevieEndReply(buf), nil
}

// Read reply into structure from buffer for XevieEnd
func xevieEndReply(buf []byte) *XevieEndReply {
	v := new(XevieEndReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	return v
}

func (cook XevieEndCookie) Check() error {
	return cook.check()
}

// Write request to wire for XevieEnd
func (c *Conn) xevieEndRequest(Cmap uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XEVIE"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], Cmap)
	b += 4

	return buf
}

// Request XevieSend
// size: 104
type XevieSendCookie struct {
	*cookie
}

func (c *Conn) XevieSend(Event XevieEvent, DataType uint32) XevieSendCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xevieSendRequest(Event, DataType), cookie)
	return XevieSendCookie{cookie}
}

func (c *Conn) XevieSendUnchecked(Event XevieEvent, DataType uint32) XevieSendCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xevieSendRequest(Event, DataType), cookie)
	return XevieSendCookie{cookie}
}

// Request reply for XevieSend
// size: 32
type XevieSendReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
}

// Waits and reads reply data from request XevieSend
func (cook XevieSendCookie) Reply() (*XevieSendReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xevieSendReply(buf), nil
}

// Read reply into structure from buffer for XevieSend
func xevieSendReply(buf []byte) *XevieSendReply {
	v := new(XevieSendReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	return v
}

func (cook XevieSendCookie) Check() error {
	return cook.check()
}

// Write request to wire for XevieSend
func (c *Conn) xevieSendRequest(Event XevieEvent, DataType uint32) []byte {
	size := 104
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XEVIE"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	{
		structBytes := Event.Bytes()
		copy(buf[b:], structBytes)
		b += pad(len(structBytes))
	}

	Put32(buf[b:], DataType)
	b += 4

	b += 64 // padding

	return buf
}

// Request XevieSelectInput
// size: 8
type XevieSelectInputCookie struct {
	*cookie
}

func (c *Conn) XevieSelectInput(EventMask uint32) XevieSelectInputCookie {
	cookie := c.newCookie(true, true)
	c.newRequest(c.xevieSelectInputRequest(EventMask), cookie)
	return XevieSelectInputCookie{cookie}
}

func (c *Conn) XevieSelectInputUnchecked(EventMask uint32) XevieSelectInputCookie {
	cookie := c.newCookie(false, true)
	c.newRequest(c.xevieSelectInputRequest(EventMask), cookie)
	return XevieSelectInputCookie{cookie}
}

// Request reply for XevieSelectInput
// size: 32
type XevieSelectInputReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	// padding: 24 bytes
}

// Waits and reads reply data from request XevieSelectInput
func (cook XevieSelectInputCookie) Reply() (*XevieSelectInputReply, error) {
	buf, err := cook.reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return xevieSelectInputReply(buf), nil
}

// Read reply into structure from buffer for XevieSelectInput
func xevieSelectInputReply(buf []byte) *XevieSelectInputReply {
	v := new(XevieSelectInputReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = Get16(buf[b:])
	b += 2

	v.Length = Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	return v
}

func (cook XevieSelectInputCookie) Check() error {
	return cook.check()
}

// Write request to wire for XevieSelectInput
func (c *Conn) xevieSelectInputRequest(EventMask uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.extensions["XEVIE"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	Put32(buf[b:], EventMask)
	b += 4

	return buf
}
