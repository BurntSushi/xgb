// Package randr is the X client API for the RANDR extension.
package randr

/*
	This file was generated by randr.xml on May 10 2012 8:04:31pm EDT.
	This file is automatically generated. Edit at your peril!
*/

import (
	"github.com/BurntSushi/xgb"

	"github.com/BurntSushi/xgb/render"
	"github.com/BurntSushi/xgb/xproto"
)

// Init must be called before using the RANDR extension.
func Init(c *xgb.Conn) error {
	reply, err := xproto.QueryExtension(c, 5, "RANDR").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return xgb.Errorf("No extension named RANDR could be found on on the server.")
	}

	xgb.ExtLock.Lock()
	c.Extensions["RANDR"] = reply.MajorOpcode
	for evNum, fun := range xgb.NewExtEventFuncs["RANDR"] {
		xgb.NewEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range xgb.NewExtErrorFuncs["RANDR"] {
		xgb.NewErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	xgb.ExtLock.Unlock()

	return nil
}

func init() {
	xgb.NewExtEventFuncs["RANDR"] = make(map[int]xgb.NewEventFun)
	xgb.NewExtErrorFuncs["RANDR"] = make(map[int]xgb.NewErrorFun)
}

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

const (
	RotationRotate0   = 1
	RotationRotate90  = 2
	RotationRotate180 = 4
	RotationRotate270 = 8
	RotationReflectX  = 16
	RotationReflectY  = 32
)

const (
	SetConfigSuccess           = 0
	SetConfigInvalidConfigTime = 1
	SetConfigInvalidTime       = 2
	SetConfigFailed            = 3
)

const (
	NotifyMaskScreenChange   = 1
	NotifyMaskCrtcChange     = 2
	NotifyMaskOutputChange   = 4
	NotifyMaskOutputProperty = 8
)

const (
	ModeFlagHsyncPositive  = 1
	ModeFlagHsyncNegative  = 2
	ModeFlagVsyncPositive  = 4
	ModeFlagVsyncNegative  = 8
	ModeFlagInterlace      = 16
	ModeFlagDoubleScan     = 32
	ModeFlagCsync          = 64
	ModeFlagCsyncPositive  = 128
	ModeFlagCsyncNegative  = 256
	ModeFlagHskewPresent   = 512
	ModeFlagBcast          = 1024
	ModeFlagPixelMultiplex = 2048
	ModeFlagDoubleClock    = 4096
	ModeFlagHalveClock     = 8192
)

const (
	ConnectionConnected    = 0
	ConnectionDisconnected = 1
	ConnectionUnknown      = 2
)

const (
	NotifyCrtcChange     = 0
	NotifyOutputChange   = 1
	NotifyOutputProperty = 2
)

type Mode uint32

func NewModeId(c *xgb.Conn) (Mode, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Mode(id), nil
}

type Crtc uint32

func NewCrtcId(c *xgb.Conn) (Crtc, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Crtc(id), nil
}

type Output uint32

func NewOutputId(c *xgb.Conn) (Output, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Output(id), nil
}

// 'ScreenSize' struct definition
// Size: 8
type ScreenSize struct {
	Width   uint16
	Height  uint16
	Mwidth  uint16
	Mheight uint16
}

// Struct read ScreenSize
func ScreenSizeRead(buf []byte, v *ScreenSize) int {
	b := 0

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	v.Mwidth = xgb.Get16(buf[b:])
	b += 2

	v.Mheight = xgb.Get16(buf[b:])
	b += 2

	return b
}

// Struct list read ScreenSize
func ScreenSizeReadList(buf []byte, dest []ScreenSize) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ScreenSize{}
		b += ScreenSizeRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write ScreenSize
func (v ScreenSize) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put16(buf[b:], v.Width)
	b += 2

	xgb.Put16(buf[b:], v.Height)
	b += 2

	xgb.Put16(buf[b:], v.Mwidth)
	b += 2

	xgb.Put16(buf[b:], v.Mheight)
	b += 2

	return buf
}

// Write struct list ScreenSize
func ScreenSizeListBytes(buf []byte, list []ScreenSize) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'RefreshRates' struct definition
// Size: (2 + xgb.Pad((int(NRates) * 2)))
type RefreshRates struct {
	NRates uint16
	Rates  []uint16 // size: xgb.Pad((int(NRates) * 2))
}

// Struct read RefreshRates
func RefreshRatesRead(buf []byte, v *RefreshRates) int {
	b := 0

	v.NRates = xgb.Get16(buf[b:])
	b += 2

	v.Rates = make([]uint16, v.NRates)
	for i := 0; i < int(v.NRates); i++ {
		v.Rates[i] = xgb.Get16(buf[b:])
		b += 2
	}
	b = xgb.Pad(b)

	return b
}

// Struct list read RefreshRates
func RefreshRatesReadList(buf []byte, dest []RefreshRates) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = RefreshRates{}
		b += RefreshRatesRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write RefreshRates
func (v RefreshRates) Bytes() []byte {
	buf := make([]byte, (2 + xgb.Pad((int(v.NRates) * 2))))
	b := 0

	xgb.Put16(buf[b:], v.NRates)
	b += 2

	for i := 0; i < int(v.NRates); i++ {
		xgb.Put16(buf[b:], v.Rates[i])
		b += 2
	}
	b = xgb.Pad(b)

	return buf
}

// Write struct list RefreshRates
func RefreshRatesListBytes(buf []byte, list []RefreshRates) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size RefreshRates
func RefreshRatesListSize(list []RefreshRates) int {
	size := 0
	for _, item := range list {
		size += (2 + xgb.Pad((int(item.NRates) * 2)))
	}
	return size
}

// 'ModeInfo' struct definition
// Size: 32
type ModeInfo struct {
	Id         uint32
	Width      uint16
	Height     uint16
	DotClock   uint32
	HsyncStart uint16
	HsyncEnd   uint16
	Htotal     uint16
	Hskew      uint16
	VsyncStart uint16
	VsyncEnd   uint16
	Vtotal     uint16
	NameLen    uint16
	ModeFlags  uint32
}

// Struct read ModeInfo
func ModeInfoRead(buf []byte, v *ModeInfo) int {
	b := 0

	v.Id = xgb.Get32(buf[b:])
	b += 4

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	v.DotClock = xgb.Get32(buf[b:])
	b += 4

	v.HsyncStart = xgb.Get16(buf[b:])
	b += 2

	v.HsyncEnd = xgb.Get16(buf[b:])
	b += 2

	v.Htotal = xgb.Get16(buf[b:])
	b += 2

	v.Hskew = xgb.Get16(buf[b:])
	b += 2

	v.VsyncStart = xgb.Get16(buf[b:])
	b += 2

	v.VsyncEnd = xgb.Get16(buf[b:])
	b += 2

	v.Vtotal = xgb.Get16(buf[b:])
	b += 2

	v.NameLen = xgb.Get16(buf[b:])
	b += 2

	v.ModeFlags = xgb.Get32(buf[b:])
	b += 4

	return b
}

// Struct list read ModeInfo
func ModeInfoReadList(buf []byte, dest []ModeInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ModeInfo{}
		b += ModeInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write ModeInfo
func (v ModeInfo) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	xgb.Put32(buf[b:], v.Id)
	b += 4

	xgb.Put16(buf[b:], v.Width)
	b += 2

	xgb.Put16(buf[b:], v.Height)
	b += 2

	xgb.Put32(buf[b:], v.DotClock)
	b += 4

	xgb.Put16(buf[b:], v.HsyncStart)
	b += 2

	xgb.Put16(buf[b:], v.HsyncEnd)
	b += 2

	xgb.Put16(buf[b:], v.Htotal)
	b += 2

	xgb.Put16(buf[b:], v.Hskew)
	b += 2

	xgb.Put16(buf[b:], v.VsyncStart)
	b += 2

	xgb.Put16(buf[b:], v.VsyncEnd)
	b += 2

	xgb.Put16(buf[b:], v.Vtotal)
	b += 2

	xgb.Put16(buf[b:], v.NameLen)
	b += 2

	xgb.Put32(buf[b:], v.ModeFlags)
	b += 4

	return buf
}

// Write struct list ModeInfo
func ModeInfoListBytes(buf []byte, list []ModeInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'CrtcChange' struct definition
// Size: 28
type CrtcChange struct {
	Timestamp xproto.Timestamp
	Window    xproto.Window
	Crtc      Crtc
	Mode      Mode
	Rotation  uint16
	// padding: 2 bytes
	X      int16
	Y      int16
	Width  uint16
	Height uint16
}

// Struct read CrtcChange
func CrtcChangeRead(buf []byte, v *CrtcChange) int {
	b := 0

	v.Timestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Window = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.Crtc = Crtc(xgb.Get32(buf[b:]))
	b += 4

	v.Mode = Mode(xgb.Get32(buf[b:]))
	b += 4

	v.Rotation = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.X = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Y = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	return b
}

// Struct list read CrtcChange
func CrtcChangeReadList(buf []byte, dest []CrtcChange) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = CrtcChange{}
		b += CrtcChangeRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write CrtcChange
func (v CrtcChange) Bytes() []byte {
	buf := make([]byte, 28)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Timestamp))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Crtc))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Mode))
	b += 4

	xgb.Put16(buf[b:], v.Rotation)
	b += 2

	b += 2 // padding

	xgb.Put16(buf[b:], uint16(v.X))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Y))
	b += 2

	xgb.Put16(buf[b:], v.Width)
	b += 2

	xgb.Put16(buf[b:], v.Height)
	b += 2

	return buf
}

// Write struct list CrtcChange
func CrtcChangeListBytes(buf []byte, list []CrtcChange) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'OutputChange' struct definition
// Size: 28
type OutputChange struct {
	Timestamp       xproto.Timestamp
	ConfigTimestamp xproto.Timestamp
	Window          xproto.Window
	Output          Output
	Crtc            Crtc
	Mode            Mode
	Rotation        uint16
	Connection      byte
	SubpixelOrder   byte
}

// Struct read OutputChange
func OutputChangeRead(buf []byte, v *OutputChange) int {
	b := 0

	v.Timestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.ConfigTimestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Window = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.Output = Output(xgb.Get32(buf[b:]))
	b += 4

	v.Crtc = Crtc(xgb.Get32(buf[b:]))
	b += 4

	v.Mode = Mode(xgb.Get32(buf[b:]))
	b += 4

	v.Rotation = xgb.Get16(buf[b:])
	b += 2

	v.Connection = buf[b]
	b += 1

	v.SubpixelOrder = buf[b]
	b += 1

	return b
}

// Struct list read OutputChange
func OutputChangeReadList(buf []byte, dest []OutputChange) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = OutputChange{}
		b += OutputChangeRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write OutputChange
func (v OutputChange) Bytes() []byte {
	buf := make([]byte, 28)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Timestamp))
	b += 4

	xgb.Put32(buf[b:], uint32(v.ConfigTimestamp))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Output))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Crtc))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Mode))
	b += 4

	xgb.Put16(buf[b:], v.Rotation)
	b += 2

	buf[b] = v.Connection
	b += 1

	buf[b] = v.SubpixelOrder
	b += 1

	return buf
}

// Write struct list OutputChange
func OutputChangeListBytes(buf []byte, list []OutputChange) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'OutputProperty' struct definition
// Size: 28
type OutputProperty struct {
	Window    xproto.Window
	Output    Output
	Atom      xproto.Atom
	Timestamp xproto.Timestamp
	Status    byte
	// padding: 11 bytes
}

// Struct read OutputProperty
func OutputPropertyRead(buf []byte, v *OutputProperty) int {
	b := 0

	v.Window = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.Output = Output(xgb.Get32(buf[b:]))
	b += 4

	v.Atom = xproto.Atom(xgb.Get32(buf[b:]))
	b += 4

	v.Timestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Status = buf[b]
	b += 1

	b += 11 // padding

	return b
}

// Struct list read OutputProperty
func OutputPropertyReadList(buf []byte, dest []OutputProperty) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = OutputProperty{}
		b += OutputPropertyRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write OutputProperty
func (v OutputProperty) Bytes() []byte {
	buf := make([]byte, 28)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Output))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Atom))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Timestamp))
	b += 4

	buf[b] = v.Status
	b += 1

	b += 11 // padding

	return buf
}

// Write struct list OutputProperty
func OutputPropertyListBytes(buf []byte, list []OutputProperty) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Union definition NotifyDataUnion
// Note that to *create* a Union, you should *never* create
// this struct directly (unless you know what you're doing).
// Instead use one of the following constructors for 'NotifyDataUnion':
//     NotifyDataUnionCcNew(Cc CrtcChange) NotifyDataUnion
//     NotifyDataUnionOcNew(Oc OutputChange) NotifyDataUnion
//     NotifyDataUnionOpNew(Op OutputProperty) NotifyDataUnion
type NotifyDataUnion struct {
	Cc CrtcChange
	Oc OutputChange
	Op OutputProperty
}

// Union constructor for NotifyDataUnion for field Cc.
func NotifyDataUnionCcNew(Cc CrtcChange) NotifyDataUnion {
	var b int
	buf := make([]byte, 28)

	{
		structBytes := Cc.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	// Create the Union type
	v := NotifyDataUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Cc = CrtcChange{}
	b += CrtcChangeRead(buf[b:], &v.Cc)

	b = 0 // always read the same bytes
	v.Oc = OutputChange{}
	b += OutputChangeRead(buf[b:], &v.Oc)

	b = 0 // always read the same bytes
	v.Op = OutputProperty{}
	b += OutputPropertyRead(buf[b:], &v.Op)

	return v
}

// Union constructor for NotifyDataUnion for field Oc.
func NotifyDataUnionOcNew(Oc OutputChange) NotifyDataUnion {
	var b int
	buf := make([]byte, 28)

	{
		structBytes := Oc.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	// Create the Union type
	v := NotifyDataUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Cc = CrtcChange{}
	b += CrtcChangeRead(buf[b:], &v.Cc)

	b = 0 // always read the same bytes
	v.Oc = OutputChange{}
	b += OutputChangeRead(buf[b:], &v.Oc)

	b = 0 // always read the same bytes
	v.Op = OutputProperty{}
	b += OutputPropertyRead(buf[b:], &v.Op)

	return v
}

// Union constructor for NotifyDataUnion for field Op.
func NotifyDataUnionOpNew(Op OutputProperty) NotifyDataUnion {
	var b int
	buf := make([]byte, 28)

	{
		structBytes := Op.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	// Create the Union type
	v := NotifyDataUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Cc = CrtcChange{}
	b += CrtcChangeRead(buf[b:], &v.Cc)

	b = 0 // always read the same bytes
	v.Oc = OutputChange{}
	b += OutputChangeRead(buf[b:], &v.Oc)

	b = 0 // always read the same bytes
	v.Op = OutputProperty{}
	b += OutputPropertyRead(buf[b:], &v.Op)

	return v
}

// Union read NotifyDataUnion
func NotifyDataUnionRead(buf []byte, v *NotifyDataUnion) int {
	var b int

	b = 0 // re-read the same bytes
	v.Cc = CrtcChange{}
	b += CrtcChangeRead(buf[b:], &v.Cc)

	b = 0 // re-read the same bytes
	v.Oc = OutputChange{}
	b += OutputChangeRead(buf[b:], &v.Oc)

	b = 0 // re-read the same bytes
	v.Op = OutputProperty{}
	b += OutputPropertyRead(buf[b:], &v.Op)

	return 28
}

// Union list read NotifyDataUnion
func NotifyDataUnionReadList(buf []byte, dest []NotifyDataUnion) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = NotifyDataUnion{}
		b += NotifyDataUnionRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Union write NotifyDataUnion
// Each field in a union must contain the same data.
// So simply pick the first field and write that to the wire.
func (v NotifyDataUnion) Bytes() []byte {
	buf := make([]byte, 28)
	b := 0

	{
		structBytes := v.Cc.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return buf
}

// Union list write NotifyDataUnion
func NotifyDataUnionListBytes(buf []byte, list []NotifyDataUnion) int {
	b := 0
	var unionBytes []byte
	for _, item := range list {
		unionBytes = item.Bytes()
		copy(buf[b:], unionBytes)
		b += xgb.Pad(len(unionBytes))
	}
	return b
}

// Event definition ScreenChangeNotify (0)
// Size: 32

const ScreenChangeNotify = 0

type ScreenChangeNotifyEvent struct {
	Sequence        uint16
	Rotation        byte
	Timestamp       xproto.Timestamp
	ConfigTimestamp xproto.Timestamp
	Root            xproto.Window
	RequestWindow   xproto.Window
	SizeID          uint16
	SubpixelOrder   uint16
	Width           uint16
	Height          uint16
	Mwidth          uint16
	Mheight         uint16
}

// Event read ScreenChangeNotify
func ScreenChangeNotifyEventNew(buf []byte) xgb.Event {
	v := ScreenChangeNotifyEvent{}
	b := 1 // don't read event number

	v.Rotation = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Timestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.ConfigTimestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Root = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.RequestWindow = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.SizeID = xgb.Get16(buf[b:])
	b += 2

	v.SubpixelOrder = xgb.Get16(buf[b:])
	b += 2

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	v.Mwidth = xgb.Get16(buf[b:])
	b += 2

	v.Mheight = xgb.Get16(buf[b:])
	b += 2

	return v
}

// Event write ScreenChangeNotify
func (v ScreenChangeNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 0
	b += 1

	buf[b] = v.Rotation
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Timestamp))
	b += 4

	xgb.Put32(buf[b:], uint32(v.ConfigTimestamp))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Root))
	b += 4

	xgb.Put32(buf[b:], uint32(v.RequestWindow))
	b += 4

	xgb.Put16(buf[b:], v.SizeID)
	b += 2

	xgb.Put16(buf[b:], v.SubpixelOrder)
	b += 2

	xgb.Put16(buf[b:], v.Width)
	b += 2

	xgb.Put16(buf[b:], v.Height)
	b += 2

	xgb.Put16(buf[b:], v.Mwidth)
	b += 2

	xgb.Put16(buf[b:], v.Mheight)
	b += 2

	return buf
}

func (v ScreenChangeNotifyEvent) ImplementsEvent() {}

func (v ScreenChangeNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v ScreenChangeNotifyEvent) String() string {
	fieldVals := make([]string, 0, 11)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Rotation: %d", v.Rotation))
	fieldVals = append(fieldVals, xgb.Sprintf("Timestamp: %d", v.Timestamp))
	fieldVals = append(fieldVals, xgb.Sprintf("ConfigTimestamp: %d", v.ConfigTimestamp))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("RequestWindow: %d", v.RequestWindow))
	fieldVals = append(fieldVals, xgb.Sprintf("SizeID: %d", v.SizeID))
	fieldVals = append(fieldVals, xgb.Sprintf("SubpixelOrder: %d", v.SubpixelOrder))
	fieldVals = append(fieldVals, xgb.Sprintf("Width: %d", v.Width))
	fieldVals = append(fieldVals, xgb.Sprintf("Height: %d", v.Height))
	fieldVals = append(fieldVals, xgb.Sprintf("Mwidth: %d", v.Mwidth))
	fieldVals = append(fieldVals, xgb.Sprintf("Mheight: %d", v.Mheight))
	return "ScreenChangeNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["RANDR"][0] = ScreenChangeNotifyEventNew
}

// Event definition Notify (1)
// Size: 32

const Notify = 1

type NotifyEvent struct {
	Sequence uint16
	SubCode  byte
	U        NotifyDataUnion
}

// Event read Notify
func NotifyEventNew(buf []byte) xgb.Event {
	v := NotifyEvent{}
	b := 1 // don't read event number

	v.SubCode = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.U = NotifyDataUnion{}
	b += NotifyDataUnionRead(buf[b:], &v.U)

	return v
}

// Event write Notify
func (v NotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 1
	b += 1

	buf[b] = v.SubCode
	b += 1

	b += 2 // skip sequence number

	{
		unionBytes := v.U.Bytes()
		copy(buf[b:], unionBytes)
		b += xgb.Pad(len(unionBytes))
	}

	return buf
}

func (v NotifyEvent) ImplementsEvent() {}

func (v NotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v NotifyEvent) String() string {
	fieldVals := make([]string, 0, 2)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("SubCode: %d", v.SubCode))
	return "Notify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["RANDR"][1] = NotifyEventNew
}

// Error definition BadOutput (0)
// Size: 32

const BadBadOutput = 0

type BadOutputError struct {
	Sequence uint16
	NiceName string
}

// Error read BadOutput
func BadOutputErrorNew(buf []byte) xgb.Error {
	v := BadOutputError{}
	v.NiceName = "BadOutput"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

func (err BadOutputError) ImplementsError() {}

func (err BadOutputError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadOutputError) BadId() uint32 {
	return 0
}

func (err BadOutputError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadBadOutput {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["RANDR"][0] = BadOutputErrorNew
}

// Error definition BadCrtc (1)
// Size: 32

const BadBadCrtc = 1

type BadCrtcError struct {
	Sequence uint16
	NiceName string
}

// Error read BadCrtc
func BadCrtcErrorNew(buf []byte) xgb.Error {
	v := BadCrtcError{}
	v.NiceName = "BadCrtc"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

func (err BadCrtcError) ImplementsError() {}

func (err BadCrtcError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadCrtcError) BadId() uint32 {
	return 0
}

func (err BadCrtcError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadBadCrtc {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["RANDR"][1] = BadCrtcErrorNew
}

// Error definition BadMode (2)
// Size: 32

const BadBadMode = 2

type BadModeError struct {
	Sequence uint16
	NiceName string
}

// Error read BadMode
func BadModeErrorNew(buf []byte) xgb.Error {
	v := BadModeError{}
	v.NiceName = "BadMode"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

func (err BadModeError) ImplementsError() {}

func (err BadModeError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadModeError) BadId() uint32 {
	return 0
}

func (err BadModeError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadBadMode {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["RANDR"][2] = BadModeErrorNew
}

// Request QueryVersion
// size: 12
type QueryVersionCookie struct {
	*xgb.Cookie
}

func QueryVersion(c *xgb.Conn, MajorVersion uint32, MinorVersion uint32) QueryVersionCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryVersionRequest(c, MajorVersion, MinorVersion), cookie)
	return QueryVersionCookie{cookie}
}

func QueryVersionUnchecked(c *xgb.Conn, MajorVersion uint32, MinorVersion uint32) QueryVersionCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryVersionRequest(c, MajorVersion, MinorVersion), cookie)
	return QueryVersionCookie{cookie}
}

// Request reply for QueryVersion
// size: 32
type QueryVersionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	MajorVersion uint32
	MinorVersion uint32
	// padding: 16 bytes
}

// Waits and reads reply data from request QueryVersion
func (cook QueryVersionCookie) Reply() (*QueryVersionReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryVersionReply(buf), nil
}

// Read reply into structure from buffer for QueryVersion
func queryVersionReply(buf []byte) *QueryVersionReply {
	v := new(QueryVersionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.MajorVersion = xgb.Get32(buf[b:])
	b += 4

	v.MinorVersion = xgb.Get32(buf[b:])
	b += 4

	b += 16 // padding

	return v
}

// Write request to wire for QueryVersion
func queryVersionRequest(c *xgb.Conn, MajorVersion uint32, MinorVersion uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 0 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], MajorVersion)
	b += 4

	xgb.Put32(buf[b:], MinorVersion)
	b += 4

	return buf
}

// Request SetScreenConfig
// size: 24
type SetScreenConfigCookie struct {
	*xgb.Cookie
}

func SetScreenConfig(c *xgb.Conn, Window xproto.Window, Timestamp xproto.Timestamp, ConfigTimestamp xproto.Timestamp, SizeID uint16, Rotation uint16, Rate uint16) SetScreenConfigCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(setScreenConfigRequest(c, Window, Timestamp, ConfigTimestamp, SizeID, Rotation, Rate), cookie)
	return SetScreenConfigCookie{cookie}
}

func SetScreenConfigUnchecked(c *xgb.Conn, Window xproto.Window, Timestamp xproto.Timestamp, ConfigTimestamp xproto.Timestamp, SizeID uint16, Rotation uint16, Rate uint16) SetScreenConfigCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(setScreenConfigRequest(c, Window, Timestamp, ConfigTimestamp, SizeID, Rotation, Rate), cookie)
	return SetScreenConfigCookie{cookie}
}

// Request reply for SetScreenConfig
// size: 32
type SetScreenConfigReply struct {
	Sequence        uint16
	Length          uint32
	Status          byte
	NewTimestamp    xproto.Timestamp
	ConfigTimestamp xproto.Timestamp
	Root            xproto.Window
	SubpixelOrder   uint16
	// padding: 10 bytes
}

// Waits and reads reply data from request SetScreenConfig
func (cook SetScreenConfigCookie) Reply() (*SetScreenConfigReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return setScreenConfigReply(buf), nil
}

// Read reply into structure from buffer for SetScreenConfig
func setScreenConfigReply(buf []byte) *SetScreenConfigReply {
	v := new(SetScreenConfigReply)
	b := 1 // skip reply determinant

	v.Status = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NewTimestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.ConfigTimestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Root = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.SubpixelOrder = xgb.Get16(buf[b:])
	b += 2

	b += 10 // padding

	return v
}

// Write request to wire for SetScreenConfig
func setScreenConfigRequest(c *xgb.Conn, Window xproto.Window, Timestamp xproto.Timestamp, ConfigTimestamp xproto.Timestamp, SizeID uint16, Rotation uint16, Rate uint16) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put32(buf[b:], uint32(Timestamp))
	b += 4

	xgb.Put32(buf[b:], uint32(ConfigTimestamp))
	b += 4

	xgb.Put16(buf[b:], SizeID)
	b += 2

	xgb.Put16(buf[b:], Rotation)
	b += 2

	xgb.Put16(buf[b:], Rate)
	b += 2

	b += 2 // padding

	return buf
}

// Request SelectInput
// size: 12
type SelectInputCookie struct {
	*xgb.Cookie
}

// Write request to wire for SelectInput
func SelectInput(c *xgb.Conn, Window xproto.Window, Enable uint16) SelectInputCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(selectInputRequest(c, Window, Enable), cookie)
	return SelectInputCookie{cookie}
}

func SelectInputChecked(c *xgb.Conn, Window xproto.Window, Enable uint16) SelectInputCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(selectInputRequest(c, Window, Enable), cookie)
	return SelectInputCookie{cookie}
}

func (cook SelectInputCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SelectInput
func selectInputRequest(c *xgb.Conn, Window xproto.Window, Enable uint16) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put16(buf[b:], Enable)
	b += 2

	b += 2 // padding

	return buf
}

// Request GetScreenInfo
// size: 8
type GetScreenInfoCookie struct {
	*xgb.Cookie
}

func GetScreenInfo(c *xgb.Conn, Window xproto.Window) GetScreenInfoCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getScreenInfoRequest(c, Window), cookie)
	return GetScreenInfoCookie{cookie}
}

func GetScreenInfoUnchecked(c *xgb.Conn, Window xproto.Window) GetScreenInfoCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getScreenInfoRequest(c, Window), cookie)
	return GetScreenInfoCookie{cookie}
}

// Request reply for GetScreenInfo
// size: ((32 + xgb.Pad((int(NSizes) * 8))) + RefreshRatesListSize(Rates))
type GetScreenInfoReply struct {
	Sequence        uint16
	Length          uint32
	Rotations       byte
	Root            xproto.Window
	Timestamp       xproto.Timestamp
	ConfigTimestamp xproto.Timestamp
	NSizes          uint16
	SizeID          uint16
	Rotation        uint16
	Rate            uint16
	NInfo           uint16
	// padding: 2 bytes
	Sizes []ScreenSize   // size: xgb.Pad((int(NSizes) * 8))
	Rates []RefreshRates // size: RefreshRatesListSize(Rates)
}

// Waits and reads reply data from request GetScreenInfo
func (cook GetScreenInfoCookie) Reply() (*GetScreenInfoReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getScreenInfoReply(buf), nil
}

// Read reply into structure from buffer for GetScreenInfo
func getScreenInfoReply(buf []byte) *GetScreenInfoReply {
	v := new(GetScreenInfoReply)
	b := 1 // skip reply determinant

	v.Rotations = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Root = xproto.Window(xgb.Get32(buf[b:]))
	b += 4

	v.Timestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.ConfigTimestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.NSizes = xgb.Get16(buf[b:])
	b += 2

	v.SizeID = xgb.Get16(buf[b:])
	b += 2

	v.Rotation = xgb.Get16(buf[b:])
	b += 2

	v.Rate = xgb.Get16(buf[b:])
	b += 2

	v.NInfo = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.Sizes = make([]ScreenSize, v.NSizes)
	b += ScreenSizeReadList(buf[b:], v.Sizes)

	v.Rates = make([]RefreshRates, (int(v.NInfo) - int(v.NSizes)))
	b += RefreshRatesReadList(buf[b:], v.Rates)

	return v
}

// Write request to wire for GetScreenInfo
func getScreenInfoRequest(c *xgb.Conn, Window xproto.Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request GetScreenSizeRange
// size: 8
type GetScreenSizeRangeCookie struct {
	*xgb.Cookie
}

func GetScreenSizeRange(c *xgb.Conn, Window xproto.Window) GetScreenSizeRangeCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getScreenSizeRangeRequest(c, Window), cookie)
	return GetScreenSizeRangeCookie{cookie}
}

func GetScreenSizeRangeUnchecked(c *xgb.Conn, Window xproto.Window) GetScreenSizeRangeCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getScreenSizeRangeRequest(c, Window), cookie)
	return GetScreenSizeRangeCookie{cookie}
}

// Request reply for GetScreenSizeRange
// size: 32
type GetScreenSizeRangeReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	MinWidth  uint16
	MinHeight uint16
	MaxWidth  uint16
	MaxHeight uint16
	// padding: 16 bytes
}

// Waits and reads reply data from request GetScreenSizeRange
func (cook GetScreenSizeRangeCookie) Reply() (*GetScreenSizeRangeReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getScreenSizeRangeReply(buf), nil
}

// Read reply into structure from buffer for GetScreenSizeRange
func getScreenSizeRangeReply(buf []byte) *GetScreenSizeRangeReply {
	v := new(GetScreenSizeRangeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.MinWidth = xgb.Get16(buf[b:])
	b += 2

	v.MinHeight = xgb.Get16(buf[b:])
	b += 2

	v.MaxWidth = xgb.Get16(buf[b:])
	b += 2

	v.MaxHeight = xgb.Get16(buf[b:])
	b += 2

	b += 16 // padding

	return v
}

// Write request to wire for GetScreenSizeRange
func getScreenSizeRangeRequest(c *xgb.Conn, Window xproto.Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request SetScreenSize
// size: 20
type SetScreenSizeCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetScreenSize
func SetScreenSize(c *xgb.Conn, Window xproto.Window, Width uint16, Height uint16, MmWidth uint32, MmHeight uint32) SetScreenSizeCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setScreenSizeRequest(c, Window, Width, Height, MmWidth, MmHeight), cookie)
	return SetScreenSizeCookie{cookie}
}

func SetScreenSizeChecked(c *xgb.Conn, Window xproto.Window, Width uint16, Height uint16, MmWidth uint32, MmHeight uint32) SetScreenSizeCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setScreenSizeRequest(c, Window, Width, Height, MmWidth, MmHeight), cookie)
	return SetScreenSizeCookie{cookie}
}

func (cook SetScreenSizeCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetScreenSize
func setScreenSizeRequest(c *xgb.Conn, Window xproto.Window, Width uint16, Height uint16, MmWidth uint32, MmHeight uint32) []byte {
	size := 20
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	xgb.Put32(buf[b:], MmWidth)
	b += 4

	xgb.Put32(buf[b:], MmHeight)
	b += 4

	return buf
}

// Request GetScreenResources
// size: 8
type GetScreenResourcesCookie struct {
	*xgb.Cookie
}

func GetScreenResources(c *xgb.Conn, Window xproto.Window) GetScreenResourcesCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getScreenResourcesRequest(c, Window), cookie)
	return GetScreenResourcesCookie{cookie}
}

func GetScreenResourcesUnchecked(c *xgb.Conn, Window xproto.Window) GetScreenResourcesCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getScreenResourcesRequest(c, Window), cookie)
	return GetScreenResourcesCookie{cookie}
}

// Request reply for GetScreenResources
// size: ((((32 + xgb.Pad((int(NumCrtcs) * 4))) + xgb.Pad((int(NumOutputs) * 4))) + xgb.Pad((int(NumModes) * 32))) + xgb.Pad((int(NamesLen) * 1)))
type GetScreenResourcesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Timestamp       xproto.Timestamp
	ConfigTimestamp xproto.Timestamp
	NumCrtcs        uint16
	NumOutputs      uint16
	NumModes        uint16
	NamesLen        uint16
	// padding: 8 bytes
	Crtcs   []Crtc     // size: xgb.Pad((int(NumCrtcs) * 4))
	Outputs []Output   // size: xgb.Pad((int(NumOutputs) * 4))
	Modes   []ModeInfo // size: xgb.Pad((int(NumModes) * 32))
	Names   []byte     // size: xgb.Pad((int(NamesLen) * 1))
}

// Waits and reads reply data from request GetScreenResources
func (cook GetScreenResourcesCookie) Reply() (*GetScreenResourcesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getScreenResourcesReply(buf), nil
}

// Read reply into structure from buffer for GetScreenResources
func getScreenResourcesReply(buf []byte) *GetScreenResourcesReply {
	v := new(GetScreenResourcesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Timestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.ConfigTimestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.NumCrtcs = xgb.Get16(buf[b:])
	b += 2

	v.NumOutputs = xgb.Get16(buf[b:])
	b += 2

	v.NumModes = xgb.Get16(buf[b:])
	b += 2

	v.NamesLen = xgb.Get16(buf[b:])
	b += 2

	b += 8 // padding

	v.Crtcs = make([]Crtc, v.NumCrtcs)
	for i := 0; i < int(v.NumCrtcs); i++ {
		v.Crtcs[i] = Crtc(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	v.Outputs = make([]Output, v.NumOutputs)
	for i := 0; i < int(v.NumOutputs); i++ {
		v.Outputs[i] = Output(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	v.Modes = make([]ModeInfo, v.NumModes)
	b += ModeInfoReadList(buf[b:], v.Modes)

	v.Names = make([]byte, v.NamesLen)
	copy(v.Names[:v.NamesLen], buf[b:])
	b += xgb.Pad(int(v.NamesLen))

	return v
}

// Write request to wire for GetScreenResources
func getScreenResourcesRequest(c *xgb.Conn, Window xproto.Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 8 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request GetOutputInfo
// size: 12
type GetOutputInfoCookie struct {
	*xgb.Cookie
}

func GetOutputInfo(c *xgb.Conn, Output Output, ConfigTimestamp xproto.Timestamp) GetOutputInfoCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getOutputInfoRequest(c, Output, ConfigTimestamp), cookie)
	return GetOutputInfoCookie{cookie}
}

func GetOutputInfoUnchecked(c *xgb.Conn, Output Output, ConfigTimestamp xproto.Timestamp) GetOutputInfoCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getOutputInfoRequest(c, Output, ConfigTimestamp), cookie)
	return GetOutputInfoCookie{cookie}
}

// Request reply for GetOutputInfo
// size: ((((36 + xgb.Pad((int(NumCrtcs) * 4))) + xgb.Pad((int(NumModes) * 4))) + xgb.Pad((int(NumClones) * 4))) + xgb.Pad((int(NameLen) * 1)))
type GetOutputInfoReply struct {
	Sequence      uint16
	Length        uint32
	Status        byte
	Timestamp     xproto.Timestamp
	Crtc          Crtc
	MmWidth       uint32
	MmHeight      uint32
	Connection    byte
	SubpixelOrder byte
	NumCrtcs      uint16
	NumModes      uint16
	NumPreferred  uint16
	NumClones     uint16
	NameLen       uint16
	Crtcs         []Crtc   // size: xgb.Pad((int(NumCrtcs) * 4))
	Modes         []Mode   // size: xgb.Pad((int(NumModes) * 4))
	Clones        []Output // size: xgb.Pad((int(NumClones) * 4))
	Name          []byte   // size: xgb.Pad((int(NameLen) * 1))
}

// Waits and reads reply data from request GetOutputInfo
func (cook GetOutputInfoCookie) Reply() (*GetOutputInfoReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getOutputInfoReply(buf), nil
}

// Read reply into structure from buffer for GetOutputInfo
func getOutputInfoReply(buf []byte) *GetOutputInfoReply {
	v := new(GetOutputInfoReply)
	b := 1 // skip reply determinant

	v.Status = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Timestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Crtc = Crtc(xgb.Get32(buf[b:]))
	b += 4

	v.MmWidth = xgb.Get32(buf[b:])
	b += 4

	v.MmHeight = xgb.Get32(buf[b:])
	b += 4

	v.Connection = buf[b]
	b += 1

	v.SubpixelOrder = buf[b]
	b += 1

	v.NumCrtcs = xgb.Get16(buf[b:])
	b += 2

	v.NumModes = xgb.Get16(buf[b:])
	b += 2

	v.NumPreferred = xgb.Get16(buf[b:])
	b += 2

	v.NumClones = xgb.Get16(buf[b:])
	b += 2

	v.NameLen = xgb.Get16(buf[b:])
	b += 2

	v.Crtcs = make([]Crtc, v.NumCrtcs)
	for i := 0; i < int(v.NumCrtcs); i++ {
		v.Crtcs[i] = Crtc(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	v.Modes = make([]Mode, v.NumModes)
	for i := 0; i < int(v.NumModes); i++ {
		v.Modes[i] = Mode(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	v.Clones = make([]Output, v.NumClones)
	for i := 0; i < int(v.NumClones); i++ {
		v.Clones[i] = Output(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	v.Name = make([]byte, v.NameLen)
	copy(v.Name[:v.NameLen], buf[b:])
	b += xgb.Pad(int(v.NameLen))

	return v
}

// Write request to wire for GetOutputInfo
func getOutputInfoRequest(c *xgb.Conn, Output Output, ConfigTimestamp xproto.Timestamp) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 9 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Output))
	b += 4

	xgb.Put32(buf[b:], uint32(ConfigTimestamp))
	b += 4

	return buf
}

// Request ListOutputProperties
// size: 8
type ListOutputPropertiesCookie struct {
	*xgb.Cookie
}

func ListOutputProperties(c *xgb.Conn, Output Output) ListOutputPropertiesCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(listOutputPropertiesRequest(c, Output), cookie)
	return ListOutputPropertiesCookie{cookie}
}

func ListOutputPropertiesUnchecked(c *xgb.Conn, Output Output) ListOutputPropertiesCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(listOutputPropertiesRequest(c, Output), cookie)
	return ListOutputPropertiesCookie{cookie}
}

// Request reply for ListOutputProperties
// size: (32 + xgb.Pad((int(NumAtoms) * 4)))
type ListOutputPropertiesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumAtoms uint16
	// padding: 22 bytes
	Atoms []xproto.Atom // size: xgb.Pad((int(NumAtoms) * 4))
}

// Waits and reads reply data from request ListOutputProperties
func (cook ListOutputPropertiesCookie) Reply() (*ListOutputPropertiesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listOutputPropertiesReply(buf), nil
}

// Read reply into structure from buffer for ListOutputProperties
func listOutputPropertiesReply(buf []byte) *ListOutputPropertiesReply {
	v := new(ListOutputPropertiesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumAtoms = xgb.Get16(buf[b:])
	b += 2

	b += 22 // padding

	v.Atoms = make([]xproto.Atom, v.NumAtoms)
	for i := 0; i < int(v.NumAtoms); i++ {
		v.Atoms[i] = xproto.Atom(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for ListOutputProperties
func listOutputPropertiesRequest(c *xgb.Conn, Output Output) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 10 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Output))
	b += 4

	return buf
}

// Request QueryOutputProperty
// size: 12
type QueryOutputPropertyCookie struct {
	*xgb.Cookie
}

func QueryOutputProperty(c *xgb.Conn, Output Output, Property xproto.Atom) QueryOutputPropertyCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryOutputPropertyRequest(c, Output, Property), cookie)
	return QueryOutputPropertyCookie{cookie}
}

func QueryOutputPropertyUnchecked(c *xgb.Conn, Output Output, Property xproto.Atom) QueryOutputPropertyCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryOutputPropertyRequest(c, Output, Property), cookie)
	return QueryOutputPropertyCookie{cookie}
}

// Request reply for QueryOutputProperty
// size: (32 + xgb.Pad((int(Length) * 4)))
type QueryOutputPropertyReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Pending   bool
	Range     bool
	Immutable bool
	// padding: 21 bytes
	ValidValues []int32 // size: xgb.Pad((int(Length) * 4))
}

// Waits and reads reply data from request QueryOutputProperty
func (cook QueryOutputPropertyCookie) Reply() (*QueryOutputPropertyReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryOutputPropertyReply(buf), nil
}

// Read reply into structure from buffer for QueryOutputProperty
func queryOutputPropertyReply(buf []byte) *QueryOutputPropertyReply {
	v := new(QueryOutputPropertyReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	if buf[b] == 1 {
		v.Pending = true
	} else {
		v.Pending = false
	}
	b += 1

	if buf[b] == 1 {
		v.Range = true
	} else {
		v.Range = false
	}
	b += 1

	if buf[b] == 1 {
		v.Immutable = true
	} else {
		v.Immutable = false
	}
	b += 1

	b += 21 // padding

	v.ValidValues = make([]int32, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.ValidValues[i] = int32(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for QueryOutputProperty
func queryOutputPropertyRequest(c *xgb.Conn, Output Output, Property xproto.Atom) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 11 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Output))
	b += 4

	xgb.Put32(buf[b:], uint32(Property))
	b += 4

	return buf
}

// Request ConfigureOutputProperty
// size: xgb.Pad((16 + xgb.Pad((len(Values) * 4))))
type ConfigureOutputPropertyCookie struct {
	*xgb.Cookie
}

// Write request to wire for ConfigureOutputProperty
func ConfigureOutputProperty(c *xgb.Conn, Output Output, Property xproto.Atom, Pending bool, Range bool, Values []int32) ConfigureOutputPropertyCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(configureOutputPropertyRequest(c, Output, Property, Pending, Range, Values), cookie)
	return ConfigureOutputPropertyCookie{cookie}
}

func ConfigureOutputPropertyChecked(c *xgb.Conn, Output Output, Property xproto.Atom, Pending bool, Range bool, Values []int32) ConfigureOutputPropertyCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(configureOutputPropertyRequest(c, Output, Property, Pending, Range, Values), cookie)
	return ConfigureOutputPropertyCookie{cookie}
}

func (cook ConfigureOutputPropertyCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ConfigureOutputProperty
func configureOutputPropertyRequest(c *xgb.Conn, Output Output, Property xproto.Atom, Pending bool, Range bool, Values []int32) []byte {
	size := xgb.Pad((16 + xgb.Pad((len(Values) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 12 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Output))
	b += 4

	xgb.Put32(buf[b:], uint32(Property))
	b += 4

	if Pending {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	if Range {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 2 // padding

	for i := 0; i < int(len(Values)); i++ {
		xgb.Put32(buf[b:], uint32(Values[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request ChangeOutputProperty
// size: xgb.Pad((24 + xgb.Pad((((int(NumUnits) * int(Format)) / 8) * 1))))
type ChangeOutputPropertyCookie struct {
	*xgb.Cookie
}

// Write request to wire for ChangeOutputProperty
func ChangeOutputProperty(c *xgb.Conn, Output Output, Property xproto.Atom, Type xproto.Atom, Format byte, Mode byte, NumUnits uint32, Data []byte) ChangeOutputPropertyCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeOutputPropertyRequest(c, Output, Property, Type, Format, Mode, NumUnits, Data), cookie)
	return ChangeOutputPropertyCookie{cookie}
}

func ChangeOutputPropertyChecked(c *xgb.Conn, Output Output, Property xproto.Atom, Type xproto.Atom, Format byte, Mode byte, NumUnits uint32, Data []byte) ChangeOutputPropertyCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeOutputPropertyRequest(c, Output, Property, Type, Format, Mode, NumUnits, Data), cookie)
	return ChangeOutputPropertyCookie{cookie}
}

func (cook ChangeOutputPropertyCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeOutputProperty
func changeOutputPropertyRequest(c *xgb.Conn, Output Output, Property xproto.Atom, Type xproto.Atom, Format byte, Mode byte, NumUnits uint32, Data []byte) []byte {
	size := xgb.Pad((24 + xgb.Pad((((int(NumUnits) * int(Format)) / 8) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 13 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Output))
	b += 4

	xgb.Put32(buf[b:], uint32(Property))
	b += 4

	xgb.Put32(buf[b:], uint32(Type))
	b += 4

	buf[b] = Format
	b += 1

	buf[b] = Mode
	b += 1

	b += 2 // padding

	xgb.Put32(buf[b:], NumUnits)
	b += 4

	copy(buf[b:], Data[:((int(NumUnits)*int(Format))/8)])
	b += xgb.Pad(int(((int(NumUnits) * int(Format)) / 8)))

	return buf
}

// Request DeleteOutputProperty
// size: 12
type DeleteOutputPropertyCookie struct {
	*xgb.Cookie
}

// Write request to wire for DeleteOutputProperty
func DeleteOutputProperty(c *xgb.Conn, Output Output, Property xproto.Atom) DeleteOutputPropertyCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(deleteOutputPropertyRequest(c, Output, Property), cookie)
	return DeleteOutputPropertyCookie{cookie}
}

func DeleteOutputPropertyChecked(c *xgb.Conn, Output Output, Property xproto.Atom) DeleteOutputPropertyCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(deleteOutputPropertyRequest(c, Output, Property), cookie)
	return DeleteOutputPropertyCookie{cookie}
}

func (cook DeleteOutputPropertyCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DeleteOutputProperty
func deleteOutputPropertyRequest(c *xgb.Conn, Output Output, Property xproto.Atom) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 14 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Output))
	b += 4

	xgb.Put32(buf[b:], uint32(Property))
	b += 4

	return buf
}

// Request GetOutputProperty
// size: 28
type GetOutputPropertyCookie struct {
	*xgb.Cookie
}

func GetOutputProperty(c *xgb.Conn, Output Output, Property xproto.Atom, Type xproto.Atom, LongOffset uint32, LongLength uint32, Delete bool, Pending bool) GetOutputPropertyCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getOutputPropertyRequest(c, Output, Property, Type, LongOffset, LongLength, Delete, Pending), cookie)
	return GetOutputPropertyCookie{cookie}
}

func GetOutputPropertyUnchecked(c *xgb.Conn, Output Output, Property xproto.Atom, Type xproto.Atom, LongOffset uint32, LongLength uint32, Delete bool, Pending bool) GetOutputPropertyCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getOutputPropertyRequest(c, Output, Property, Type, LongOffset, LongLength, Delete, Pending), cookie)
	return GetOutputPropertyCookie{cookie}
}

// Request reply for GetOutputProperty
// size: (32 + xgb.Pad(((int(NumItems) * (int(Format) / 8)) * 1)))
type GetOutputPropertyReply struct {
	Sequence   uint16
	Length     uint32
	Format     byte
	Type       xproto.Atom
	BytesAfter uint32
	NumItems   uint32
	// padding: 12 bytes
	Data []byte // size: xgb.Pad(((int(NumItems) * (int(Format) / 8)) * 1))
}

// Waits and reads reply data from request GetOutputProperty
func (cook GetOutputPropertyCookie) Reply() (*GetOutputPropertyReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getOutputPropertyReply(buf), nil
}

// Read reply into structure from buffer for GetOutputProperty
func getOutputPropertyReply(buf []byte) *GetOutputPropertyReply {
	v := new(GetOutputPropertyReply)
	b := 1 // skip reply determinant

	v.Format = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Type = xproto.Atom(xgb.Get32(buf[b:]))
	b += 4

	v.BytesAfter = xgb.Get32(buf[b:])
	b += 4

	v.NumItems = xgb.Get32(buf[b:])
	b += 4

	b += 12 // padding

	v.Data = make([]byte, (int(v.NumItems) * (int(v.Format) / 8)))
	copy(v.Data[:(int(v.NumItems)*(int(v.Format)/8))], buf[b:])
	b += xgb.Pad(int((int(v.NumItems) * (int(v.Format) / 8))))

	return v
}

// Write request to wire for GetOutputProperty
func getOutputPropertyRequest(c *xgb.Conn, Output Output, Property xproto.Atom, Type xproto.Atom, LongOffset uint32, LongLength uint32, Delete bool, Pending bool) []byte {
	size := 28
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 15 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Output))
	b += 4

	xgb.Put32(buf[b:], uint32(Property))
	b += 4

	xgb.Put32(buf[b:], uint32(Type))
	b += 4

	xgb.Put32(buf[b:], LongOffset)
	b += 4

	xgb.Put32(buf[b:], LongLength)
	b += 4

	if Delete {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	if Pending {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 2 // padding

	return buf
}

// Request CreateMode
// size: xgb.Pad((40 + xgb.Pad((len(Name) * 1))))
type CreateModeCookie struct {
	*xgb.Cookie
}

func CreateMode(c *xgb.Conn, Window xproto.Window, ModeInfo ModeInfo, Name string) CreateModeCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(createModeRequest(c, Window, ModeInfo, Name), cookie)
	return CreateModeCookie{cookie}
}

func CreateModeUnchecked(c *xgb.Conn, Window xproto.Window, ModeInfo ModeInfo, Name string) CreateModeCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(createModeRequest(c, Window, ModeInfo, Name), cookie)
	return CreateModeCookie{cookie}
}

// Request reply for CreateMode
// size: 32
type CreateModeReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Mode Mode
	// padding: 20 bytes
}

// Waits and reads reply data from request CreateMode
func (cook CreateModeCookie) Reply() (*CreateModeReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return createModeReply(buf), nil
}

// Read reply into structure from buffer for CreateMode
func createModeReply(buf []byte) *CreateModeReply {
	v := new(CreateModeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Mode = Mode(xgb.Get32(buf[b:]))
	b += 4

	b += 20 // padding

	return v
}

// Write request to wire for CreateMode
func createModeRequest(c *xgb.Conn, Window xproto.Window, ModeInfo ModeInfo, Name string) []byte {
	size := xgb.Pad((40 + xgb.Pad((len(Name) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 16 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	{
		structBytes := ModeInfo.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	copy(buf[b:], Name[:len(Name)])
	b += xgb.Pad(int(len(Name)))

	return buf
}

// Request DestroyMode
// size: 8
type DestroyModeCookie struct {
	*xgb.Cookie
}

// Write request to wire for DestroyMode
func DestroyMode(c *xgb.Conn, Mode Mode) DestroyModeCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroyModeRequest(c, Mode), cookie)
	return DestroyModeCookie{cookie}
}

func DestroyModeChecked(c *xgb.Conn, Mode Mode) DestroyModeCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroyModeRequest(c, Mode), cookie)
	return DestroyModeCookie{cookie}
}

func (cook DestroyModeCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroyMode
func destroyModeRequest(c *xgb.Conn, Mode Mode) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 17 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Mode))
	b += 4

	return buf
}

// Request AddOutputMode
// size: 12
type AddOutputModeCookie struct {
	*xgb.Cookie
}

// Write request to wire for AddOutputMode
func AddOutputMode(c *xgb.Conn, Output Output, Mode Mode) AddOutputModeCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(addOutputModeRequest(c, Output, Mode), cookie)
	return AddOutputModeCookie{cookie}
}

func AddOutputModeChecked(c *xgb.Conn, Output Output, Mode Mode) AddOutputModeCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(addOutputModeRequest(c, Output, Mode), cookie)
	return AddOutputModeCookie{cookie}
}

func (cook AddOutputModeCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for AddOutputMode
func addOutputModeRequest(c *xgb.Conn, Output Output, Mode Mode) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 18 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Output))
	b += 4

	xgb.Put32(buf[b:], uint32(Mode))
	b += 4

	return buf
}

// Request DeleteOutputMode
// size: 12
type DeleteOutputModeCookie struct {
	*xgb.Cookie
}

// Write request to wire for DeleteOutputMode
func DeleteOutputMode(c *xgb.Conn, Output Output, Mode Mode) DeleteOutputModeCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(deleteOutputModeRequest(c, Output, Mode), cookie)
	return DeleteOutputModeCookie{cookie}
}

func DeleteOutputModeChecked(c *xgb.Conn, Output Output, Mode Mode) DeleteOutputModeCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(deleteOutputModeRequest(c, Output, Mode), cookie)
	return DeleteOutputModeCookie{cookie}
}

func (cook DeleteOutputModeCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DeleteOutputMode
func deleteOutputModeRequest(c *xgb.Conn, Output Output, Mode Mode) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 19 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Output))
	b += 4

	xgb.Put32(buf[b:], uint32(Mode))
	b += 4

	return buf
}

// Request GetCrtcInfo
// size: 12
type GetCrtcInfoCookie struct {
	*xgb.Cookie
}

func GetCrtcInfo(c *xgb.Conn, Crtc Crtc, ConfigTimestamp xproto.Timestamp) GetCrtcInfoCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getCrtcInfoRequest(c, Crtc, ConfigTimestamp), cookie)
	return GetCrtcInfoCookie{cookie}
}

func GetCrtcInfoUnchecked(c *xgb.Conn, Crtc Crtc, ConfigTimestamp xproto.Timestamp) GetCrtcInfoCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getCrtcInfoRequest(c, Crtc, ConfigTimestamp), cookie)
	return GetCrtcInfoCookie{cookie}
}

// Request reply for GetCrtcInfo
// size: ((32 + xgb.Pad((int(NumOutputs) * 4))) + xgb.Pad((int(NumPossibleOutputs) * 4)))
type GetCrtcInfoReply struct {
	Sequence           uint16
	Length             uint32
	Status             byte
	Timestamp          xproto.Timestamp
	X                  int16
	Y                  int16
	Width              uint16
	Height             uint16
	Mode               Mode
	Rotation           uint16
	Rotations          uint16
	NumOutputs         uint16
	NumPossibleOutputs uint16
	Outputs            []Output // size: xgb.Pad((int(NumOutputs) * 4))
	Possible           []Output // size: xgb.Pad((int(NumPossibleOutputs) * 4))
}

// Waits and reads reply data from request GetCrtcInfo
func (cook GetCrtcInfoCookie) Reply() (*GetCrtcInfoReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getCrtcInfoReply(buf), nil
}

// Read reply into structure from buffer for GetCrtcInfo
func getCrtcInfoReply(buf []byte) *GetCrtcInfoReply {
	v := new(GetCrtcInfoReply)
	b := 1 // skip reply determinant

	v.Status = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Timestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.X = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Y = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	v.Mode = Mode(xgb.Get32(buf[b:]))
	b += 4

	v.Rotation = xgb.Get16(buf[b:])
	b += 2

	v.Rotations = xgb.Get16(buf[b:])
	b += 2

	v.NumOutputs = xgb.Get16(buf[b:])
	b += 2

	v.NumPossibleOutputs = xgb.Get16(buf[b:])
	b += 2

	v.Outputs = make([]Output, v.NumOutputs)
	for i := 0; i < int(v.NumOutputs); i++ {
		v.Outputs[i] = Output(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	v.Possible = make([]Output, v.NumPossibleOutputs)
	for i := 0; i < int(v.NumPossibleOutputs); i++ {
		v.Possible[i] = Output(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetCrtcInfo
func getCrtcInfoRequest(c *xgb.Conn, Crtc Crtc, ConfigTimestamp xproto.Timestamp) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 20 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Crtc))
	b += 4

	xgb.Put32(buf[b:], uint32(ConfigTimestamp))
	b += 4

	return buf
}

// Request SetCrtcConfig
// size: xgb.Pad((28 + xgb.Pad((len(Outputs) * 4))))
type SetCrtcConfigCookie struct {
	*xgb.Cookie
}

func SetCrtcConfig(c *xgb.Conn, Crtc Crtc, Timestamp xproto.Timestamp, ConfigTimestamp xproto.Timestamp, X int16, Y int16, Mode Mode, Rotation uint16, Outputs []Output) SetCrtcConfigCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(setCrtcConfigRequest(c, Crtc, Timestamp, ConfigTimestamp, X, Y, Mode, Rotation, Outputs), cookie)
	return SetCrtcConfigCookie{cookie}
}

func SetCrtcConfigUnchecked(c *xgb.Conn, Crtc Crtc, Timestamp xproto.Timestamp, ConfigTimestamp xproto.Timestamp, X int16, Y int16, Mode Mode, Rotation uint16, Outputs []Output) SetCrtcConfigCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(setCrtcConfigRequest(c, Crtc, Timestamp, ConfigTimestamp, X, Y, Mode, Rotation, Outputs), cookie)
	return SetCrtcConfigCookie{cookie}
}

// Request reply for SetCrtcConfig
// size: 32
type SetCrtcConfigReply struct {
	Sequence  uint16
	Length    uint32
	Status    byte
	Timestamp xproto.Timestamp
	// padding: 20 bytes
}

// Waits and reads reply data from request SetCrtcConfig
func (cook SetCrtcConfigCookie) Reply() (*SetCrtcConfigReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return setCrtcConfigReply(buf), nil
}

// Read reply into structure from buffer for SetCrtcConfig
func setCrtcConfigReply(buf []byte) *SetCrtcConfigReply {
	v := new(SetCrtcConfigReply)
	b := 1 // skip reply determinant

	v.Status = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Timestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	b += 20 // padding

	return v
}

// Write request to wire for SetCrtcConfig
func setCrtcConfigRequest(c *xgb.Conn, Crtc Crtc, Timestamp xproto.Timestamp, ConfigTimestamp xproto.Timestamp, X int16, Y int16, Mode Mode, Rotation uint16, Outputs []Output) []byte {
	size := xgb.Pad((28 + xgb.Pad((len(Outputs) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 21 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Crtc))
	b += 4

	xgb.Put32(buf[b:], uint32(Timestamp))
	b += 4

	xgb.Put32(buf[b:], uint32(ConfigTimestamp))
	b += 4

	xgb.Put16(buf[b:], uint16(X))
	b += 2

	xgb.Put16(buf[b:], uint16(Y))
	b += 2

	xgb.Put32(buf[b:], uint32(Mode))
	b += 4

	xgb.Put16(buf[b:], Rotation)
	b += 2

	b += 2 // padding

	for i := 0; i < int(len(Outputs)); i++ {
		xgb.Put32(buf[b:], uint32(Outputs[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request GetCrtcGammaSize
// size: 8
type GetCrtcGammaSizeCookie struct {
	*xgb.Cookie
}

func GetCrtcGammaSize(c *xgb.Conn, Crtc Crtc) GetCrtcGammaSizeCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getCrtcGammaSizeRequest(c, Crtc), cookie)
	return GetCrtcGammaSizeCookie{cookie}
}

func GetCrtcGammaSizeUnchecked(c *xgb.Conn, Crtc Crtc) GetCrtcGammaSizeCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getCrtcGammaSizeRequest(c, Crtc), cookie)
	return GetCrtcGammaSizeCookie{cookie}
}

// Request reply for GetCrtcGammaSize
// size: 32
type GetCrtcGammaSizeReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Size uint16
	// padding: 22 bytes
}

// Waits and reads reply data from request GetCrtcGammaSize
func (cook GetCrtcGammaSizeCookie) Reply() (*GetCrtcGammaSizeReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getCrtcGammaSizeReply(buf), nil
}

// Read reply into structure from buffer for GetCrtcGammaSize
func getCrtcGammaSizeReply(buf []byte) *GetCrtcGammaSizeReply {
	v := new(GetCrtcGammaSizeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Size = xgb.Get16(buf[b:])
	b += 2

	b += 22 // padding

	return v
}

// Write request to wire for GetCrtcGammaSize
func getCrtcGammaSizeRequest(c *xgb.Conn, Crtc Crtc) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 22 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Crtc))
	b += 4

	return buf
}

// Request GetCrtcGamma
// size: 8
type GetCrtcGammaCookie struct {
	*xgb.Cookie
}

func GetCrtcGamma(c *xgb.Conn, Crtc Crtc) GetCrtcGammaCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getCrtcGammaRequest(c, Crtc), cookie)
	return GetCrtcGammaCookie{cookie}
}

func GetCrtcGammaUnchecked(c *xgb.Conn, Crtc Crtc) GetCrtcGammaCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getCrtcGammaRequest(c, Crtc), cookie)
	return GetCrtcGammaCookie{cookie}
}

// Request reply for GetCrtcGamma
// size: (((32 + xgb.Pad((int(Size) * 2))) + xgb.Pad((int(Size) * 2))) + xgb.Pad((int(Size) * 2)))
type GetCrtcGammaReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Size uint16
	// padding: 22 bytes
	Red   []uint16 // size: xgb.Pad((int(Size) * 2))
	Green []uint16 // size: xgb.Pad((int(Size) * 2))
	Blue  []uint16 // size: xgb.Pad((int(Size) * 2))
}

// Waits and reads reply data from request GetCrtcGamma
func (cook GetCrtcGammaCookie) Reply() (*GetCrtcGammaReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getCrtcGammaReply(buf), nil
}

// Read reply into structure from buffer for GetCrtcGamma
func getCrtcGammaReply(buf []byte) *GetCrtcGammaReply {
	v := new(GetCrtcGammaReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Size = xgb.Get16(buf[b:])
	b += 2

	b += 22 // padding

	v.Red = make([]uint16, v.Size)
	for i := 0; i < int(v.Size); i++ {
		v.Red[i] = xgb.Get16(buf[b:])
		b += 2
	}
	b = xgb.Pad(b)

	v.Green = make([]uint16, v.Size)
	for i := 0; i < int(v.Size); i++ {
		v.Green[i] = xgb.Get16(buf[b:])
		b += 2
	}
	b = xgb.Pad(b)

	v.Blue = make([]uint16, v.Size)
	for i := 0; i < int(v.Size); i++ {
		v.Blue[i] = xgb.Get16(buf[b:])
		b += 2
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetCrtcGamma
func getCrtcGammaRequest(c *xgb.Conn, Crtc Crtc) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 23 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Crtc))
	b += 4

	return buf
}

// Request SetCrtcGamma
// size: xgb.Pad((((12 + xgb.Pad((int(Size) * 2))) + xgb.Pad((int(Size) * 2))) + xgb.Pad((int(Size) * 2))))
type SetCrtcGammaCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetCrtcGamma
func SetCrtcGamma(c *xgb.Conn, Crtc Crtc, Size uint16, Red []uint16, Green []uint16, Blue []uint16) SetCrtcGammaCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setCrtcGammaRequest(c, Crtc, Size, Red, Green, Blue), cookie)
	return SetCrtcGammaCookie{cookie}
}

func SetCrtcGammaChecked(c *xgb.Conn, Crtc Crtc, Size uint16, Red []uint16, Green []uint16, Blue []uint16) SetCrtcGammaCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setCrtcGammaRequest(c, Crtc, Size, Red, Green, Blue), cookie)
	return SetCrtcGammaCookie{cookie}
}

func (cook SetCrtcGammaCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetCrtcGamma
func setCrtcGammaRequest(c *xgb.Conn, Crtc Crtc, Size uint16, Red []uint16, Green []uint16, Blue []uint16) []byte {
	size := xgb.Pad((((12 + xgb.Pad((int(Size) * 2))) + xgb.Pad((int(Size) * 2))) + xgb.Pad((int(Size) * 2))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 24 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Crtc))
	b += 4

	xgb.Put16(buf[b:], Size)
	b += 2

	b += 2 // padding

	for i := 0; i < int(Size); i++ {
		xgb.Put16(buf[b:], Red[i])
		b += 2
	}
	b = xgb.Pad(b)

	for i := 0; i < int(Size); i++ {
		xgb.Put16(buf[b:], Green[i])
		b += 2
	}
	b = xgb.Pad(b)

	for i := 0; i < int(Size); i++ {
		xgb.Put16(buf[b:], Blue[i])
		b += 2
	}
	b = xgb.Pad(b)

	return buf
}

// Request GetScreenResourcesCurrent
// size: 8
type GetScreenResourcesCurrentCookie struct {
	*xgb.Cookie
}

func GetScreenResourcesCurrent(c *xgb.Conn, Window xproto.Window) GetScreenResourcesCurrentCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getScreenResourcesCurrentRequest(c, Window), cookie)
	return GetScreenResourcesCurrentCookie{cookie}
}

func GetScreenResourcesCurrentUnchecked(c *xgb.Conn, Window xproto.Window) GetScreenResourcesCurrentCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getScreenResourcesCurrentRequest(c, Window), cookie)
	return GetScreenResourcesCurrentCookie{cookie}
}

// Request reply for GetScreenResourcesCurrent
// size: ((((32 + xgb.Pad((int(NumCrtcs) * 4))) + xgb.Pad((int(NumOutputs) * 4))) + xgb.Pad((int(NumModes) * 32))) + xgb.Pad((int(NamesLen) * 1)))
type GetScreenResourcesCurrentReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Timestamp       xproto.Timestamp
	ConfigTimestamp xproto.Timestamp
	NumCrtcs        uint16
	NumOutputs      uint16
	NumModes        uint16
	NamesLen        uint16
	// padding: 8 bytes
	Crtcs   []Crtc     // size: xgb.Pad((int(NumCrtcs) * 4))
	Outputs []Output   // size: xgb.Pad((int(NumOutputs) * 4))
	Modes   []ModeInfo // size: xgb.Pad((int(NumModes) * 32))
	Names   []byte     // size: xgb.Pad((int(NamesLen) * 1))
}

// Waits and reads reply data from request GetScreenResourcesCurrent
func (cook GetScreenResourcesCurrentCookie) Reply() (*GetScreenResourcesCurrentReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getScreenResourcesCurrentReply(buf), nil
}

// Read reply into structure from buffer for GetScreenResourcesCurrent
func getScreenResourcesCurrentReply(buf []byte) *GetScreenResourcesCurrentReply {
	v := new(GetScreenResourcesCurrentReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Timestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.ConfigTimestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.NumCrtcs = xgb.Get16(buf[b:])
	b += 2

	v.NumOutputs = xgb.Get16(buf[b:])
	b += 2

	v.NumModes = xgb.Get16(buf[b:])
	b += 2

	v.NamesLen = xgb.Get16(buf[b:])
	b += 2

	b += 8 // padding

	v.Crtcs = make([]Crtc, v.NumCrtcs)
	for i := 0; i < int(v.NumCrtcs); i++ {
		v.Crtcs[i] = Crtc(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	v.Outputs = make([]Output, v.NumOutputs)
	for i := 0; i < int(v.NumOutputs); i++ {
		v.Outputs[i] = Output(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	v.Modes = make([]ModeInfo, v.NumModes)
	b += ModeInfoReadList(buf[b:], v.Modes)

	v.Names = make([]byte, v.NamesLen)
	copy(v.Names[:v.NamesLen], buf[b:])
	b += xgb.Pad(int(v.NamesLen))

	return v
}

// Write request to wire for GetScreenResourcesCurrent
func getScreenResourcesCurrentRequest(c *xgb.Conn, Window xproto.Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 25 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request SetCrtcTransform
// size: xgb.Pad(((48 + xgb.Pad((int(FilterLen) * 1))) + xgb.Pad((len(FilterParams) * 4))))
type SetCrtcTransformCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetCrtcTransform
func SetCrtcTransform(c *xgb.Conn, Crtc Crtc, Transform render.Transform, FilterLen uint16, FilterName string, FilterParams []render.Fixed) SetCrtcTransformCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setCrtcTransformRequest(c, Crtc, Transform, FilterLen, FilterName, FilterParams), cookie)
	return SetCrtcTransformCookie{cookie}
}

func SetCrtcTransformChecked(c *xgb.Conn, Crtc Crtc, Transform render.Transform, FilterLen uint16, FilterName string, FilterParams []render.Fixed) SetCrtcTransformCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setCrtcTransformRequest(c, Crtc, Transform, FilterLen, FilterName, FilterParams), cookie)
	return SetCrtcTransformCookie{cookie}
}

func (cook SetCrtcTransformCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetCrtcTransform
func setCrtcTransformRequest(c *xgb.Conn, Crtc Crtc, Transform render.Transform, FilterLen uint16, FilterName string, FilterParams []render.Fixed) []byte {
	size := xgb.Pad(((48 + xgb.Pad((int(FilterLen) * 1))) + xgb.Pad((len(FilterParams) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 26 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Crtc))
	b += 4

	{
		structBytes := Transform.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	xgb.Put16(buf[b:], FilterLen)
	b += 2

	b += 2 // padding

	copy(buf[b:], FilterName[:FilterLen])
	b += xgb.Pad(int(FilterLen))

	for i := 0; i < int(len(FilterParams)); i++ {
		xgb.Put32(buf[b:], uint32(FilterParams[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request GetCrtcTransform
// size: 8
type GetCrtcTransformCookie struct {
	*xgb.Cookie
}

func GetCrtcTransform(c *xgb.Conn, Crtc Crtc) GetCrtcTransformCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getCrtcTransformRequest(c, Crtc), cookie)
	return GetCrtcTransformCookie{cookie}
}

func GetCrtcTransformUnchecked(c *xgb.Conn, Crtc Crtc) GetCrtcTransformCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getCrtcTransformRequest(c, Crtc), cookie)
	return GetCrtcTransformCookie{cookie}
}

// Request reply for GetCrtcTransform
// size: ((((96 + xgb.Pad((int(PendingLen) * 1))) + xgb.Pad((int(PendingNparams) * 4))) + xgb.Pad((int(CurrentLen) * 1))) + xgb.Pad((int(CurrentNparams) * 4)))
type GetCrtcTransformReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	PendingTransform render.Transform
	HasTransforms    bool
	// padding: 3 bytes
	CurrentTransform render.Transform
	// padding: 4 bytes
	PendingLen        uint16
	PendingNparams    uint16
	CurrentLen        uint16
	CurrentNparams    uint16
	PendingFilterName string         // size: xgb.Pad((int(PendingLen) * 1))
	PendingParams     []render.Fixed // size: xgb.Pad((int(PendingNparams) * 4))
	CurrentFilterName string         // size: xgb.Pad((int(CurrentLen) * 1))
	CurrentParams     []render.Fixed // size: xgb.Pad((int(CurrentNparams) * 4))
}

// Waits and reads reply data from request GetCrtcTransform
func (cook GetCrtcTransformCookie) Reply() (*GetCrtcTransformReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getCrtcTransformReply(buf), nil
}

// Read reply into structure from buffer for GetCrtcTransform
func getCrtcTransformReply(buf []byte) *GetCrtcTransformReply {
	v := new(GetCrtcTransformReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.PendingTransform = render.Transform{}
	b += render.TransformRead(buf[b:], &v.PendingTransform)

	if buf[b] == 1 {
		v.HasTransforms = true
	} else {
		v.HasTransforms = false
	}
	b += 1

	b += 3 // padding

	v.CurrentTransform = render.Transform{}
	b += render.TransformRead(buf[b:], &v.CurrentTransform)

	b += 4 // padding

	v.PendingLen = xgb.Get16(buf[b:])
	b += 2

	v.PendingNparams = xgb.Get16(buf[b:])
	b += 2

	v.CurrentLen = xgb.Get16(buf[b:])
	b += 2

	v.CurrentNparams = xgb.Get16(buf[b:])
	b += 2

	{
		byteString := make([]byte, v.PendingLen)
		copy(byteString[:v.PendingLen], buf[b:])
		v.PendingFilterName = string(byteString)
		b += xgb.Pad(int(v.PendingLen))
	}

	v.PendingParams = make([]render.Fixed, v.PendingNparams)
	for i := 0; i < int(v.PendingNparams); i++ {
		v.PendingParams[i] = render.Fixed(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	{
		byteString := make([]byte, v.CurrentLen)
		copy(byteString[:v.CurrentLen], buf[b:])
		v.CurrentFilterName = string(byteString)
		b += xgb.Pad(int(v.CurrentLen))
	}

	v.CurrentParams = make([]render.Fixed, v.CurrentNparams)
	for i := 0; i < int(v.CurrentNparams); i++ {
		v.CurrentParams[i] = render.Fixed(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetCrtcTransform
func getCrtcTransformRequest(c *xgb.Conn, Crtc Crtc) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 27 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Crtc))
	b += 4

	return buf
}

// Request GetPanning
// size: 8
type GetPanningCookie struct {
	*xgb.Cookie
}

func GetPanning(c *xgb.Conn, Crtc Crtc) GetPanningCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getPanningRequest(c, Crtc), cookie)
	return GetPanningCookie{cookie}
}

func GetPanningUnchecked(c *xgb.Conn, Crtc Crtc) GetPanningCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getPanningRequest(c, Crtc), cookie)
	return GetPanningCookie{cookie}
}

// Request reply for GetPanning
// size: 36
type GetPanningReply struct {
	Sequence     uint16
	Length       uint32
	Status       byte
	Timestamp    xproto.Timestamp
	Left         uint16
	Top          uint16
	Width        uint16
	Height       uint16
	TrackLeft    uint16
	TrackTop     uint16
	TrackWidth   uint16
	TrackHeight  uint16
	BorderLeft   int16
	BorderTop    int16
	BorderRight  int16
	BorderBottom int16
}

// Waits and reads reply data from request GetPanning
func (cook GetPanningCookie) Reply() (*GetPanningReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getPanningReply(buf), nil
}

// Read reply into structure from buffer for GetPanning
func getPanningReply(buf []byte) *GetPanningReply {
	v := new(GetPanningReply)
	b := 1 // skip reply determinant

	v.Status = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Timestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Left = xgb.Get16(buf[b:])
	b += 2

	v.Top = xgb.Get16(buf[b:])
	b += 2

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	v.TrackLeft = xgb.Get16(buf[b:])
	b += 2

	v.TrackTop = xgb.Get16(buf[b:])
	b += 2

	v.TrackWidth = xgb.Get16(buf[b:])
	b += 2

	v.TrackHeight = xgb.Get16(buf[b:])
	b += 2

	v.BorderLeft = int16(xgb.Get16(buf[b:]))
	b += 2

	v.BorderTop = int16(xgb.Get16(buf[b:]))
	b += 2

	v.BorderRight = int16(xgb.Get16(buf[b:]))
	b += 2

	v.BorderBottom = int16(xgb.Get16(buf[b:]))
	b += 2

	return v
}

// Write request to wire for GetPanning
func getPanningRequest(c *xgb.Conn, Crtc Crtc) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 28 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Crtc))
	b += 4

	return buf
}

// Request SetPanning
// size: 36
type SetPanningCookie struct {
	*xgb.Cookie
}

func SetPanning(c *xgb.Conn, Crtc Crtc, Timestamp xproto.Timestamp, Left uint16, Top uint16, Width uint16, Height uint16, TrackLeft uint16, TrackTop uint16, TrackWidth uint16, TrackHeight uint16, BorderLeft int16, BorderTop int16, BorderRight int16, BorderBottom int16) SetPanningCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(setPanningRequest(c, Crtc, Timestamp, Left, Top, Width, Height, TrackLeft, TrackTop, TrackWidth, TrackHeight, BorderLeft, BorderTop, BorderRight, BorderBottom), cookie)
	return SetPanningCookie{cookie}
}

func SetPanningUnchecked(c *xgb.Conn, Crtc Crtc, Timestamp xproto.Timestamp, Left uint16, Top uint16, Width uint16, Height uint16, TrackLeft uint16, TrackTop uint16, TrackWidth uint16, TrackHeight uint16, BorderLeft int16, BorderTop int16, BorderRight int16, BorderBottom int16) SetPanningCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(setPanningRequest(c, Crtc, Timestamp, Left, Top, Width, Height, TrackLeft, TrackTop, TrackWidth, TrackHeight, BorderLeft, BorderTop, BorderRight, BorderBottom), cookie)
	return SetPanningCookie{cookie}
}

// Request reply for SetPanning
// size: 12
type SetPanningReply struct {
	Sequence  uint16
	Length    uint32
	Status    byte
	Timestamp xproto.Timestamp
}

// Waits and reads reply data from request SetPanning
func (cook SetPanningCookie) Reply() (*SetPanningReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return setPanningReply(buf), nil
}

// Read reply into structure from buffer for SetPanning
func setPanningReply(buf []byte) *SetPanningReply {
	v := new(SetPanningReply)
	b := 1 // skip reply determinant

	v.Status = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Timestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Write request to wire for SetPanning
func setPanningRequest(c *xgb.Conn, Crtc Crtc, Timestamp xproto.Timestamp, Left uint16, Top uint16, Width uint16, Height uint16, TrackLeft uint16, TrackTop uint16, TrackWidth uint16, TrackHeight uint16, BorderLeft int16, BorderTop int16, BorderRight int16, BorderBottom int16) []byte {
	size := 36
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 29 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Crtc))
	b += 4

	xgb.Put32(buf[b:], uint32(Timestamp))
	b += 4

	xgb.Put16(buf[b:], Left)
	b += 2

	xgb.Put16(buf[b:], Top)
	b += 2

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	xgb.Put16(buf[b:], TrackLeft)
	b += 2

	xgb.Put16(buf[b:], TrackTop)
	b += 2

	xgb.Put16(buf[b:], TrackWidth)
	b += 2

	xgb.Put16(buf[b:], TrackHeight)
	b += 2

	xgb.Put16(buf[b:], uint16(BorderLeft))
	b += 2

	xgb.Put16(buf[b:], uint16(BorderTop))
	b += 2

	xgb.Put16(buf[b:], uint16(BorderRight))
	b += 2

	xgb.Put16(buf[b:], uint16(BorderBottom))
	b += 2

	return buf
}

// Request SetOutputPrimary
// size: 12
type SetOutputPrimaryCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetOutputPrimary
func SetOutputPrimary(c *xgb.Conn, Window xproto.Window, Output Output) SetOutputPrimaryCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setOutputPrimaryRequest(c, Window, Output), cookie)
	return SetOutputPrimaryCookie{cookie}
}

func SetOutputPrimaryChecked(c *xgb.Conn, Window xproto.Window, Output Output) SetOutputPrimaryCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setOutputPrimaryRequest(c, Window, Output), cookie)
	return SetOutputPrimaryCookie{cookie}
}

func (cook SetOutputPrimaryCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetOutputPrimary
func setOutputPrimaryRequest(c *xgb.Conn, Window xproto.Window, Output Output) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 30 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put32(buf[b:], uint32(Output))
	b += 4

	return buf
}

// Request GetOutputPrimary
// size: 8
type GetOutputPrimaryCookie struct {
	*xgb.Cookie
}

func GetOutputPrimary(c *xgb.Conn, Window xproto.Window) GetOutputPrimaryCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getOutputPrimaryRequest(c, Window), cookie)
	return GetOutputPrimaryCookie{cookie}
}

func GetOutputPrimaryUnchecked(c *xgb.Conn, Window xproto.Window) GetOutputPrimaryCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getOutputPrimaryRequest(c, Window), cookie)
	return GetOutputPrimaryCookie{cookie}
}

// Request reply for GetOutputPrimary
// size: 12
type GetOutputPrimaryReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Output Output
}

// Waits and reads reply data from request GetOutputPrimary
func (cook GetOutputPrimaryCookie) Reply() (*GetOutputPrimaryReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getOutputPrimaryReply(buf), nil
}

// Read reply into structure from buffer for GetOutputPrimary
func getOutputPrimaryReply(buf []byte) *GetOutputPrimaryReply {
	v := new(GetOutputPrimaryReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Output = Output(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Write request to wire for GetOutputPrimary
func getOutputPrimaryRequest(c *xgb.Conn, Window xproto.Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RANDR"]
	b += 1

	buf[b] = 31 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}
