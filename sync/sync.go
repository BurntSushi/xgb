// Package sync is the X client API for the SYNC extension.
package sync

/*
	This file was generated by sync.xml on May 10 2012 8:04:32pm EDT.
	This file is automatically generated. Edit at your peril!
*/

import (
	"github.com/BurntSushi/xgb"

	"github.com/BurntSushi/xgb/xproto"
)

// Init must be called before using the SYNC extension.
func Init(c *xgb.Conn) error {
	reply, err := xproto.QueryExtension(c, 4, "SYNC").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return xgb.Errorf("No extension named SYNC could be found on on the server.")
	}

	xgb.ExtLock.Lock()
	c.Extensions["SYNC"] = reply.MajorOpcode
	for evNum, fun := range xgb.NewExtEventFuncs["SYNC"] {
		xgb.NewEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range xgb.NewExtErrorFuncs["SYNC"] {
		xgb.NewErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	xgb.ExtLock.Unlock()

	return nil
}

func init() {
	xgb.NewExtEventFuncs["SYNC"] = make(map[int]xgb.NewEventFun)
	xgb.NewExtErrorFuncs["SYNC"] = make(map[int]xgb.NewErrorFun)
}

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

const (
	AlarmstateActive    = 0
	AlarmstateInactive  = 1
	AlarmstateDestroyed = 2
)

const (
	TesttypePositiveTransition = 0
	TesttypeNegativeTransition = 1
	TesttypePositiveComparison = 2
	TesttypeNegativeComparison = 3
)

const (
	ValuetypeAbsolute = 0
	ValuetypeRelative = 1
)

const (
	CaCounter   = 1
	CaValueType = 2
	CaValue     = 4
	CaTestType  = 8
	CaDelta     = 16
	CaEvents    = 32
)

type Alarm uint32

func NewAlarmId(c *xgb.Conn) (Alarm, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Alarm(id), nil
}

type Counter uint32

func NewCounterId(c *xgb.Conn) (Counter, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Counter(id), nil
}

type Fence uint32

func NewFenceId(c *xgb.Conn) (Fence, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Fence(id), nil
}

// 'Int64' struct definition
// Size: 8
type Int64 struct {
	Hi int32
	Lo uint32
}

// Struct read Int64
func Int64Read(buf []byte, v *Int64) int {
	b := 0

	v.Hi = int32(xgb.Get32(buf[b:]))
	b += 4

	v.Lo = xgb.Get32(buf[b:])
	b += 4

	return b
}

// Struct list read Int64
func Int64ReadList(buf []byte, dest []Int64) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Int64{}
		b += Int64Read(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Int64
func (v Int64) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Hi))
	b += 4

	xgb.Put32(buf[b:], v.Lo)
	b += 4

	return buf
}

// Write struct list Int64
func Int64ListBytes(buf []byte, list []Int64) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Systemcounter' struct definition
// Size: (14 + xgb.Pad((int(NameLen) * 1)))
type Systemcounter struct {
	Counter    Counter
	Resolution Int64
	NameLen    uint16
	Name       string // size: xgb.Pad((int(NameLen) * 1))
}

// Struct read Systemcounter
func SystemcounterRead(buf []byte, v *Systemcounter) int {
	b := 0

	v.Counter = Counter(xgb.Get32(buf[b:]))
	b += 4

	v.Resolution = Int64{}
	b += Int64Read(buf[b:], &v.Resolution)

	v.NameLen = xgb.Get16(buf[b:])
	b += 2

	{
		byteString := make([]byte, v.NameLen)
		copy(byteString[:v.NameLen], buf[b:])
		v.Name = string(byteString)
		b += xgb.Pad(int(v.NameLen))
	}

	return b
}

// Struct list read Systemcounter
func SystemcounterReadList(buf []byte, dest []Systemcounter) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Systemcounter{}
		b += SystemcounterRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Systemcounter
func (v Systemcounter) Bytes() []byte {
	buf := make([]byte, (14 + xgb.Pad((int(v.NameLen) * 1))))
	b := 0

	xgb.Put32(buf[b:], uint32(v.Counter))
	b += 4

	{
		structBytes := v.Resolution.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	xgb.Put16(buf[b:], v.NameLen)
	b += 2

	copy(buf[b:], v.Name[:v.NameLen])
	b += xgb.Pad(int(v.NameLen))

	return buf
}

// Write struct list Systemcounter
func SystemcounterListBytes(buf []byte, list []Systemcounter) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size Systemcounter
func SystemcounterListSize(list []Systemcounter) int {
	size := 0
	for _, item := range list {
		size += (14 + xgb.Pad((int(item.NameLen) * 1)))
	}
	return size
}

// 'Trigger' struct definition
// Size: 20
type Trigger struct {
	Counter   Counter
	WaitType  uint32
	WaitValue Int64
	TestType  uint32
}

// Struct read Trigger
func TriggerRead(buf []byte, v *Trigger) int {
	b := 0

	v.Counter = Counter(xgb.Get32(buf[b:]))
	b += 4

	v.WaitType = xgb.Get32(buf[b:])
	b += 4

	v.WaitValue = Int64{}
	b += Int64Read(buf[b:], &v.WaitValue)

	v.TestType = xgb.Get32(buf[b:])
	b += 4

	return b
}

// Struct list read Trigger
func TriggerReadList(buf []byte, dest []Trigger) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Trigger{}
		b += TriggerRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Trigger
func (v Trigger) Bytes() []byte {
	buf := make([]byte, 20)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Counter))
	b += 4

	xgb.Put32(buf[b:], v.WaitType)
	b += 4

	{
		structBytes := v.WaitValue.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	xgb.Put32(buf[b:], v.TestType)
	b += 4

	return buf
}

// Write struct list Trigger
func TriggerListBytes(buf []byte, list []Trigger) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Waitcondition' struct definition
// Size: 28
type Waitcondition struct {
	Trigger        Trigger
	EventThreshold Int64
}

// Struct read Waitcondition
func WaitconditionRead(buf []byte, v *Waitcondition) int {
	b := 0

	v.Trigger = Trigger{}
	b += TriggerRead(buf[b:], &v.Trigger)

	v.EventThreshold = Int64{}
	b += Int64Read(buf[b:], &v.EventThreshold)

	return b
}

// Struct list read Waitcondition
func WaitconditionReadList(buf []byte, dest []Waitcondition) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Waitcondition{}
		b += WaitconditionRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Waitcondition
func (v Waitcondition) Bytes() []byte {
	buf := make([]byte, 28)
	b := 0

	{
		structBytes := v.Trigger.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.EventThreshold.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	return buf
}

// Write struct list Waitcondition
func WaitconditionListBytes(buf []byte, list []Waitcondition) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Event definition CounterNotify (0)
// Size: 32

const CounterNotify = 0

type CounterNotifyEvent struct {
	Sequence     uint16
	Kind         byte
	Counter      Counter
	WaitValue    Int64
	CounterValue Int64
	Timestamp    xproto.Timestamp
	Count        uint16
	Destroyed    bool
	// padding: 1 bytes
}

// Event read CounterNotify
func CounterNotifyEventNew(buf []byte) xgb.Event {
	v := CounterNotifyEvent{}
	b := 1 // don't read event number

	v.Kind = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Counter = Counter(xgb.Get32(buf[b:]))
	b += 4

	v.WaitValue = Int64{}
	b += Int64Read(buf[b:], &v.WaitValue)

	v.CounterValue = Int64{}
	b += Int64Read(buf[b:], &v.CounterValue)

	v.Timestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Count = xgb.Get16(buf[b:])
	b += 2

	if buf[b] == 1 {
		v.Destroyed = true
	} else {
		v.Destroyed = false
	}
	b += 1

	b += 1 // padding

	return v
}

// Event write CounterNotify
func (v CounterNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 0
	b += 1

	buf[b] = v.Kind
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Counter))
	b += 4

	{
		structBytes := v.WaitValue.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.CounterValue.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	xgb.Put32(buf[b:], uint32(v.Timestamp))
	b += 4

	xgb.Put16(buf[b:], v.Count)
	b += 2

	if v.Destroyed {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 1 // padding

	return buf
}

func (v CounterNotifyEvent) ImplementsEvent() {}

func (v CounterNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v CounterNotifyEvent) String() string {
	fieldVals := make([]string, 0, 8)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Kind: %d", v.Kind))
	fieldVals = append(fieldVals, xgb.Sprintf("Counter: %d", v.Counter))
	fieldVals = append(fieldVals, xgb.Sprintf("Timestamp: %d", v.Timestamp))
	fieldVals = append(fieldVals, xgb.Sprintf("Count: %d", v.Count))
	fieldVals = append(fieldVals, xgb.Sprintf("Destroyed: %t", v.Destroyed))
	return "CounterNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["SYNC"][0] = CounterNotifyEventNew
}

// Event definition AlarmNotify (1)
// Size: 32

const AlarmNotify = 1

type AlarmNotifyEvent struct {
	Sequence     uint16
	Kind         byte
	Alarm        Alarm
	CounterValue Int64
	AlarmValue   Int64
	Timestamp    xproto.Timestamp
	State        byte
	// padding: 3 bytes
}

// Event read AlarmNotify
func AlarmNotifyEventNew(buf []byte) xgb.Event {
	v := AlarmNotifyEvent{}
	b := 1 // don't read event number

	v.Kind = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Alarm = Alarm(xgb.Get32(buf[b:]))
	b += 4

	v.CounterValue = Int64{}
	b += Int64Read(buf[b:], &v.CounterValue)

	v.AlarmValue = Int64{}
	b += Int64Read(buf[b:], &v.AlarmValue)

	v.Timestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.State = buf[b]
	b += 1

	b += 3 // padding

	return v
}

// Event write AlarmNotify
func (v AlarmNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 1
	b += 1

	buf[b] = v.Kind
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Alarm))
	b += 4

	{
		structBytes := v.CounterValue.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.AlarmValue.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	xgb.Put32(buf[b:], uint32(v.Timestamp))
	b += 4

	buf[b] = v.State
	b += 1

	b += 3 // padding

	return buf
}

func (v AlarmNotifyEvent) ImplementsEvent() {}

func (v AlarmNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v AlarmNotifyEvent) String() string {
	fieldVals := make([]string, 0, 7)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Kind: %d", v.Kind))
	fieldVals = append(fieldVals, xgb.Sprintf("Alarm: %d", v.Alarm))
	fieldVals = append(fieldVals, xgb.Sprintf("Timestamp: %d", v.Timestamp))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	return "AlarmNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["SYNC"][1] = AlarmNotifyEventNew
}

// Error definition Counter (0)
// Size: 32

const BadCounter = 0

type CounterError struct {
	Sequence    uint16
	NiceName    string
	BadCounter  uint32
	MinorOpcode uint16
	MajorOpcode byte
}

// Error read Counter
func CounterErrorNew(buf []byte) xgb.Error {
	v := CounterError{}
	v.NiceName = "Counter"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.BadCounter = xgb.Get32(buf[b:])
	b += 4

	v.MinorOpcode = xgb.Get16(buf[b:])
	b += 2

	v.MajorOpcode = buf[b]
	b += 1

	return v
}

func (err CounterError) ImplementsError() {}

func (err CounterError) SequenceId() uint16 {
	return err.Sequence
}

func (err CounterError) BadId() uint32 {
	return 0
}

func (err CounterError) Error() string {
	fieldVals := make([]string, 0, 3)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadCounter: %d", err.BadCounter))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadCounter {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["SYNC"][0] = CounterErrorNew
}

// Error definition Alarm (1)
// Size: 32

const BadAlarm = 1

type AlarmError struct {
	Sequence    uint16
	NiceName    string
	BadAlarm    uint32
	MinorOpcode uint16
	MajorOpcode byte
}

// Error read Alarm
func AlarmErrorNew(buf []byte) xgb.Error {
	v := AlarmError{}
	v.NiceName = "Alarm"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.BadAlarm = xgb.Get32(buf[b:])
	b += 4

	v.MinorOpcode = xgb.Get16(buf[b:])
	b += 2

	v.MajorOpcode = buf[b]
	b += 1

	return v
}

func (err AlarmError) ImplementsError() {}

func (err AlarmError) SequenceId() uint16 {
	return err.Sequence
}

func (err AlarmError) BadId() uint32 {
	return 0
}

func (err AlarmError) Error() string {
	fieldVals := make([]string, 0, 3)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadAlarm: %d", err.BadAlarm))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadAlarm {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["SYNC"][1] = AlarmErrorNew
}

// Request Initialize
// size: 8
type InitializeCookie struct {
	*xgb.Cookie
}

func Initialize(c *xgb.Conn, DesiredMajorVersion byte, DesiredMinorVersion byte) InitializeCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(initializeRequest(c, DesiredMajorVersion, DesiredMinorVersion), cookie)
	return InitializeCookie{cookie}
}

func InitializeUnchecked(c *xgb.Conn, DesiredMajorVersion byte, DesiredMinorVersion byte) InitializeCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(initializeRequest(c, DesiredMajorVersion, DesiredMinorVersion), cookie)
	return InitializeCookie{cookie}
}

// Request reply for Initialize
// size: 32
type InitializeReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	MajorVersion byte
	MinorVersion byte
	// padding: 22 bytes
}

// Waits and reads reply data from request Initialize
func (cook InitializeCookie) Reply() (*InitializeReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return initializeReply(buf), nil
}

// Read reply into structure from buffer for Initialize
func initializeReply(buf []byte) *InitializeReply {
	v := new(InitializeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.MajorVersion = buf[b]
	b += 1

	v.MinorVersion = buf[b]
	b += 1

	b += 22 // padding

	return v
}

// Write request to wire for Initialize
func initializeRequest(c *xgb.Conn, DesiredMajorVersion byte, DesiredMinorVersion byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 0 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DesiredMajorVersion
	b += 1

	buf[b] = DesiredMinorVersion
	b += 1

	return buf
}

// Request ListSystemCounters
// size: 4
type ListSystemCountersCookie struct {
	*xgb.Cookie
}

func ListSystemCounters(c *xgb.Conn) ListSystemCountersCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(listSystemCountersRequest(c), cookie)
	return ListSystemCountersCookie{cookie}
}

func ListSystemCountersUnchecked(c *xgb.Conn) ListSystemCountersCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(listSystemCountersRequest(c), cookie)
	return ListSystemCountersCookie{cookie}
}

// Request reply for ListSystemCounters
// size: (32 + SystemcounterListSize(Counters))
type ListSystemCountersReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	CountersLen uint32
	// padding: 20 bytes
	Counters []Systemcounter // size: SystemcounterListSize(Counters)
}

// Waits and reads reply data from request ListSystemCounters
func (cook ListSystemCountersCookie) Reply() (*ListSystemCountersReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listSystemCountersReply(buf), nil
}

// Read reply into structure from buffer for ListSystemCounters
func listSystemCountersReply(buf []byte) *ListSystemCountersReply {
	v := new(ListSystemCountersReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.CountersLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.Counters = make([]Systemcounter, v.CountersLen)
	b += SystemcounterReadList(buf[b:], v.Counters)

	return v
}

// Write request to wire for ListSystemCounters
func listSystemCountersRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request CreateCounter
// size: 16
type CreateCounterCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateCounter
func CreateCounter(c *xgb.Conn, Id Counter, InitialValue Int64) CreateCounterCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createCounterRequest(c, Id, InitialValue), cookie)
	return CreateCounterCookie{cookie}
}

func CreateCounterChecked(c *xgb.Conn, Id Counter, InitialValue Int64) CreateCounterCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createCounterRequest(c, Id, InitialValue), cookie)
	return CreateCounterCookie{cookie}
}

func (cook CreateCounterCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateCounter
func createCounterRequest(c *xgb.Conn, Id Counter, InitialValue Int64) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Id))
	b += 4

	{
		structBytes := InitialValue.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	return buf
}

// Request DestroyCounter
// size: 8
type DestroyCounterCookie struct {
	*xgb.Cookie
}

// Write request to wire for DestroyCounter
func DestroyCounter(c *xgb.Conn, Counter Counter) DestroyCounterCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroyCounterRequest(c, Counter), cookie)
	return DestroyCounterCookie{cookie}
}

func DestroyCounterChecked(c *xgb.Conn, Counter Counter) DestroyCounterCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroyCounterRequest(c, Counter), cookie)
	return DestroyCounterCookie{cookie}
}

func (cook DestroyCounterCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroyCounter
func destroyCounterRequest(c *xgb.Conn, Counter Counter) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Counter))
	b += 4

	return buf
}

// Request QueryCounter
// size: 8
type QueryCounterCookie struct {
	*xgb.Cookie
}

func QueryCounter(c *xgb.Conn, Counter Counter) QueryCounterCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryCounterRequest(c, Counter), cookie)
	return QueryCounterCookie{cookie}
}

func QueryCounterUnchecked(c *xgb.Conn, Counter Counter) QueryCounterCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryCounterRequest(c, Counter), cookie)
	return QueryCounterCookie{cookie}
}

// Request reply for QueryCounter
// size: 16
type QueryCounterReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	CounterValue Int64
}

// Waits and reads reply data from request QueryCounter
func (cook QueryCounterCookie) Reply() (*QueryCounterReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryCounterReply(buf), nil
}

// Read reply into structure from buffer for QueryCounter
func queryCounterReply(buf []byte) *QueryCounterReply {
	v := new(QueryCounterReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.CounterValue = Int64{}
	b += Int64Read(buf[b:], &v.CounterValue)

	return v
}

// Write request to wire for QueryCounter
func queryCounterRequest(c *xgb.Conn, Counter Counter) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Counter))
	b += 4

	return buf
}

// Request Await
// size: xgb.Pad((4 + xgb.Pad((len(WaitList) * 28))))
type AwaitCookie struct {
	*xgb.Cookie
}

// Write request to wire for Await
func Await(c *xgb.Conn, WaitList []Waitcondition) AwaitCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(awaitRequest(c, WaitList), cookie)
	return AwaitCookie{cookie}
}

func AwaitChecked(c *xgb.Conn, WaitList []Waitcondition) AwaitCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(awaitRequest(c, WaitList), cookie)
	return AwaitCookie{cookie}
}

func (cook AwaitCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for Await
func awaitRequest(c *xgb.Conn, WaitList []Waitcondition) []byte {
	size := xgb.Pad((4 + xgb.Pad((len(WaitList) * 28))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	b += WaitconditionListBytes(buf[b:], WaitList)

	return buf
}

// Request ChangeCounter
// size: 16
type ChangeCounterCookie struct {
	*xgb.Cookie
}

// Write request to wire for ChangeCounter
func ChangeCounter(c *xgb.Conn, Counter Counter, Amount Int64) ChangeCounterCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeCounterRequest(c, Counter, Amount), cookie)
	return ChangeCounterCookie{cookie}
}

func ChangeCounterChecked(c *xgb.Conn, Counter Counter, Amount Int64) ChangeCounterCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeCounterRequest(c, Counter, Amount), cookie)
	return ChangeCounterCookie{cookie}
}

func (cook ChangeCounterCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeCounter
func changeCounterRequest(c *xgb.Conn, Counter Counter, Amount Int64) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Counter))
	b += 4

	{
		structBytes := Amount.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	return buf
}

// Request SetCounter
// size: 16
type SetCounterCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetCounter
func SetCounter(c *xgb.Conn, Counter Counter, Value Int64) SetCounterCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setCounterRequest(c, Counter, Value), cookie)
	return SetCounterCookie{cookie}
}

func SetCounterChecked(c *xgb.Conn, Counter Counter, Value Int64) SetCounterCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setCounterRequest(c, Counter, Value), cookie)
	return SetCounterCookie{cookie}
}

func (cook SetCounterCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetCounter
func setCounterRequest(c *xgb.Conn, Counter Counter, Value Int64) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Counter))
	b += 4

	{
		structBytes := Value.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	return buf
}

// Request CreateAlarm
// size: xgb.Pad((8 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
type CreateAlarmCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateAlarm
func CreateAlarm(c *xgb.Conn, Id Alarm, ValueMask uint32, ValueList []uint32) CreateAlarmCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createAlarmRequest(c, Id, ValueMask, ValueList), cookie)
	return CreateAlarmCookie{cookie}
}

func CreateAlarmChecked(c *xgb.Conn, Id Alarm, ValueMask uint32, ValueList []uint32) CreateAlarmCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createAlarmRequest(c, Id, ValueMask, ValueList), cookie)
	return CreateAlarmCookie{cookie}
}

func (cook CreateAlarmCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateAlarm
func createAlarmRequest(c *xgb.Conn, Id Alarm, ValueMask uint32, ValueList []uint32) []byte {
	size := xgb.Pad((8 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 8 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Id))
	b += 4

	xgb.Put32(buf[b:], ValueMask)
	b += 4
	for i := 0; i < xgb.PopCount(int(ValueMask)); i++ {
		xgb.Put32(buf[b:], ValueList[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request ChangeAlarm
// size: xgb.Pad((8 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
type ChangeAlarmCookie struct {
	*xgb.Cookie
}

// Write request to wire for ChangeAlarm
func ChangeAlarm(c *xgb.Conn, Id Alarm, ValueMask uint32, ValueList []uint32) ChangeAlarmCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeAlarmRequest(c, Id, ValueMask, ValueList), cookie)
	return ChangeAlarmCookie{cookie}
}

func ChangeAlarmChecked(c *xgb.Conn, Id Alarm, ValueMask uint32, ValueList []uint32) ChangeAlarmCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeAlarmRequest(c, Id, ValueMask, ValueList), cookie)
	return ChangeAlarmCookie{cookie}
}

func (cook ChangeAlarmCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeAlarm
func changeAlarmRequest(c *xgb.Conn, Id Alarm, ValueMask uint32, ValueList []uint32) []byte {
	size := xgb.Pad((8 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 9 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Id))
	b += 4

	xgb.Put32(buf[b:], ValueMask)
	b += 4
	for i := 0; i < xgb.PopCount(int(ValueMask)); i++ {
		xgb.Put32(buf[b:], ValueList[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request DestroyAlarm
// size: 8
type DestroyAlarmCookie struct {
	*xgb.Cookie
}

// Write request to wire for DestroyAlarm
func DestroyAlarm(c *xgb.Conn, Alarm Alarm) DestroyAlarmCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroyAlarmRequest(c, Alarm), cookie)
	return DestroyAlarmCookie{cookie}
}

func DestroyAlarmChecked(c *xgb.Conn, Alarm Alarm) DestroyAlarmCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroyAlarmRequest(c, Alarm), cookie)
	return DestroyAlarmCookie{cookie}
}

func (cook DestroyAlarmCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroyAlarm
func destroyAlarmRequest(c *xgb.Conn, Alarm Alarm) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 11 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Alarm))
	b += 4

	return buf
}

// Request QueryAlarm
// size: 8
type QueryAlarmCookie struct {
	*xgb.Cookie
}

func QueryAlarm(c *xgb.Conn, Alarm Alarm) QueryAlarmCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryAlarmRequest(c, Alarm), cookie)
	return QueryAlarmCookie{cookie}
}

func QueryAlarmUnchecked(c *xgb.Conn, Alarm Alarm) QueryAlarmCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryAlarmRequest(c, Alarm), cookie)
	return QueryAlarmCookie{cookie}
}

// Request reply for QueryAlarm
// size: 40
type QueryAlarmReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Trigger Trigger
	Delta   Int64
	Events  bool
	State   byte
	// padding: 2 bytes
}

// Waits and reads reply data from request QueryAlarm
func (cook QueryAlarmCookie) Reply() (*QueryAlarmReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryAlarmReply(buf), nil
}

// Read reply into structure from buffer for QueryAlarm
func queryAlarmReply(buf []byte) *QueryAlarmReply {
	v := new(QueryAlarmReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Trigger = Trigger{}
	b += TriggerRead(buf[b:], &v.Trigger)

	v.Delta = Int64{}
	b += Int64Read(buf[b:], &v.Delta)

	if buf[b] == 1 {
		v.Events = true
	} else {
		v.Events = false
	}
	b += 1

	v.State = buf[b]
	b += 1

	b += 2 // padding

	return v
}

// Write request to wire for QueryAlarm
func queryAlarmRequest(c *xgb.Conn, Alarm Alarm) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 10 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Alarm))
	b += 4

	return buf
}

// Request SetPriority
// size: 12
type SetPriorityCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetPriority
func SetPriority(c *xgb.Conn, Id uint32, Priority int32) SetPriorityCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setPriorityRequest(c, Id, Priority), cookie)
	return SetPriorityCookie{cookie}
}

func SetPriorityChecked(c *xgb.Conn, Id uint32, Priority int32) SetPriorityCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setPriorityRequest(c, Id, Priority), cookie)
	return SetPriorityCookie{cookie}
}

func (cook SetPriorityCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetPriority
func setPriorityRequest(c *xgb.Conn, Id uint32, Priority int32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 12 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Id)
	b += 4

	xgb.Put32(buf[b:], uint32(Priority))
	b += 4

	return buf
}

// Request GetPriority
// size: 8
type GetPriorityCookie struct {
	*xgb.Cookie
}

func GetPriority(c *xgb.Conn, Id uint32) GetPriorityCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getPriorityRequest(c, Id), cookie)
	return GetPriorityCookie{cookie}
}

func GetPriorityUnchecked(c *xgb.Conn, Id uint32) GetPriorityCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getPriorityRequest(c, Id), cookie)
	return GetPriorityCookie{cookie}
}

// Request reply for GetPriority
// size: 12
type GetPriorityReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Priority int32
}

// Waits and reads reply data from request GetPriority
func (cook GetPriorityCookie) Reply() (*GetPriorityReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getPriorityReply(buf), nil
}

// Read reply into structure from buffer for GetPriority
func getPriorityReply(buf []byte) *GetPriorityReply {
	v := new(GetPriorityReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Priority = int32(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Write request to wire for GetPriority
func getPriorityRequest(c *xgb.Conn, Id uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 13 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Id)
	b += 4

	return buf
}

// Request CreateFence
// size: 16
type CreateFenceCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateFence
func CreateFence(c *xgb.Conn, Drawable xproto.Drawable, Fence Fence, InitiallyTriggered bool) CreateFenceCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createFenceRequest(c, Drawable, Fence, InitiallyTriggered), cookie)
	return CreateFenceCookie{cookie}
}

func CreateFenceChecked(c *xgb.Conn, Drawable xproto.Drawable, Fence Fence, InitiallyTriggered bool) CreateFenceCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createFenceRequest(c, Drawable, Fence, InitiallyTriggered), cookie)
	return CreateFenceCookie{cookie}
}

func (cook CreateFenceCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateFence
func createFenceRequest(c *xgb.Conn, Drawable xproto.Drawable, Fence Fence, InitiallyTriggered bool) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 14 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Fence))
	b += 4

	if InitiallyTriggered {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request TriggerFence
// size: 8
type TriggerFenceCookie struct {
	*xgb.Cookie
}

// Write request to wire for TriggerFence
func TriggerFence(c *xgb.Conn, Fence Fence) TriggerFenceCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(triggerFenceRequest(c, Fence), cookie)
	return TriggerFenceCookie{cookie}
}

func TriggerFenceChecked(c *xgb.Conn, Fence Fence) TriggerFenceCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(triggerFenceRequest(c, Fence), cookie)
	return TriggerFenceCookie{cookie}
}

func (cook TriggerFenceCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for TriggerFence
func triggerFenceRequest(c *xgb.Conn, Fence Fence) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 15 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Fence))
	b += 4

	return buf
}

// Request ResetFence
// size: 8
type ResetFenceCookie struct {
	*xgb.Cookie
}

// Write request to wire for ResetFence
func ResetFence(c *xgb.Conn, Fence Fence) ResetFenceCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(resetFenceRequest(c, Fence), cookie)
	return ResetFenceCookie{cookie}
}

func ResetFenceChecked(c *xgb.Conn, Fence Fence) ResetFenceCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(resetFenceRequest(c, Fence), cookie)
	return ResetFenceCookie{cookie}
}

func (cook ResetFenceCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ResetFence
func resetFenceRequest(c *xgb.Conn, Fence Fence) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 16 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Fence))
	b += 4

	return buf
}

// Request DestroyFence
// size: 8
type DestroyFenceCookie struct {
	*xgb.Cookie
}

// Write request to wire for DestroyFence
func DestroyFence(c *xgb.Conn, Fence Fence) DestroyFenceCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroyFenceRequest(c, Fence), cookie)
	return DestroyFenceCookie{cookie}
}

func DestroyFenceChecked(c *xgb.Conn, Fence Fence) DestroyFenceCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroyFenceRequest(c, Fence), cookie)
	return DestroyFenceCookie{cookie}
}

func (cook DestroyFenceCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroyFence
func destroyFenceRequest(c *xgb.Conn, Fence Fence) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 17 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Fence))
	b += 4

	return buf
}

// Request QueryFence
// size: 8
type QueryFenceCookie struct {
	*xgb.Cookie
}

func QueryFence(c *xgb.Conn, Fence Fence) QueryFenceCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryFenceRequest(c, Fence), cookie)
	return QueryFenceCookie{cookie}
}

func QueryFenceUnchecked(c *xgb.Conn, Fence Fence) QueryFenceCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryFenceRequest(c, Fence), cookie)
	return QueryFenceCookie{cookie}
}

// Request reply for QueryFence
// size: 32
type QueryFenceReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Triggered bool
	// padding: 23 bytes
}

// Waits and reads reply data from request QueryFence
func (cook QueryFenceCookie) Reply() (*QueryFenceReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryFenceReply(buf), nil
}

// Read reply into structure from buffer for QueryFence
func queryFenceReply(buf []byte) *QueryFenceReply {
	v := new(QueryFenceReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	if buf[b] == 1 {
		v.Triggered = true
	} else {
		v.Triggered = false
	}
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for QueryFence
func queryFenceRequest(c *xgb.Conn, Fence Fence) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 18 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Fence))
	b += 4

	return buf
}

// Request AwaitFence
// size: xgb.Pad((4 + xgb.Pad((len(FenceList) * 4))))
type AwaitFenceCookie struct {
	*xgb.Cookie
}

// Write request to wire for AwaitFence
func AwaitFence(c *xgb.Conn, FenceList []Fence) AwaitFenceCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(awaitFenceRequest(c, FenceList), cookie)
	return AwaitFenceCookie{cookie}
}

func AwaitFenceChecked(c *xgb.Conn, FenceList []Fence) AwaitFenceCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(awaitFenceRequest(c, FenceList), cookie)
	return AwaitFenceCookie{cookie}
}

func (cook AwaitFenceCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for AwaitFence
func awaitFenceRequest(c *xgb.Conn, FenceList []Fence) []byte {
	size := xgb.Pad((4 + xgb.Pad((len(FenceList) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 19 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	for i := 0; i < int(len(FenceList)); i++ {
		xgb.Put32(buf[b:], uint32(FenceList[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}
