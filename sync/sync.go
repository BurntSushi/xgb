// Package sync is the X client API for the SYNC extension.
package sync

/*
	This file was generated by sync.xml on Aug 11 2013 8:39:43pm EDT.
	This file is automatically generated. Edit at your peril!
*/

import (
	"github.com/BurntSushi/xgb"

	"github.com/BurntSushi/xgb/xproto"
)

// Init must be called before using the SYNC extension.
func Init(c *xgb.Conn) error {
	reply, err := xproto.QueryExtension(c, 4, "SYNC").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return xgb.Errorf("No extension named SYNC could be found on on the server.")
	}

	xgb.ExtLock.Lock()
	c.Extensions["SYNC"] = reply.MajorOpcode
	for evNum, fun := range xgb.NewExtEventFuncs["SYNC"] {
		xgb.NewEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range xgb.NewExtErrorFuncs["SYNC"] {
		xgb.NewErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	xgb.ExtLock.Unlock()

	return nil
}

func init() {
	xgb.NewExtEventFuncs["SYNC"] = make(map[int]xgb.NewEventFun)
	xgb.NewExtErrorFuncs["SYNC"] = make(map[int]xgb.NewErrorFun)
}

type Alarm uint32

func NewAlarmId(c *xgb.Conn) (Alarm, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Alarm(id), nil
}

// BadAlarm is the error number for a BadAlarm.
const BadAlarm = 1

type AlarmError struct {
	Sequence    uint16
	NiceName    string
	BadAlarm    uint32
	MinorOpcode uint16
	MajorOpcode byte
}

// AlarmErrorNew constructs a AlarmError value that implements xgb.Error from a byte slice.
func AlarmErrorNew(buf []byte) xgb.Error {
	v := AlarmError{}
	v.NiceName = "Alarm"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.BadAlarm = xgb.Get32(buf[b:])
	b += 4

	v.MinorOpcode = xgb.Get16(buf[b:])
	b += 2

	v.MajorOpcode = buf[b]
	b += 1

	return v
}

// SequenceId returns the sequence id attached to the BadAlarm error.
// This is mostly used internally.
func (err AlarmError) SequenceId() uint16 {
	return err.Sequence
}

// BadId returns the 'BadValue' number if one exists for the BadAlarm error. If no bad value exists, 0 is returned.
func (err AlarmError) BadId() uint32 {
	return 0
}

// Error returns a rudimentary string representation of the BadAlarm error.

func (err AlarmError) Error() string {
	fieldVals := make([]string, 0, 3)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadAlarm: %d", err.BadAlarm))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadAlarm {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["SYNC"][1] = AlarmErrorNew
}

// AlarmNotify is the event number for a AlarmNotifyEvent.
const AlarmNotify = 1

type AlarmNotifyEvent struct {
	Sequence     uint16
	Kind         byte
	Alarm        Alarm
	CounterValue Int64
	AlarmValue   Int64
	Timestamp    xproto.Timestamp
	State        byte
	// padding: 3 bytes
}

// AlarmNotifyEventNew constructs a AlarmNotifyEvent value that implements xgb.Event from a byte slice.
func AlarmNotifyEventNew(buf []byte) xgb.Event {
	v := AlarmNotifyEvent{}
	b := 1 // don't read event number

	v.Kind = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Alarm = Alarm(xgb.Get32(buf[b:]))
	b += 4

	v.CounterValue = Int64{}
	b += Int64Read(buf[b:], &v.CounterValue)

	v.AlarmValue = Int64{}
	b += Int64Read(buf[b:], &v.AlarmValue)

	v.Timestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.State = buf[b]
	b += 1

	b += 3 // padding

	return v
}

// Bytes writes a AlarmNotifyEvent value to a byte slice.
func (v AlarmNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 1
	b += 1

	buf[b] = v.Kind
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Alarm))
	b += 4

	{
		structBytes := v.CounterValue.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.AlarmValue.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	xgb.Put32(buf[b:], uint32(v.Timestamp))
	b += 4

	buf[b] = v.State
	b += 1

	b += 3 // padding

	return buf
}

// SequenceId returns the sequence id attached to the AlarmNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v AlarmNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of AlarmNotifyEvent.
func (v AlarmNotifyEvent) String() string {
	fieldVals := make([]string, 0, 7)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Kind: %d", v.Kind))
	fieldVals = append(fieldVals, xgb.Sprintf("Alarm: %d", v.Alarm))
	fieldVals = append(fieldVals, xgb.Sprintf("Timestamp: %d", v.Timestamp))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	return "AlarmNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["SYNC"][1] = AlarmNotifyEventNew
}

const (
	AlarmstateActive    = 0
	AlarmstateInactive  = 1
	AlarmstateDestroyed = 2
)

const (
	CaCounter   = 1
	CaValueType = 2
	CaValue     = 4
	CaTestType  = 8
	CaDelta     = 16
	CaEvents    = 32
)

type Counter uint32

func NewCounterId(c *xgb.Conn) (Counter, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Counter(id), nil
}

// BadCounter is the error number for a BadCounter.
const BadCounter = 0

type CounterError struct {
	Sequence    uint16
	NiceName    string
	BadCounter  uint32
	MinorOpcode uint16
	MajorOpcode byte
}

// CounterErrorNew constructs a CounterError value that implements xgb.Error from a byte slice.
func CounterErrorNew(buf []byte) xgb.Error {
	v := CounterError{}
	v.NiceName = "Counter"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.BadCounter = xgb.Get32(buf[b:])
	b += 4

	v.MinorOpcode = xgb.Get16(buf[b:])
	b += 2

	v.MajorOpcode = buf[b]
	b += 1

	return v
}

// SequenceId returns the sequence id attached to the BadCounter error.
// This is mostly used internally.
func (err CounterError) SequenceId() uint16 {
	return err.Sequence
}

// BadId returns the 'BadValue' number if one exists for the BadCounter error. If no bad value exists, 0 is returned.
func (err CounterError) BadId() uint32 {
	return 0
}

// Error returns a rudimentary string representation of the BadCounter error.

func (err CounterError) Error() string {
	fieldVals := make([]string, 0, 3)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadCounter: %d", err.BadCounter))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadCounter {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["SYNC"][0] = CounterErrorNew
}

// CounterNotify is the event number for a CounterNotifyEvent.
const CounterNotify = 0

type CounterNotifyEvent struct {
	Sequence     uint16
	Kind         byte
	Counter      Counter
	WaitValue    Int64
	CounterValue Int64
	Timestamp    xproto.Timestamp
	Count        uint16
	Destroyed    bool
	// padding: 1 bytes
}

// CounterNotifyEventNew constructs a CounterNotifyEvent value that implements xgb.Event from a byte slice.
func CounterNotifyEventNew(buf []byte) xgb.Event {
	v := CounterNotifyEvent{}
	b := 1 // don't read event number

	v.Kind = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Counter = Counter(xgb.Get32(buf[b:]))
	b += 4

	v.WaitValue = Int64{}
	b += Int64Read(buf[b:], &v.WaitValue)

	v.CounterValue = Int64{}
	b += Int64Read(buf[b:], &v.CounterValue)

	v.Timestamp = xproto.Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Count = xgb.Get16(buf[b:])
	b += 2

	if buf[b] == 1 {
		v.Destroyed = true
	} else {
		v.Destroyed = false
	}
	b += 1

	b += 1 // padding

	return v
}

// Bytes writes a CounterNotifyEvent value to a byte slice.
func (v CounterNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 0
	b += 1

	buf[b] = v.Kind
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Counter))
	b += 4

	{
		structBytes := v.WaitValue.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.CounterValue.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	xgb.Put32(buf[b:], uint32(v.Timestamp))
	b += 4

	xgb.Put16(buf[b:], v.Count)
	b += 2

	if v.Destroyed {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 1 // padding

	return buf
}

// SequenceId returns the sequence id attached to the CounterNotify event.
// Events without a sequence number (KeymapNotify) return 0.
// This is mostly used internally.
func (v CounterNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

// String is a rudimentary string representation of CounterNotifyEvent.
func (v CounterNotifyEvent) String() string {
	fieldVals := make([]string, 0, 8)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Kind: %d", v.Kind))
	fieldVals = append(fieldVals, xgb.Sprintf("Counter: %d", v.Counter))
	fieldVals = append(fieldVals, xgb.Sprintf("Timestamp: %d", v.Timestamp))
	fieldVals = append(fieldVals, xgb.Sprintf("Count: %d", v.Count))
	fieldVals = append(fieldVals, xgb.Sprintf("Destroyed: %t", v.Destroyed))
	return "CounterNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["SYNC"][0] = CounterNotifyEventNew
}

type Fence uint32

func NewFenceId(c *xgb.Conn) (Fence, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Fence(id), nil
}

type Int64 struct {
	Hi int32
	Lo uint32
}

// Int64Read reads a byte slice into a Int64 value.
func Int64Read(buf []byte, v *Int64) int {
	b := 0

	v.Hi = int32(xgb.Get32(buf[b:]))
	b += 4

	v.Lo = xgb.Get32(buf[b:])
	b += 4

	return b
}

// Int64ReadList reads a byte slice into a list of Int64 values.
func Int64ReadList(buf []byte, dest []Int64) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Int64{}
		b += Int64Read(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a Int64 value to a byte slice.
func (v Int64) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Hi))
	b += 4

	xgb.Put32(buf[b:], v.Lo)
	b += 4

	return buf
}

// Int64ListBytes writes a list of Int64 values to a byte slice.
func Int64ListBytes(buf []byte, list []Int64) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

type Systemcounter struct {
	Counter    Counter
	Resolution Int64
	NameLen    uint16
	Name       string // size: xgb.Pad((int(NameLen) * 1))
}

// SystemcounterRead reads a byte slice into a Systemcounter value.
func SystemcounterRead(buf []byte, v *Systemcounter) int {
	b := 0

	v.Counter = Counter(xgb.Get32(buf[b:]))
	b += 4

	v.Resolution = Int64{}
	b += Int64Read(buf[b:], &v.Resolution)

	v.NameLen = xgb.Get16(buf[b:])
	b += 2

	{
		byteString := make([]byte, v.NameLen)
		copy(byteString[:v.NameLen], buf[b:])
		v.Name = string(byteString)
		b += xgb.Pad(int(v.NameLen))
	}

	return b
}

// SystemcounterReadList reads a byte slice into a list of Systemcounter values.
func SystemcounterReadList(buf []byte, dest []Systemcounter) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Systemcounter{}
		b += SystemcounterRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a Systemcounter value to a byte slice.
func (v Systemcounter) Bytes() []byte {
	buf := make([]byte, (14 + xgb.Pad((int(v.NameLen) * 1))))
	b := 0

	xgb.Put32(buf[b:], uint32(v.Counter))
	b += 4

	{
		structBytes := v.Resolution.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	xgb.Put16(buf[b:], v.NameLen)
	b += 2

	copy(buf[b:], v.Name[:v.NameLen])
	b += xgb.Pad(int(v.NameLen))

	return buf
}

// SystemcounterListBytes writes a list of Systemcounter values to a byte slice.
func SystemcounterListBytes(buf []byte, list []Systemcounter) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// SystemcounterListSize computes the size (bytes) of a list of Systemcounter values.
func SystemcounterListSize(list []Systemcounter) int {
	size := 0
	for _, item := range list {
		size += (14 + xgb.Pad((int(item.NameLen) * 1)))
	}
	return size
}

const (
	TesttypePositiveTransition = 0
	TesttypeNegativeTransition = 1
	TesttypePositiveComparison = 2
	TesttypeNegativeComparison = 3
)

type Trigger struct {
	Counter   Counter
	WaitType  uint32
	WaitValue Int64
	TestType  uint32
}

// TriggerRead reads a byte slice into a Trigger value.
func TriggerRead(buf []byte, v *Trigger) int {
	b := 0

	v.Counter = Counter(xgb.Get32(buf[b:]))
	b += 4

	v.WaitType = xgb.Get32(buf[b:])
	b += 4

	v.WaitValue = Int64{}
	b += Int64Read(buf[b:], &v.WaitValue)

	v.TestType = xgb.Get32(buf[b:])
	b += 4

	return b
}

// TriggerReadList reads a byte slice into a list of Trigger values.
func TriggerReadList(buf []byte, dest []Trigger) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Trigger{}
		b += TriggerRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a Trigger value to a byte slice.
func (v Trigger) Bytes() []byte {
	buf := make([]byte, 20)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Counter))
	b += 4

	xgb.Put32(buf[b:], v.WaitType)
	b += 4

	{
		structBytes := v.WaitValue.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	xgb.Put32(buf[b:], v.TestType)
	b += 4

	return buf
}

// TriggerListBytes writes a list of Trigger values to a byte slice.
func TriggerListBytes(buf []byte, list []Trigger) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

const (
	ValuetypeAbsolute = 0
	ValuetypeRelative = 1
)

type Waitcondition struct {
	Trigger        Trigger
	EventThreshold Int64
}

// WaitconditionRead reads a byte slice into a Waitcondition value.
func WaitconditionRead(buf []byte, v *Waitcondition) int {
	b := 0

	v.Trigger = Trigger{}
	b += TriggerRead(buf[b:], &v.Trigger)

	v.EventThreshold = Int64{}
	b += Int64Read(buf[b:], &v.EventThreshold)

	return b
}

// WaitconditionReadList reads a byte slice into a list of Waitcondition values.
func WaitconditionReadList(buf []byte, dest []Waitcondition) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Waitcondition{}
		b += WaitconditionRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Bytes writes a Waitcondition value to a byte slice.
func (v Waitcondition) Bytes() []byte {
	buf := make([]byte, 28)
	b := 0

	{
		structBytes := v.Trigger.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.EventThreshold.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	return buf
}

// WaitconditionListBytes writes a list of Waitcondition values to a byte slice.
func WaitconditionListBytes(buf []byte, list []Waitcondition) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Card32'

// AwaitCookie is a cookie used only for Await requests.
type AwaitCookie struct {
	*xgb.Cookie
}

// Await sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func Await(c *xgb.Conn, WaitList []Waitcondition) AwaitCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'Await' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(awaitRequest(c, WaitList), cookie)
	return AwaitCookie{cookie}
}

// AwaitChecked sends a checked request.
// If an error occurs, it can be retrieved using AwaitCookie.Check()
func AwaitChecked(c *xgb.Conn, WaitList []Waitcondition) AwaitCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'Await' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(awaitRequest(c, WaitList), cookie)
	return AwaitCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook AwaitCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for Await
// awaitRequest writes a Await request to a byte slice.
func awaitRequest(c *xgb.Conn, WaitList []Waitcondition) []byte {
	size := xgb.Pad((4 + xgb.Pad((len(WaitList) * 28))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	b += WaitconditionListBytes(buf[b:], WaitList)

	return buf
}

// AwaitFenceCookie is a cookie used only for AwaitFence requests.
type AwaitFenceCookie struct {
	*xgb.Cookie
}

// AwaitFence sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func AwaitFence(c *xgb.Conn, FenceList []Fence) AwaitFenceCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'AwaitFence' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(awaitFenceRequest(c, FenceList), cookie)
	return AwaitFenceCookie{cookie}
}

// AwaitFenceChecked sends a checked request.
// If an error occurs, it can be retrieved using AwaitFenceCookie.Check()
func AwaitFenceChecked(c *xgb.Conn, FenceList []Fence) AwaitFenceCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'AwaitFence' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(awaitFenceRequest(c, FenceList), cookie)
	return AwaitFenceCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook AwaitFenceCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for AwaitFence
// awaitFenceRequest writes a AwaitFence request to a byte slice.
func awaitFenceRequest(c *xgb.Conn, FenceList []Fence) []byte {
	size := xgb.Pad((4 + xgb.Pad((len(FenceList) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 19 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	for i := 0; i < int(len(FenceList)); i++ {
		xgb.Put32(buf[b:], uint32(FenceList[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// ChangeAlarmCookie is a cookie used only for ChangeAlarm requests.
type ChangeAlarmCookie struct {
	*xgb.Cookie
}

// ChangeAlarm sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func ChangeAlarm(c *xgb.Conn, Id Alarm, ValueMask uint32, ValueList []uint32) ChangeAlarmCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'ChangeAlarm' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeAlarmRequest(c, Id, ValueMask, ValueList), cookie)
	return ChangeAlarmCookie{cookie}
}

// ChangeAlarmChecked sends a checked request.
// If an error occurs, it can be retrieved using ChangeAlarmCookie.Check()
func ChangeAlarmChecked(c *xgb.Conn, Id Alarm, ValueMask uint32, ValueList []uint32) ChangeAlarmCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'ChangeAlarm' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeAlarmRequest(c, Id, ValueMask, ValueList), cookie)
	return ChangeAlarmCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook ChangeAlarmCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeAlarm
// changeAlarmRequest writes a ChangeAlarm request to a byte slice.
func changeAlarmRequest(c *xgb.Conn, Id Alarm, ValueMask uint32, ValueList []uint32) []byte {
	size := xgb.Pad((8 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 9 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Id))
	b += 4

	xgb.Put32(buf[b:], ValueMask)
	b += 4
	for i := 0; i < xgb.PopCount(int(ValueMask)); i++ {
		xgb.Put32(buf[b:], ValueList[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// ChangeCounterCookie is a cookie used only for ChangeCounter requests.
type ChangeCounterCookie struct {
	*xgb.Cookie
}

// ChangeCounter sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func ChangeCounter(c *xgb.Conn, Counter Counter, Amount Int64) ChangeCounterCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'ChangeCounter' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeCounterRequest(c, Counter, Amount), cookie)
	return ChangeCounterCookie{cookie}
}

// ChangeCounterChecked sends a checked request.
// If an error occurs, it can be retrieved using ChangeCounterCookie.Check()
func ChangeCounterChecked(c *xgb.Conn, Counter Counter, Amount Int64) ChangeCounterCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'ChangeCounter' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeCounterRequest(c, Counter, Amount), cookie)
	return ChangeCounterCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook ChangeCounterCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeCounter
// changeCounterRequest writes a ChangeCounter request to a byte slice.
func changeCounterRequest(c *xgb.Conn, Counter Counter, Amount Int64) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Counter))
	b += 4

	{
		structBytes := Amount.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	return buf
}

// CreateAlarmCookie is a cookie used only for CreateAlarm requests.
type CreateAlarmCookie struct {
	*xgb.Cookie
}

// CreateAlarm sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func CreateAlarm(c *xgb.Conn, Id Alarm, ValueMask uint32, ValueList []uint32) CreateAlarmCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'CreateAlarm' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(createAlarmRequest(c, Id, ValueMask, ValueList), cookie)
	return CreateAlarmCookie{cookie}
}

// CreateAlarmChecked sends a checked request.
// If an error occurs, it can be retrieved using CreateAlarmCookie.Check()
func CreateAlarmChecked(c *xgb.Conn, Id Alarm, ValueMask uint32, ValueList []uint32) CreateAlarmCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'CreateAlarm' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(createAlarmRequest(c, Id, ValueMask, ValueList), cookie)
	return CreateAlarmCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook CreateAlarmCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateAlarm
// createAlarmRequest writes a CreateAlarm request to a byte slice.
func createAlarmRequest(c *xgb.Conn, Id Alarm, ValueMask uint32, ValueList []uint32) []byte {
	size := xgb.Pad((8 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 8 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Id))
	b += 4

	xgb.Put32(buf[b:], ValueMask)
	b += 4
	for i := 0; i < xgb.PopCount(int(ValueMask)); i++ {
		xgb.Put32(buf[b:], ValueList[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// CreateCounterCookie is a cookie used only for CreateCounter requests.
type CreateCounterCookie struct {
	*xgb.Cookie
}

// CreateCounter sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func CreateCounter(c *xgb.Conn, Id Counter, InitialValue Int64) CreateCounterCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'CreateCounter' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(createCounterRequest(c, Id, InitialValue), cookie)
	return CreateCounterCookie{cookie}
}

// CreateCounterChecked sends a checked request.
// If an error occurs, it can be retrieved using CreateCounterCookie.Check()
func CreateCounterChecked(c *xgb.Conn, Id Counter, InitialValue Int64) CreateCounterCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'CreateCounter' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(createCounterRequest(c, Id, InitialValue), cookie)
	return CreateCounterCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook CreateCounterCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateCounter
// createCounterRequest writes a CreateCounter request to a byte slice.
func createCounterRequest(c *xgb.Conn, Id Counter, InitialValue Int64) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Id))
	b += 4

	{
		structBytes := InitialValue.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	return buf
}

// CreateFenceCookie is a cookie used only for CreateFence requests.
type CreateFenceCookie struct {
	*xgb.Cookie
}

// CreateFence sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func CreateFence(c *xgb.Conn, Drawable xproto.Drawable, Fence Fence, InitiallyTriggered bool) CreateFenceCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'CreateFence' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(createFenceRequest(c, Drawable, Fence, InitiallyTriggered), cookie)
	return CreateFenceCookie{cookie}
}

// CreateFenceChecked sends a checked request.
// If an error occurs, it can be retrieved using CreateFenceCookie.Check()
func CreateFenceChecked(c *xgb.Conn, Drawable xproto.Drawable, Fence Fence, InitiallyTriggered bool) CreateFenceCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'CreateFence' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(createFenceRequest(c, Drawable, Fence, InitiallyTriggered), cookie)
	return CreateFenceCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook CreateFenceCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateFence
// createFenceRequest writes a CreateFence request to a byte slice.
func createFenceRequest(c *xgb.Conn, Drawable xproto.Drawable, Fence Fence, InitiallyTriggered bool) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 14 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Fence))
	b += 4

	if InitiallyTriggered {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// DestroyAlarmCookie is a cookie used only for DestroyAlarm requests.
type DestroyAlarmCookie struct {
	*xgb.Cookie
}

// DestroyAlarm sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func DestroyAlarm(c *xgb.Conn, Alarm Alarm) DestroyAlarmCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'DestroyAlarm' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroyAlarmRequest(c, Alarm), cookie)
	return DestroyAlarmCookie{cookie}
}

// DestroyAlarmChecked sends a checked request.
// If an error occurs, it can be retrieved using DestroyAlarmCookie.Check()
func DestroyAlarmChecked(c *xgb.Conn, Alarm Alarm) DestroyAlarmCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'DestroyAlarm' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroyAlarmRequest(c, Alarm), cookie)
	return DestroyAlarmCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook DestroyAlarmCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroyAlarm
// destroyAlarmRequest writes a DestroyAlarm request to a byte slice.
func destroyAlarmRequest(c *xgb.Conn, Alarm Alarm) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 11 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Alarm))
	b += 4

	return buf
}

// DestroyCounterCookie is a cookie used only for DestroyCounter requests.
type DestroyCounterCookie struct {
	*xgb.Cookie
}

// DestroyCounter sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func DestroyCounter(c *xgb.Conn, Counter Counter) DestroyCounterCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'DestroyCounter' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroyCounterRequest(c, Counter), cookie)
	return DestroyCounterCookie{cookie}
}

// DestroyCounterChecked sends a checked request.
// If an error occurs, it can be retrieved using DestroyCounterCookie.Check()
func DestroyCounterChecked(c *xgb.Conn, Counter Counter) DestroyCounterCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'DestroyCounter' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroyCounterRequest(c, Counter), cookie)
	return DestroyCounterCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook DestroyCounterCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroyCounter
// destroyCounterRequest writes a DestroyCounter request to a byte slice.
func destroyCounterRequest(c *xgb.Conn, Counter Counter) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Counter))
	b += 4

	return buf
}

// DestroyFenceCookie is a cookie used only for DestroyFence requests.
type DestroyFenceCookie struct {
	*xgb.Cookie
}

// DestroyFence sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func DestroyFence(c *xgb.Conn, Fence Fence) DestroyFenceCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'DestroyFence' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroyFenceRequest(c, Fence), cookie)
	return DestroyFenceCookie{cookie}
}

// DestroyFenceChecked sends a checked request.
// If an error occurs, it can be retrieved using DestroyFenceCookie.Check()
func DestroyFenceChecked(c *xgb.Conn, Fence Fence) DestroyFenceCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'DestroyFence' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroyFenceRequest(c, Fence), cookie)
	return DestroyFenceCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook DestroyFenceCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroyFence
// destroyFenceRequest writes a DestroyFence request to a byte slice.
func destroyFenceRequest(c *xgb.Conn, Fence Fence) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 17 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Fence))
	b += 4

	return buf
}

// GetPriorityCookie is a cookie used only for GetPriority requests.
type GetPriorityCookie struct {
	*xgb.Cookie
}

// GetPriority sends a checked request.
// If an error occurs, it will be returned with the reply by calling GetPriorityCookie.Reply()
func GetPriority(c *xgb.Conn, Id uint32) GetPriorityCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'GetPriority' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(getPriorityRequest(c, Id), cookie)
	return GetPriorityCookie{cookie}
}

// GetPriorityUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func GetPriorityUnchecked(c *xgb.Conn, Id uint32) GetPriorityCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'GetPriority' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(getPriorityRequest(c, Id), cookie)
	return GetPriorityCookie{cookie}
}

// GetPriorityReply represents the data returned from a GetPriority request.
type GetPriorityReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	Priority int32
}

// Reply blocks and returns the reply data for a GetPriority request.
func (cook GetPriorityCookie) Reply() (*GetPriorityReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getPriorityReply(buf), nil
}

// getPriorityReply reads a byte slice into a GetPriorityReply value.
func getPriorityReply(buf []byte) *GetPriorityReply {
	v := new(GetPriorityReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Priority = int32(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Write request to wire for GetPriority
// getPriorityRequest writes a GetPriority request to a byte slice.
func getPriorityRequest(c *xgb.Conn, Id uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 13 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Id)
	b += 4

	return buf
}

// InitializeCookie is a cookie used only for Initialize requests.
type InitializeCookie struct {
	*xgb.Cookie
}

// Initialize sends a checked request.
// If an error occurs, it will be returned with the reply by calling InitializeCookie.Reply()
func Initialize(c *xgb.Conn, DesiredMajorVersion byte, DesiredMinorVersion byte) InitializeCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'Initialize' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(initializeRequest(c, DesiredMajorVersion, DesiredMinorVersion), cookie)
	return InitializeCookie{cookie}
}

// InitializeUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func InitializeUnchecked(c *xgb.Conn, DesiredMajorVersion byte, DesiredMinorVersion byte) InitializeCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'Initialize' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(initializeRequest(c, DesiredMajorVersion, DesiredMinorVersion), cookie)
	return InitializeCookie{cookie}
}

// InitializeReply represents the data returned from a Initialize request.
type InitializeReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	MajorVersion byte
	MinorVersion byte
	// padding: 22 bytes
}

// Reply blocks and returns the reply data for a Initialize request.
func (cook InitializeCookie) Reply() (*InitializeReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return initializeReply(buf), nil
}

// initializeReply reads a byte slice into a InitializeReply value.
func initializeReply(buf []byte) *InitializeReply {
	v := new(InitializeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.MajorVersion = buf[b]
	b += 1

	v.MinorVersion = buf[b]
	b += 1

	b += 22 // padding

	return v
}

// Write request to wire for Initialize
// initializeRequest writes a Initialize request to a byte slice.
func initializeRequest(c *xgb.Conn, DesiredMajorVersion byte, DesiredMinorVersion byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 0 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = DesiredMajorVersion
	b += 1

	buf[b] = DesiredMinorVersion
	b += 1

	return buf
}

// ListSystemCountersCookie is a cookie used only for ListSystemCounters requests.
type ListSystemCountersCookie struct {
	*xgb.Cookie
}

// ListSystemCounters sends a checked request.
// If an error occurs, it will be returned with the reply by calling ListSystemCountersCookie.Reply()
func ListSystemCounters(c *xgb.Conn) ListSystemCountersCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'ListSystemCounters' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(listSystemCountersRequest(c), cookie)
	return ListSystemCountersCookie{cookie}
}

// ListSystemCountersUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func ListSystemCountersUnchecked(c *xgb.Conn) ListSystemCountersCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'ListSystemCounters' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(listSystemCountersRequest(c), cookie)
	return ListSystemCountersCookie{cookie}
}

// ListSystemCountersReply represents the data returned from a ListSystemCounters request.
type ListSystemCountersReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	CountersLen uint32
	// padding: 20 bytes
	Counters []Systemcounter // size: SystemcounterListSize(Counters)
}

// Reply blocks and returns the reply data for a ListSystemCounters request.
func (cook ListSystemCountersCookie) Reply() (*ListSystemCountersReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listSystemCountersReply(buf), nil
}

// listSystemCountersReply reads a byte slice into a ListSystemCountersReply value.
func listSystemCountersReply(buf []byte) *ListSystemCountersReply {
	v := new(ListSystemCountersReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.CountersLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.Counters = make([]Systemcounter, v.CountersLen)
	b += SystemcounterReadList(buf[b:], v.Counters)

	return v
}

// Write request to wire for ListSystemCounters
// listSystemCountersRequest writes a ListSystemCounters request to a byte slice.
func listSystemCountersRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// QueryAlarmCookie is a cookie used only for QueryAlarm requests.
type QueryAlarmCookie struct {
	*xgb.Cookie
}

// QueryAlarm sends a checked request.
// If an error occurs, it will be returned with the reply by calling QueryAlarmCookie.Reply()
func QueryAlarm(c *xgb.Conn, Alarm Alarm) QueryAlarmCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'QueryAlarm' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryAlarmRequest(c, Alarm), cookie)
	return QueryAlarmCookie{cookie}
}

// QueryAlarmUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func QueryAlarmUnchecked(c *xgb.Conn, Alarm Alarm) QueryAlarmCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'QueryAlarm' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryAlarmRequest(c, Alarm), cookie)
	return QueryAlarmCookie{cookie}
}

// QueryAlarmReply represents the data returned from a QueryAlarm request.
type QueryAlarmReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	Trigger Trigger
	Delta   Int64
	Events  bool
	State   byte
	// padding: 2 bytes
}

// Reply blocks and returns the reply data for a QueryAlarm request.
func (cook QueryAlarmCookie) Reply() (*QueryAlarmReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryAlarmReply(buf), nil
}

// queryAlarmReply reads a byte slice into a QueryAlarmReply value.
func queryAlarmReply(buf []byte) *QueryAlarmReply {
	v := new(QueryAlarmReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Trigger = Trigger{}
	b += TriggerRead(buf[b:], &v.Trigger)

	v.Delta = Int64{}
	b += Int64Read(buf[b:], &v.Delta)

	if buf[b] == 1 {
		v.Events = true
	} else {
		v.Events = false
	}
	b += 1

	v.State = buf[b]
	b += 1

	b += 2 // padding

	return v
}

// Write request to wire for QueryAlarm
// queryAlarmRequest writes a QueryAlarm request to a byte slice.
func queryAlarmRequest(c *xgb.Conn, Alarm Alarm) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 10 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Alarm))
	b += 4

	return buf
}

// QueryCounterCookie is a cookie used only for QueryCounter requests.
type QueryCounterCookie struct {
	*xgb.Cookie
}

// QueryCounter sends a checked request.
// If an error occurs, it will be returned with the reply by calling QueryCounterCookie.Reply()
func QueryCounter(c *xgb.Conn, Counter Counter) QueryCounterCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'QueryCounter' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryCounterRequest(c, Counter), cookie)
	return QueryCounterCookie{cookie}
}

// QueryCounterUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func QueryCounterUnchecked(c *xgb.Conn, Counter Counter) QueryCounterCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'QueryCounter' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryCounterRequest(c, Counter), cookie)
	return QueryCounterCookie{cookie}
}

// QueryCounterReply represents the data returned from a QueryCounter request.
type QueryCounterReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	CounterValue Int64
}

// Reply blocks and returns the reply data for a QueryCounter request.
func (cook QueryCounterCookie) Reply() (*QueryCounterReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryCounterReply(buf), nil
}

// queryCounterReply reads a byte slice into a QueryCounterReply value.
func queryCounterReply(buf []byte) *QueryCounterReply {
	v := new(QueryCounterReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.CounterValue = Int64{}
	b += Int64Read(buf[b:], &v.CounterValue)

	return v
}

// Write request to wire for QueryCounter
// queryCounterRequest writes a QueryCounter request to a byte slice.
func queryCounterRequest(c *xgb.Conn, Counter Counter) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Counter))
	b += 4

	return buf
}

// QueryFenceCookie is a cookie used only for QueryFence requests.
type QueryFenceCookie struct {
	*xgb.Cookie
}

// QueryFence sends a checked request.
// If an error occurs, it will be returned with the reply by calling QueryFenceCookie.Reply()
func QueryFence(c *xgb.Conn, Fence Fence) QueryFenceCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'QueryFence' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryFenceRequest(c, Fence), cookie)
	return QueryFenceCookie{cookie}
}

// QueryFenceUnchecked sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func QueryFenceUnchecked(c *xgb.Conn, Fence Fence) QueryFenceCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'QueryFence' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryFenceRequest(c, Fence), cookie)
	return QueryFenceCookie{cookie}
}

// QueryFenceReply represents the data returned from a QueryFence request.
type QueryFenceReply struct {
	Sequence uint16 // sequence number of the request for this reply
	Length   uint32 // number of bytes in this reply
	// padding: 1 bytes
	Triggered bool
	// padding: 23 bytes
}

// Reply blocks and returns the reply data for a QueryFence request.
func (cook QueryFenceCookie) Reply() (*QueryFenceReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryFenceReply(buf), nil
}

// queryFenceReply reads a byte slice into a QueryFenceReply value.
func queryFenceReply(buf []byte) *QueryFenceReply {
	v := new(QueryFenceReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	if buf[b] == 1 {
		v.Triggered = true
	} else {
		v.Triggered = false
	}
	b += 1

	b += 23 // padding

	return v
}

// Write request to wire for QueryFence
// queryFenceRequest writes a QueryFence request to a byte slice.
func queryFenceRequest(c *xgb.Conn, Fence Fence) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 18 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Fence))
	b += 4

	return buf
}

// ResetFenceCookie is a cookie used only for ResetFence requests.
type ResetFenceCookie struct {
	*xgb.Cookie
}

// ResetFence sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func ResetFence(c *xgb.Conn, Fence Fence) ResetFenceCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'ResetFence' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(resetFenceRequest(c, Fence), cookie)
	return ResetFenceCookie{cookie}
}

// ResetFenceChecked sends a checked request.
// If an error occurs, it can be retrieved using ResetFenceCookie.Check()
func ResetFenceChecked(c *xgb.Conn, Fence Fence) ResetFenceCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'ResetFence' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(resetFenceRequest(c, Fence), cookie)
	return ResetFenceCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook ResetFenceCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ResetFence
// resetFenceRequest writes a ResetFence request to a byte slice.
func resetFenceRequest(c *xgb.Conn, Fence Fence) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 16 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Fence))
	b += 4

	return buf
}

// SetCounterCookie is a cookie used only for SetCounter requests.
type SetCounterCookie struct {
	*xgb.Cookie
}

// SetCounter sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SetCounter(c *xgb.Conn, Counter Counter, Value Int64) SetCounterCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'SetCounter' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(setCounterRequest(c, Counter, Value), cookie)
	return SetCounterCookie{cookie}
}

// SetCounterChecked sends a checked request.
// If an error occurs, it can be retrieved using SetCounterCookie.Check()
func SetCounterChecked(c *xgb.Conn, Counter Counter, Value Int64) SetCounterCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'SetCounter' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(setCounterRequest(c, Counter, Value), cookie)
	return SetCounterCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook SetCounterCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetCounter
// setCounterRequest writes a SetCounter request to a byte slice.
func setCounterRequest(c *xgb.Conn, Counter Counter, Value Int64) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Counter))
	b += 4

	{
		structBytes := Value.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	return buf
}

// SetPriorityCookie is a cookie used only for SetPriority requests.
type SetPriorityCookie struct {
	*xgb.Cookie
}

// SetPriority sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func SetPriority(c *xgb.Conn, Id uint32, Priority int32) SetPriorityCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'SetPriority' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(setPriorityRequest(c, Id, Priority), cookie)
	return SetPriorityCookie{cookie}
}

// SetPriorityChecked sends a checked request.
// If an error occurs, it can be retrieved using SetPriorityCookie.Check()
func SetPriorityChecked(c *xgb.Conn, Id uint32, Priority int32) SetPriorityCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'SetPriority' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(setPriorityRequest(c, Id, Priority), cookie)
	return SetPriorityCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook SetPriorityCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetPriority
// setPriorityRequest writes a SetPriority request to a byte slice.
func setPriorityRequest(c *xgb.Conn, Id uint32, Priority int32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 12 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Id)
	b += 4

	xgb.Put32(buf[b:], uint32(Priority))
	b += 4

	return buf
}

// TriggerFenceCookie is a cookie used only for TriggerFence requests.
type TriggerFenceCookie struct {
	*xgb.Cookie
}

// TriggerFence sends an unchecked request.
// If an error occurs, it can only be retrieved using xgb.WaitForEvent or xgb.PollForEvent.
func TriggerFence(c *xgb.Conn, Fence Fence) TriggerFenceCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'TriggerFence' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(false, false)
	c.NewRequest(triggerFenceRequest(c, Fence), cookie)
	return TriggerFenceCookie{cookie}
}

// TriggerFenceChecked sends a checked request.
// If an error occurs, it can be retrieved using TriggerFenceCookie.Check()
func TriggerFenceChecked(c *xgb.Conn, Fence Fence) TriggerFenceCookie {
	if _, ok := c.Extensions["SYNC"]; !ok {
		panic("Cannot issue request 'TriggerFence' using the uninitialized extension 'SYNC'. sync.Init(connObj) must be called first.")
	}
	cookie := c.NewCookie(true, false)
	c.NewRequest(triggerFenceRequest(c, Fence), cookie)
	return TriggerFenceCookie{cookie}
}

// Check returns an error if one occurred for checked requests that are not expecting a reply.
// This cannot be called for requests expecting a reply, nor for unchecked requests.
func (cook TriggerFenceCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for TriggerFence
// triggerFenceRequest writes a TriggerFence request to a byte slice.
func triggerFenceRequest(c *xgb.Conn, Fence Fence) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["SYNC"]
	b += 1

	buf[b] = 15 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Fence))
	b += 4

	return buf
}
