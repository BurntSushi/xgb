// Package shm is the X client API for the MIT-SHM extension.
package shm

/*
	This file was generated by shm.xml on May 10 2012 8:04:32pm EDT.
	This file is automatically generated. Edit at your peril!
*/

import (
	"github.com/BurntSushi/xgb"

	"github.com/BurntSushi/xgb/xproto"
)

// Init must be called before using the MIT-SHM extension.
func Init(c *xgb.Conn) error {
	reply, err := xproto.QueryExtension(c, 7, "MIT-SHM").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return xgb.Errorf("No extension named MIT-SHM could be found on on the server.")
	}

	xgb.ExtLock.Lock()
	c.Extensions["MIT-SHM"] = reply.MajorOpcode
	for evNum, fun := range xgb.NewExtEventFuncs["MIT-SHM"] {
		xgb.NewEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range xgb.NewExtErrorFuncs["MIT-SHM"] {
		xgb.NewErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	xgb.ExtLock.Unlock()

	return nil
}

func init() {
	xgb.NewExtEventFuncs["MIT-SHM"] = make(map[int]xgb.NewEventFun)
	xgb.NewExtErrorFuncs["MIT-SHM"] = make(map[int]xgb.NewErrorFun)
}

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

type Seg uint32

func NewSegId(c *xgb.Conn) (Seg, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Seg(id), nil
}

// Event definition Completion (0)
// Size: 32

const Completion = 0

type CompletionEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Drawable   xproto.Drawable
	MinorEvent uint16
	MajorEvent byte
	// padding: 1 bytes
	Shmseg Seg
	Offset uint32
}

// Event read Completion
func CompletionEventNew(buf []byte) xgb.Event {
	v := CompletionEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Drawable = xproto.Drawable(xgb.Get32(buf[b:]))
	b += 4

	v.MinorEvent = xgb.Get16(buf[b:])
	b += 2

	v.MajorEvent = buf[b]
	b += 1

	b += 1 // padding

	v.Shmseg = Seg(xgb.Get32(buf[b:]))
	b += 4

	v.Offset = xgb.Get32(buf[b:])
	b += 4

	return v
}

// Event write Completion
func (v CompletionEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 0
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Drawable))
	b += 4

	xgb.Put16(buf[b:], v.MinorEvent)
	b += 2

	buf[b] = v.MajorEvent
	b += 1

	b += 1 // padding

	xgb.Put32(buf[b:], uint32(v.Shmseg))
	b += 4

	xgb.Put32(buf[b:], v.Offset)
	b += 4

	return buf
}

func (v CompletionEvent) ImplementsEvent() {}

func (v CompletionEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v CompletionEvent) String() string {
	fieldVals := make([]string, 0, 7)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Drawable: %d", v.Drawable))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorEvent: %d", v.MinorEvent))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorEvent: %d", v.MajorEvent))
	fieldVals = append(fieldVals, xgb.Sprintf("Shmseg: %d", v.Shmseg))
	fieldVals = append(fieldVals, xgb.Sprintf("Offset: %d", v.Offset))
	return "Completion {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtEventFuncs["MIT-SHM"][0] = CompletionEventNew
}

// ErrorCopy definition BadSeg (0)

const BadBadSeg = 0

type BadSegError xproto.ValueError

func BadSegErrorNew(buf []byte) xgb.Error {
	v := BadSegError(xproto.ValueErrorNew(buf).(xproto.ValueError))
	v.NiceName = "BadSeg"
	return v
}

func (err BadSegError) ImplementsError() {}

func (err BadSegError) SequenceId() uint16 {
	return err.Sequence
}

func (err BadSegError) BadId() uint32 {
	return 0
}

func (err BadSegError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadBadSeg {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["MIT-SHM"][0] = BadSegErrorNew
}

// Request QueryVersion
// size: 4
type QueryVersionCookie struct {
	*xgb.Cookie
}

func QueryVersion(c *xgb.Conn) QueryVersionCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryVersionRequest(c), cookie)
	return QueryVersionCookie{cookie}
}

func QueryVersionUnchecked(c *xgb.Conn) QueryVersionCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryVersionRequest(c), cookie)
	return QueryVersionCookie{cookie}
}

// Request reply for QueryVersion
// size: 32
type QueryVersionReply struct {
	Sequence      uint16
	Length        uint32
	SharedPixmaps bool
	MajorVersion  uint16
	MinorVersion  uint16
	Uid           uint16
	Gid           uint16
	PixmapFormat  byte
	// padding: 15 bytes
}

// Waits and reads reply data from request QueryVersion
func (cook QueryVersionCookie) Reply() (*QueryVersionReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryVersionReply(buf), nil
}

// Read reply into structure from buffer for QueryVersion
func queryVersionReply(buf []byte) *QueryVersionReply {
	v := new(QueryVersionReply)
	b := 1 // skip reply determinant

	if buf[b] == 1 {
		v.SharedPixmaps = true
	} else {
		v.SharedPixmaps = false
	}
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.MajorVersion = xgb.Get16(buf[b:])
	b += 2

	v.MinorVersion = xgb.Get16(buf[b:])
	b += 2

	v.Uid = xgb.Get16(buf[b:])
	b += 2

	v.Gid = xgb.Get16(buf[b:])
	b += 2

	v.PixmapFormat = buf[b]
	b += 1

	b += 15 // padding

	return v
}

// Write request to wire for QueryVersion
func queryVersionRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["MIT-SHM"]
	b += 1

	buf[b] = 0 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request Attach
// size: 16
type AttachCookie struct {
	*xgb.Cookie
}

// Write request to wire for Attach
func Attach(c *xgb.Conn, Shmseg Seg, Shmid uint32, ReadOnly bool) AttachCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(attachRequest(c, Shmseg, Shmid, ReadOnly), cookie)
	return AttachCookie{cookie}
}

func AttachChecked(c *xgb.Conn, Shmseg Seg, Shmid uint32, ReadOnly bool) AttachCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(attachRequest(c, Shmseg, Shmid, ReadOnly), cookie)
	return AttachCookie{cookie}
}

func (cook AttachCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for Attach
func attachRequest(c *xgb.Conn, Shmseg Seg, Shmid uint32, ReadOnly bool) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["MIT-SHM"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Shmseg))
	b += 4

	xgb.Put32(buf[b:], Shmid)
	b += 4

	if ReadOnly {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 3 // padding

	return buf
}

// Request Detach
// size: 8
type DetachCookie struct {
	*xgb.Cookie
}

// Write request to wire for Detach
func Detach(c *xgb.Conn, Shmseg Seg) DetachCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(detachRequest(c, Shmseg), cookie)
	return DetachCookie{cookie}
}

func DetachChecked(c *xgb.Conn, Shmseg Seg) DetachCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(detachRequest(c, Shmseg), cookie)
	return DetachCookie{cookie}
}

func (cook DetachCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for Detach
func detachRequest(c *xgb.Conn, Shmseg Seg) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["MIT-SHM"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Shmseg))
	b += 4

	return buf
}

// Request PutImage
// size: 40
type PutImageCookie struct {
	*xgb.Cookie
}

// Write request to wire for PutImage
func PutImage(c *xgb.Conn, Drawable xproto.Drawable, Gc xproto.Gcontext, TotalWidth uint16, TotalHeight uint16, SrcX uint16, SrcY uint16, SrcWidth uint16, SrcHeight uint16, DstX int16, DstY int16, Depth byte, Format byte, SendEvent byte, Shmseg Seg, Offset uint32) PutImageCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(putImageRequest(c, Drawable, Gc, TotalWidth, TotalHeight, SrcX, SrcY, SrcWidth, SrcHeight, DstX, DstY, Depth, Format, SendEvent, Shmseg, Offset), cookie)
	return PutImageCookie{cookie}
}

func PutImageChecked(c *xgb.Conn, Drawable xproto.Drawable, Gc xproto.Gcontext, TotalWidth uint16, TotalHeight uint16, SrcX uint16, SrcY uint16, SrcWidth uint16, SrcHeight uint16, DstX int16, DstY int16, Depth byte, Format byte, SendEvent byte, Shmseg Seg, Offset uint32) PutImageCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(putImageRequest(c, Drawable, Gc, TotalWidth, TotalHeight, SrcX, SrcY, SrcWidth, SrcHeight, DstX, DstY, Depth, Format, SendEvent, Shmseg, Offset), cookie)
	return PutImageCookie{cookie}
}

func (cook PutImageCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for PutImage
func putImageRequest(c *xgb.Conn, Drawable xproto.Drawable, Gc xproto.Gcontext, TotalWidth uint16, TotalHeight uint16, SrcX uint16, SrcY uint16, SrcWidth uint16, SrcHeight uint16, DstX int16, DstY int16, Depth byte, Format byte, SendEvent byte, Shmseg Seg, Offset uint32) []byte {
	size := 40
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["MIT-SHM"]
	b += 1

	buf[b] = 3 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put16(buf[b:], TotalWidth)
	b += 2

	xgb.Put16(buf[b:], TotalHeight)
	b += 2

	xgb.Put16(buf[b:], SrcX)
	b += 2

	xgb.Put16(buf[b:], SrcY)
	b += 2

	xgb.Put16(buf[b:], SrcWidth)
	b += 2

	xgb.Put16(buf[b:], SrcHeight)
	b += 2

	xgb.Put16(buf[b:], uint16(DstX))
	b += 2

	xgb.Put16(buf[b:], uint16(DstY))
	b += 2

	buf[b] = Depth
	b += 1

	buf[b] = Format
	b += 1

	buf[b] = SendEvent
	b += 1

	b += 1 // padding

	xgb.Put32(buf[b:], uint32(Shmseg))
	b += 4

	xgb.Put32(buf[b:], Offset)
	b += 4

	return buf
}

// Request GetImage
// size: 32
type GetImageCookie struct {
	*xgb.Cookie
}

func GetImage(c *xgb.Conn, Drawable xproto.Drawable, X int16, Y int16, Width uint16, Height uint16, PlaneMask uint32, Format byte, Shmseg Seg, Offset uint32) GetImageCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getImageRequest(c, Drawable, X, Y, Width, Height, PlaneMask, Format, Shmseg, Offset), cookie)
	return GetImageCookie{cookie}
}

func GetImageUnchecked(c *xgb.Conn, Drawable xproto.Drawable, X int16, Y int16, Width uint16, Height uint16, PlaneMask uint32, Format byte, Shmseg Seg, Offset uint32) GetImageCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getImageRequest(c, Drawable, X, Y, Width, Height, PlaneMask, Format, Shmseg, Offset), cookie)
	return GetImageCookie{cookie}
}

// Request reply for GetImage
// size: 16
type GetImageReply struct {
	Sequence uint16
	Length   uint32
	Depth    byte
	Visual   xproto.Visualid
	Size     uint32
}

// Waits and reads reply data from request GetImage
func (cook GetImageCookie) Reply() (*GetImageReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getImageReply(buf), nil
}

// Read reply into structure from buffer for GetImage
func getImageReply(buf []byte) *GetImageReply {
	v := new(GetImageReply)
	b := 1 // skip reply determinant

	v.Depth = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Visual = xproto.Visualid(xgb.Get32(buf[b:]))
	b += 4

	v.Size = xgb.Get32(buf[b:])
	b += 4

	return v
}

// Write request to wire for GetImage
func getImageRequest(c *xgb.Conn, Drawable xproto.Drawable, X int16, Y int16, Width uint16, Height uint16, PlaneMask uint32, Format byte, Shmseg Seg, Offset uint32) []byte {
	size := 32
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["MIT-SHM"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put16(buf[b:], uint16(X))
	b += 2

	xgb.Put16(buf[b:], uint16(Y))
	b += 2

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	xgb.Put32(buf[b:], PlaneMask)
	b += 4

	buf[b] = Format
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], uint32(Shmseg))
	b += 4

	xgb.Put32(buf[b:], Offset)
	b += 4

	return buf
}

// Request CreatePixmap
// size: 28
type CreatePixmapCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreatePixmap
func CreatePixmap(c *xgb.Conn, Pid xproto.Pixmap, Drawable xproto.Drawable, Width uint16, Height uint16, Depth byte, Shmseg Seg, Offset uint32) CreatePixmapCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createPixmapRequest(c, Pid, Drawable, Width, Height, Depth, Shmseg, Offset), cookie)
	return CreatePixmapCookie{cookie}
}

func CreatePixmapChecked(c *xgb.Conn, Pid xproto.Pixmap, Drawable xproto.Drawable, Width uint16, Height uint16, Depth byte, Shmseg Seg, Offset uint32) CreatePixmapCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createPixmapRequest(c, Pid, Drawable, Width, Height, Depth, Shmseg, Offset), cookie)
	return CreatePixmapCookie{cookie}
}

func (cook CreatePixmapCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreatePixmap
func createPixmapRequest(c *xgb.Conn, Pid xproto.Pixmap, Drawable xproto.Drawable, Width uint16, Height uint16, Depth byte, Shmseg Seg, Offset uint32) []byte {
	size := 28
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["MIT-SHM"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Pid))
	b += 4

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	buf[b] = Depth
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], uint32(Shmseg))
	b += 4

	xgb.Put32(buf[b:], Offset)
	b += 4

	return buf
}
