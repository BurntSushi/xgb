// Package xproto is the X client API for the  extension.
package xproto

/*
	This file was generated by xproto.xml on May 10 2012 8:04:32pm EDT.
	This file is automatically generated. Edit at your peril!
*/

import (
	"github.com/BurntSushi/xgb"
)

// Setup parses the setup bytes retrieved when
// connecting into a SetupInfo struct.
func Setup(c *xgb.Conn) *SetupInfo {
	setup := new(SetupInfo)
	SetupInfoRead(c.SetupBytes, setup)
	return setup
}

// DefaultScreen gets the default screen info from SetupInfo.
func (s *SetupInfo) DefaultScreen(c *xgb.Conn) *ScreenInfo {
	return &s.Roots[c.DefaultScreen]
}

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

const (
	VisualClassStaticGray  = 0
	VisualClassGrayScale   = 1
	VisualClassStaticColor = 2
	VisualClassPseudoColor = 3
	VisualClassTrueColor   = 4
	VisualClassDirectColor = 5
)

const (
	EventMaskNoEvent              = 0
	EventMaskKeyPress             = 1
	EventMaskKeyRelease           = 2
	EventMaskButtonPress          = 4
	EventMaskButtonRelease        = 8
	EventMaskEnterWindow          = 16
	EventMaskLeaveWindow          = 32
	EventMaskPointerMotion        = 64
	EventMaskPointerMotionHint    = 128
	EventMaskButton1Motion        = 256
	EventMaskButton2Motion        = 512
	EventMaskButton3Motion        = 1024
	EventMaskButton4Motion        = 2048
	EventMaskButton5Motion        = 4096
	EventMaskButtonMotion         = 8192
	EventMaskKeymapState          = 16384
	EventMaskExposure             = 32768
	EventMaskVisibilityChange     = 65536
	EventMaskStructureNotify      = 131072
	EventMaskResizeRedirect       = 262144
	EventMaskSubstructureNotify   = 524288
	EventMaskSubstructureRedirect = 1048576
	EventMaskFocusChange          = 2097152
	EventMaskPropertyChange       = 4194304
	EventMaskColorMapChange       = 8388608
	EventMaskOwnerGrabButton      = 16777216
)

const (
	BackingStoreNotUseful  = 0
	BackingStoreWhenMapped = 1
	BackingStoreAlways     = 2
)

const (
	ImageOrderLSBFirst = 0
	ImageOrderMSBFirst = 1
)

const (
	ModMaskShift   = 1
	ModMaskLock    = 2
	ModMaskControl = 4
	ModMask1       = 8
	ModMask2       = 16
	ModMask3       = 32
	ModMask4       = 64
	ModMask5       = 128
	ModMaskAny     = 32768
)

const (
	KeyButMaskShift   = 1
	KeyButMaskLock    = 2
	KeyButMaskControl = 4
	KeyButMaskMod1    = 8
	KeyButMaskMod2    = 16
	KeyButMaskMod3    = 32
	KeyButMaskMod4    = 64
	KeyButMaskMod5    = 128
	KeyButMaskButton1 = 256
	KeyButMaskButton2 = 512
	KeyButMaskButton3 = 1024
	KeyButMaskButton4 = 2048
	KeyButMaskButton5 = 4096
)

const (
	WindowNone = 0
)

const (
	ButtonMask1   = 256
	ButtonMask2   = 512
	ButtonMask3   = 1024
	ButtonMask4   = 2048
	ButtonMask5   = 4096
	ButtonMaskAny = 32768
)

const (
	MotionNormal = 0
	MotionHint   = 1
)

const (
	NotifyDetailAncestor         = 0
	NotifyDetailVirtual          = 1
	NotifyDetailInferior         = 2
	NotifyDetailNonlinear        = 3
	NotifyDetailNonlinearVirtual = 4
	NotifyDetailPointer          = 5
	NotifyDetailPointerRoot      = 6
	NotifyDetailNone             = 7
)

const (
	NotifyModeNormal       = 0
	NotifyModeGrab         = 1
	NotifyModeUngrab       = 2
	NotifyModeWhileGrabbed = 3
)

const (
	VisibilityUnobscured        = 0
	VisibilityPartiallyObscured = 1
	VisibilityFullyObscured     = 2
)

const (
	PlaceOnTop    = 0
	PlaceOnBottom = 1
)

const (
	PropertyNewValue = 0
	PropertyDelete   = 1
)

const (
	TimeCurrentTime = 0
)

const (
	AtomNone               = 0
	AtomAny                = 0
	AtomPrimary            = 1
	AtomSecondary          = 2
	AtomArc                = 3
	AtomAtom               = 4
	AtomBitmap             = 5
	AtomCardinal           = 6
	AtomColormap           = 7
	AtomCursor             = 8
	AtomCutBuffer0         = 9
	AtomCutBuffer1         = 10
	AtomCutBuffer2         = 11
	AtomCutBuffer3         = 12
	AtomCutBuffer4         = 13
	AtomCutBuffer5         = 14
	AtomCutBuffer6         = 15
	AtomCutBuffer7         = 16
	AtomDrawable           = 17
	AtomFont               = 18
	AtomInteger            = 19
	AtomPixmap             = 20
	AtomPoint              = 21
	AtomRectangle          = 22
	AtomResourceManager    = 23
	AtomRgbColorMap        = 24
	AtomRgbBestMap         = 25
	AtomRgbBlueMap         = 26
	AtomRgbDefaultMap      = 27
	AtomRgbGrayMap         = 28
	AtomRgbGreenMap        = 29
	AtomRgbRedMap          = 30
	AtomString             = 31
	AtomVisualid           = 32
	AtomWindow             = 33
	AtomWmCommand          = 34
	AtomWmHints            = 35
	AtomWmClientMachine    = 36
	AtomWmIconName         = 37
	AtomWmIconSize         = 38
	AtomWmName             = 39
	AtomWmNormalHints      = 40
	AtomWmSizeHints        = 41
	AtomWmZoomHints        = 42
	AtomMinSpace           = 43
	AtomNormSpace          = 44
	AtomMaxSpace           = 45
	AtomEndSpace           = 46
	AtomSuperscriptX       = 47
	AtomSuperscriptY       = 48
	AtomSubscriptX         = 49
	AtomSubscriptY         = 50
	AtomUnderlinePosition  = 51
	AtomUnderlineThickness = 52
	AtomStrikeoutAscent    = 53
	AtomStrikeoutDescent   = 54
	AtomItalicAngle        = 55
	AtomXHeight            = 56
	AtomQuadWidth          = 57
	AtomWeight             = 58
	AtomPointSize          = 59
	AtomResolution         = 60
	AtomCopyright          = 61
	AtomNotice             = 62
	AtomFontName           = 63
	AtomFamilyName         = 64
	AtomFullName           = 65
	AtomCapHeight          = 66
	AtomWmClass            = 67
	AtomWmTransientFor     = 68
)

const (
	ColormapStateUninstalled = 0
	ColormapStateInstalled   = 1
)

const (
	ColormapNone = 0
)

const (
	MappingModifier = 0
	MappingKeyboard = 1
	MappingPointer  = 2
)

const (
	WindowClassCopyFromParent = 0
	WindowClassInputOutput    = 1
	WindowClassInputOnly      = 2
)

const (
	CwBackPixmap       = 1
	CwBackPixel        = 2
	CwBorderPixmap     = 4
	CwBorderPixel      = 8
	CwBitGravity       = 16
	CwWinGravity       = 32
	CwBackingStore     = 64
	CwBackingPlanes    = 128
	CwBackingPixel     = 256
	CwOverrideRedirect = 512
	CwSaveUnder        = 1024
	CwEventMask        = 2048
	CwDontPropagate    = 4096
	CwColormap         = 8192
	CwCursor           = 16384
)

const (
	BackPixmapNone           = 0
	BackPixmapParentRelative = 1
)

const (
	GravityBitForget = 0
	GravityWinUnmap  = 0
	GravityNorthWest = 1
	GravityNorth     = 2
	GravityNorthEast = 3
	GravityWest      = 4
	GravityCenter    = 5
	GravityEast      = 6
	GravitySouthWest = 7
	GravitySouth     = 8
	GravitySouthEast = 9
	GravityStatic    = 10
)

const (
	MapStateUnmapped   = 0
	MapStateUnviewable = 1
	MapStateViewable   = 2
)

const (
	SetModeInsert = 0
	SetModeDelete = 1
)

const (
	ConfigWindowX           = 1
	ConfigWindowY           = 2
	ConfigWindowWidth       = 4
	ConfigWindowHeight      = 8
	ConfigWindowBorderWidth = 16
	ConfigWindowSibling     = 32
	ConfigWindowStackMode   = 64
)

const (
	StackModeAbove    = 0
	StackModeBelow    = 1
	StackModeTopIf    = 2
	StackModeBottomIf = 3
	StackModeOpposite = 4
)

const (
	CirculateRaiseLowest  = 0
	CirculateLowerHighest = 1
)

const (
	PropModeReplace = 0
	PropModePrepend = 1
	PropModeAppend  = 2
)

const (
	GetPropertyTypeAny = 0
)

const (
	SendEventDestPointerWindow = 0
	SendEventDestItemFocus     = 1
)

const (
	GrabModeSync  = 0
	GrabModeAsync = 1
)

const (
	GrabStatusSuccess        = 0
	GrabStatusAlreadyGrabbed = 1
	GrabStatusInvalidTime    = 2
	GrabStatusNotViewable    = 3
	GrabStatusFrozen         = 4
)

const (
	CursorNone = 0
)

const (
	ButtonIndexAny = 0
	ButtonIndex1   = 1
	ButtonIndex2   = 2
	ButtonIndex3   = 3
	ButtonIndex4   = 4
	ButtonIndex5   = 5
)

const (
	GrabAny = 0
)

const (
	AllowAsyncPointer   = 0
	AllowSyncPointer    = 1
	AllowReplayPointer  = 2
	AllowAsyncKeyboard  = 3
	AllowSyncKeyboard   = 4
	AllowReplayKeyboard = 5
	AllowAsyncBoth      = 6
	AllowSyncBoth       = 7
)

const (
	InputFocusNone           = 0
	InputFocusPointerRoot    = 1
	InputFocusParent         = 2
	InputFocusFollowKeyboard = 3
)

const (
	FontDrawLeftToRight = 0
	FontDrawRightToLeft = 1
)

const (
	GcFunction           = 1
	GcPlaneMask          = 2
	GcForeground         = 4
	GcBackground         = 8
	GcLineWidth          = 16
	GcLineStyle          = 32
	GcCapStyle           = 64
	GcJoinStyle          = 128
	GcFillStyle          = 256
	GcFillRule           = 512
	GcTile               = 1024
	GcStipple            = 2048
	GcTileStippleOriginX = 4096
	GcTileStippleOriginY = 8192
	GcFont               = 16384
	GcSubwindowMode      = 32768
	GcGraphicsExposures  = 65536
	GcClipOriginX        = 131072
	GcClipOriginY        = 262144
	GcClipMask           = 524288
	GcDashOffset         = 1048576
	GcDashList           = 2097152
	GcArcMode            = 4194304
)

const (
	GxClear        = 0
	GxAnd          = 1
	GxAndReverse   = 2
	GxCopy         = 3
	GxAndInverted  = 4
	GxNoop         = 5
	GxXor          = 6
	GxOr           = 7
	GxNor          = 8
	GxEquiv        = 9
	GxInvert       = 10
	GxOrReverse    = 11
	GxCopyInverted = 12
	GxOrInverted   = 13
	GxNand         = 14
	GxSet          = 15
)

const (
	LineStyleSolid      = 0
	LineStyleOnOffDash  = 1
	LineStyleDoubleDash = 2
)

const (
	CapStyleNotLast    = 0
	CapStyleButt       = 1
	CapStyleRound      = 2
	CapStyleProjecting = 3
)

const (
	JoinStyleMiter = 0
	JoinStyleRound = 1
	JoinStyleBevel = 2
)

const (
	FillStyleSolid          = 0
	FillStyleTiled          = 1
	FillStyleStippled       = 2
	FillStyleOpaqueStippled = 3
)

const (
	FillRuleEvenOdd = 0
	FillRuleWinding = 1
)

const (
	SubwindowModeClipByChildren   = 0
	SubwindowModeIncludeInferiors = 1
)

const (
	ArcModeChord    = 0
	ArcModePieSlice = 1
)

const (
	ClipOrderingUnsorted = 0
	ClipOrderingYSorted  = 1
	ClipOrderingYXSorted = 2
	ClipOrderingYXBanded = 3
)

const (
	CoordModeOrigin   = 0
	CoordModePrevious = 1
)

const (
	PolyShapeComplex   = 0
	PolyShapeNonconvex = 1
	PolyShapeConvex    = 2
)

const (
	ImageFormatXYBitmap = 0
	ImageFormatXYPixmap = 1
	ImageFormatZPixmap  = 2
)

const (
	ColormapAllocNone = 0
	ColormapAllocAll  = 1
)

const (
	ColorFlagRed   = 1
	ColorFlagGreen = 2
	ColorFlagBlue  = 4
)

const (
	PixmapNone = 0
)

const (
	FontNone = 0
)

const (
	QueryShapeOfLargestCursor  = 0
	QueryShapeOfFastestTile    = 1
	QueryShapeOfFastestStipple = 2
)

const (
	KbKeyClickPercent = 1
	KbBellPercent     = 2
	KbBellPitch       = 4
	KbBellDuration    = 8
	KbLed             = 16
	KbLedMode         = 32
	KbKey             = 64
	KbAutoRepeatMode  = 128
)

const (
	LedModeOff = 0
	LedModeOn  = 1
)

const (
	AutoRepeatModeOff     = 0
	AutoRepeatModeOn      = 1
	AutoRepeatModeDefault = 2
)

const (
	BlankingNotPreferred = 0
	BlankingPreferred    = 1
	BlankingDefault      = 2
)

const (
	ExposuresNotAllowed = 0
	ExposuresAllowed    = 1
	ExposuresDefault    = 2
)

const (
	HostModeInsert = 0
	HostModeDelete = 1
)

const (
	FamilyInternet          = 0
	FamilyDECnet            = 1
	FamilyChaos             = 2
	FamilyServerInterpreted = 5
	FamilyInternet6         = 6
)

const (
	AccessControlDisable = 0
	AccessControlEnable  = 1
)

const (
	CloseDownDestroyAll      = 0
	CloseDownRetainPermanent = 1
	CloseDownRetainTemporary = 2
)

const (
	KillAllTemporary = 0
)

const (
	ScreenSaverReset  = 0
	ScreenSaverActive = 1
)

const (
	MappingStatusSuccess = 0
	MappingStatusBusy    = 1
	MappingStatusFailure = 2
)

const (
	MapIndexShift   = 0
	MapIndexLock    = 1
	MapIndexControl = 2
	MapIndex1       = 3
	MapIndex2       = 4
	MapIndex3       = 5
	MapIndex4       = 6
	MapIndex5       = 7
)

type Window uint32

func NewWindowId(c *xgb.Conn) (Window, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Window(id), nil
}

type Pixmap uint32

func NewPixmapId(c *xgb.Conn) (Pixmap, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Pixmap(id), nil
}

type Cursor uint32

func NewCursorId(c *xgb.Conn) (Cursor, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Cursor(id), nil
}

type Font uint32

func NewFontId(c *xgb.Conn) (Font, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Font(id), nil
}

type Gcontext uint32

func NewGcontextId(c *xgb.Conn) (Gcontext, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Gcontext(id), nil
}

type Colormap uint32

func NewColormapId(c *xgb.Conn) (Colormap, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Colormap(id), nil
}

type Atom uint32

func NewAtomId(c *xgb.Conn) (Atom, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Atom(id), nil
}

type Drawable uint32

func NewDrawableId(c *xgb.Conn) (Drawable, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Drawable(id), nil
}

type Fontable uint32

func NewFontableId(c *xgb.Conn) (Fontable, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Fontable(id), nil
}

type Visualid uint32

type Timestamp uint32

type Keysym uint32

type Keycode byte

type Button byte

// 'Char2b' struct definition
// Size: 2
type Char2b struct {
	Byte1 byte
	Byte2 byte
}

// Struct read Char2b
func Char2bRead(buf []byte, v *Char2b) int {
	b := 0

	v.Byte1 = buf[b]
	b += 1

	v.Byte2 = buf[b]
	b += 1

	return b
}

// Struct list read Char2b
func Char2bReadList(buf []byte, dest []Char2b) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Char2b{}
		b += Char2bRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Char2b
func (v Char2b) Bytes() []byte {
	buf := make([]byte, 2)
	b := 0

	buf[b] = v.Byte1
	b += 1

	buf[b] = v.Byte2
	b += 1

	return buf
}

// Write struct list Char2b
func Char2bListBytes(buf []byte, list []Char2b) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Point' struct definition
// Size: 4
type Point struct {
	X int16
	Y int16
}

// Struct read Point
func PointRead(buf []byte, v *Point) int {
	b := 0

	v.X = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Y = int16(xgb.Get16(buf[b:]))
	b += 2

	return b
}

// Struct list read Point
func PointReadList(buf []byte, dest []Point) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Point{}
		b += PointRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Point
func (v Point) Bytes() []byte {
	buf := make([]byte, 4)
	b := 0

	xgb.Put16(buf[b:], uint16(v.X))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Y))
	b += 2

	return buf
}

// Write struct list Point
func PointListBytes(buf []byte, list []Point) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Rectangle' struct definition
// Size: 8
type Rectangle struct {
	X      int16
	Y      int16
	Width  uint16
	Height uint16
}

// Struct read Rectangle
func RectangleRead(buf []byte, v *Rectangle) int {
	b := 0

	v.X = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Y = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	return b
}

// Struct list read Rectangle
func RectangleReadList(buf []byte, dest []Rectangle) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Rectangle{}
		b += RectangleRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Rectangle
func (v Rectangle) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put16(buf[b:], uint16(v.X))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Y))
	b += 2

	xgb.Put16(buf[b:], v.Width)
	b += 2

	xgb.Put16(buf[b:], v.Height)
	b += 2

	return buf
}

// Write struct list Rectangle
func RectangleListBytes(buf []byte, list []Rectangle) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Arc' struct definition
// Size: 12
type Arc struct {
	X      int16
	Y      int16
	Width  uint16
	Height uint16
	Angle1 int16
	Angle2 int16
}

// Struct read Arc
func ArcRead(buf []byte, v *Arc) int {
	b := 0

	v.X = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Y = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	v.Angle1 = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Angle2 = int16(xgb.Get16(buf[b:]))
	b += 2

	return b
}

// Struct list read Arc
func ArcReadList(buf []byte, dest []Arc) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Arc{}
		b += ArcRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Arc
func (v Arc) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	xgb.Put16(buf[b:], uint16(v.X))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Y))
	b += 2

	xgb.Put16(buf[b:], v.Width)
	b += 2

	xgb.Put16(buf[b:], v.Height)
	b += 2

	xgb.Put16(buf[b:], uint16(v.Angle1))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Angle2))
	b += 2

	return buf
}

// Write struct list Arc
func ArcListBytes(buf []byte, list []Arc) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Format' struct definition
// Size: 8
type Format struct {
	Depth        byte
	BitsPerPixel byte
	ScanlinePad  byte
	// padding: 5 bytes
}

// Struct read Format
func FormatRead(buf []byte, v *Format) int {
	b := 0

	v.Depth = buf[b]
	b += 1

	v.BitsPerPixel = buf[b]
	b += 1

	v.ScanlinePad = buf[b]
	b += 1

	b += 5 // padding

	return b
}

// Struct list read Format
func FormatReadList(buf []byte, dest []Format) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Format{}
		b += FormatRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Format
func (v Format) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	buf[b] = v.Depth
	b += 1

	buf[b] = v.BitsPerPixel
	b += 1

	buf[b] = v.ScanlinePad
	b += 1

	b += 5 // padding

	return buf
}

// Write struct list Format
func FormatListBytes(buf []byte, list []Format) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'VisualInfo' struct definition
// Size: 24
type VisualInfo struct {
	VisualId        Visualid
	Class           byte
	BitsPerRgbValue byte
	ColormapEntries uint16
	RedMask         uint32
	GreenMask       uint32
	BlueMask        uint32
	// padding: 4 bytes
}

// Struct read VisualInfo
func VisualInfoRead(buf []byte, v *VisualInfo) int {
	b := 0

	v.VisualId = Visualid(xgb.Get32(buf[b:]))
	b += 4

	v.Class = buf[b]
	b += 1

	v.BitsPerRgbValue = buf[b]
	b += 1

	v.ColormapEntries = xgb.Get16(buf[b:])
	b += 2

	v.RedMask = xgb.Get32(buf[b:])
	b += 4

	v.GreenMask = xgb.Get32(buf[b:])
	b += 4

	v.BlueMask = xgb.Get32(buf[b:])
	b += 4

	b += 4 // padding

	return b
}

// Struct list read VisualInfo
func VisualInfoReadList(buf []byte, dest []VisualInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = VisualInfo{}
		b += VisualInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write VisualInfo
func (v VisualInfo) Bytes() []byte {
	buf := make([]byte, 24)
	b := 0

	xgb.Put32(buf[b:], uint32(v.VisualId))
	b += 4

	buf[b] = v.Class
	b += 1

	buf[b] = v.BitsPerRgbValue
	b += 1

	xgb.Put16(buf[b:], v.ColormapEntries)
	b += 2

	xgb.Put32(buf[b:], v.RedMask)
	b += 4

	xgb.Put32(buf[b:], v.GreenMask)
	b += 4

	xgb.Put32(buf[b:], v.BlueMask)
	b += 4

	b += 4 // padding

	return buf
}

// Write struct list VisualInfo
func VisualInfoListBytes(buf []byte, list []VisualInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'DepthInfo' struct definition
// Size: (8 + xgb.Pad((int(VisualsLen) * 24)))
type DepthInfo struct {
	Depth byte
	// padding: 1 bytes
	VisualsLen uint16
	// padding: 4 bytes
	Visuals []VisualInfo // size: xgb.Pad((int(VisualsLen) * 24))
}

// Struct read DepthInfo
func DepthInfoRead(buf []byte, v *DepthInfo) int {
	b := 0

	v.Depth = buf[b]
	b += 1

	b += 1 // padding

	v.VisualsLen = xgb.Get16(buf[b:])
	b += 2

	b += 4 // padding

	v.Visuals = make([]VisualInfo, v.VisualsLen)
	b += VisualInfoReadList(buf[b:], v.Visuals)

	return b
}

// Struct list read DepthInfo
func DepthInfoReadList(buf []byte, dest []DepthInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = DepthInfo{}
		b += DepthInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write DepthInfo
func (v DepthInfo) Bytes() []byte {
	buf := make([]byte, (8 + xgb.Pad((int(v.VisualsLen) * 24))))
	b := 0

	buf[b] = v.Depth
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], v.VisualsLen)
	b += 2

	b += 4 // padding

	b += VisualInfoListBytes(buf[b:], v.Visuals)

	return buf
}

// Write struct list DepthInfo
func DepthInfoListBytes(buf []byte, list []DepthInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size DepthInfo
func DepthInfoListSize(list []DepthInfo) int {
	size := 0
	for _, item := range list {
		size += (8 + xgb.Pad((int(item.VisualsLen) * 24)))
	}
	return size
}

// 'ScreenInfo' struct definition
// Size: (40 + DepthInfoListSize(AllowedDepths))
type ScreenInfo struct {
	Root                Window
	DefaultColormap     Colormap
	WhitePixel          uint32
	BlackPixel          uint32
	CurrentInputMasks   uint32
	WidthInPixels       uint16
	HeightInPixels      uint16
	WidthInMillimeters  uint16
	HeightInMillimeters uint16
	MinInstalledMaps    uint16
	MaxInstalledMaps    uint16
	RootVisual          Visualid
	BackingStores       byte
	SaveUnders          bool
	RootDepth           byte
	AllowedDepthsLen    byte
	AllowedDepths       []DepthInfo // size: DepthInfoListSize(AllowedDepths)
}

// Struct read ScreenInfo
func ScreenInfoRead(buf []byte, v *ScreenInfo) int {
	b := 0

	v.Root = Window(xgb.Get32(buf[b:]))
	b += 4

	v.DefaultColormap = Colormap(xgb.Get32(buf[b:]))
	b += 4

	v.WhitePixel = xgb.Get32(buf[b:])
	b += 4

	v.BlackPixel = xgb.Get32(buf[b:])
	b += 4

	v.CurrentInputMasks = xgb.Get32(buf[b:])
	b += 4

	v.WidthInPixels = xgb.Get16(buf[b:])
	b += 2

	v.HeightInPixels = xgb.Get16(buf[b:])
	b += 2

	v.WidthInMillimeters = xgb.Get16(buf[b:])
	b += 2

	v.HeightInMillimeters = xgb.Get16(buf[b:])
	b += 2

	v.MinInstalledMaps = xgb.Get16(buf[b:])
	b += 2

	v.MaxInstalledMaps = xgb.Get16(buf[b:])
	b += 2

	v.RootVisual = Visualid(xgb.Get32(buf[b:]))
	b += 4

	v.BackingStores = buf[b]
	b += 1

	if buf[b] == 1 {
		v.SaveUnders = true
	} else {
		v.SaveUnders = false
	}
	b += 1

	v.RootDepth = buf[b]
	b += 1

	v.AllowedDepthsLen = buf[b]
	b += 1

	v.AllowedDepths = make([]DepthInfo, v.AllowedDepthsLen)
	b += DepthInfoReadList(buf[b:], v.AllowedDepths)

	return b
}

// Struct list read ScreenInfo
func ScreenInfoReadList(buf []byte, dest []ScreenInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ScreenInfo{}
		b += ScreenInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write ScreenInfo
func (v ScreenInfo) Bytes() []byte {
	buf := make([]byte, (40 + DepthInfoListSize(v.AllowedDepths)))
	b := 0

	xgb.Put32(buf[b:], uint32(v.Root))
	b += 4

	xgb.Put32(buf[b:], uint32(v.DefaultColormap))
	b += 4

	xgb.Put32(buf[b:], v.WhitePixel)
	b += 4

	xgb.Put32(buf[b:], v.BlackPixel)
	b += 4

	xgb.Put32(buf[b:], v.CurrentInputMasks)
	b += 4

	xgb.Put16(buf[b:], v.WidthInPixels)
	b += 2

	xgb.Put16(buf[b:], v.HeightInPixels)
	b += 2

	xgb.Put16(buf[b:], v.WidthInMillimeters)
	b += 2

	xgb.Put16(buf[b:], v.HeightInMillimeters)
	b += 2

	xgb.Put16(buf[b:], v.MinInstalledMaps)
	b += 2

	xgb.Put16(buf[b:], v.MaxInstalledMaps)
	b += 2

	xgb.Put32(buf[b:], uint32(v.RootVisual))
	b += 4

	buf[b] = v.BackingStores
	b += 1

	if v.SaveUnders {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	buf[b] = v.RootDepth
	b += 1

	buf[b] = v.AllowedDepthsLen
	b += 1

	b += DepthInfoListBytes(buf[b:], v.AllowedDepths)

	return buf
}

// Write struct list ScreenInfo
func ScreenInfoListBytes(buf []byte, list []ScreenInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size ScreenInfo
func ScreenInfoListSize(list []ScreenInfo) int {
	size := 0
	for _, item := range list {
		size += (40 + DepthInfoListSize(item.AllowedDepths))
	}
	return size
}

// 'SetupRequest' struct definition
// Size: ((12 + xgb.Pad((int(AuthorizationProtocolNameLen) * 1))) + xgb.Pad((int(AuthorizationProtocolDataLen) * 1)))
type SetupRequest struct {
	ByteOrder byte
	// padding: 1 bytes
	ProtocolMajorVersion         uint16
	ProtocolMinorVersion         uint16
	AuthorizationProtocolNameLen uint16
	AuthorizationProtocolDataLen uint16
	// padding: 2 bytes
	AuthorizationProtocolName string // size: xgb.Pad((int(AuthorizationProtocolNameLen) * 1))
	AuthorizationProtocolData string // size: xgb.Pad((int(AuthorizationProtocolDataLen) * 1))
}

// Struct read SetupRequest
func SetupRequestRead(buf []byte, v *SetupRequest) int {
	b := 0

	v.ByteOrder = buf[b]
	b += 1

	b += 1 // padding

	v.ProtocolMajorVersion = xgb.Get16(buf[b:])
	b += 2

	v.ProtocolMinorVersion = xgb.Get16(buf[b:])
	b += 2

	v.AuthorizationProtocolNameLen = xgb.Get16(buf[b:])
	b += 2

	v.AuthorizationProtocolDataLen = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	{
		byteString := make([]byte, v.AuthorizationProtocolNameLen)
		copy(byteString[:v.AuthorizationProtocolNameLen], buf[b:])
		v.AuthorizationProtocolName = string(byteString)
		b += xgb.Pad(int(v.AuthorizationProtocolNameLen))
	}

	{
		byteString := make([]byte, v.AuthorizationProtocolDataLen)
		copy(byteString[:v.AuthorizationProtocolDataLen], buf[b:])
		v.AuthorizationProtocolData = string(byteString)
		b += xgb.Pad(int(v.AuthorizationProtocolDataLen))
	}

	return b
}

// Struct list read SetupRequest
func SetupRequestReadList(buf []byte, dest []SetupRequest) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SetupRequest{}
		b += SetupRequestRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write SetupRequest
func (v SetupRequest) Bytes() []byte {
	buf := make([]byte, ((12 + xgb.Pad((int(v.AuthorizationProtocolNameLen) * 1))) + xgb.Pad((int(v.AuthorizationProtocolDataLen) * 1))))
	b := 0

	buf[b] = v.ByteOrder
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], v.ProtocolMajorVersion)
	b += 2

	xgb.Put16(buf[b:], v.ProtocolMinorVersion)
	b += 2

	xgb.Put16(buf[b:], v.AuthorizationProtocolNameLen)
	b += 2

	xgb.Put16(buf[b:], v.AuthorizationProtocolDataLen)
	b += 2

	b += 2 // padding

	copy(buf[b:], v.AuthorizationProtocolName[:v.AuthorizationProtocolNameLen])
	b += xgb.Pad(int(v.AuthorizationProtocolNameLen))

	copy(buf[b:], v.AuthorizationProtocolData[:v.AuthorizationProtocolDataLen])
	b += xgb.Pad(int(v.AuthorizationProtocolDataLen))

	return buf
}

// Write struct list SetupRequest
func SetupRequestListBytes(buf []byte, list []SetupRequest) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size SetupRequest
func SetupRequestListSize(list []SetupRequest) int {
	size := 0
	for _, item := range list {
		size += ((12 + xgb.Pad((int(item.AuthorizationProtocolNameLen) * 1))) + xgb.Pad((int(item.AuthorizationProtocolDataLen) * 1)))
	}
	return size
}

// 'SetupFailed' struct definition
// Size: (8 + xgb.Pad((int(ReasonLen) * 1)))
type SetupFailed struct {
	Status               byte
	ReasonLen            byte
	ProtocolMajorVersion uint16
	ProtocolMinorVersion uint16
	Length               uint16
	Reason               string // size: xgb.Pad((int(ReasonLen) * 1))
}

// Struct read SetupFailed
func SetupFailedRead(buf []byte, v *SetupFailed) int {
	b := 0

	v.Status = buf[b]
	b += 1

	v.ReasonLen = buf[b]
	b += 1

	v.ProtocolMajorVersion = xgb.Get16(buf[b:])
	b += 2

	v.ProtocolMinorVersion = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get16(buf[b:])
	b += 2

	{
		byteString := make([]byte, v.ReasonLen)
		copy(byteString[:v.ReasonLen], buf[b:])
		v.Reason = string(byteString)
		b += xgb.Pad(int(v.ReasonLen))
	}

	return b
}

// Struct list read SetupFailed
func SetupFailedReadList(buf []byte, dest []SetupFailed) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SetupFailed{}
		b += SetupFailedRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write SetupFailed
func (v SetupFailed) Bytes() []byte {
	buf := make([]byte, (8 + xgb.Pad((int(v.ReasonLen) * 1))))
	b := 0

	buf[b] = v.Status
	b += 1

	buf[b] = v.ReasonLen
	b += 1

	xgb.Put16(buf[b:], v.ProtocolMajorVersion)
	b += 2

	xgb.Put16(buf[b:], v.ProtocolMinorVersion)
	b += 2

	xgb.Put16(buf[b:], v.Length)
	b += 2

	copy(buf[b:], v.Reason[:v.ReasonLen])
	b += xgb.Pad(int(v.ReasonLen))

	return buf
}

// Write struct list SetupFailed
func SetupFailedListBytes(buf []byte, list []SetupFailed) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size SetupFailed
func SetupFailedListSize(list []SetupFailed) int {
	size := 0
	for _, item := range list {
		size += (8 + xgb.Pad((int(item.ReasonLen) * 1)))
	}
	return size
}

// 'SetupAuthenticate' struct definition
// Size: (8 + xgb.Pad(((int(Length) * 4) * 1)))
type SetupAuthenticate struct {
	Status byte
	// padding: 5 bytes
	Length uint16
	Reason string // size: xgb.Pad(((int(Length) * 4) * 1))
}

// Struct read SetupAuthenticate
func SetupAuthenticateRead(buf []byte, v *SetupAuthenticate) int {
	b := 0

	v.Status = buf[b]
	b += 1

	b += 5 // padding

	v.Length = xgb.Get16(buf[b:])
	b += 2

	{
		byteString := make([]byte, (int(v.Length) * 4))
		copy(byteString[:(int(v.Length)*4)], buf[b:])
		v.Reason = string(byteString)
		b += xgb.Pad(int((int(v.Length) * 4)))
	}

	return b
}

// Struct list read SetupAuthenticate
func SetupAuthenticateReadList(buf []byte, dest []SetupAuthenticate) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SetupAuthenticate{}
		b += SetupAuthenticateRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write SetupAuthenticate
func (v SetupAuthenticate) Bytes() []byte {
	buf := make([]byte, (8 + xgb.Pad(((int(v.Length) * 4) * 1))))
	b := 0

	buf[b] = v.Status
	b += 1

	b += 5 // padding

	xgb.Put16(buf[b:], v.Length)
	b += 2

	copy(buf[b:], v.Reason[:(int(v.Length)*4)])
	b += xgb.Pad(int((int(v.Length) * 4)))

	return buf
}

// Write struct list SetupAuthenticate
func SetupAuthenticateListBytes(buf []byte, list []SetupAuthenticate) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size SetupAuthenticate
func SetupAuthenticateListSize(list []SetupAuthenticate) int {
	size := 0
	for _, item := range list {
		size += (8 + xgb.Pad(((int(item.Length) * 4) * 1)))
	}
	return size
}

// 'SetupInfo' struct definition
// Size: (((40 + xgb.Pad((int(VendorLen) * 1))) + xgb.Pad((int(PixmapFormatsLen) * 8))) + ScreenInfoListSize(Roots))
type SetupInfo struct {
	Status byte
	// padding: 1 bytes
	ProtocolMajorVersion     uint16
	ProtocolMinorVersion     uint16
	Length                   uint16
	ReleaseNumber            uint32
	ResourceIdBase           uint32
	ResourceIdMask           uint32
	MotionBufferSize         uint32
	VendorLen                uint16
	MaximumRequestLength     uint16
	RootsLen                 byte
	PixmapFormatsLen         byte
	ImageByteOrder           byte
	BitmapFormatBitOrder     byte
	BitmapFormatScanlineUnit byte
	BitmapFormatScanlinePad  byte
	MinKeycode               Keycode
	MaxKeycode               Keycode
	// padding: 4 bytes
	Vendor        string       // size: xgb.Pad((int(VendorLen) * 1))
	PixmapFormats []Format     // size: xgb.Pad((int(PixmapFormatsLen) * 8))
	Roots         []ScreenInfo // size: ScreenInfoListSize(Roots)
}

// Struct read SetupInfo
func SetupInfoRead(buf []byte, v *SetupInfo) int {
	b := 0

	v.Status = buf[b]
	b += 1

	b += 1 // padding

	v.ProtocolMajorVersion = xgb.Get16(buf[b:])
	b += 2

	v.ProtocolMinorVersion = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get16(buf[b:])
	b += 2

	v.ReleaseNumber = xgb.Get32(buf[b:])
	b += 4

	v.ResourceIdBase = xgb.Get32(buf[b:])
	b += 4

	v.ResourceIdMask = xgb.Get32(buf[b:])
	b += 4

	v.MotionBufferSize = xgb.Get32(buf[b:])
	b += 4

	v.VendorLen = xgb.Get16(buf[b:])
	b += 2

	v.MaximumRequestLength = xgb.Get16(buf[b:])
	b += 2

	v.RootsLen = buf[b]
	b += 1

	v.PixmapFormatsLen = buf[b]
	b += 1

	v.ImageByteOrder = buf[b]
	b += 1

	v.BitmapFormatBitOrder = buf[b]
	b += 1

	v.BitmapFormatScanlineUnit = buf[b]
	b += 1

	v.BitmapFormatScanlinePad = buf[b]
	b += 1

	v.MinKeycode = Keycode(buf[b])
	b += 1

	v.MaxKeycode = Keycode(buf[b])
	b += 1

	b += 4 // padding

	{
		byteString := make([]byte, v.VendorLen)
		copy(byteString[:v.VendorLen], buf[b:])
		v.Vendor = string(byteString)
		b += xgb.Pad(int(v.VendorLen))
	}

	v.PixmapFormats = make([]Format, v.PixmapFormatsLen)
	b += FormatReadList(buf[b:], v.PixmapFormats)

	v.Roots = make([]ScreenInfo, v.RootsLen)
	b += ScreenInfoReadList(buf[b:], v.Roots)

	return b
}

// Struct list read SetupInfo
func SetupInfoReadList(buf []byte, dest []SetupInfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = SetupInfo{}
		b += SetupInfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write SetupInfo
func (v SetupInfo) Bytes() []byte {
	buf := make([]byte, (((40 + xgb.Pad((int(v.VendorLen) * 1))) + xgb.Pad((int(v.PixmapFormatsLen) * 8))) + ScreenInfoListSize(v.Roots)))
	b := 0

	buf[b] = v.Status
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], v.ProtocolMajorVersion)
	b += 2

	xgb.Put16(buf[b:], v.ProtocolMinorVersion)
	b += 2

	xgb.Put16(buf[b:], v.Length)
	b += 2

	xgb.Put32(buf[b:], v.ReleaseNumber)
	b += 4

	xgb.Put32(buf[b:], v.ResourceIdBase)
	b += 4

	xgb.Put32(buf[b:], v.ResourceIdMask)
	b += 4

	xgb.Put32(buf[b:], v.MotionBufferSize)
	b += 4

	xgb.Put16(buf[b:], v.VendorLen)
	b += 2

	xgb.Put16(buf[b:], v.MaximumRequestLength)
	b += 2

	buf[b] = v.RootsLen
	b += 1

	buf[b] = v.PixmapFormatsLen
	b += 1

	buf[b] = v.ImageByteOrder
	b += 1

	buf[b] = v.BitmapFormatBitOrder
	b += 1

	buf[b] = v.BitmapFormatScanlineUnit
	b += 1

	buf[b] = v.BitmapFormatScanlinePad
	b += 1

	buf[b] = byte(v.MinKeycode)
	b += 1

	buf[b] = byte(v.MaxKeycode)
	b += 1

	b += 4 // padding

	copy(buf[b:], v.Vendor[:v.VendorLen])
	b += xgb.Pad(int(v.VendorLen))

	b += FormatListBytes(buf[b:], v.PixmapFormats)

	b += ScreenInfoListBytes(buf[b:], v.Roots)

	return buf
}

// Write struct list SetupInfo
func SetupInfoListBytes(buf []byte, list []SetupInfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size SetupInfo
func SetupInfoListSize(list []SetupInfo) int {
	size := 0
	for _, item := range list {
		size += (((40 + xgb.Pad((int(item.VendorLen) * 1))) + xgb.Pad((int(item.PixmapFormatsLen) * 8))) + ScreenInfoListSize(item.Roots))
	}
	return size
}

// 'Timecoord' struct definition
// Size: 8
type Timecoord struct {
	Time Timestamp
	X    int16
	Y    int16
}

// Struct read Timecoord
func TimecoordRead(buf []byte, v *Timecoord) int {
	b := 0

	v.Time = Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.X = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Y = int16(xgb.Get16(buf[b:]))
	b += 2

	return b
}

// Struct list read Timecoord
func TimecoordReadList(buf []byte, dest []Timecoord) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Timecoord{}
		b += TimecoordRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Timecoord
func (v Timecoord) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	xgb.Put16(buf[b:], uint16(v.X))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Y))
	b += 2

	return buf
}

// Write struct list Timecoord
func TimecoordListBytes(buf []byte, list []Timecoord) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Fontprop' struct definition
// Size: 8
type Fontprop struct {
	Name  Atom
	Value uint32
}

// Struct read Fontprop
func FontpropRead(buf []byte, v *Fontprop) int {
	b := 0

	v.Name = Atom(xgb.Get32(buf[b:]))
	b += 4

	v.Value = xgb.Get32(buf[b:])
	b += 4

	return b
}

// Struct list read Fontprop
func FontpropReadList(buf []byte, dest []Fontprop) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Fontprop{}
		b += FontpropRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Fontprop
func (v Fontprop) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Name))
	b += 4

	xgb.Put32(buf[b:], v.Value)
	b += 4

	return buf
}

// Write struct list Fontprop
func FontpropListBytes(buf []byte, list []Fontprop) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Charinfo' struct definition
// Size: 12
type Charinfo struct {
	LeftSideBearing  int16
	RightSideBearing int16
	CharacterWidth   int16
	Ascent           int16
	Descent          int16
	Attributes       uint16
}

// Struct read Charinfo
func CharinfoRead(buf []byte, v *Charinfo) int {
	b := 0

	v.LeftSideBearing = int16(xgb.Get16(buf[b:]))
	b += 2

	v.RightSideBearing = int16(xgb.Get16(buf[b:]))
	b += 2

	v.CharacterWidth = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Ascent = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Descent = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Attributes = xgb.Get16(buf[b:])
	b += 2

	return b
}

// Struct list read Charinfo
func CharinfoReadList(buf []byte, dest []Charinfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Charinfo{}
		b += CharinfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Charinfo
func (v Charinfo) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	xgb.Put16(buf[b:], uint16(v.LeftSideBearing))
	b += 2

	xgb.Put16(buf[b:], uint16(v.RightSideBearing))
	b += 2

	xgb.Put16(buf[b:], uint16(v.CharacterWidth))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Ascent))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Descent))
	b += 2

	xgb.Put16(buf[b:], v.Attributes)
	b += 2

	return buf
}

// Write struct list Charinfo
func CharinfoListBytes(buf []byte, list []Charinfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Str' struct definition
// Size: (1 + xgb.Pad((int(NameLen) * 1)))
type Str struct {
	NameLen byte
	Name    string // size: xgb.Pad((int(NameLen) * 1))
}

// Struct read Str
func StrRead(buf []byte, v *Str) int {
	b := 0

	v.NameLen = buf[b]
	b += 1

	{
		byteString := make([]byte, v.NameLen)
		copy(byteString[:v.NameLen], buf[b:])
		v.Name = string(byteString)
		b += xgb.Pad(int(v.NameLen))
	}

	return b
}

// Struct list read Str
func StrReadList(buf []byte, dest []Str) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Str{}
		b += StrRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Str
func (v Str) Bytes() []byte {
	buf := make([]byte, (1 + xgb.Pad((int(v.NameLen) * 1))))
	b := 0

	buf[b] = v.NameLen
	b += 1

	copy(buf[b:], v.Name[:v.NameLen])
	b += xgb.Pad(int(v.NameLen))

	return buf
}

// Write struct list Str
func StrListBytes(buf []byte, list []Str) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size Str
func StrListSize(list []Str) int {
	size := 0
	for _, item := range list {
		size += (1 + xgb.Pad((int(item.NameLen) * 1)))
	}
	return size
}

// 'Segment' struct definition
// Size: 8
type Segment struct {
	X1 int16
	Y1 int16
	X2 int16
	Y2 int16
}

// Struct read Segment
func SegmentRead(buf []byte, v *Segment) int {
	b := 0

	v.X1 = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Y1 = int16(xgb.Get16(buf[b:]))
	b += 2

	v.X2 = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Y2 = int16(xgb.Get16(buf[b:]))
	b += 2

	return b
}

// Struct list read Segment
func SegmentReadList(buf []byte, dest []Segment) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Segment{}
		b += SegmentRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Segment
func (v Segment) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put16(buf[b:], uint16(v.X1))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Y1))
	b += 2

	xgb.Put16(buf[b:], uint16(v.X2))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Y2))
	b += 2

	return buf
}

// Write struct list Segment
func SegmentListBytes(buf []byte, list []Segment) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Coloritem' struct definition
// Size: 12
type Coloritem struct {
	Pixel uint32
	Red   uint16
	Green uint16
	Blue  uint16
	Flags byte
	// padding: 1 bytes
}

// Struct read Coloritem
func ColoritemRead(buf []byte, v *Coloritem) int {
	b := 0

	v.Pixel = xgb.Get32(buf[b:])
	b += 4

	v.Red = xgb.Get16(buf[b:])
	b += 2

	v.Green = xgb.Get16(buf[b:])
	b += 2

	v.Blue = xgb.Get16(buf[b:])
	b += 2

	v.Flags = buf[b]
	b += 1

	b += 1 // padding

	return b
}

// Struct list read Coloritem
func ColoritemReadList(buf []byte, dest []Coloritem) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Coloritem{}
		b += ColoritemRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Coloritem
func (v Coloritem) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	xgb.Put32(buf[b:], v.Pixel)
	b += 4

	xgb.Put16(buf[b:], v.Red)
	b += 2

	xgb.Put16(buf[b:], v.Green)
	b += 2

	xgb.Put16(buf[b:], v.Blue)
	b += 2

	buf[b] = v.Flags
	b += 1

	b += 1 // padding

	return buf
}

// Write struct list Coloritem
func ColoritemListBytes(buf []byte, list []Coloritem) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Rgb' struct definition
// Size: 8
type Rgb struct {
	Red   uint16
	Green uint16
	Blue  uint16
	// padding: 2 bytes
}

// Struct read Rgb
func RgbRead(buf []byte, v *Rgb) int {
	b := 0

	v.Red = xgb.Get16(buf[b:])
	b += 2

	v.Green = xgb.Get16(buf[b:])
	b += 2

	v.Blue = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	return b
}

// Struct list read Rgb
func RgbReadList(buf []byte, dest []Rgb) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Rgb{}
		b += RgbRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Rgb
func (v Rgb) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put16(buf[b:], v.Red)
	b += 2

	xgb.Put16(buf[b:], v.Green)
	b += 2

	xgb.Put16(buf[b:], v.Blue)
	b += 2

	b += 2 // padding

	return buf
}

// Write struct list Rgb
func RgbListBytes(buf []byte, list []Rgb) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Host' struct definition
// Size: (4 + xgb.Pad((int(AddressLen) * 1)))
type Host struct {
	Family byte
	// padding: 1 bytes
	AddressLen uint16
	Address    []byte // size: xgb.Pad((int(AddressLen) * 1))
}

// Struct read Host
func HostRead(buf []byte, v *Host) int {
	b := 0

	v.Family = buf[b]
	b += 1

	b += 1 // padding

	v.AddressLen = xgb.Get16(buf[b:])
	b += 2

	v.Address = make([]byte, v.AddressLen)
	copy(v.Address[:v.AddressLen], buf[b:])
	b += xgb.Pad(int(v.AddressLen))

	return b
}

// Struct list read Host
func HostReadList(buf []byte, dest []Host) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Host{}
		b += HostRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Host
func (v Host) Bytes() []byte {
	buf := make([]byte, (4 + xgb.Pad((int(v.AddressLen) * 1))))
	b := 0

	buf[b] = v.Family
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], v.AddressLen)
	b += 2

	copy(buf[b:], v.Address[:v.AddressLen])
	b += xgb.Pad(int(v.AddressLen))

	return buf
}

// Write struct list Host
func HostListBytes(buf []byte, list []Host) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size Host
func HostListSize(list []Host) int {
	size := 0
	for _, item := range list {
		size += (4 + xgb.Pad((int(item.AddressLen) * 1)))
	}
	return size
}

// Union definition ClientMessageDataUnion
// Note that to *create* a Union, you should *never* create
// this struct directly (unless you know what you're doing).
// Instead use one of the following constructors for 'ClientMessageDataUnion':
//     ClientMessageDataUnionData8New(Data8 []byte) ClientMessageDataUnion
//     ClientMessageDataUnionData16New(Data16 []uint16) ClientMessageDataUnion
//     ClientMessageDataUnionData32New(Data32 []uint32) ClientMessageDataUnion
type ClientMessageDataUnion struct {
	Data8  []byte   // size: 20
	Data16 []uint16 // size: 20
	Data32 []uint32 // size: 20
}

// Union constructor for ClientMessageDataUnion for field Data8.
func ClientMessageDataUnionData8New(Data8 []byte) ClientMessageDataUnion {
	var b int
	buf := make([]byte, 20)

	copy(buf[b:], Data8[:20])
	b += xgb.Pad(int(20))

	// Create the Union type
	v := ClientMessageDataUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Data8 = make([]byte, 20)
	copy(v.Data8[:20], buf[b:])
	b += xgb.Pad(int(20))

	b = 0 // always read the same bytes
	v.Data16 = make([]uint16, 10)
	for i := 0; i < int(10); i++ {
		v.Data16[i] = xgb.Get16(buf[b:])
		b += 2
	}
	b = xgb.Pad(b)

	b = 0 // always read the same bytes
	v.Data32 = make([]uint32, 5)
	for i := 0; i < int(5); i++ {
		v.Data32[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Union constructor for ClientMessageDataUnion for field Data16.
func ClientMessageDataUnionData16New(Data16 []uint16) ClientMessageDataUnion {
	var b int
	buf := make([]byte, 20)

	for i := 0; i < int(10); i++ {
		xgb.Put16(buf[b:], Data16[i])
		b += 2
	}
	b = xgb.Pad(b)

	// Create the Union type
	v := ClientMessageDataUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Data8 = make([]byte, 20)
	copy(v.Data8[:20], buf[b:])
	b += xgb.Pad(int(20))

	b = 0 // always read the same bytes
	v.Data16 = make([]uint16, 10)
	for i := 0; i < int(10); i++ {
		v.Data16[i] = xgb.Get16(buf[b:])
		b += 2
	}
	b = xgb.Pad(b)

	b = 0 // always read the same bytes
	v.Data32 = make([]uint32, 5)
	for i := 0; i < int(5); i++ {
		v.Data32[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Union constructor for ClientMessageDataUnion for field Data32.
func ClientMessageDataUnionData32New(Data32 []uint32) ClientMessageDataUnion {
	var b int
	buf := make([]byte, 20)

	for i := 0; i < int(5); i++ {
		xgb.Put32(buf[b:], Data32[i])
		b += 4
	}
	b = xgb.Pad(b)

	// Create the Union type
	v := ClientMessageDataUnion{}

	// Now copy buf into all fields

	b = 0 // always read the same bytes
	v.Data8 = make([]byte, 20)
	copy(v.Data8[:20], buf[b:])
	b += xgb.Pad(int(20))

	b = 0 // always read the same bytes
	v.Data16 = make([]uint16, 10)
	for i := 0; i < int(10); i++ {
		v.Data16[i] = xgb.Get16(buf[b:])
		b += 2
	}
	b = xgb.Pad(b)

	b = 0 // always read the same bytes
	v.Data32 = make([]uint32, 5)
	for i := 0; i < int(5); i++ {
		v.Data32[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Union read ClientMessageDataUnion
func ClientMessageDataUnionRead(buf []byte, v *ClientMessageDataUnion) int {
	var b int

	b = 0 // re-read the same bytes
	v.Data8 = make([]byte, 20)
	copy(v.Data8[:20], buf[b:])
	b += xgb.Pad(int(20))

	b = 0 // re-read the same bytes
	v.Data16 = make([]uint16, 10)
	for i := 0; i < int(10); i++ {
		v.Data16[i] = xgb.Get16(buf[b:])
		b += 2
	}
	b = xgb.Pad(b)

	b = 0 // re-read the same bytes
	v.Data32 = make([]uint32, 5)
	for i := 0; i < int(5); i++ {
		v.Data32[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return 20
}

// Union list read ClientMessageDataUnion
func ClientMessageDataUnionReadList(buf []byte, dest []ClientMessageDataUnion) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = ClientMessageDataUnion{}
		b += ClientMessageDataUnionRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Union write ClientMessageDataUnion
// Each field in a union must contain the same data.
// So simply pick the first field and write that to the wire.
func (v ClientMessageDataUnion) Bytes() []byte {
	buf := make([]byte, 20)
	b := 0

	copy(buf[b:], v.Data8[:20])
	b += xgb.Pad(int(20))
	return buf
}

// Union list write ClientMessageDataUnion
func ClientMessageDataUnionListBytes(buf []byte, list []ClientMessageDataUnion) int {
	b := 0
	var unionBytes []byte
	for _, item := range list {
		unionBytes = item.Bytes()
		copy(buf[b:], unionBytes)
		b += xgb.Pad(len(unionBytes))
	}
	return b
}

// Event definition KeyPress (2)
// Size: 32

const KeyPress = 2

type KeyPressEvent struct {
	Sequence   uint16
	Detail     Keycode
	Time       Timestamp
	Root       Window
	Event      Window
	Child      Window
	RootX      int16
	RootY      int16
	EventX     int16
	EventY     int16
	State      uint16
	SameScreen bool
	// padding: 1 bytes
}

// Event read KeyPress
func KeyPressEventNew(buf []byte) xgb.Event {
	v := KeyPressEvent{}
	b := 1 // don't read event number

	v.Detail = Keycode(buf[b])
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Root = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Event = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Child = Window(xgb.Get32(buf[b:]))
	b += 4

	v.RootX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.RootY = int16(xgb.Get16(buf[b:]))
	b += 2

	v.EventX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.EventY = int16(xgb.Get16(buf[b:]))
	b += 2

	v.State = xgb.Get16(buf[b:])
	b += 2

	if buf[b] == 1 {
		v.SameScreen = true
	} else {
		v.SameScreen = false
	}
	b += 1

	b += 1 // padding

	return v
}

// Event write KeyPress
func (v KeyPressEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 2
	b += 1

	buf[b] = byte(v.Detail)
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Root))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Event))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Child))
	b += 4

	xgb.Put16(buf[b:], uint16(v.RootX))
	b += 2

	xgb.Put16(buf[b:], uint16(v.RootY))
	b += 2

	xgb.Put16(buf[b:], uint16(v.EventX))
	b += 2

	xgb.Put16(buf[b:], uint16(v.EventY))
	b += 2

	xgb.Put16(buf[b:], v.State)
	b += 2

	if v.SameScreen {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 1 // padding

	return buf
}

func (v KeyPressEvent) ImplementsEvent() {}

func (v KeyPressEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v KeyPressEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	return "KeyPress {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[2] = KeyPressEventNew
}

// Event definition ButtonPress (4)
// Size: 32

const ButtonPress = 4

type ButtonPressEvent struct {
	Sequence   uint16
	Detail     Button
	Time       Timestamp
	Root       Window
	Event      Window
	Child      Window
	RootX      int16
	RootY      int16
	EventX     int16
	EventY     int16
	State      uint16
	SameScreen bool
	// padding: 1 bytes
}

// Event read ButtonPress
func ButtonPressEventNew(buf []byte) xgb.Event {
	v := ButtonPressEvent{}
	b := 1 // don't read event number

	v.Detail = Button(buf[b])
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Root = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Event = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Child = Window(xgb.Get32(buf[b:]))
	b += 4

	v.RootX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.RootY = int16(xgb.Get16(buf[b:]))
	b += 2

	v.EventX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.EventY = int16(xgb.Get16(buf[b:]))
	b += 2

	v.State = xgb.Get16(buf[b:])
	b += 2

	if buf[b] == 1 {
		v.SameScreen = true
	} else {
		v.SameScreen = false
	}
	b += 1

	b += 1 // padding

	return v
}

// Event write ButtonPress
func (v ButtonPressEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 4
	b += 1

	buf[b] = byte(v.Detail)
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Root))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Event))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Child))
	b += 4

	xgb.Put16(buf[b:], uint16(v.RootX))
	b += 2

	xgb.Put16(buf[b:], uint16(v.RootY))
	b += 2

	xgb.Put16(buf[b:], uint16(v.EventX))
	b += 2

	xgb.Put16(buf[b:], uint16(v.EventY))
	b += 2

	xgb.Put16(buf[b:], v.State)
	b += 2

	if v.SameScreen {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 1 // padding

	return buf
}

func (v ButtonPressEvent) ImplementsEvent() {}

func (v ButtonPressEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v ButtonPressEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	return "ButtonPress {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[4] = ButtonPressEventNew
}

// Event definition MotionNotify (6)
// Size: 32

const MotionNotify = 6

type MotionNotifyEvent struct {
	Sequence   uint16
	Detail     byte
	Time       Timestamp
	Root       Window
	Event      Window
	Child      Window
	RootX      int16
	RootY      int16
	EventX     int16
	EventY     int16
	State      uint16
	SameScreen bool
	// padding: 1 bytes
}

// Event read MotionNotify
func MotionNotifyEventNew(buf []byte) xgb.Event {
	v := MotionNotifyEvent{}
	b := 1 // don't read event number

	v.Detail = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Root = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Event = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Child = Window(xgb.Get32(buf[b:]))
	b += 4

	v.RootX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.RootY = int16(xgb.Get16(buf[b:]))
	b += 2

	v.EventX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.EventY = int16(xgb.Get16(buf[b:]))
	b += 2

	v.State = xgb.Get16(buf[b:])
	b += 2

	if buf[b] == 1 {
		v.SameScreen = true
	} else {
		v.SameScreen = false
	}
	b += 1

	b += 1 // padding

	return v
}

// Event write MotionNotify
func (v MotionNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 6
	b += 1

	buf[b] = v.Detail
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Root))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Event))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Child))
	b += 4

	xgb.Put16(buf[b:], uint16(v.RootX))
	b += 2

	xgb.Put16(buf[b:], uint16(v.RootY))
	b += 2

	xgb.Put16(buf[b:], uint16(v.EventX))
	b += 2

	xgb.Put16(buf[b:], uint16(v.EventY))
	b += 2

	xgb.Put16(buf[b:], v.State)
	b += 2

	if v.SameScreen {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 1 // padding

	return buf
}

func (v MotionNotifyEvent) ImplementsEvent() {}

func (v MotionNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v MotionNotifyEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	return "MotionNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[6] = MotionNotifyEventNew
}

// Event definition EnterNotify (7)
// Size: 32

const EnterNotify = 7

type EnterNotifyEvent struct {
	Sequence        uint16
	Detail          byte
	Time            Timestamp
	Root            Window
	Event           Window
	Child           Window
	RootX           int16
	RootY           int16
	EventX          int16
	EventY          int16
	State           uint16
	Mode            byte
	SameScreenFocus byte
}

// Event read EnterNotify
func EnterNotifyEventNew(buf []byte) xgb.Event {
	v := EnterNotifyEvent{}
	b := 1 // don't read event number

	v.Detail = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Root = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Event = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Child = Window(xgb.Get32(buf[b:]))
	b += 4

	v.RootX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.RootY = int16(xgb.Get16(buf[b:]))
	b += 2

	v.EventX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.EventY = int16(xgb.Get16(buf[b:]))
	b += 2

	v.State = xgb.Get16(buf[b:])
	b += 2

	v.Mode = buf[b]
	b += 1

	v.SameScreenFocus = buf[b]
	b += 1

	return v
}

// Event write EnterNotify
func (v EnterNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 7
	b += 1

	buf[b] = v.Detail
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Root))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Event))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Child))
	b += 4

	xgb.Put16(buf[b:], uint16(v.RootX))
	b += 2

	xgb.Put16(buf[b:], uint16(v.RootY))
	b += 2

	xgb.Put16(buf[b:], uint16(v.EventX))
	b += 2

	xgb.Put16(buf[b:], uint16(v.EventY))
	b += 2

	xgb.Put16(buf[b:], v.State)
	b += 2

	buf[b] = v.Mode
	b += 1

	buf[b] = v.SameScreenFocus
	b += 1

	return buf
}

func (v EnterNotifyEvent) ImplementsEvent() {}

func (v EnterNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v EnterNotifyEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("Mode: %d", v.Mode))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreenFocus: %d", v.SameScreenFocus))
	return "EnterNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[7] = EnterNotifyEventNew
}

// Event definition FocusIn (9)
// Size: 32

const FocusIn = 9

type FocusInEvent struct {
	Sequence uint16
	Detail   byte
	Event    Window
	Mode     byte
	// padding: 3 bytes
}

// Event read FocusIn
func FocusInEventNew(buf []byte) xgb.Event {
	v := FocusInEvent{}
	b := 1 // don't read event number

	v.Detail = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Event = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Mode = buf[b]
	b += 1

	b += 3 // padding

	return v
}

// Event write FocusIn
func (v FocusInEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 9
	b += 1

	buf[b] = v.Detail
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Event))
	b += 4

	buf[b] = v.Mode
	b += 1

	b += 3 // padding

	return buf
}

func (v FocusInEvent) ImplementsEvent() {}

func (v FocusInEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v FocusInEvent) String() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Mode: %d", v.Mode))
	return "FocusIn {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[9] = FocusInEventNew
}

// Event definition KeymapNotify (11)
// Size: 32

const KeymapNotify = 11

type KeymapNotifyEvent struct {
	Keys []byte // size: 32
}

// Event read KeymapNotify
func KeymapNotifyEventNew(buf []byte) xgb.Event {
	v := KeymapNotifyEvent{}
	b := 1 // don't read event number

	v.Keys = make([]byte, 31)
	copy(v.Keys[:31], buf[b:])
	b += xgb.Pad(int(31))

	return v
}

// Event write KeymapNotify
func (v KeymapNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 11
	b += 1

	copy(buf[b:], v.Keys[:31])
	b += xgb.Pad(int(31))

	return buf
}

func (v KeymapNotifyEvent) ImplementsEvent() {}

func (v KeymapNotifyEvent) SequenceId() uint16 {
	return uint16(0)
}

func (v KeymapNotifyEvent) String() string {
	fieldVals := make([]string, 0, 1)
	return "KeymapNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[11] = KeymapNotifyEventNew
}

// Event definition Expose (12)
// Size: 32

const Expose = 12

type ExposeEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Window Window
	X      uint16
	Y      uint16
	Width  uint16
	Height uint16
	Count  uint16
	// padding: 2 bytes
}

// Event read Expose
func ExposeEventNew(buf []byte) xgb.Event {
	v := ExposeEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Window = Window(xgb.Get32(buf[b:]))
	b += 4

	v.X = xgb.Get16(buf[b:])
	b += 2

	v.Y = xgb.Get16(buf[b:])
	b += 2

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	v.Count = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	return v
}

// Event write Expose
func (v ExposeEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 12
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	xgb.Put16(buf[b:], v.X)
	b += 2

	xgb.Put16(buf[b:], v.Y)
	b += 2

	xgb.Put16(buf[b:], v.Width)
	b += 2

	xgb.Put16(buf[b:], v.Height)
	b += 2

	xgb.Put16(buf[b:], v.Count)
	b += 2

	b += 2 // padding

	return buf
}

func (v ExposeEvent) ImplementsEvent() {}

func (v ExposeEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v ExposeEvent) String() string {
	fieldVals := make([]string, 0, 8)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("X: %d", v.X))
	fieldVals = append(fieldVals, xgb.Sprintf("Y: %d", v.Y))
	fieldVals = append(fieldVals, xgb.Sprintf("Width: %d", v.Width))
	fieldVals = append(fieldVals, xgb.Sprintf("Height: %d", v.Height))
	fieldVals = append(fieldVals, xgb.Sprintf("Count: %d", v.Count))
	return "Expose {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[12] = ExposeEventNew
}

// Event definition GraphicsExposure (13)
// Size: 32

const GraphicsExposure = 13

type GraphicsExposureEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Drawable    Drawable
	X           uint16
	Y           uint16
	Width       uint16
	Height      uint16
	MinorOpcode uint16
	Count       uint16
	MajorOpcode byte
	// padding: 3 bytes
}

// Event read GraphicsExposure
func GraphicsExposureEventNew(buf []byte) xgb.Event {
	v := GraphicsExposureEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Drawable = Drawable(xgb.Get32(buf[b:]))
	b += 4

	v.X = xgb.Get16(buf[b:])
	b += 2

	v.Y = xgb.Get16(buf[b:])
	b += 2

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	v.MinorOpcode = xgb.Get16(buf[b:])
	b += 2

	v.Count = xgb.Get16(buf[b:])
	b += 2

	v.MajorOpcode = buf[b]
	b += 1

	b += 3 // padding

	return v
}

// Event write GraphicsExposure
func (v GraphicsExposureEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 13
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Drawable))
	b += 4

	xgb.Put16(buf[b:], v.X)
	b += 2

	xgb.Put16(buf[b:], v.Y)
	b += 2

	xgb.Put16(buf[b:], v.Width)
	b += 2

	xgb.Put16(buf[b:], v.Height)
	b += 2

	xgb.Put16(buf[b:], v.MinorOpcode)
	b += 2

	xgb.Put16(buf[b:], v.Count)
	b += 2

	buf[b] = v.MajorOpcode
	b += 1

	b += 3 // padding

	return buf
}

func (v GraphicsExposureEvent) ImplementsEvent() {}

func (v GraphicsExposureEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v GraphicsExposureEvent) String() string {
	fieldVals := make([]string, 0, 10)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Drawable: %d", v.Drawable))
	fieldVals = append(fieldVals, xgb.Sprintf("X: %d", v.X))
	fieldVals = append(fieldVals, xgb.Sprintf("Y: %d", v.Y))
	fieldVals = append(fieldVals, xgb.Sprintf("Width: %d", v.Width))
	fieldVals = append(fieldVals, xgb.Sprintf("Height: %d", v.Height))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", v.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("Count: %d", v.Count))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", v.MajorOpcode))
	return "GraphicsExposure {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[13] = GraphicsExposureEventNew
}

// Event definition NoExposure (14)
// Size: 32

const NoExposure = 14

type NoExposureEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Drawable    Drawable
	MinorOpcode uint16
	MajorOpcode byte
	// padding: 1 bytes
}

// Event read NoExposure
func NoExposureEventNew(buf []byte) xgb.Event {
	v := NoExposureEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Drawable = Drawable(xgb.Get32(buf[b:]))
	b += 4

	v.MinorOpcode = xgb.Get16(buf[b:])
	b += 2

	v.MajorOpcode = buf[b]
	b += 1

	b += 1 // padding

	return v
}

// Event write NoExposure
func (v NoExposureEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 14
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Drawable))
	b += 4

	xgb.Put16(buf[b:], v.MinorOpcode)
	b += 2

	buf[b] = v.MajorOpcode
	b += 1

	b += 1 // padding

	return buf
}

func (v NoExposureEvent) ImplementsEvent() {}

func (v NoExposureEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v NoExposureEvent) String() string {
	fieldVals := make([]string, 0, 5)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Drawable: %d", v.Drawable))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", v.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", v.MajorOpcode))
	return "NoExposure {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[14] = NoExposureEventNew
}

// Event definition VisibilityNotify (15)
// Size: 32

const VisibilityNotify = 15

type VisibilityNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Window Window
	State  byte
	// padding: 3 bytes
}

// Event read VisibilityNotify
func VisibilityNotifyEventNew(buf []byte) xgb.Event {
	v := VisibilityNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Window = Window(xgb.Get32(buf[b:]))
	b += 4

	v.State = buf[b]
	b += 1

	b += 3 // padding

	return v
}

// Event write VisibilityNotify
func (v VisibilityNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 15
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	buf[b] = v.State
	b += 1

	b += 3 // padding

	return buf
}

func (v VisibilityNotifyEvent) ImplementsEvent() {}

func (v VisibilityNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v VisibilityNotifyEvent) String() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	return "VisibilityNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[15] = VisibilityNotifyEventNew
}

// Event definition CreateNotify (16)
// Size: 32

const CreateNotify = 16

type CreateNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Parent           Window
	Window           Window
	X                int16
	Y                int16
	Width            uint16
	Height           uint16
	BorderWidth      uint16
	OverrideRedirect bool
	// padding: 1 bytes
}

// Event read CreateNotify
func CreateNotifyEventNew(buf []byte) xgb.Event {
	v := CreateNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Parent = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Window = Window(xgb.Get32(buf[b:]))
	b += 4

	v.X = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Y = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	v.BorderWidth = xgb.Get16(buf[b:])
	b += 2

	if buf[b] == 1 {
		v.OverrideRedirect = true
	} else {
		v.OverrideRedirect = false
	}
	b += 1

	b += 1 // padding

	return v
}

// Event write CreateNotify
func (v CreateNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 16
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Parent))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	xgb.Put16(buf[b:], uint16(v.X))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Y))
	b += 2

	xgb.Put16(buf[b:], v.Width)
	b += 2

	xgb.Put16(buf[b:], v.Height)
	b += 2

	xgb.Put16(buf[b:], v.BorderWidth)
	b += 2

	if v.OverrideRedirect {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 1 // padding

	return buf
}

func (v CreateNotifyEvent) ImplementsEvent() {}

func (v CreateNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v CreateNotifyEvent) String() string {
	fieldVals := make([]string, 0, 10)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Parent: %d", v.Parent))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("X: %d", v.X))
	fieldVals = append(fieldVals, xgb.Sprintf("Y: %d", v.Y))
	fieldVals = append(fieldVals, xgb.Sprintf("Width: %d", v.Width))
	fieldVals = append(fieldVals, xgb.Sprintf("Height: %d", v.Height))
	fieldVals = append(fieldVals, xgb.Sprintf("BorderWidth: %d", v.BorderWidth))
	fieldVals = append(fieldVals, xgb.Sprintf("OverrideRedirect: %t", v.OverrideRedirect))
	return "CreateNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[16] = CreateNotifyEventNew
}

// Event definition DestroyNotify (17)
// Size: 32

const DestroyNotify = 17

type DestroyNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Event  Window
	Window Window
}

// Event read DestroyNotify
func DestroyNotifyEventNew(buf []byte) xgb.Event {
	v := DestroyNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Event = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Window = Window(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Event write DestroyNotify
func (v DestroyNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 17
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Event))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	return buf
}

func (v DestroyNotifyEvent) ImplementsEvent() {}

func (v DestroyNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v DestroyNotifyEvent) String() string {
	fieldVals := make([]string, 0, 3)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	return "DestroyNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[17] = DestroyNotifyEventNew
}

// Event definition UnmapNotify (18)
// Size: 32

const UnmapNotify = 18

type UnmapNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Event         Window
	Window        Window
	FromConfigure bool
	// padding: 3 bytes
}

// Event read UnmapNotify
func UnmapNotifyEventNew(buf []byte) xgb.Event {
	v := UnmapNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Event = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Window = Window(xgb.Get32(buf[b:]))
	b += 4

	if buf[b] == 1 {
		v.FromConfigure = true
	} else {
		v.FromConfigure = false
	}
	b += 1

	b += 3 // padding

	return v
}

// Event write UnmapNotify
func (v UnmapNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 18
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Event))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	if v.FromConfigure {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 3 // padding

	return buf
}

func (v UnmapNotifyEvent) ImplementsEvent() {}

func (v UnmapNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v UnmapNotifyEvent) String() string {
	fieldVals := make([]string, 0, 5)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("FromConfigure: %t", v.FromConfigure))
	return "UnmapNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[18] = UnmapNotifyEventNew
}

// Event definition MapNotify (19)
// Size: 32

const MapNotify = 19

type MapNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Event            Window
	Window           Window
	OverrideRedirect bool
	// padding: 3 bytes
}

// Event read MapNotify
func MapNotifyEventNew(buf []byte) xgb.Event {
	v := MapNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Event = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Window = Window(xgb.Get32(buf[b:]))
	b += 4

	if buf[b] == 1 {
		v.OverrideRedirect = true
	} else {
		v.OverrideRedirect = false
	}
	b += 1

	b += 3 // padding

	return v
}

// Event write MapNotify
func (v MapNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 19
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Event))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	if v.OverrideRedirect {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 3 // padding

	return buf
}

func (v MapNotifyEvent) ImplementsEvent() {}

func (v MapNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v MapNotifyEvent) String() string {
	fieldVals := make([]string, 0, 5)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("OverrideRedirect: %t", v.OverrideRedirect))
	return "MapNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[19] = MapNotifyEventNew
}

// Event definition MapRequest (20)
// Size: 32

const MapRequest = 20

type MapRequestEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Parent Window
	Window Window
}

// Event read MapRequest
func MapRequestEventNew(buf []byte) xgb.Event {
	v := MapRequestEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Parent = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Window = Window(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Event write MapRequest
func (v MapRequestEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 20
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Parent))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	return buf
}

func (v MapRequestEvent) ImplementsEvent() {}

func (v MapRequestEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v MapRequestEvent) String() string {
	fieldVals := make([]string, 0, 3)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Parent: %d", v.Parent))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	return "MapRequest {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[20] = MapRequestEventNew
}

// Event definition ReparentNotify (21)
// Size: 32

const ReparentNotify = 21

type ReparentNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Event            Window
	Window           Window
	Parent           Window
	X                int16
	Y                int16
	OverrideRedirect bool
	// padding: 3 bytes
}

// Event read ReparentNotify
func ReparentNotifyEventNew(buf []byte) xgb.Event {
	v := ReparentNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Event = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Window = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Parent = Window(xgb.Get32(buf[b:]))
	b += 4

	v.X = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Y = int16(xgb.Get16(buf[b:]))
	b += 2

	if buf[b] == 1 {
		v.OverrideRedirect = true
	} else {
		v.OverrideRedirect = false
	}
	b += 1

	b += 3 // padding

	return v
}

// Event write ReparentNotify
func (v ReparentNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 21
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Event))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Parent))
	b += 4

	xgb.Put16(buf[b:], uint16(v.X))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Y))
	b += 2

	if v.OverrideRedirect {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 3 // padding

	return buf
}

func (v ReparentNotifyEvent) ImplementsEvent() {}

func (v ReparentNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v ReparentNotifyEvent) String() string {
	fieldVals := make([]string, 0, 8)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("Parent: %d", v.Parent))
	fieldVals = append(fieldVals, xgb.Sprintf("X: %d", v.X))
	fieldVals = append(fieldVals, xgb.Sprintf("Y: %d", v.Y))
	fieldVals = append(fieldVals, xgb.Sprintf("OverrideRedirect: %t", v.OverrideRedirect))
	return "ReparentNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[21] = ReparentNotifyEventNew
}

// Event definition ConfigureNotify (22)
// Size: 32

const ConfigureNotify = 22

type ConfigureNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Event            Window
	Window           Window
	AboveSibling     Window
	X                int16
	Y                int16
	Width            uint16
	Height           uint16
	BorderWidth      uint16
	OverrideRedirect bool
	// padding: 1 bytes
}

// Event read ConfigureNotify
func ConfigureNotifyEventNew(buf []byte) xgb.Event {
	v := ConfigureNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Event = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Window = Window(xgb.Get32(buf[b:]))
	b += 4

	v.AboveSibling = Window(xgb.Get32(buf[b:]))
	b += 4

	v.X = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Y = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	v.BorderWidth = xgb.Get16(buf[b:])
	b += 2

	if buf[b] == 1 {
		v.OverrideRedirect = true
	} else {
		v.OverrideRedirect = false
	}
	b += 1

	b += 1 // padding

	return v
}

// Event write ConfigureNotify
func (v ConfigureNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 22
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Event))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	xgb.Put32(buf[b:], uint32(v.AboveSibling))
	b += 4

	xgb.Put16(buf[b:], uint16(v.X))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Y))
	b += 2

	xgb.Put16(buf[b:], v.Width)
	b += 2

	xgb.Put16(buf[b:], v.Height)
	b += 2

	xgb.Put16(buf[b:], v.BorderWidth)
	b += 2

	if v.OverrideRedirect {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	b += 1 // padding

	return buf
}

func (v ConfigureNotifyEvent) ImplementsEvent() {}

func (v ConfigureNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v ConfigureNotifyEvent) String() string {
	fieldVals := make([]string, 0, 11)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("AboveSibling: %d", v.AboveSibling))
	fieldVals = append(fieldVals, xgb.Sprintf("X: %d", v.X))
	fieldVals = append(fieldVals, xgb.Sprintf("Y: %d", v.Y))
	fieldVals = append(fieldVals, xgb.Sprintf("Width: %d", v.Width))
	fieldVals = append(fieldVals, xgb.Sprintf("Height: %d", v.Height))
	fieldVals = append(fieldVals, xgb.Sprintf("BorderWidth: %d", v.BorderWidth))
	fieldVals = append(fieldVals, xgb.Sprintf("OverrideRedirect: %t", v.OverrideRedirect))
	return "ConfigureNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[22] = ConfigureNotifyEventNew
}

// Event definition ConfigureRequest (23)
// Size: 32

const ConfigureRequest = 23

type ConfigureRequestEvent struct {
	Sequence    uint16
	StackMode   byte
	Parent      Window
	Window      Window
	Sibling     Window
	X           int16
	Y           int16
	Width       uint16
	Height      uint16
	BorderWidth uint16
	ValueMask   uint16
}

// Event read ConfigureRequest
func ConfigureRequestEventNew(buf []byte) xgb.Event {
	v := ConfigureRequestEvent{}
	b := 1 // don't read event number

	v.StackMode = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Parent = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Window = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Sibling = Window(xgb.Get32(buf[b:]))
	b += 4

	v.X = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Y = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	v.BorderWidth = xgb.Get16(buf[b:])
	b += 2

	v.ValueMask = xgb.Get16(buf[b:])
	b += 2

	return v
}

// Event write ConfigureRequest
func (v ConfigureRequestEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 23
	b += 1

	buf[b] = v.StackMode
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Parent))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Sibling))
	b += 4

	xgb.Put16(buf[b:], uint16(v.X))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Y))
	b += 2

	xgb.Put16(buf[b:], v.Width)
	b += 2

	xgb.Put16(buf[b:], v.Height)
	b += 2

	xgb.Put16(buf[b:], v.BorderWidth)
	b += 2

	xgb.Put16(buf[b:], v.ValueMask)
	b += 2

	return buf
}

func (v ConfigureRequestEvent) ImplementsEvent() {}

func (v ConfigureRequestEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v ConfigureRequestEvent) String() string {
	fieldVals := make([]string, 0, 10)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("StackMode: %d", v.StackMode))
	fieldVals = append(fieldVals, xgb.Sprintf("Parent: %d", v.Parent))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("Sibling: %d", v.Sibling))
	fieldVals = append(fieldVals, xgb.Sprintf("X: %d", v.X))
	fieldVals = append(fieldVals, xgb.Sprintf("Y: %d", v.Y))
	fieldVals = append(fieldVals, xgb.Sprintf("Width: %d", v.Width))
	fieldVals = append(fieldVals, xgb.Sprintf("Height: %d", v.Height))
	fieldVals = append(fieldVals, xgb.Sprintf("BorderWidth: %d", v.BorderWidth))
	fieldVals = append(fieldVals, xgb.Sprintf("ValueMask: %d", v.ValueMask))
	return "ConfigureRequest {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[23] = ConfigureRequestEventNew
}

// Event definition GravityNotify (24)
// Size: 32

const GravityNotify = 24

type GravityNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Event  Window
	Window Window
	X      int16
	Y      int16
}

// Event read GravityNotify
func GravityNotifyEventNew(buf []byte) xgb.Event {
	v := GravityNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Event = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Window = Window(xgb.Get32(buf[b:]))
	b += 4

	v.X = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Y = int16(xgb.Get16(buf[b:]))
	b += 2

	return v
}

// Event write GravityNotify
func (v GravityNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 24
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Event))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	xgb.Put16(buf[b:], uint16(v.X))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Y))
	b += 2

	return buf
}

func (v GravityNotifyEvent) ImplementsEvent() {}

func (v GravityNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v GravityNotifyEvent) String() string {
	fieldVals := make([]string, 0, 5)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("X: %d", v.X))
	fieldVals = append(fieldVals, xgb.Sprintf("Y: %d", v.Y))
	return "GravityNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[24] = GravityNotifyEventNew
}

// Event definition ResizeRequest (25)
// Size: 32

const ResizeRequest = 25

type ResizeRequestEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Window Window
	Width  uint16
	Height uint16
}

// Event read ResizeRequest
func ResizeRequestEventNew(buf []byte) xgb.Event {
	v := ResizeRequestEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Window = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	return v
}

// Event write ResizeRequest
func (v ResizeRequestEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 25
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	xgb.Put16(buf[b:], v.Width)
	b += 2

	xgb.Put16(buf[b:], v.Height)
	b += 2

	return buf
}

func (v ResizeRequestEvent) ImplementsEvent() {}

func (v ResizeRequestEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v ResizeRequestEvent) String() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("Width: %d", v.Width))
	fieldVals = append(fieldVals, xgb.Sprintf("Height: %d", v.Height))
	return "ResizeRequest {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[25] = ResizeRequestEventNew
}

// Event definition CirculateNotify (26)
// Size: 32

const CirculateNotify = 26

type CirculateNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Event  Window
	Window Window
	// padding: 4 bytes
	Place byte
	// padding: 3 bytes
}

// Event read CirculateNotify
func CirculateNotifyEventNew(buf []byte) xgb.Event {
	v := CirculateNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Event = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Window = Window(xgb.Get32(buf[b:]))
	b += 4

	b += 4 // padding

	v.Place = buf[b]
	b += 1

	b += 3 // padding

	return v
}

// Event write CirculateNotify
func (v CirculateNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 26
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Event))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	b += 4 // padding

	buf[b] = v.Place
	b += 1

	b += 3 // padding

	return buf
}

func (v CirculateNotifyEvent) ImplementsEvent() {}

func (v CirculateNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v CirculateNotifyEvent) String() string {
	fieldVals := make([]string, 0, 6)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("Place: %d", v.Place))
	return "CirculateNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[26] = CirculateNotifyEventNew
}

// Event definition PropertyNotify (28)
// Size: 32

const PropertyNotify = 28

type PropertyNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Window Window
	Atom   Atom
	Time   Timestamp
	State  byte
	// padding: 3 bytes
}

// Event read PropertyNotify
func PropertyNotifyEventNew(buf []byte) xgb.Event {
	v := PropertyNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Window = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Atom = Atom(xgb.Get32(buf[b:]))
	b += 4

	v.Time = Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.State = buf[b]
	b += 1

	b += 3 // padding

	return v
}

// Event write PropertyNotify
func (v PropertyNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 28
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Atom))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	buf[b] = v.State
	b += 1

	b += 3 // padding

	return buf
}

func (v PropertyNotifyEvent) ImplementsEvent() {}

func (v PropertyNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v PropertyNotifyEvent) String() string {
	fieldVals := make([]string, 0, 6)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("Atom: %d", v.Atom))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	return "PropertyNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[28] = PropertyNotifyEventNew
}

// Event definition SelectionClear (29)
// Size: 32

const SelectionClear = 29

type SelectionClearEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Time      Timestamp
	Owner     Window
	Selection Atom
}

// Event read SelectionClear
func SelectionClearEventNew(buf []byte) xgb.Event {
	v := SelectionClearEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Owner = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Selection = Atom(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Event write SelectionClear
func (v SelectionClearEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 29
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Owner))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Selection))
	b += 4

	return buf
}

func (v SelectionClearEvent) ImplementsEvent() {}

func (v SelectionClearEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v SelectionClearEvent) String() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Owner: %d", v.Owner))
	fieldVals = append(fieldVals, xgb.Sprintf("Selection: %d", v.Selection))
	return "SelectionClear {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[29] = SelectionClearEventNew
}

// Event definition SelectionRequest (30)
// Size: 32

const SelectionRequest = 30

type SelectionRequestEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Time      Timestamp
	Owner     Window
	Requestor Window
	Selection Atom
	Target    Atom
	Property  Atom
}

// Event read SelectionRequest
func SelectionRequestEventNew(buf []byte) xgb.Event {
	v := SelectionRequestEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Owner = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Requestor = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Selection = Atom(xgb.Get32(buf[b:]))
	b += 4

	v.Target = Atom(xgb.Get32(buf[b:]))
	b += 4

	v.Property = Atom(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Event write SelectionRequest
func (v SelectionRequestEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 30
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Owner))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Requestor))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Selection))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Target))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Property))
	b += 4

	return buf
}

func (v SelectionRequestEvent) ImplementsEvent() {}

func (v SelectionRequestEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v SelectionRequestEvent) String() string {
	fieldVals := make([]string, 0, 7)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Owner: %d", v.Owner))
	fieldVals = append(fieldVals, xgb.Sprintf("Requestor: %d", v.Requestor))
	fieldVals = append(fieldVals, xgb.Sprintf("Selection: %d", v.Selection))
	fieldVals = append(fieldVals, xgb.Sprintf("Target: %d", v.Target))
	fieldVals = append(fieldVals, xgb.Sprintf("Property: %d", v.Property))
	return "SelectionRequest {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[30] = SelectionRequestEventNew
}

// Event definition SelectionNotify (31)
// Size: 32

const SelectionNotify = 31

type SelectionNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Time      Timestamp
	Requestor Window
	Selection Atom
	Target    Atom
	Property  Atom
}

// Event read SelectionNotify
func SelectionNotifyEventNew(buf []byte) xgb.Event {
	v := SelectionNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Time = Timestamp(xgb.Get32(buf[b:]))
	b += 4

	v.Requestor = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Selection = Atom(xgb.Get32(buf[b:]))
	b += 4

	v.Target = Atom(xgb.Get32(buf[b:]))
	b += 4

	v.Property = Atom(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Event write SelectionNotify
func (v SelectionNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 31
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Time))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Requestor))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Selection))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Target))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Property))
	b += 4

	return buf
}

func (v SelectionNotifyEvent) ImplementsEvent() {}

func (v SelectionNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v SelectionNotifyEvent) String() string {
	fieldVals := make([]string, 0, 6)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Requestor: %d", v.Requestor))
	fieldVals = append(fieldVals, xgb.Sprintf("Selection: %d", v.Selection))
	fieldVals = append(fieldVals, xgb.Sprintf("Target: %d", v.Target))
	fieldVals = append(fieldVals, xgb.Sprintf("Property: %d", v.Property))
	return "SelectionNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[31] = SelectionNotifyEventNew
}

// Event definition ColormapNotify (32)
// Size: 32

const ColormapNotify = 32

type ColormapNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Window   Window
	Colormap Colormap
	New      bool
	State    byte
	// padding: 2 bytes
}

// Event read ColormapNotify
func ColormapNotifyEventNew(buf []byte) xgb.Event {
	v := ColormapNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Window = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Colormap = Colormap(xgb.Get32(buf[b:]))
	b += 4

	if buf[b] == 1 {
		v.New = true
	} else {
		v.New = false
	}
	b += 1

	v.State = buf[b]
	b += 1

	b += 2 // padding

	return v
}

// Event write ColormapNotify
func (v ColormapNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 32
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Colormap))
	b += 4

	if v.New {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	buf[b] = v.State
	b += 1

	b += 2 // padding

	return buf
}

func (v ColormapNotifyEvent) ImplementsEvent() {}

func (v ColormapNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v ColormapNotifyEvent) String() string {
	fieldVals := make([]string, 0, 6)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("Colormap: %d", v.Colormap))
	fieldVals = append(fieldVals, xgb.Sprintf("New: %t", v.New))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	return "ColormapNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[32] = ColormapNotifyEventNew
}

// Event definition ClientMessage (33)
// Size: 32

const ClientMessage = 33

type ClientMessageEvent struct {
	Sequence uint16
	Format   byte
	Window   Window
	Type     Atom
	Data     ClientMessageDataUnion
}

// Event read ClientMessage
func ClientMessageEventNew(buf []byte) xgb.Event {
	v := ClientMessageEvent{}
	b := 1 // don't read event number

	v.Format = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Window = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Type = Atom(xgb.Get32(buf[b:]))
	b += 4

	v.Data = ClientMessageDataUnion{}
	b += ClientMessageDataUnionRead(buf[b:], &v.Data)

	return v
}

// Event write ClientMessage
func (v ClientMessageEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 33
	b += 1

	buf[b] = v.Format
	b += 1

	b += 2 // skip sequence number

	xgb.Put32(buf[b:], uint32(v.Window))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Type))
	b += 4

	{
		unionBytes := v.Data.Bytes()
		copy(buf[b:], unionBytes)
		b += xgb.Pad(len(unionBytes))
	}

	return buf
}

func (v ClientMessageEvent) ImplementsEvent() {}

func (v ClientMessageEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v ClientMessageEvent) String() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Format: %d", v.Format))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("Type: %d", v.Type))
	return "ClientMessage {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[33] = ClientMessageEventNew
}

// Event definition MappingNotify (34)
// Size: 32

const MappingNotify = 34

type MappingNotifyEvent struct {
	Sequence uint16
	// padding: 1 bytes
	Request      byte
	FirstKeycode Keycode
	Count        byte
	// padding: 1 bytes
}

// Event read MappingNotify
func MappingNotifyEventNew(buf []byte) xgb.Event {
	v := MappingNotifyEvent{}
	b := 1 // don't read event number

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Request = buf[b]
	b += 1

	v.FirstKeycode = Keycode(buf[b])
	b += 1

	v.Count = buf[b]
	b += 1

	b += 1 // padding

	return v
}

// Event write MappingNotify
func (v MappingNotifyEvent) Bytes() []byte {
	buf := make([]byte, 32)
	b := 0

	// write event number
	buf[b] = 34
	b += 1

	b += 1 // padding

	b += 2 // skip sequence number

	buf[b] = v.Request
	b += 1

	buf[b] = byte(v.FirstKeycode)
	b += 1

	buf[b] = v.Count
	b += 1

	b += 1 // padding

	return buf
}

func (v MappingNotifyEvent) ImplementsEvent() {}

func (v MappingNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v MappingNotifyEvent) String() string {
	fieldVals := make([]string, 0, 5)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Request: %d", v.Request))
	fieldVals = append(fieldVals, xgb.Sprintf("FirstKeycode: %d", v.FirstKeycode))
	fieldVals = append(fieldVals, xgb.Sprintf("Count: %d", v.Count))
	return "MappingNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[34] = MappingNotifyEventNew
}

// EventCopy definition KeyRelease (3)

const KeyRelease = 3

type KeyReleaseEvent KeyPressEvent

func KeyReleaseEventNew(buf []byte) xgb.Event {
	return KeyReleaseEvent(KeyPressEventNew(buf).(KeyPressEvent))
}

func (v KeyReleaseEvent) Bytes() []byte {
	return KeyPressEvent(v).Bytes()
}

func (v KeyReleaseEvent) ImplementsEvent() {}

func (v KeyReleaseEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v KeyReleaseEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	return "KeyRelease {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[3] = KeyReleaseEventNew
}

// EventCopy definition ButtonRelease (5)

const ButtonRelease = 5

type ButtonReleaseEvent ButtonPressEvent

func ButtonReleaseEventNew(buf []byte) xgb.Event {
	return ButtonReleaseEvent(ButtonPressEventNew(buf).(ButtonPressEvent))
}

func (v ButtonReleaseEvent) Bytes() []byte {
	return ButtonPressEvent(v).Bytes()
}

func (v ButtonReleaseEvent) ImplementsEvent() {}

func (v ButtonReleaseEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v ButtonReleaseEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreen: %t", v.SameScreen))
	return "ButtonRelease {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[5] = ButtonReleaseEventNew
}

// EventCopy definition LeaveNotify (8)

const LeaveNotify = 8

type LeaveNotifyEvent EnterNotifyEvent

func LeaveNotifyEventNew(buf []byte) xgb.Event {
	return LeaveNotifyEvent(EnterNotifyEventNew(buf).(EnterNotifyEvent))
}

func (v LeaveNotifyEvent) Bytes() []byte {
	return EnterNotifyEvent(v).Bytes()
}

func (v LeaveNotifyEvent) ImplementsEvent() {}

func (v LeaveNotifyEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v LeaveNotifyEvent) String() string {
	fieldVals := make([]string, 0, 12)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Time: %d", v.Time))
	fieldVals = append(fieldVals, xgb.Sprintf("Root: %d", v.Root))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Child: %d", v.Child))
	fieldVals = append(fieldVals, xgb.Sprintf("RootX: %d", v.RootX))
	fieldVals = append(fieldVals, xgb.Sprintf("RootY: %d", v.RootY))
	fieldVals = append(fieldVals, xgb.Sprintf("EventX: %d", v.EventX))
	fieldVals = append(fieldVals, xgb.Sprintf("EventY: %d", v.EventY))
	fieldVals = append(fieldVals, xgb.Sprintf("State: %d", v.State))
	fieldVals = append(fieldVals, xgb.Sprintf("Mode: %d", v.Mode))
	fieldVals = append(fieldVals, xgb.Sprintf("SameScreenFocus: %d", v.SameScreenFocus))
	return "LeaveNotify {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[8] = LeaveNotifyEventNew
}

// EventCopy definition FocusOut (10)

const FocusOut = 10

type FocusOutEvent FocusInEvent

func FocusOutEventNew(buf []byte) xgb.Event {
	return FocusOutEvent(FocusInEventNew(buf).(FocusInEvent))
}

func (v FocusOutEvent) Bytes() []byte {
	return FocusInEvent(v).Bytes()
}

func (v FocusOutEvent) ImplementsEvent() {}

func (v FocusOutEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v FocusOutEvent) String() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Detail: %d", v.Detail))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Mode: %d", v.Mode))
	return "FocusOut {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[10] = FocusOutEventNew
}

// EventCopy definition CirculateRequest (27)

const CirculateRequest = 27

type CirculateRequestEvent CirculateNotifyEvent

func CirculateRequestEventNew(buf []byte) xgb.Event {
	return CirculateRequestEvent(CirculateNotifyEventNew(buf).(CirculateNotifyEvent))
}

func (v CirculateRequestEvent) Bytes() []byte {
	return CirculateNotifyEvent(v).Bytes()
}

func (v CirculateRequestEvent) ImplementsEvent() {}

func (v CirculateRequestEvent) SequenceId() uint16 {
	return v.Sequence
}

func (v CirculateRequestEvent) String() string {
	fieldVals := make([]string, 0, 6)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", v.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("Event: %d", v.Event))
	fieldVals = append(fieldVals, xgb.Sprintf("Window: %d", v.Window))
	fieldVals = append(fieldVals, xgb.Sprintf("Place: %d", v.Place))
	return "CirculateRequest {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewEventFuncs[27] = CirculateRequestEventNew
}

// Error definition Request (1)
// Size: 32

const BadRequest = 1

type RequestError struct {
	Sequence    uint16
	NiceName    string
	BadValue    uint32
	MinorOpcode uint16
	MajorOpcode byte
	// padding: 1 bytes
}

// Error read Request
func RequestErrorNew(buf []byte) xgb.Error {
	v := RequestError{}
	v.NiceName = "Request"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.BadValue = xgb.Get32(buf[b:])
	b += 4

	v.MinorOpcode = xgb.Get16(buf[b:])
	b += 2

	v.MajorOpcode = buf[b]
	b += 1

	b += 1 // padding

	return v
}

func (err RequestError) ImplementsError() {}

func (err RequestError) SequenceId() uint16 {
	return err.Sequence
}

func (err RequestError) BadId() uint32 {
	return err.BadValue
}

func (err RequestError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadRequest {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[1] = RequestErrorNew
}

// Error definition Value (2)
// Size: 32

const BadValue = 2

type ValueError struct {
	Sequence    uint16
	NiceName    string
	BadValue    uint32
	MinorOpcode uint16
	MajorOpcode byte
	// padding: 1 bytes
}

// Error read Value
func ValueErrorNew(buf []byte) xgb.Error {
	v := ValueError{}
	v.NiceName = "Value"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.BadValue = xgb.Get32(buf[b:])
	b += 4

	v.MinorOpcode = xgb.Get16(buf[b:])
	b += 2

	v.MajorOpcode = buf[b]
	b += 1

	b += 1 // padding

	return v
}

func (err ValueError) ImplementsError() {}

func (err ValueError) SequenceId() uint16 {
	return err.Sequence
}

func (err ValueError) BadId() uint32 {
	return err.BadValue
}

func (err ValueError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadValue {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[2] = ValueErrorNew
}

// ErrorCopy definition Window (3)

const BadWindow = 3

type WindowError ValueError

func WindowErrorNew(buf []byte) xgb.Error {
	v := WindowError(ValueErrorNew(buf).(ValueError))
	v.NiceName = "Window"
	return v
}

func (err WindowError) ImplementsError() {}

func (err WindowError) SequenceId() uint16 {
	return err.Sequence
}

func (err WindowError) BadId() uint32 {
	return err.BadValue
}

func (err WindowError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadWindow {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[3] = WindowErrorNew
}

// ErrorCopy definition Pixmap (4)

const BadPixmap = 4

type PixmapError ValueError

func PixmapErrorNew(buf []byte) xgb.Error {
	v := PixmapError(ValueErrorNew(buf).(ValueError))
	v.NiceName = "Pixmap"
	return v
}

func (err PixmapError) ImplementsError() {}

func (err PixmapError) SequenceId() uint16 {
	return err.Sequence
}

func (err PixmapError) BadId() uint32 {
	return err.BadValue
}

func (err PixmapError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadPixmap {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[4] = PixmapErrorNew
}

// ErrorCopy definition Atom (5)

const BadAtom = 5

type AtomError ValueError

func AtomErrorNew(buf []byte) xgb.Error {
	v := AtomError(ValueErrorNew(buf).(ValueError))
	v.NiceName = "Atom"
	return v
}

func (err AtomError) ImplementsError() {}

func (err AtomError) SequenceId() uint16 {
	return err.Sequence
}

func (err AtomError) BadId() uint32 {
	return err.BadValue
}

func (err AtomError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadAtom {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[5] = AtomErrorNew
}

// ErrorCopy definition Cursor (6)

const BadCursor = 6

type CursorError ValueError

func CursorErrorNew(buf []byte) xgb.Error {
	v := CursorError(ValueErrorNew(buf).(ValueError))
	v.NiceName = "Cursor"
	return v
}

func (err CursorError) ImplementsError() {}

func (err CursorError) SequenceId() uint16 {
	return err.Sequence
}

func (err CursorError) BadId() uint32 {
	return err.BadValue
}

func (err CursorError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadCursor {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[6] = CursorErrorNew
}

// ErrorCopy definition Font (7)

const BadFont = 7

type FontError ValueError

func FontErrorNew(buf []byte) xgb.Error {
	v := FontError(ValueErrorNew(buf).(ValueError))
	v.NiceName = "Font"
	return v
}

func (err FontError) ImplementsError() {}

func (err FontError) SequenceId() uint16 {
	return err.Sequence
}

func (err FontError) BadId() uint32 {
	return err.BadValue
}

func (err FontError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadFont {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[7] = FontErrorNew
}

// ErrorCopy definition Match (8)

const BadMatch = 8

type MatchError RequestError

func MatchErrorNew(buf []byte) xgb.Error {
	v := MatchError(RequestErrorNew(buf).(RequestError))
	v.NiceName = "Match"
	return v
}

func (err MatchError) ImplementsError() {}

func (err MatchError) SequenceId() uint16 {
	return err.Sequence
}

func (err MatchError) BadId() uint32 {
	return err.BadValue
}

func (err MatchError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadMatch {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[8] = MatchErrorNew
}

// ErrorCopy definition Drawable (9)

const BadDrawable = 9

type DrawableError ValueError

func DrawableErrorNew(buf []byte) xgb.Error {
	v := DrawableError(ValueErrorNew(buf).(ValueError))
	v.NiceName = "Drawable"
	return v
}

func (err DrawableError) ImplementsError() {}

func (err DrawableError) SequenceId() uint16 {
	return err.Sequence
}

func (err DrawableError) BadId() uint32 {
	return err.BadValue
}

func (err DrawableError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadDrawable {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[9] = DrawableErrorNew
}

// ErrorCopy definition Access (10)

const BadAccess = 10

type AccessError RequestError

func AccessErrorNew(buf []byte) xgb.Error {
	v := AccessError(RequestErrorNew(buf).(RequestError))
	v.NiceName = "Access"
	return v
}

func (err AccessError) ImplementsError() {}

func (err AccessError) SequenceId() uint16 {
	return err.Sequence
}

func (err AccessError) BadId() uint32 {
	return err.BadValue
}

func (err AccessError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadAccess {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[10] = AccessErrorNew
}

// ErrorCopy definition Alloc (11)

const BadAlloc = 11

type AllocError RequestError

func AllocErrorNew(buf []byte) xgb.Error {
	v := AllocError(RequestErrorNew(buf).(RequestError))
	v.NiceName = "Alloc"
	return v
}

func (err AllocError) ImplementsError() {}

func (err AllocError) SequenceId() uint16 {
	return err.Sequence
}

func (err AllocError) BadId() uint32 {
	return err.BadValue
}

func (err AllocError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadAlloc {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[11] = AllocErrorNew
}

// ErrorCopy definition Colormap (12)

const BadColormap = 12

type ColormapError ValueError

func ColormapErrorNew(buf []byte) xgb.Error {
	v := ColormapError(ValueErrorNew(buf).(ValueError))
	v.NiceName = "Colormap"
	return v
}

func (err ColormapError) ImplementsError() {}

func (err ColormapError) SequenceId() uint16 {
	return err.Sequence
}

func (err ColormapError) BadId() uint32 {
	return err.BadValue
}

func (err ColormapError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadColormap {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[12] = ColormapErrorNew
}

// ErrorCopy definition GContext (13)

const BadGContext = 13

type GContextError ValueError

func GContextErrorNew(buf []byte) xgb.Error {
	v := GContextError(ValueErrorNew(buf).(ValueError))
	v.NiceName = "GContext"
	return v
}

func (err GContextError) ImplementsError() {}

func (err GContextError) SequenceId() uint16 {
	return err.Sequence
}

func (err GContextError) BadId() uint32 {
	return err.BadValue
}

func (err GContextError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadGContext {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[13] = GContextErrorNew
}

// ErrorCopy definition IDChoice (14)

const BadIDChoice = 14

type IDChoiceError ValueError

func IDChoiceErrorNew(buf []byte) xgb.Error {
	v := IDChoiceError(ValueErrorNew(buf).(ValueError))
	v.NiceName = "IDChoice"
	return v
}

func (err IDChoiceError) ImplementsError() {}

func (err IDChoiceError) SequenceId() uint16 {
	return err.Sequence
}

func (err IDChoiceError) BadId() uint32 {
	return err.BadValue
}

func (err IDChoiceError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadIDChoice {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[14] = IDChoiceErrorNew
}

// ErrorCopy definition Name (15)

const BadName = 15

type NameError RequestError

func NameErrorNew(buf []byte) xgb.Error {
	v := NameError(RequestErrorNew(buf).(RequestError))
	v.NiceName = "Name"
	return v
}

func (err NameError) ImplementsError() {}

func (err NameError) SequenceId() uint16 {
	return err.Sequence
}

func (err NameError) BadId() uint32 {
	return err.BadValue
}

func (err NameError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadName {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[15] = NameErrorNew
}

// ErrorCopy definition Length (16)

const BadLength = 16

type LengthError RequestError

func LengthErrorNew(buf []byte) xgb.Error {
	v := LengthError(RequestErrorNew(buf).(RequestError))
	v.NiceName = "Length"
	return v
}

func (err LengthError) ImplementsError() {}

func (err LengthError) SequenceId() uint16 {
	return err.Sequence
}

func (err LengthError) BadId() uint32 {
	return err.BadValue
}

func (err LengthError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadLength {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[16] = LengthErrorNew
}

// ErrorCopy definition Implementation (17)

const BadImplementation = 17

type ImplementationError RequestError

func ImplementationErrorNew(buf []byte) xgb.Error {
	v := ImplementationError(RequestErrorNew(buf).(RequestError))
	v.NiceName = "Implementation"
	return v
}

func (err ImplementationError) ImplementsError() {}

func (err ImplementationError) SequenceId() uint16 {
	return err.Sequence
}

func (err ImplementationError) BadId() uint32 {
	return err.BadValue
}

func (err ImplementationError) Error() string {
	fieldVals := make([]string, 0, 4)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	fieldVals = append(fieldVals, xgb.Sprintf("BadValue: %d", err.BadValue))
	fieldVals = append(fieldVals, xgb.Sprintf("MinorOpcode: %d", err.MinorOpcode))
	fieldVals = append(fieldVals, xgb.Sprintf("MajorOpcode: %d", err.MajorOpcode))
	return "BadImplementation {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewErrorFuncs[17] = ImplementationErrorNew
}

// Request CreateWindow
// size: xgb.Pad((28 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
type CreateWindowCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateWindow
func CreateWindow(c *xgb.Conn, Depth byte, Wid Window, Parent Window, X int16, Y int16, Width uint16, Height uint16, BorderWidth uint16, Class uint16, Visual Visualid, ValueMask uint32, ValueList []uint32) CreateWindowCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createWindowRequest(c, Depth, Wid, Parent, X, Y, Width, Height, BorderWidth, Class, Visual, ValueMask, ValueList), cookie)
	return CreateWindowCookie{cookie}
}

func CreateWindowChecked(c *xgb.Conn, Depth byte, Wid Window, Parent Window, X int16, Y int16, Width uint16, Height uint16, BorderWidth uint16, Class uint16, Visual Visualid, ValueMask uint32, ValueList []uint32) CreateWindowCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createWindowRequest(c, Depth, Wid, Parent, X, Y, Width, Height, BorderWidth, Class, Visual, ValueMask, ValueList), cookie)
	return CreateWindowCookie{cookie}
}

func (cook CreateWindowCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateWindow
func createWindowRequest(c *xgb.Conn, Depth byte, Wid Window, Parent Window, X int16, Y int16, Width uint16, Height uint16, BorderWidth uint16, Class uint16, Visual Visualid, ValueMask uint32, ValueList []uint32) []byte {
	size := xgb.Pad((28 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 1 // request opcode
	b += 1

	buf[b] = Depth
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Wid))
	b += 4

	xgb.Put32(buf[b:], uint32(Parent))
	b += 4

	xgb.Put16(buf[b:], uint16(X))
	b += 2

	xgb.Put16(buf[b:], uint16(Y))
	b += 2

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	xgb.Put16(buf[b:], BorderWidth)
	b += 2

	xgb.Put16(buf[b:], Class)
	b += 2

	xgb.Put32(buf[b:], uint32(Visual))
	b += 4

	xgb.Put32(buf[b:], ValueMask)
	b += 4
	for i := 0; i < xgb.PopCount(int(ValueMask)); i++ {
		xgb.Put32(buf[b:], ValueList[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request ChangeWindowAttributes
// size: xgb.Pad((8 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
type ChangeWindowAttributesCookie struct {
	*xgb.Cookie
}

// Write request to wire for ChangeWindowAttributes
func ChangeWindowAttributes(c *xgb.Conn, Window Window, ValueMask uint32, ValueList []uint32) ChangeWindowAttributesCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeWindowAttributesRequest(c, Window, ValueMask, ValueList), cookie)
	return ChangeWindowAttributesCookie{cookie}
}

func ChangeWindowAttributesChecked(c *xgb.Conn, Window Window, ValueMask uint32, ValueList []uint32) ChangeWindowAttributesCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeWindowAttributesRequest(c, Window, ValueMask, ValueList), cookie)
	return ChangeWindowAttributesCookie{cookie}
}

func (cook ChangeWindowAttributesCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeWindowAttributes
func changeWindowAttributesRequest(c *xgb.Conn, Window Window, ValueMask uint32, ValueList []uint32) []byte {
	size := xgb.Pad((8 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 2 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put32(buf[b:], ValueMask)
	b += 4
	for i := 0; i < xgb.PopCount(int(ValueMask)); i++ {
		xgb.Put32(buf[b:], ValueList[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request GetWindowAttributes
// size: 8
type GetWindowAttributesCookie struct {
	*xgb.Cookie
}

func GetWindowAttributes(c *xgb.Conn, Window Window) GetWindowAttributesCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getWindowAttributesRequest(c, Window), cookie)
	return GetWindowAttributesCookie{cookie}
}

func GetWindowAttributesUnchecked(c *xgb.Conn, Window Window) GetWindowAttributesCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getWindowAttributesRequest(c, Window), cookie)
	return GetWindowAttributesCookie{cookie}
}

// Request reply for GetWindowAttributes
// size: 44
type GetWindowAttributesReply struct {
	Sequence           uint16
	Length             uint32
	BackingStore       byte
	Visual             Visualid
	Class              uint16
	BitGravity         byte
	WinGravity         byte
	BackingPlanes      uint32
	BackingPixel       uint32
	SaveUnder          bool
	MapIsInstalled     bool
	MapState           byte
	OverrideRedirect   bool
	Colormap           Colormap
	AllEventMasks      uint32
	YourEventMask      uint32
	DoNotPropagateMask uint16
	// padding: 2 bytes
}

// Waits and reads reply data from request GetWindowAttributes
func (cook GetWindowAttributesCookie) Reply() (*GetWindowAttributesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getWindowAttributesReply(buf), nil
}

// Read reply into structure from buffer for GetWindowAttributes
func getWindowAttributesReply(buf []byte) *GetWindowAttributesReply {
	v := new(GetWindowAttributesReply)
	b := 1 // skip reply determinant

	v.BackingStore = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Visual = Visualid(xgb.Get32(buf[b:]))
	b += 4

	v.Class = xgb.Get16(buf[b:])
	b += 2

	v.BitGravity = buf[b]
	b += 1

	v.WinGravity = buf[b]
	b += 1

	v.BackingPlanes = xgb.Get32(buf[b:])
	b += 4

	v.BackingPixel = xgb.Get32(buf[b:])
	b += 4

	if buf[b] == 1 {
		v.SaveUnder = true
	} else {
		v.SaveUnder = false
	}
	b += 1

	if buf[b] == 1 {
		v.MapIsInstalled = true
	} else {
		v.MapIsInstalled = false
	}
	b += 1

	v.MapState = buf[b]
	b += 1

	if buf[b] == 1 {
		v.OverrideRedirect = true
	} else {
		v.OverrideRedirect = false
	}
	b += 1

	v.Colormap = Colormap(xgb.Get32(buf[b:]))
	b += 4

	v.AllEventMasks = xgb.Get32(buf[b:])
	b += 4

	v.YourEventMask = xgb.Get32(buf[b:])
	b += 4

	v.DoNotPropagateMask = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	return v
}

// Write request to wire for GetWindowAttributes
func getWindowAttributesRequest(c *xgb.Conn, Window Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 3 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request DestroyWindow
// size: 8
type DestroyWindowCookie struct {
	*xgb.Cookie
}

// Write request to wire for DestroyWindow
func DestroyWindow(c *xgb.Conn, Window Window) DestroyWindowCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroyWindowRequest(c, Window), cookie)
	return DestroyWindowCookie{cookie}
}

func DestroyWindowChecked(c *xgb.Conn, Window Window) DestroyWindowCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroyWindowRequest(c, Window), cookie)
	return DestroyWindowCookie{cookie}
}

func (cook DestroyWindowCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroyWindow
func destroyWindowRequest(c *xgb.Conn, Window Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 4 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request DestroySubwindows
// size: 8
type DestroySubwindowsCookie struct {
	*xgb.Cookie
}

// Write request to wire for DestroySubwindows
func DestroySubwindows(c *xgb.Conn, Window Window) DestroySubwindowsCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(destroySubwindowsRequest(c, Window), cookie)
	return DestroySubwindowsCookie{cookie}
}

func DestroySubwindowsChecked(c *xgb.Conn, Window Window) DestroySubwindowsCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(destroySubwindowsRequest(c, Window), cookie)
	return DestroySubwindowsCookie{cookie}
}

func (cook DestroySubwindowsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DestroySubwindows
func destroySubwindowsRequest(c *xgb.Conn, Window Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 5 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request ChangeSaveSet
// size: 8
type ChangeSaveSetCookie struct {
	*xgb.Cookie
}

// Write request to wire for ChangeSaveSet
func ChangeSaveSet(c *xgb.Conn, Mode byte, Window Window) ChangeSaveSetCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeSaveSetRequest(c, Mode, Window), cookie)
	return ChangeSaveSetCookie{cookie}
}

func ChangeSaveSetChecked(c *xgb.Conn, Mode byte, Window Window) ChangeSaveSetCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeSaveSetRequest(c, Mode, Window), cookie)
	return ChangeSaveSetCookie{cookie}
}

func (cook ChangeSaveSetCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeSaveSet
func changeSaveSetRequest(c *xgb.Conn, Mode byte, Window Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 6 // request opcode
	b += 1

	buf[b] = Mode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request ReparentWindow
// size: 16
type ReparentWindowCookie struct {
	*xgb.Cookie
}

// Write request to wire for ReparentWindow
func ReparentWindow(c *xgb.Conn, Window Window, Parent Window, X int16, Y int16) ReparentWindowCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(reparentWindowRequest(c, Window, Parent, X, Y), cookie)
	return ReparentWindowCookie{cookie}
}

func ReparentWindowChecked(c *xgb.Conn, Window Window, Parent Window, X int16, Y int16) ReparentWindowCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(reparentWindowRequest(c, Window, Parent, X, Y), cookie)
	return ReparentWindowCookie{cookie}
}

func (cook ReparentWindowCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ReparentWindow
func reparentWindowRequest(c *xgb.Conn, Window Window, Parent Window, X int16, Y int16) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = 7 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put32(buf[b:], uint32(Parent))
	b += 4

	xgb.Put16(buf[b:], uint16(X))
	b += 2

	xgb.Put16(buf[b:], uint16(Y))
	b += 2

	return buf
}

// Request MapWindow
// size: 8
type MapWindowCookie struct {
	*xgb.Cookie
}

// Write request to wire for MapWindow
func MapWindow(c *xgb.Conn, Window Window) MapWindowCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(mapWindowRequest(c, Window), cookie)
	return MapWindowCookie{cookie}
}

func MapWindowChecked(c *xgb.Conn, Window Window) MapWindowCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(mapWindowRequest(c, Window), cookie)
	return MapWindowCookie{cookie}
}

func (cook MapWindowCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for MapWindow
func mapWindowRequest(c *xgb.Conn, Window Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 8 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request MapSubwindows
// size: 8
type MapSubwindowsCookie struct {
	*xgb.Cookie
}

// Write request to wire for MapSubwindows
func MapSubwindows(c *xgb.Conn, Window Window) MapSubwindowsCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(mapSubwindowsRequest(c, Window), cookie)
	return MapSubwindowsCookie{cookie}
}

func MapSubwindowsChecked(c *xgb.Conn, Window Window) MapSubwindowsCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(mapSubwindowsRequest(c, Window), cookie)
	return MapSubwindowsCookie{cookie}
}

func (cook MapSubwindowsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for MapSubwindows
func mapSubwindowsRequest(c *xgb.Conn, Window Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 9 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request UnmapWindow
// size: 8
type UnmapWindowCookie struct {
	*xgb.Cookie
}

// Write request to wire for UnmapWindow
func UnmapWindow(c *xgb.Conn, Window Window) UnmapWindowCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(unmapWindowRequest(c, Window), cookie)
	return UnmapWindowCookie{cookie}
}

func UnmapWindowChecked(c *xgb.Conn, Window Window) UnmapWindowCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(unmapWindowRequest(c, Window), cookie)
	return UnmapWindowCookie{cookie}
}

func (cook UnmapWindowCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UnmapWindow
func unmapWindowRequest(c *xgb.Conn, Window Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 10 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request UnmapSubwindows
// size: 8
type UnmapSubwindowsCookie struct {
	*xgb.Cookie
}

// Write request to wire for UnmapSubwindows
func UnmapSubwindows(c *xgb.Conn, Window Window) UnmapSubwindowsCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(unmapSubwindowsRequest(c, Window), cookie)
	return UnmapSubwindowsCookie{cookie}
}

func UnmapSubwindowsChecked(c *xgb.Conn, Window Window) UnmapSubwindowsCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(unmapSubwindowsRequest(c, Window), cookie)
	return UnmapSubwindowsCookie{cookie}
}

func (cook UnmapSubwindowsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UnmapSubwindows
func unmapSubwindowsRequest(c *xgb.Conn, Window Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 11 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request ConfigureWindow
// size: xgb.Pad((10 + (2 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
type ConfigureWindowCookie struct {
	*xgb.Cookie
}

// Write request to wire for ConfigureWindow
func ConfigureWindow(c *xgb.Conn, Window Window, ValueMask uint16, ValueList []uint32) ConfigureWindowCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(configureWindowRequest(c, Window, ValueMask, ValueList), cookie)
	return ConfigureWindowCookie{cookie}
}

func ConfigureWindowChecked(c *xgb.Conn, Window Window, ValueMask uint16, ValueList []uint32) ConfigureWindowCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(configureWindowRequest(c, Window, ValueMask, ValueList), cookie)
	return ConfigureWindowCookie{cookie}
}

func (cook ConfigureWindowCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ConfigureWindow
func configureWindowRequest(c *xgb.Conn, Window Window, ValueMask uint16, ValueList []uint32) []byte {
	size := xgb.Pad((10 + (2 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 12 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put16(buf[b:], ValueMask)
	b += 2

	b += 2 // padding

	for i := 0; i < xgb.PopCount(int(ValueMask)); i++ {
		xgb.Put32(buf[b:], ValueList[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request CirculateWindow
// size: 8
type CirculateWindowCookie struct {
	*xgb.Cookie
}

// Write request to wire for CirculateWindow
func CirculateWindow(c *xgb.Conn, Direction byte, Window Window) CirculateWindowCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(circulateWindowRequest(c, Direction, Window), cookie)
	return CirculateWindowCookie{cookie}
}

func CirculateWindowChecked(c *xgb.Conn, Direction byte, Window Window) CirculateWindowCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(circulateWindowRequest(c, Direction, Window), cookie)
	return CirculateWindowCookie{cookie}
}

func (cook CirculateWindowCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CirculateWindow
func circulateWindowRequest(c *xgb.Conn, Direction byte, Window Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 13 // request opcode
	b += 1

	buf[b] = Direction
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request GetGeometry
// size: 8
type GetGeometryCookie struct {
	*xgb.Cookie
}

func GetGeometry(c *xgb.Conn, Drawable Drawable) GetGeometryCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getGeometryRequest(c, Drawable), cookie)
	return GetGeometryCookie{cookie}
}

func GetGeometryUnchecked(c *xgb.Conn, Drawable Drawable) GetGeometryCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getGeometryRequest(c, Drawable), cookie)
	return GetGeometryCookie{cookie}
}

// Request reply for GetGeometry
// size: 24
type GetGeometryReply struct {
	Sequence    uint16
	Length      uint32
	Depth       byte
	Root        Window
	X           int16
	Y           int16
	Width       uint16
	Height      uint16
	BorderWidth uint16
	// padding: 2 bytes
}

// Waits and reads reply data from request GetGeometry
func (cook GetGeometryCookie) Reply() (*GetGeometryReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getGeometryReply(buf), nil
}

// Read reply into structure from buffer for GetGeometry
func getGeometryReply(buf []byte) *GetGeometryReply {
	v := new(GetGeometryReply)
	b := 1 // skip reply determinant

	v.Depth = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Root = Window(xgb.Get32(buf[b:]))
	b += 4

	v.X = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Y = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	v.BorderWidth = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	return v
}

// Write request to wire for GetGeometry
func getGeometryRequest(c *xgb.Conn, Drawable Drawable) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 14 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	return buf
}

// Request QueryTree
// size: 8
type QueryTreeCookie struct {
	*xgb.Cookie
}

func QueryTree(c *xgb.Conn, Window Window) QueryTreeCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryTreeRequest(c, Window), cookie)
	return QueryTreeCookie{cookie}
}

func QueryTreeUnchecked(c *xgb.Conn, Window Window) QueryTreeCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryTreeRequest(c, Window), cookie)
	return QueryTreeCookie{cookie}
}

// Request reply for QueryTree
// size: (32 + xgb.Pad((int(ChildrenLen) * 4)))
type QueryTreeReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Root        Window
	Parent      Window
	ChildrenLen uint16
	// padding: 14 bytes
	Children []Window // size: xgb.Pad((int(ChildrenLen) * 4))
}

// Waits and reads reply data from request QueryTree
func (cook QueryTreeCookie) Reply() (*QueryTreeReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryTreeReply(buf), nil
}

// Read reply into structure from buffer for QueryTree
func queryTreeReply(buf []byte) *QueryTreeReply {
	v := new(QueryTreeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Root = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Parent = Window(xgb.Get32(buf[b:]))
	b += 4

	v.ChildrenLen = xgb.Get16(buf[b:])
	b += 2

	b += 14 // padding

	v.Children = make([]Window, v.ChildrenLen)
	for i := 0; i < int(v.ChildrenLen); i++ {
		v.Children[i] = Window(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for QueryTree
func queryTreeRequest(c *xgb.Conn, Window Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 15 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request InternAtom
// size: xgb.Pad((8 + xgb.Pad((int(NameLen) * 1))))
type InternAtomCookie struct {
	*xgb.Cookie
}

func InternAtom(c *xgb.Conn, OnlyIfExists bool, NameLen uint16, Name string) InternAtomCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(internAtomRequest(c, OnlyIfExists, NameLen, Name), cookie)
	return InternAtomCookie{cookie}
}

func InternAtomUnchecked(c *xgb.Conn, OnlyIfExists bool, NameLen uint16, Name string) InternAtomCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(internAtomRequest(c, OnlyIfExists, NameLen, Name), cookie)
	return InternAtomCookie{cookie}
}

// Request reply for InternAtom
// size: 12
type InternAtomReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Atom Atom
}

// Waits and reads reply data from request InternAtom
func (cook InternAtomCookie) Reply() (*InternAtomReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return internAtomReply(buf), nil
}

// Read reply into structure from buffer for InternAtom
func internAtomReply(buf []byte) *InternAtomReply {
	v := new(InternAtomReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Atom = Atom(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Write request to wire for InternAtom
func internAtomRequest(c *xgb.Conn, OnlyIfExists bool, NameLen uint16, Name string) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(NameLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 16 // request opcode
	b += 1

	if OnlyIfExists {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], NameLen)
	b += 2

	b += 2 // padding

	copy(buf[b:], Name[:NameLen])
	b += xgb.Pad(int(NameLen))

	return buf
}

// Request GetAtomName
// size: 8
type GetAtomNameCookie struct {
	*xgb.Cookie
}

func GetAtomName(c *xgb.Conn, Atom Atom) GetAtomNameCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getAtomNameRequest(c, Atom), cookie)
	return GetAtomNameCookie{cookie}
}

func GetAtomNameUnchecked(c *xgb.Conn, Atom Atom) GetAtomNameCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getAtomNameRequest(c, Atom), cookie)
	return GetAtomNameCookie{cookie}
}

// Request reply for GetAtomName
// size: (32 + xgb.Pad((int(NameLen) * 1)))
type GetAtomNameReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NameLen uint16
	// padding: 22 bytes
	Name string // size: xgb.Pad((int(NameLen) * 1))
}

// Waits and reads reply data from request GetAtomName
func (cook GetAtomNameCookie) Reply() (*GetAtomNameReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getAtomNameReply(buf), nil
}

// Read reply into structure from buffer for GetAtomName
func getAtomNameReply(buf []byte) *GetAtomNameReply {
	v := new(GetAtomNameReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NameLen = xgb.Get16(buf[b:])
	b += 2

	b += 22 // padding

	{
		byteString := make([]byte, v.NameLen)
		copy(byteString[:v.NameLen], buf[b:])
		v.Name = string(byteString)
		b += xgb.Pad(int(v.NameLen))
	}

	return v
}

// Write request to wire for GetAtomName
func getAtomNameRequest(c *xgb.Conn, Atom Atom) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 17 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Atom))
	b += 4

	return buf
}

// Request ChangeProperty
// size: xgb.Pad((24 + xgb.Pad((((int(DataLen) * int(Format)) / 8) * 1))))
type ChangePropertyCookie struct {
	*xgb.Cookie
}

// Write request to wire for ChangeProperty
func ChangeProperty(c *xgb.Conn, Mode byte, Window Window, Property Atom, Type Atom, Format byte, DataLen uint32, Data []byte) ChangePropertyCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(changePropertyRequest(c, Mode, Window, Property, Type, Format, DataLen, Data), cookie)
	return ChangePropertyCookie{cookie}
}

func ChangePropertyChecked(c *xgb.Conn, Mode byte, Window Window, Property Atom, Type Atom, Format byte, DataLen uint32, Data []byte) ChangePropertyCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(changePropertyRequest(c, Mode, Window, Property, Type, Format, DataLen, Data), cookie)
	return ChangePropertyCookie{cookie}
}

func (cook ChangePropertyCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeProperty
func changePropertyRequest(c *xgb.Conn, Mode byte, Window Window, Property Atom, Type Atom, Format byte, DataLen uint32, Data []byte) []byte {
	size := xgb.Pad((24 + xgb.Pad((((int(DataLen) * int(Format)) / 8) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 18 // request opcode
	b += 1

	buf[b] = Mode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put32(buf[b:], uint32(Property))
	b += 4

	xgb.Put32(buf[b:], uint32(Type))
	b += 4

	buf[b] = Format
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], DataLen)
	b += 4

	copy(buf[b:], Data[:((int(DataLen)*int(Format))/8)])
	b += xgb.Pad(int(((int(DataLen) * int(Format)) / 8)))

	return buf
}

// Request DeleteProperty
// size: 12
type DeletePropertyCookie struct {
	*xgb.Cookie
}

// Write request to wire for DeleteProperty
func DeleteProperty(c *xgb.Conn, Window Window, Property Atom) DeletePropertyCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(deletePropertyRequest(c, Window, Property), cookie)
	return DeletePropertyCookie{cookie}
}

func DeletePropertyChecked(c *xgb.Conn, Window Window, Property Atom) DeletePropertyCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(deletePropertyRequest(c, Window, Property), cookie)
	return DeletePropertyCookie{cookie}
}

func (cook DeletePropertyCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for DeleteProperty
func deletePropertyRequest(c *xgb.Conn, Window Window, Property Atom) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = 19 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put32(buf[b:], uint32(Property))
	b += 4

	return buf
}

// Request GetProperty
// size: 24
type GetPropertyCookie struct {
	*xgb.Cookie
}

func GetProperty(c *xgb.Conn, Delete bool, Window Window, Property Atom, Type Atom, LongOffset uint32, LongLength uint32) GetPropertyCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getPropertyRequest(c, Delete, Window, Property, Type, LongOffset, LongLength), cookie)
	return GetPropertyCookie{cookie}
}

func GetPropertyUnchecked(c *xgb.Conn, Delete bool, Window Window, Property Atom, Type Atom, LongOffset uint32, LongLength uint32) GetPropertyCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getPropertyRequest(c, Delete, Window, Property, Type, LongOffset, LongLength), cookie)
	return GetPropertyCookie{cookie}
}

// Request reply for GetProperty
// size: (32 + xgb.Pad(((int(ValueLen) * (int(Format) / 8)) * 1)))
type GetPropertyReply struct {
	Sequence   uint16
	Length     uint32
	Format     byte
	Type       Atom
	BytesAfter uint32
	ValueLen   uint32
	// padding: 12 bytes
	Value []byte // size: xgb.Pad(((int(ValueLen) * (int(Format) / 8)) * 1))
}

// Waits and reads reply data from request GetProperty
func (cook GetPropertyCookie) Reply() (*GetPropertyReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getPropertyReply(buf), nil
}

// Read reply into structure from buffer for GetProperty
func getPropertyReply(buf []byte) *GetPropertyReply {
	v := new(GetPropertyReply)
	b := 1 // skip reply determinant

	v.Format = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Type = Atom(xgb.Get32(buf[b:]))
	b += 4

	v.BytesAfter = xgb.Get32(buf[b:])
	b += 4

	v.ValueLen = xgb.Get32(buf[b:])
	b += 4

	b += 12 // padding

	v.Value = make([]byte, (int(v.ValueLen) * (int(v.Format) / 8)))
	copy(v.Value[:(int(v.ValueLen)*(int(v.Format)/8))], buf[b:])
	b += xgb.Pad(int((int(v.ValueLen) * (int(v.Format) / 8))))

	return v
}

// Write request to wire for GetProperty
func getPropertyRequest(c *xgb.Conn, Delete bool, Window Window, Property Atom, Type Atom, LongOffset uint32, LongLength uint32) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = 20 // request opcode
	b += 1

	if Delete {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put32(buf[b:], uint32(Property))
	b += 4

	xgb.Put32(buf[b:], uint32(Type))
	b += 4

	xgb.Put32(buf[b:], LongOffset)
	b += 4

	xgb.Put32(buf[b:], LongLength)
	b += 4

	return buf
}

// Request ListProperties
// size: 8
type ListPropertiesCookie struct {
	*xgb.Cookie
}

func ListProperties(c *xgb.Conn, Window Window) ListPropertiesCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(listPropertiesRequest(c, Window), cookie)
	return ListPropertiesCookie{cookie}
}

func ListPropertiesUnchecked(c *xgb.Conn, Window Window) ListPropertiesCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(listPropertiesRequest(c, Window), cookie)
	return ListPropertiesCookie{cookie}
}

// Request reply for ListProperties
// size: (32 + xgb.Pad((int(AtomsLen) * 4)))
type ListPropertiesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	AtomsLen uint16
	// padding: 22 bytes
	Atoms []Atom // size: xgb.Pad((int(AtomsLen) * 4))
}

// Waits and reads reply data from request ListProperties
func (cook ListPropertiesCookie) Reply() (*ListPropertiesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listPropertiesReply(buf), nil
}

// Read reply into structure from buffer for ListProperties
func listPropertiesReply(buf []byte) *ListPropertiesReply {
	v := new(ListPropertiesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.AtomsLen = xgb.Get16(buf[b:])
	b += 2

	b += 22 // padding

	v.Atoms = make([]Atom, v.AtomsLen)
	for i := 0; i < int(v.AtomsLen); i++ {
		v.Atoms[i] = Atom(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for ListProperties
func listPropertiesRequest(c *xgb.Conn, Window Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 21 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request SetSelectionOwner
// size: 16
type SetSelectionOwnerCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetSelectionOwner
func SetSelectionOwner(c *xgb.Conn, Owner Window, Selection Atom, Time Timestamp) SetSelectionOwnerCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setSelectionOwnerRequest(c, Owner, Selection, Time), cookie)
	return SetSelectionOwnerCookie{cookie}
}

func SetSelectionOwnerChecked(c *xgb.Conn, Owner Window, Selection Atom, Time Timestamp) SetSelectionOwnerCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setSelectionOwnerRequest(c, Owner, Selection, Time), cookie)
	return SetSelectionOwnerCookie{cookie}
}

func (cook SetSelectionOwnerCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetSelectionOwner
func setSelectionOwnerRequest(c *xgb.Conn, Owner Window, Selection Atom, Time Timestamp) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = 22 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Owner))
	b += 4

	xgb.Put32(buf[b:], uint32(Selection))
	b += 4

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	return buf
}

// Request GetSelectionOwner
// size: 8
type GetSelectionOwnerCookie struct {
	*xgb.Cookie
}

func GetSelectionOwner(c *xgb.Conn, Selection Atom) GetSelectionOwnerCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getSelectionOwnerRequest(c, Selection), cookie)
	return GetSelectionOwnerCookie{cookie}
}

func GetSelectionOwnerUnchecked(c *xgb.Conn, Selection Atom) GetSelectionOwnerCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getSelectionOwnerRequest(c, Selection), cookie)
	return GetSelectionOwnerCookie{cookie}
}

// Request reply for GetSelectionOwner
// size: 12
type GetSelectionOwnerReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Owner Window
}

// Waits and reads reply data from request GetSelectionOwner
func (cook GetSelectionOwnerCookie) Reply() (*GetSelectionOwnerReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getSelectionOwnerReply(buf), nil
}

// Read reply into structure from buffer for GetSelectionOwner
func getSelectionOwnerReply(buf []byte) *GetSelectionOwnerReply {
	v := new(GetSelectionOwnerReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Owner = Window(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Write request to wire for GetSelectionOwner
func getSelectionOwnerRequest(c *xgb.Conn, Selection Atom) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 23 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Selection))
	b += 4

	return buf
}

// Request ConvertSelection
// size: 24
type ConvertSelectionCookie struct {
	*xgb.Cookie
}

// Write request to wire for ConvertSelection
func ConvertSelection(c *xgb.Conn, Requestor Window, Selection Atom, Target Atom, Property Atom, Time Timestamp) ConvertSelectionCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(convertSelectionRequest(c, Requestor, Selection, Target, Property, Time), cookie)
	return ConvertSelectionCookie{cookie}
}

func ConvertSelectionChecked(c *xgb.Conn, Requestor Window, Selection Atom, Target Atom, Property Atom, Time Timestamp) ConvertSelectionCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(convertSelectionRequest(c, Requestor, Selection, Target, Property, Time), cookie)
	return ConvertSelectionCookie{cookie}
}

func (cook ConvertSelectionCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ConvertSelection
func convertSelectionRequest(c *xgb.Conn, Requestor Window, Selection Atom, Target Atom, Property Atom, Time Timestamp) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = 24 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Requestor))
	b += 4

	xgb.Put32(buf[b:], uint32(Selection))
	b += 4

	xgb.Put32(buf[b:], uint32(Target))
	b += 4

	xgb.Put32(buf[b:], uint32(Property))
	b += 4

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	return buf
}

// Request SendEvent
// size: 44
type SendEventCookie struct {
	*xgb.Cookie
}

// Write request to wire for SendEvent
func SendEvent(c *xgb.Conn, Propagate bool, Destination Window, EventMask uint32, Event string) SendEventCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(sendEventRequest(c, Propagate, Destination, EventMask, Event), cookie)
	return SendEventCookie{cookie}
}

func SendEventChecked(c *xgb.Conn, Propagate bool, Destination Window, EventMask uint32, Event string) SendEventCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(sendEventRequest(c, Propagate, Destination, EventMask, Event), cookie)
	return SendEventCookie{cookie}
}

func (cook SendEventCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SendEvent
func sendEventRequest(c *xgb.Conn, Propagate bool, Destination Window, EventMask uint32, Event string) []byte {
	size := 44
	b := 0
	buf := make([]byte, size)

	buf[b] = 25 // request opcode
	b += 1

	if Propagate {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Destination))
	b += 4

	xgb.Put32(buf[b:], EventMask)
	b += 4

	copy(buf[b:], Event[:32])
	b += xgb.Pad(int(32))

	return buf
}

// Request GrabPointer
// size: 24
type GrabPointerCookie struct {
	*xgb.Cookie
}

func GrabPointer(c *xgb.Conn, OwnerEvents bool, GrabWindow Window, EventMask uint16, PointerMode byte, KeyboardMode byte, ConfineTo Window, Cursor Cursor, Time Timestamp) GrabPointerCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(grabPointerRequest(c, OwnerEvents, GrabWindow, EventMask, PointerMode, KeyboardMode, ConfineTo, Cursor, Time), cookie)
	return GrabPointerCookie{cookie}
}

func GrabPointerUnchecked(c *xgb.Conn, OwnerEvents bool, GrabWindow Window, EventMask uint16, PointerMode byte, KeyboardMode byte, ConfineTo Window, Cursor Cursor, Time Timestamp) GrabPointerCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(grabPointerRequest(c, OwnerEvents, GrabWindow, EventMask, PointerMode, KeyboardMode, ConfineTo, Cursor, Time), cookie)
	return GrabPointerCookie{cookie}
}

// Request reply for GrabPointer
// size: 8
type GrabPointerReply struct {
	Sequence uint16
	Length   uint32
	Status   byte
}

// Waits and reads reply data from request GrabPointer
func (cook GrabPointerCookie) Reply() (*GrabPointerReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return grabPointerReply(buf), nil
}

// Read reply into structure from buffer for GrabPointer
func grabPointerReply(buf []byte) *GrabPointerReply {
	v := new(GrabPointerReply)
	b := 1 // skip reply determinant

	v.Status = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	return v
}

// Write request to wire for GrabPointer
func grabPointerRequest(c *xgb.Conn, OwnerEvents bool, GrabWindow Window, EventMask uint16, PointerMode byte, KeyboardMode byte, ConfineTo Window, Cursor Cursor, Time Timestamp) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = 26 // request opcode
	b += 1

	if OwnerEvents {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GrabWindow))
	b += 4

	xgb.Put16(buf[b:], EventMask)
	b += 2

	buf[b] = PointerMode
	b += 1

	buf[b] = KeyboardMode
	b += 1

	xgb.Put32(buf[b:], uint32(ConfineTo))
	b += 4

	xgb.Put32(buf[b:], uint32(Cursor))
	b += 4

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	return buf
}

// Request UngrabPointer
// size: 8
type UngrabPointerCookie struct {
	*xgb.Cookie
}

// Write request to wire for UngrabPointer
func UngrabPointer(c *xgb.Conn, Time Timestamp) UngrabPointerCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(ungrabPointerRequest(c, Time), cookie)
	return UngrabPointerCookie{cookie}
}

func UngrabPointerChecked(c *xgb.Conn, Time Timestamp) UngrabPointerCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(ungrabPointerRequest(c, Time), cookie)
	return UngrabPointerCookie{cookie}
}

func (cook UngrabPointerCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UngrabPointer
func ungrabPointerRequest(c *xgb.Conn, Time Timestamp) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 27 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	return buf
}

// Request GrabButton
// size: 24
type GrabButtonCookie struct {
	*xgb.Cookie
}

// Write request to wire for GrabButton
func GrabButton(c *xgb.Conn, OwnerEvents bool, GrabWindow Window, EventMask uint16, PointerMode byte, KeyboardMode byte, ConfineTo Window, Cursor Cursor, Button byte, Modifiers uint16) GrabButtonCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(grabButtonRequest(c, OwnerEvents, GrabWindow, EventMask, PointerMode, KeyboardMode, ConfineTo, Cursor, Button, Modifiers), cookie)
	return GrabButtonCookie{cookie}
}

func GrabButtonChecked(c *xgb.Conn, OwnerEvents bool, GrabWindow Window, EventMask uint16, PointerMode byte, KeyboardMode byte, ConfineTo Window, Cursor Cursor, Button byte, Modifiers uint16) GrabButtonCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(grabButtonRequest(c, OwnerEvents, GrabWindow, EventMask, PointerMode, KeyboardMode, ConfineTo, Cursor, Button, Modifiers), cookie)
	return GrabButtonCookie{cookie}
}

func (cook GrabButtonCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for GrabButton
func grabButtonRequest(c *xgb.Conn, OwnerEvents bool, GrabWindow Window, EventMask uint16, PointerMode byte, KeyboardMode byte, ConfineTo Window, Cursor Cursor, Button byte, Modifiers uint16) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = 28 // request opcode
	b += 1

	if OwnerEvents {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GrabWindow))
	b += 4

	xgb.Put16(buf[b:], EventMask)
	b += 2

	buf[b] = PointerMode
	b += 1

	buf[b] = KeyboardMode
	b += 1

	xgb.Put32(buf[b:], uint32(ConfineTo))
	b += 4

	xgb.Put32(buf[b:], uint32(Cursor))
	b += 4

	buf[b] = Button
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], Modifiers)
	b += 2

	return buf
}

// Request UngrabButton
// size: 12
type UngrabButtonCookie struct {
	*xgb.Cookie
}

// Write request to wire for UngrabButton
func UngrabButton(c *xgb.Conn, Button byte, GrabWindow Window, Modifiers uint16) UngrabButtonCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(ungrabButtonRequest(c, Button, GrabWindow, Modifiers), cookie)
	return UngrabButtonCookie{cookie}
}

func UngrabButtonChecked(c *xgb.Conn, Button byte, GrabWindow Window, Modifiers uint16) UngrabButtonCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(ungrabButtonRequest(c, Button, GrabWindow, Modifiers), cookie)
	return UngrabButtonCookie{cookie}
}

func (cook UngrabButtonCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UngrabButton
func ungrabButtonRequest(c *xgb.Conn, Button byte, GrabWindow Window, Modifiers uint16) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = 29 // request opcode
	b += 1

	buf[b] = Button
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GrabWindow))
	b += 4

	xgb.Put16(buf[b:], Modifiers)
	b += 2

	b += 2 // padding

	return buf
}

// Request ChangeActivePointerGrab
// size: 16
type ChangeActivePointerGrabCookie struct {
	*xgb.Cookie
}

// Write request to wire for ChangeActivePointerGrab
func ChangeActivePointerGrab(c *xgb.Conn, Cursor Cursor, Time Timestamp, EventMask uint16) ChangeActivePointerGrabCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeActivePointerGrabRequest(c, Cursor, Time, EventMask), cookie)
	return ChangeActivePointerGrabCookie{cookie}
}

func ChangeActivePointerGrabChecked(c *xgb.Conn, Cursor Cursor, Time Timestamp, EventMask uint16) ChangeActivePointerGrabCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeActivePointerGrabRequest(c, Cursor, Time, EventMask), cookie)
	return ChangeActivePointerGrabCookie{cookie}
}

func (cook ChangeActivePointerGrabCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeActivePointerGrab
func changeActivePointerGrabRequest(c *xgb.Conn, Cursor Cursor, Time Timestamp, EventMask uint16) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = 30 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cursor))
	b += 4

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	xgb.Put16(buf[b:], EventMask)
	b += 2

	b += 2 // padding

	return buf
}

// Request GrabKeyboard
// size: 16
type GrabKeyboardCookie struct {
	*xgb.Cookie
}

func GrabKeyboard(c *xgb.Conn, OwnerEvents bool, GrabWindow Window, Time Timestamp, PointerMode byte, KeyboardMode byte) GrabKeyboardCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(grabKeyboardRequest(c, OwnerEvents, GrabWindow, Time, PointerMode, KeyboardMode), cookie)
	return GrabKeyboardCookie{cookie}
}

func GrabKeyboardUnchecked(c *xgb.Conn, OwnerEvents bool, GrabWindow Window, Time Timestamp, PointerMode byte, KeyboardMode byte) GrabKeyboardCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(grabKeyboardRequest(c, OwnerEvents, GrabWindow, Time, PointerMode, KeyboardMode), cookie)
	return GrabKeyboardCookie{cookie}
}

// Request reply for GrabKeyboard
// size: 8
type GrabKeyboardReply struct {
	Sequence uint16
	Length   uint32
	Status   byte
}

// Waits and reads reply data from request GrabKeyboard
func (cook GrabKeyboardCookie) Reply() (*GrabKeyboardReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return grabKeyboardReply(buf), nil
}

// Read reply into structure from buffer for GrabKeyboard
func grabKeyboardReply(buf []byte) *GrabKeyboardReply {
	v := new(GrabKeyboardReply)
	b := 1 // skip reply determinant

	v.Status = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	return v
}

// Write request to wire for GrabKeyboard
func grabKeyboardRequest(c *xgb.Conn, OwnerEvents bool, GrabWindow Window, Time Timestamp, PointerMode byte, KeyboardMode byte) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = 31 // request opcode
	b += 1

	if OwnerEvents {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GrabWindow))
	b += 4

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	buf[b] = PointerMode
	b += 1

	buf[b] = KeyboardMode
	b += 1

	b += 2 // padding

	return buf
}

// Request UngrabKeyboard
// size: 8
type UngrabKeyboardCookie struct {
	*xgb.Cookie
}

// Write request to wire for UngrabKeyboard
func UngrabKeyboard(c *xgb.Conn, Time Timestamp) UngrabKeyboardCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(ungrabKeyboardRequest(c, Time), cookie)
	return UngrabKeyboardCookie{cookie}
}

func UngrabKeyboardChecked(c *xgb.Conn, Time Timestamp) UngrabKeyboardCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(ungrabKeyboardRequest(c, Time), cookie)
	return UngrabKeyboardCookie{cookie}
}

func (cook UngrabKeyboardCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UngrabKeyboard
func ungrabKeyboardRequest(c *xgb.Conn, Time Timestamp) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 32 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	return buf
}

// Request GrabKey
// size: 16
type GrabKeyCookie struct {
	*xgb.Cookie
}

// Write request to wire for GrabKey
func GrabKey(c *xgb.Conn, OwnerEvents bool, GrabWindow Window, Modifiers uint16, Key Keycode, PointerMode byte, KeyboardMode byte) GrabKeyCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(grabKeyRequest(c, OwnerEvents, GrabWindow, Modifiers, Key, PointerMode, KeyboardMode), cookie)
	return GrabKeyCookie{cookie}
}

func GrabKeyChecked(c *xgb.Conn, OwnerEvents bool, GrabWindow Window, Modifiers uint16, Key Keycode, PointerMode byte, KeyboardMode byte) GrabKeyCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(grabKeyRequest(c, OwnerEvents, GrabWindow, Modifiers, Key, PointerMode, KeyboardMode), cookie)
	return GrabKeyCookie{cookie}
}

func (cook GrabKeyCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for GrabKey
func grabKeyRequest(c *xgb.Conn, OwnerEvents bool, GrabWindow Window, Modifiers uint16, Key Keycode, PointerMode byte, KeyboardMode byte) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = 33 // request opcode
	b += 1

	if OwnerEvents {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GrabWindow))
	b += 4

	xgb.Put16(buf[b:], Modifiers)
	b += 2

	buf[b] = byte(Key)
	b += 1

	buf[b] = PointerMode
	b += 1

	buf[b] = KeyboardMode
	b += 1

	b += 3 // padding

	return buf
}

// Request UngrabKey
// size: 12
type UngrabKeyCookie struct {
	*xgb.Cookie
}

// Write request to wire for UngrabKey
func UngrabKey(c *xgb.Conn, Key Keycode, GrabWindow Window, Modifiers uint16) UngrabKeyCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(ungrabKeyRequest(c, Key, GrabWindow, Modifiers), cookie)
	return UngrabKeyCookie{cookie}
}

func UngrabKeyChecked(c *xgb.Conn, Key Keycode, GrabWindow Window, Modifiers uint16) UngrabKeyCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(ungrabKeyRequest(c, Key, GrabWindow, Modifiers), cookie)
	return UngrabKeyCookie{cookie}
}

func (cook UngrabKeyCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UngrabKey
func ungrabKeyRequest(c *xgb.Conn, Key Keycode, GrabWindow Window, Modifiers uint16) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = 34 // request opcode
	b += 1

	buf[b] = byte(Key)
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(GrabWindow))
	b += 4

	xgb.Put16(buf[b:], Modifiers)
	b += 2

	b += 2 // padding

	return buf
}

// Request AllowEvents
// size: 8
type AllowEventsCookie struct {
	*xgb.Cookie
}

// Write request to wire for AllowEvents
func AllowEvents(c *xgb.Conn, Mode byte, Time Timestamp) AllowEventsCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(allowEventsRequest(c, Mode, Time), cookie)
	return AllowEventsCookie{cookie}
}

func AllowEventsChecked(c *xgb.Conn, Mode byte, Time Timestamp) AllowEventsCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(allowEventsRequest(c, Mode, Time), cookie)
	return AllowEventsCookie{cookie}
}

func (cook AllowEventsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for AllowEvents
func allowEventsRequest(c *xgb.Conn, Mode byte, Time Timestamp) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 35 // request opcode
	b += 1

	buf[b] = Mode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	return buf
}

// Request GrabServer
// size: 4
type GrabServerCookie struct {
	*xgb.Cookie
}

// Write request to wire for GrabServer
func GrabServer(c *xgb.Conn) GrabServerCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(grabServerRequest(c), cookie)
	return GrabServerCookie{cookie}
}

func GrabServerChecked(c *xgb.Conn) GrabServerCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(grabServerRequest(c), cookie)
	return GrabServerCookie{cookie}
}

func (cook GrabServerCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for GrabServer
func grabServerRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 36 // request opcode
	b += 1

	b += 1                             // padding
	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request UngrabServer
// size: 4
type UngrabServerCookie struct {
	*xgb.Cookie
}

// Write request to wire for UngrabServer
func UngrabServer(c *xgb.Conn) UngrabServerCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(ungrabServerRequest(c), cookie)
	return UngrabServerCookie{cookie}
}

func UngrabServerChecked(c *xgb.Conn) UngrabServerCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(ungrabServerRequest(c), cookie)
	return UngrabServerCookie{cookie}
}

func (cook UngrabServerCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UngrabServer
func ungrabServerRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 37 // request opcode
	b += 1

	b += 1                             // padding
	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request QueryPointer
// size: 8
type QueryPointerCookie struct {
	*xgb.Cookie
}

func QueryPointer(c *xgb.Conn, Window Window) QueryPointerCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryPointerRequest(c, Window), cookie)
	return QueryPointerCookie{cookie}
}

func QueryPointerUnchecked(c *xgb.Conn, Window Window) QueryPointerCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryPointerRequest(c, Window), cookie)
	return QueryPointerCookie{cookie}
}

// Request reply for QueryPointer
// size: 28
type QueryPointerReply struct {
	Sequence   uint16
	Length     uint32
	SameScreen bool
	Root       Window
	Child      Window
	RootX      int16
	RootY      int16
	WinX       int16
	WinY       int16
	Mask       uint16
	// padding: 2 bytes
}

// Waits and reads reply data from request QueryPointer
func (cook QueryPointerCookie) Reply() (*QueryPointerReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryPointerReply(buf), nil
}

// Read reply into structure from buffer for QueryPointer
func queryPointerReply(buf []byte) *QueryPointerReply {
	v := new(QueryPointerReply)
	b := 1 // skip reply determinant

	if buf[b] == 1 {
		v.SameScreen = true
	} else {
		v.SameScreen = false
	}
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Root = Window(xgb.Get32(buf[b:]))
	b += 4

	v.Child = Window(xgb.Get32(buf[b:]))
	b += 4

	v.RootX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.RootY = int16(xgb.Get16(buf[b:]))
	b += 2

	v.WinX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.WinY = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Mask = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	return v
}

// Write request to wire for QueryPointer
func queryPointerRequest(c *xgb.Conn, Window Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 38 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request GetMotionEvents
// size: 16
type GetMotionEventsCookie struct {
	*xgb.Cookie
}

func GetMotionEvents(c *xgb.Conn, Window Window, Start Timestamp, Stop Timestamp) GetMotionEventsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getMotionEventsRequest(c, Window, Start, Stop), cookie)
	return GetMotionEventsCookie{cookie}
}

func GetMotionEventsUnchecked(c *xgb.Conn, Window Window, Start Timestamp, Stop Timestamp) GetMotionEventsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getMotionEventsRequest(c, Window, Start, Stop), cookie)
	return GetMotionEventsCookie{cookie}
}

// Request reply for GetMotionEvents
// size: (32 + xgb.Pad((int(EventsLen) * 8)))
type GetMotionEventsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	EventsLen uint32
	// padding: 20 bytes
	Events []Timecoord // size: xgb.Pad((int(EventsLen) * 8))
}

// Waits and reads reply data from request GetMotionEvents
func (cook GetMotionEventsCookie) Reply() (*GetMotionEventsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getMotionEventsReply(buf), nil
}

// Read reply into structure from buffer for GetMotionEvents
func getMotionEventsReply(buf []byte) *GetMotionEventsReply {
	v := new(GetMotionEventsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.EventsLen = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.Events = make([]Timecoord, v.EventsLen)
	b += TimecoordReadList(buf[b:], v.Events)

	return v
}

// Write request to wire for GetMotionEvents
func getMotionEventsRequest(c *xgb.Conn, Window Window, Start Timestamp, Stop Timestamp) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = 39 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put32(buf[b:], uint32(Start))
	b += 4

	xgb.Put32(buf[b:], uint32(Stop))
	b += 4

	return buf
}

// Request TranslateCoordinates
// size: 16
type TranslateCoordinatesCookie struct {
	*xgb.Cookie
}

func TranslateCoordinates(c *xgb.Conn, SrcWindow Window, DstWindow Window, SrcX int16, SrcY int16) TranslateCoordinatesCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(translateCoordinatesRequest(c, SrcWindow, DstWindow, SrcX, SrcY), cookie)
	return TranslateCoordinatesCookie{cookie}
}

func TranslateCoordinatesUnchecked(c *xgb.Conn, SrcWindow Window, DstWindow Window, SrcX int16, SrcY int16) TranslateCoordinatesCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(translateCoordinatesRequest(c, SrcWindow, DstWindow, SrcX, SrcY), cookie)
	return TranslateCoordinatesCookie{cookie}
}

// Request reply for TranslateCoordinates
// size: 16
type TranslateCoordinatesReply struct {
	Sequence   uint16
	Length     uint32
	SameScreen bool
	Child      Window
	DstX       int16
	DstY       int16
}

// Waits and reads reply data from request TranslateCoordinates
func (cook TranslateCoordinatesCookie) Reply() (*TranslateCoordinatesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return translateCoordinatesReply(buf), nil
}

// Read reply into structure from buffer for TranslateCoordinates
func translateCoordinatesReply(buf []byte) *TranslateCoordinatesReply {
	v := new(TranslateCoordinatesReply)
	b := 1 // skip reply determinant

	if buf[b] == 1 {
		v.SameScreen = true
	} else {
		v.SameScreen = false
	}
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Child = Window(xgb.Get32(buf[b:]))
	b += 4

	v.DstX = int16(xgb.Get16(buf[b:]))
	b += 2

	v.DstY = int16(xgb.Get16(buf[b:]))
	b += 2

	return v
}

// Write request to wire for TranslateCoordinates
func translateCoordinatesRequest(c *xgb.Conn, SrcWindow Window, DstWindow Window, SrcX int16, SrcY int16) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = 40 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(SrcWindow))
	b += 4

	xgb.Put32(buf[b:], uint32(DstWindow))
	b += 4

	xgb.Put16(buf[b:], uint16(SrcX))
	b += 2

	xgb.Put16(buf[b:], uint16(SrcY))
	b += 2

	return buf
}

// Request WarpPointer
// size: 24
type WarpPointerCookie struct {
	*xgb.Cookie
}

// Write request to wire for WarpPointer
func WarpPointer(c *xgb.Conn, SrcWindow Window, DstWindow Window, SrcX int16, SrcY int16, SrcWidth uint16, SrcHeight uint16, DstX int16, DstY int16) WarpPointerCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(warpPointerRequest(c, SrcWindow, DstWindow, SrcX, SrcY, SrcWidth, SrcHeight, DstX, DstY), cookie)
	return WarpPointerCookie{cookie}
}

func WarpPointerChecked(c *xgb.Conn, SrcWindow Window, DstWindow Window, SrcX int16, SrcY int16, SrcWidth uint16, SrcHeight uint16, DstX int16, DstY int16) WarpPointerCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(warpPointerRequest(c, SrcWindow, DstWindow, SrcX, SrcY, SrcWidth, SrcHeight, DstX, DstY), cookie)
	return WarpPointerCookie{cookie}
}

func (cook WarpPointerCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for WarpPointer
func warpPointerRequest(c *xgb.Conn, SrcWindow Window, DstWindow Window, SrcX int16, SrcY int16, SrcWidth uint16, SrcHeight uint16, DstX int16, DstY int16) []byte {
	size := 24
	b := 0
	buf := make([]byte, size)

	buf[b] = 41 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(SrcWindow))
	b += 4

	xgb.Put32(buf[b:], uint32(DstWindow))
	b += 4

	xgb.Put16(buf[b:], uint16(SrcX))
	b += 2

	xgb.Put16(buf[b:], uint16(SrcY))
	b += 2

	xgb.Put16(buf[b:], SrcWidth)
	b += 2

	xgb.Put16(buf[b:], SrcHeight)
	b += 2

	xgb.Put16(buf[b:], uint16(DstX))
	b += 2

	xgb.Put16(buf[b:], uint16(DstY))
	b += 2

	return buf
}

// Request SetInputFocus
// size: 12
type SetInputFocusCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetInputFocus
func SetInputFocus(c *xgb.Conn, RevertTo byte, Focus Window, Time Timestamp) SetInputFocusCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setInputFocusRequest(c, RevertTo, Focus, Time), cookie)
	return SetInputFocusCookie{cookie}
}

func SetInputFocusChecked(c *xgb.Conn, RevertTo byte, Focus Window, Time Timestamp) SetInputFocusCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setInputFocusRequest(c, RevertTo, Focus, Time), cookie)
	return SetInputFocusCookie{cookie}
}

func (cook SetInputFocusCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetInputFocus
func setInputFocusRequest(c *xgb.Conn, RevertTo byte, Focus Window, Time Timestamp) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = 42 // request opcode
	b += 1

	buf[b] = RevertTo
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Focus))
	b += 4

	xgb.Put32(buf[b:], uint32(Time))
	b += 4

	return buf
}

// Request GetInputFocus
// size: 4
type GetInputFocusCookie struct {
	*xgb.Cookie
}

func GetInputFocus(c *xgb.Conn) GetInputFocusCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getInputFocusRequest(c), cookie)
	return GetInputFocusCookie{cookie}
}

func GetInputFocusUnchecked(c *xgb.Conn) GetInputFocusCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getInputFocusRequest(c), cookie)
	return GetInputFocusCookie{cookie}
}

// Request reply for GetInputFocus
// size: 12
type GetInputFocusReply struct {
	Sequence uint16
	Length   uint32
	RevertTo byte
	Focus    Window
}

// Waits and reads reply data from request GetInputFocus
func (cook GetInputFocusCookie) Reply() (*GetInputFocusReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getInputFocusReply(buf), nil
}

// Read reply into structure from buffer for GetInputFocus
func getInputFocusReply(buf []byte) *GetInputFocusReply {
	v := new(GetInputFocusReply)
	b := 1 // skip reply determinant

	v.RevertTo = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Focus = Window(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Write request to wire for GetInputFocus
func getInputFocusRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 43 // request opcode
	b += 1

	b += 1                             // padding
	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request QueryKeymap
// size: 4
type QueryKeymapCookie struct {
	*xgb.Cookie
}

func QueryKeymap(c *xgb.Conn) QueryKeymapCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryKeymapRequest(c), cookie)
	return QueryKeymapCookie{cookie}
}

func QueryKeymapUnchecked(c *xgb.Conn) QueryKeymapCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryKeymapRequest(c), cookie)
	return QueryKeymapCookie{cookie}
}

// Request reply for QueryKeymap
// size: 40
type QueryKeymapReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Keys []byte // size: 32
}

// Waits and reads reply data from request QueryKeymap
func (cook QueryKeymapCookie) Reply() (*QueryKeymapReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryKeymapReply(buf), nil
}

// Read reply into structure from buffer for QueryKeymap
func queryKeymapReply(buf []byte) *QueryKeymapReply {
	v := new(QueryKeymapReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Keys = make([]byte, 32)
	copy(v.Keys[:32], buf[b:])
	b += xgb.Pad(int(32))

	return v
}

// Write request to wire for QueryKeymap
func queryKeymapRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 44 // request opcode
	b += 1

	b += 1                             // padding
	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request OpenFont
// size: xgb.Pad((12 + xgb.Pad((int(NameLen) * 1))))
type OpenFontCookie struct {
	*xgb.Cookie
}

// Write request to wire for OpenFont
func OpenFont(c *xgb.Conn, Fid Font, NameLen uint16, Name string) OpenFontCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(openFontRequest(c, Fid, NameLen, Name), cookie)
	return OpenFontCookie{cookie}
}

func OpenFontChecked(c *xgb.Conn, Fid Font, NameLen uint16, Name string) OpenFontCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(openFontRequest(c, Fid, NameLen, Name), cookie)
	return OpenFontCookie{cookie}
}

func (cook OpenFontCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for OpenFont
func openFontRequest(c *xgb.Conn, Fid Font, NameLen uint16, Name string) []byte {
	size := xgb.Pad((12 + xgb.Pad((int(NameLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 45 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Fid))
	b += 4

	xgb.Put16(buf[b:], NameLen)
	b += 2

	b += 2 // padding

	copy(buf[b:], Name[:NameLen])
	b += xgb.Pad(int(NameLen))

	return buf
}

// Request CloseFont
// size: 8
type CloseFontCookie struct {
	*xgb.Cookie
}

// Write request to wire for CloseFont
func CloseFont(c *xgb.Conn, Font Font) CloseFontCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(closeFontRequest(c, Font), cookie)
	return CloseFontCookie{cookie}
}

func CloseFontChecked(c *xgb.Conn, Font Font) CloseFontCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(closeFontRequest(c, Font), cookie)
	return CloseFontCookie{cookie}
}

func (cook CloseFontCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CloseFont
func closeFontRequest(c *xgb.Conn, Font Font) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 46 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Font))
	b += 4

	return buf
}

// Request QueryFont
// size: 8
type QueryFontCookie struct {
	*xgb.Cookie
}

func QueryFont(c *xgb.Conn, Font Fontable) QueryFontCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryFontRequest(c, Font), cookie)
	return QueryFontCookie{cookie}
}

func QueryFontUnchecked(c *xgb.Conn, Font Fontable) QueryFontCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryFontRequest(c, Font), cookie)
	return QueryFontCookie{cookie}
}

// Request reply for QueryFont
// size: ((60 + xgb.Pad((int(PropertiesLen) * 8))) + xgb.Pad((int(CharInfosLen) * 12)))
type QueryFontReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	MinBounds Charinfo
	// padding: 4 bytes
	MaxBounds Charinfo
	// padding: 4 bytes
	MinCharOrByte2 uint16
	MaxCharOrByte2 uint16
	DefaultChar    uint16
	PropertiesLen  uint16
	DrawDirection  byte
	MinByte1       byte
	MaxByte1       byte
	AllCharsExist  bool
	FontAscent     int16
	FontDescent    int16
	CharInfosLen   uint32
	Properties     []Fontprop // size: xgb.Pad((int(PropertiesLen) * 8))
	CharInfos      []Charinfo // size: xgb.Pad((int(CharInfosLen) * 12))
}

// Waits and reads reply data from request QueryFont
func (cook QueryFontCookie) Reply() (*QueryFontReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryFontReply(buf), nil
}

// Read reply into structure from buffer for QueryFont
func queryFontReply(buf []byte) *QueryFontReply {
	v := new(QueryFontReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.MinBounds = Charinfo{}
	b += CharinfoRead(buf[b:], &v.MinBounds)

	b += 4 // padding

	v.MaxBounds = Charinfo{}
	b += CharinfoRead(buf[b:], &v.MaxBounds)

	b += 4 // padding

	v.MinCharOrByte2 = xgb.Get16(buf[b:])
	b += 2

	v.MaxCharOrByte2 = xgb.Get16(buf[b:])
	b += 2

	v.DefaultChar = xgb.Get16(buf[b:])
	b += 2

	v.PropertiesLen = xgb.Get16(buf[b:])
	b += 2

	v.DrawDirection = buf[b]
	b += 1

	v.MinByte1 = buf[b]
	b += 1

	v.MaxByte1 = buf[b]
	b += 1

	if buf[b] == 1 {
		v.AllCharsExist = true
	} else {
		v.AllCharsExist = false
	}
	b += 1

	v.FontAscent = int16(xgb.Get16(buf[b:]))
	b += 2

	v.FontDescent = int16(xgb.Get16(buf[b:]))
	b += 2

	v.CharInfosLen = xgb.Get32(buf[b:])
	b += 4

	v.Properties = make([]Fontprop, v.PropertiesLen)
	b += FontpropReadList(buf[b:], v.Properties)

	v.CharInfos = make([]Charinfo, v.CharInfosLen)
	b += CharinfoReadList(buf[b:], v.CharInfos)

	return v
}

// Write request to wire for QueryFont
func queryFontRequest(c *xgb.Conn, Font Fontable) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 47 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Font))
	b += 4

	return buf
}

// Request QueryTextExtents
// size: xgb.Pad((8 + xgb.Pad((len(String) * 2))))
type QueryTextExtentsCookie struct {
	*xgb.Cookie
}

func QueryTextExtents(c *xgb.Conn, Font Fontable, String []Char2b, StringLen uint16) QueryTextExtentsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryTextExtentsRequest(c, Font, String, StringLen), cookie)
	return QueryTextExtentsCookie{cookie}
}

func QueryTextExtentsUnchecked(c *xgb.Conn, Font Fontable, String []Char2b, StringLen uint16) QueryTextExtentsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryTextExtentsRequest(c, Font, String, StringLen), cookie)
	return QueryTextExtentsCookie{cookie}
}

// Request reply for QueryTextExtents
// size: 28
type QueryTextExtentsReply struct {
	Sequence       uint16
	Length         uint32
	DrawDirection  byte
	FontAscent     int16
	FontDescent    int16
	OverallAscent  int16
	OverallDescent int16
	OverallWidth   int32
	OverallLeft    int32
	OverallRight   int32
}

// Waits and reads reply data from request QueryTextExtents
func (cook QueryTextExtentsCookie) Reply() (*QueryTextExtentsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryTextExtentsReply(buf), nil
}

// Read reply into structure from buffer for QueryTextExtents
func queryTextExtentsReply(buf []byte) *QueryTextExtentsReply {
	v := new(QueryTextExtentsReply)
	b := 1 // skip reply determinant

	v.DrawDirection = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.FontAscent = int16(xgb.Get16(buf[b:]))
	b += 2

	v.FontDescent = int16(xgb.Get16(buf[b:]))
	b += 2

	v.OverallAscent = int16(xgb.Get16(buf[b:]))
	b += 2

	v.OverallDescent = int16(xgb.Get16(buf[b:]))
	b += 2

	v.OverallWidth = int32(xgb.Get32(buf[b:]))
	b += 4

	v.OverallLeft = int32(xgb.Get32(buf[b:]))
	b += 4

	v.OverallRight = int32(xgb.Get32(buf[b:]))
	b += 4

	return v
}

// Write request to wire for QueryTextExtents
func queryTextExtentsRequest(c *xgb.Conn, Font Fontable, String []Char2b, StringLen uint16) []byte {
	size := xgb.Pad((8 + xgb.Pad((len(String) * 2))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 48 // request opcode
	b += 1

	buf[b] = byte((int(StringLen) & 1))
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Font))
	b += 4

	b += Char2bListBytes(buf[b:], String)

	// skip writing local field: StringLen (2) :: uint16

	return buf
}

// Request ListFonts
// size: xgb.Pad((8 + xgb.Pad((int(PatternLen) * 1))))
type ListFontsCookie struct {
	*xgb.Cookie
}

func ListFonts(c *xgb.Conn, MaxNames uint16, PatternLen uint16, Pattern string) ListFontsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(listFontsRequest(c, MaxNames, PatternLen, Pattern), cookie)
	return ListFontsCookie{cookie}
}

func ListFontsUnchecked(c *xgb.Conn, MaxNames uint16, PatternLen uint16, Pattern string) ListFontsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(listFontsRequest(c, MaxNames, PatternLen, Pattern), cookie)
	return ListFontsCookie{cookie}
}

// Request reply for ListFonts
// size: (32 + StrListSize(Names))
type ListFontsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NamesLen uint16
	// padding: 22 bytes
	Names []Str // size: StrListSize(Names)
}

// Waits and reads reply data from request ListFonts
func (cook ListFontsCookie) Reply() (*ListFontsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listFontsReply(buf), nil
}

// Read reply into structure from buffer for ListFonts
func listFontsReply(buf []byte) *ListFontsReply {
	v := new(ListFontsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NamesLen = xgb.Get16(buf[b:])
	b += 2

	b += 22 // padding

	v.Names = make([]Str, v.NamesLen)
	b += StrReadList(buf[b:], v.Names)

	return v
}

// Write request to wire for ListFonts
func listFontsRequest(c *xgb.Conn, MaxNames uint16, PatternLen uint16, Pattern string) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(PatternLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 49 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], MaxNames)
	b += 2

	xgb.Put16(buf[b:], PatternLen)
	b += 2

	copy(buf[b:], Pattern[:PatternLen])
	b += xgb.Pad(int(PatternLen))

	return buf
}

// Request ListFontsWithInfo
// size: xgb.Pad((8 + xgb.Pad((int(PatternLen) * 1))))
type ListFontsWithInfoCookie struct {
	*xgb.Cookie
}

func ListFontsWithInfo(c *xgb.Conn, MaxNames uint16, PatternLen uint16, Pattern string) ListFontsWithInfoCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(listFontsWithInfoRequest(c, MaxNames, PatternLen, Pattern), cookie)
	return ListFontsWithInfoCookie{cookie}
}

func ListFontsWithInfoUnchecked(c *xgb.Conn, MaxNames uint16, PatternLen uint16, Pattern string) ListFontsWithInfoCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(listFontsWithInfoRequest(c, MaxNames, PatternLen, Pattern), cookie)
	return ListFontsWithInfoCookie{cookie}
}

// Request reply for ListFontsWithInfo
// size: ((60 + xgb.Pad((int(PropertiesLen) * 8))) + xgb.Pad((int(NameLen) * 1)))
type ListFontsWithInfoReply struct {
	Sequence  uint16
	Length    uint32
	NameLen   byte
	MinBounds Charinfo
	// padding: 4 bytes
	MaxBounds Charinfo
	// padding: 4 bytes
	MinCharOrByte2 uint16
	MaxCharOrByte2 uint16
	DefaultChar    uint16
	PropertiesLen  uint16
	DrawDirection  byte
	MinByte1       byte
	MaxByte1       byte
	AllCharsExist  bool
	FontAscent     int16
	FontDescent    int16
	RepliesHint    uint32
	Properties     []Fontprop // size: xgb.Pad((int(PropertiesLen) * 8))
	Name           string     // size: xgb.Pad((int(NameLen) * 1))
}

// Waits and reads reply data from request ListFontsWithInfo
func (cook ListFontsWithInfoCookie) Reply() (*ListFontsWithInfoReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listFontsWithInfoReply(buf), nil
}

// Read reply into structure from buffer for ListFontsWithInfo
func listFontsWithInfoReply(buf []byte) *ListFontsWithInfoReply {
	v := new(ListFontsWithInfoReply)
	b := 1 // skip reply determinant

	v.NameLen = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.MinBounds = Charinfo{}
	b += CharinfoRead(buf[b:], &v.MinBounds)

	b += 4 // padding

	v.MaxBounds = Charinfo{}
	b += CharinfoRead(buf[b:], &v.MaxBounds)

	b += 4 // padding

	v.MinCharOrByte2 = xgb.Get16(buf[b:])
	b += 2

	v.MaxCharOrByte2 = xgb.Get16(buf[b:])
	b += 2

	v.DefaultChar = xgb.Get16(buf[b:])
	b += 2

	v.PropertiesLen = xgb.Get16(buf[b:])
	b += 2

	v.DrawDirection = buf[b]
	b += 1

	v.MinByte1 = buf[b]
	b += 1

	v.MaxByte1 = buf[b]
	b += 1

	if buf[b] == 1 {
		v.AllCharsExist = true
	} else {
		v.AllCharsExist = false
	}
	b += 1

	v.FontAscent = int16(xgb.Get16(buf[b:]))
	b += 2

	v.FontDescent = int16(xgb.Get16(buf[b:]))
	b += 2

	v.RepliesHint = xgb.Get32(buf[b:])
	b += 4

	v.Properties = make([]Fontprop, v.PropertiesLen)
	b += FontpropReadList(buf[b:], v.Properties)

	{
		byteString := make([]byte, v.NameLen)
		copy(byteString[:v.NameLen], buf[b:])
		v.Name = string(byteString)
		b += xgb.Pad(int(v.NameLen))
	}

	return v
}

// Write request to wire for ListFontsWithInfo
func listFontsWithInfoRequest(c *xgb.Conn, MaxNames uint16, PatternLen uint16, Pattern string) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(PatternLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 50 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], MaxNames)
	b += 2

	xgb.Put16(buf[b:], PatternLen)
	b += 2

	copy(buf[b:], Pattern[:PatternLen])
	b += xgb.Pad(int(PatternLen))

	return buf
}

// Request SetFontPath
// size: xgb.Pad((8 + StrListSize(Font)))
type SetFontPathCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetFontPath
func SetFontPath(c *xgb.Conn, FontQty uint16, Font []Str) SetFontPathCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setFontPathRequest(c, FontQty, Font), cookie)
	return SetFontPathCookie{cookie}
}

func SetFontPathChecked(c *xgb.Conn, FontQty uint16, Font []Str) SetFontPathCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setFontPathRequest(c, FontQty, Font), cookie)
	return SetFontPathCookie{cookie}
}

func (cook SetFontPathCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetFontPath
func setFontPathRequest(c *xgb.Conn, FontQty uint16, Font []Str) []byte {
	size := xgb.Pad((8 + StrListSize(Font)))
	b := 0
	buf := make([]byte, size)

	buf[b] = 51 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], FontQty)
	b += 2

	b += 2 // padding

	b += StrListBytes(buf[b:], Font)

	return buf
}

// Request GetFontPath
// size: 4
type GetFontPathCookie struct {
	*xgb.Cookie
}

func GetFontPath(c *xgb.Conn) GetFontPathCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getFontPathRequest(c), cookie)
	return GetFontPathCookie{cookie}
}

func GetFontPathUnchecked(c *xgb.Conn) GetFontPathCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getFontPathRequest(c), cookie)
	return GetFontPathCookie{cookie}
}

// Request reply for GetFontPath
// size: (32 + StrListSize(Path))
type GetFontPathReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	PathLen uint16
	// padding: 22 bytes
	Path []Str // size: StrListSize(Path)
}

// Waits and reads reply data from request GetFontPath
func (cook GetFontPathCookie) Reply() (*GetFontPathReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getFontPathReply(buf), nil
}

// Read reply into structure from buffer for GetFontPath
func getFontPathReply(buf []byte) *GetFontPathReply {
	v := new(GetFontPathReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.PathLen = xgb.Get16(buf[b:])
	b += 2

	b += 22 // padding

	v.Path = make([]Str, v.PathLen)
	b += StrReadList(buf[b:], v.Path)

	return v
}

// Write request to wire for GetFontPath
func getFontPathRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 52 // request opcode
	b += 1

	b += 1                             // padding
	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request CreatePixmap
// size: 16
type CreatePixmapCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreatePixmap
func CreatePixmap(c *xgb.Conn, Depth byte, Pid Pixmap, Drawable Drawable, Width uint16, Height uint16) CreatePixmapCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createPixmapRequest(c, Depth, Pid, Drawable, Width, Height), cookie)
	return CreatePixmapCookie{cookie}
}

func CreatePixmapChecked(c *xgb.Conn, Depth byte, Pid Pixmap, Drawable Drawable, Width uint16, Height uint16) CreatePixmapCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createPixmapRequest(c, Depth, Pid, Drawable, Width, Height), cookie)
	return CreatePixmapCookie{cookie}
}

func (cook CreatePixmapCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreatePixmap
func createPixmapRequest(c *xgb.Conn, Depth byte, Pid Pixmap, Drawable Drawable, Width uint16, Height uint16) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = 53 // request opcode
	b += 1

	buf[b] = Depth
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Pid))
	b += 4

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	return buf
}

// Request FreePixmap
// size: 8
type FreePixmapCookie struct {
	*xgb.Cookie
}

// Write request to wire for FreePixmap
func FreePixmap(c *xgb.Conn, Pixmap Pixmap) FreePixmapCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(freePixmapRequest(c, Pixmap), cookie)
	return FreePixmapCookie{cookie}
}

func FreePixmapChecked(c *xgb.Conn, Pixmap Pixmap) FreePixmapCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(freePixmapRequest(c, Pixmap), cookie)
	return FreePixmapCookie{cookie}
}

func (cook FreePixmapCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for FreePixmap
func freePixmapRequest(c *xgb.Conn, Pixmap Pixmap) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 54 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Pixmap))
	b += 4

	return buf
}

// Request CreateGC
// size: xgb.Pad((12 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
type CreateGCCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateGC
func CreateGC(c *xgb.Conn, Cid Gcontext, Drawable Drawable, ValueMask uint32, ValueList []uint32) CreateGCCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createGCRequest(c, Cid, Drawable, ValueMask, ValueList), cookie)
	return CreateGCCookie{cookie}
}

func CreateGCChecked(c *xgb.Conn, Cid Gcontext, Drawable Drawable, ValueMask uint32, ValueList []uint32) CreateGCCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createGCRequest(c, Cid, Drawable, ValueMask, ValueList), cookie)
	return CreateGCCookie{cookie}
}

func (cook CreateGCCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateGC
func createGCRequest(c *xgb.Conn, Cid Gcontext, Drawable Drawable, ValueMask uint32, ValueList []uint32) []byte {
	size := xgb.Pad((12 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 55 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cid))
	b += 4

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], ValueMask)
	b += 4
	for i := 0; i < xgb.PopCount(int(ValueMask)); i++ {
		xgb.Put32(buf[b:], ValueList[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request ChangeGC
// size: xgb.Pad((8 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
type ChangeGCCookie struct {
	*xgb.Cookie
}

// Write request to wire for ChangeGC
func ChangeGC(c *xgb.Conn, Gc Gcontext, ValueMask uint32, ValueList []uint32) ChangeGCCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeGCRequest(c, Gc, ValueMask, ValueList), cookie)
	return ChangeGCCookie{cookie}
}

func ChangeGCChecked(c *xgb.Conn, Gc Gcontext, ValueMask uint32, ValueList []uint32) ChangeGCCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeGCRequest(c, Gc, ValueMask, ValueList), cookie)
	return ChangeGCCookie{cookie}
}

func (cook ChangeGCCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeGC
func changeGCRequest(c *xgb.Conn, Gc Gcontext, ValueMask uint32, ValueList []uint32) []byte {
	size := xgb.Pad((8 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 56 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put32(buf[b:], ValueMask)
	b += 4
	for i := 0; i < xgb.PopCount(int(ValueMask)); i++ {
		xgb.Put32(buf[b:], ValueList[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request CopyGC
// size: 16
type CopyGCCookie struct {
	*xgb.Cookie
}

// Write request to wire for CopyGC
func CopyGC(c *xgb.Conn, SrcGc Gcontext, DstGc Gcontext, ValueMask uint32) CopyGCCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(copyGCRequest(c, SrcGc, DstGc, ValueMask), cookie)
	return CopyGCCookie{cookie}
}

func CopyGCChecked(c *xgb.Conn, SrcGc Gcontext, DstGc Gcontext, ValueMask uint32) CopyGCCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(copyGCRequest(c, SrcGc, DstGc, ValueMask), cookie)
	return CopyGCCookie{cookie}
}

func (cook CopyGCCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CopyGC
func copyGCRequest(c *xgb.Conn, SrcGc Gcontext, DstGc Gcontext, ValueMask uint32) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = 57 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(SrcGc))
	b += 4

	xgb.Put32(buf[b:], uint32(DstGc))
	b += 4

	xgb.Put32(buf[b:], ValueMask)
	b += 4

	return buf
}

// Request SetDashes
// size: xgb.Pad((12 + xgb.Pad((int(DashesLen) * 1))))
type SetDashesCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetDashes
func SetDashes(c *xgb.Conn, Gc Gcontext, DashOffset uint16, DashesLen uint16, Dashes []byte) SetDashesCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setDashesRequest(c, Gc, DashOffset, DashesLen, Dashes), cookie)
	return SetDashesCookie{cookie}
}

func SetDashesChecked(c *xgb.Conn, Gc Gcontext, DashOffset uint16, DashesLen uint16, Dashes []byte) SetDashesCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setDashesRequest(c, Gc, DashOffset, DashesLen, Dashes), cookie)
	return SetDashesCookie{cookie}
}

func (cook SetDashesCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetDashes
func setDashesRequest(c *xgb.Conn, Gc Gcontext, DashOffset uint16, DashesLen uint16, Dashes []byte) []byte {
	size := xgb.Pad((12 + xgb.Pad((int(DashesLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 58 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put16(buf[b:], DashOffset)
	b += 2

	xgb.Put16(buf[b:], DashesLen)
	b += 2

	copy(buf[b:], Dashes[:DashesLen])
	b += xgb.Pad(int(DashesLen))

	return buf
}

// Request SetClipRectangles
// size: xgb.Pad((12 + xgb.Pad((len(Rectangles) * 8))))
type SetClipRectanglesCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetClipRectangles
func SetClipRectangles(c *xgb.Conn, Ordering byte, Gc Gcontext, ClipXOrigin int16, ClipYOrigin int16, Rectangles []Rectangle) SetClipRectanglesCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setClipRectanglesRequest(c, Ordering, Gc, ClipXOrigin, ClipYOrigin, Rectangles), cookie)
	return SetClipRectanglesCookie{cookie}
}

func SetClipRectanglesChecked(c *xgb.Conn, Ordering byte, Gc Gcontext, ClipXOrigin int16, ClipYOrigin int16, Rectangles []Rectangle) SetClipRectanglesCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setClipRectanglesRequest(c, Ordering, Gc, ClipXOrigin, ClipYOrigin, Rectangles), cookie)
	return SetClipRectanglesCookie{cookie}
}

func (cook SetClipRectanglesCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetClipRectangles
func setClipRectanglesRequest(c *xgb.Conn, Ordering byte, Gc Gcontext, ClipXOrigin int16, ClipYOrigin int16, Rectangles []Rectangle) []byte {
	size := xgb.Pad((12 + xgb.Pad((len(Rectangles) * 8))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 59 // request opcode
	b += 1

	buf[b] = Ordering
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put16(buf[b:], uint16(ClipXOrigin))
	b += 2

	xgb.Put16(buf[b:], uint16(ClipYOrigin))
	b += 2

	b += RectangleListBytes(buf[b:], Rectangles)

	return buf
}

// Request FreeGC
// size: 8
type FreeGCCookie struct {
	*xgb.Cookie
}

// Write request to wire for FreeGC
func FreeGC(c *xgb.Conn, Gc Gcontext) FreeGCCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(freeGCRequest(c, Gc), cookie)
	return FreeGCCookie{cookie}
}

func FreeGCChecked(c *xgb.Conn, Gc Gcontext) FreeGCCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(freeGCRequest(c, Gc), cookie)
	return FreeGCCookie{cookie}
}

func (cook FreeGCCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for FreeGC
func freeGCRequest(c *xgb.Conn, Gc Gcontext) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 60 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	return buf
}

// Request ClearArea
// size: 16
type ClearAreaCookie struct {
	*xgb.Cookie
}

// Write request to wire for ClearArea
func ClearArea(c *xgb.Conn, Exposures bool, Window Window, X int16, Y int16, Width uint16, Height uint16) ClearAreaCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(clearAreaRequest(c, Exposures, Window, X, Y, Width, Height), cookie)
	return ClearAreaCookie{cookie}
}

func ClearAreaChecked(c *xgb.Conn, Exposures bool, Window Window, X int16, Y int16, Width uint16, Height uint16) ClearAreaCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(clearAreaRequest(c, Exposures, Window, X, Y, Width, Height), cookie)
	return ClearAreaCookie{cookie}
}

func (cook ClearAreaCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ClearArea
func clearAreaRequest(c *xgb.Conn, Exposures bool, Window Window, X int16, Y int16, Width uint16, Height uint16) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = 61 // request opcode
	b += 1

	if Exposures {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put16(buf[b:], uint16(X))
	b += 2

	xgb.Put16(buf[b:], uint16(Y))
	b += 2

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	return buf
}

// Request CopyArea
// size: 28
type CopyAreaCookie struct {
	*xgb.Cookie
}

// Write request to wire for CopyArea
func CopyArea(c *xgb.Conn, SrcDrawable Drawable, DstDrawable Drawable, Gc Gcontext, SrcX int16, SrcY int16, DstX int16, DstY int16, Width uint16, Height uint16) CopyAreaCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(copyAreaRequest(c, SrcDrawable, DstDrawable, Gc, SrcX, SrcY, DstX, DstY, Width, Height), cookie)
	return CopyAreaCookie{cookie}
}

func CopyAreaChecked(c *xgb.Conn, SrcDrawable Drawable, DstDrawable Drawable, Gc Gcontext, SrcX int16, SrcY int16, DstX int16, DstY int16, Width uint16, Height uint16) CopyAreaCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(copyAreaRequest(c, SrcDrawable, DstDrawable, Gc, SrcX, SrcY, DstX, DstY, Width, Height), cookie)
	return CopyAreaCookie{cookie}
}

func (cook CopyAreaCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CopyArea
func copyAreaRequest(c *xgb.Conn, SrcDrawable Drawable, DstDrawable Drawable, Gc Gcontext, SrcX int16, SrcY int16, DstX int16, DstY int16, Width uint16, Height uint16) []byte {
	size := 28
	b := 0
	buf := make([]byte, size)

	buf[b] = 62 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(SrcDrawable))
	b += 4

	xgb.Put32(buf[b:], uint32(DstDrawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put16(buf[b:], uint16(SrcX))
	b += 2

	xgb.Put16(buf[b:], uint16(SrcY))
	b += 2

	xgb.Put16(buf[b:], uint16(DstX))
	b += 2

	xgb.Put16(buf[b:], uint16(DstY))
	b += 2

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	return buf
}

// Request CopyPlane
// size: 32
type CopyPlaneCookie struct {
	*xgb.Cookie
}

// Write request to wire for CopyPlane
func CopyPlane(c *xgb.Conn, SrcDrawable Drawable, DstDrawable Drawable, Gc Gcontext, SrcX int16, SrcY int16, DstX int16, DstY int16, Width uint16, Height uint16, BitPlane uint32) CopyPlaneCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(copyPlaneRequest(c, SrcDrawable, DstDrawable, Gc, SrcX, SrcY, DstX, DstY, Width, Height, BitPlane), cookie)
	return CopyPlaneCookie{cookie}
}

func CopyPlaneChecked(c *xgb.Conn, SrcDrawable Drawable, DstDrawable Drawable, Gc Gcontext, SrcX int16, SrcY int16, DstX int16, DstY int16, Width uint16, Height uint16, BitPlane uint32) CopyPlaneCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(copyPlaneRequest(c, SrcDrawable, DstDrawable, Gc, SrcX, SrcY, DstX, DstY, Width, Height, BitPlane), cookie)
	return CopyPlaneCookie{cookie}
}

func (cook CopyPlaneCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CopyPlane
func copyPlaneRequest(c *xgb.Conn, SrcDrawable Drawable, DstDrawable Drawable, Gc Gcontext, SrcX int16, SrcY int16, DstX int16, DstY int16, Width uint16, Height uint16, BitPlane uint32) []byte {
	size := 32
	b := 0
	buf := make([]byte, size)

	buf[b] = 63 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(SrcDrawable))
	b += 4

	xgb.Put32(buf[b:], uint32(DstDrawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put16(buf[b:], uint16(SrcX))
	b += 2

	xgb.Put16(buf[b:], uint16(SrcY))
	b += 2

	xgb.Put16(buf[b:], uint16(DstX))
	b += 2

	xgb.Put16(buf[b:], uint16(DstY))
	b += 2

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	xgb.Put32(buf[b:], BitPlane)
	b += 4

	return buf
}

// Request PolyPoint
// size: xgb.Pad((12 + xgb.Pad((len(Points) * 4))))
type PolyPointCookie struct {
	*xgb.Cookie
}

// Write request to wire for PolyPoint
func PolyPoint(c *xgb.Conn, CoordinateMode byte, Drawable Drawable, Gc Gcontext, Points []Point) PolyPointCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(polyPointRequest(c, CoordinateMode, Drawable, Gc, Points), cookie)
	return PolyPointCookie{cookie}
}

func PolyPointChecked(c *xgb.Conn, CoordinateMode byte, Drawable Drawable, Gc Gcontext, Points []Point) PolyPointCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(polyPointRequest(c, CoordinateMode, Drawable, Gc, Points), cookie)
	return PolyPointCookie{cookie}
}

func (cook PolyPointCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for PolyPoint
func polyPointRequest(c *xgb.Conn, CoordinateMode byte, Drawable Drawable, Gc Gcontext, Points []Point) []byte {
	size := xgb.Pad((12 + xgb.Pad((len(Points) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 64 // request opcode
	b += 1

	buf[b] = CoordinateMode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	b += PointListBytes(buf[b:], Points)

	return buf
}

// Request PolyLine
// size: xgb.Pad((12 + xgb.Pad((len(Points) * 4))))
type PolyLineCookie struct {
	*xgb.Cookie
}

// Write request to wire for PolyLine
func PolyLine(c *xgb.Conn, CoordinateMode byte, Drawable Drawable, Gc Gcontext, Points []Point) PolyLineCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(polyLineRequest(c, CoordinateMode, Drawable, Gc, Points), cookie)
	return PolyLineCookie{cookie}
}

func PolyLineChecked(c *xgb.Conn, CoordinateMode byte, Drawable Drawable, Gc Gcontext, Points []Point) PolyLineCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(polyLineRequest(c, CoordinateMode, Drawable, Gc, Points), cookie)
	return PolyLineCookie{cookie}
}

func (cook PolyLineCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for PolyLine
func polyLineRequest(c *xgb.Conn, CoordinateMode byte, Drawable Drawable, Gc Gcontext, Points []Point) []byte {
	size := xgb.Pad((12 + xgb.Pad((len(Points) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 65 // request opcode
	b += 1

	buf[b] = CoordinateMode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	b += PointListBytes(buf[b:], Points)

	return buf
}

// Request PolySegment
// size: xgb.Pad((12 + xgb.Pad((len(Segments) * 8))))
type PolySegmentCookie struct {
	*xgb.Cookie
}

// Write request to wire for PolySegment
func PolySegment(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Segments []Segment) PolySegmentCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(polySegmentRequest(c, Drawable, Gc, Segments), cookie)
	return PolySegmentCookie{cookie}
}

func PolySegmentChecked(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Segments []Segment) PolySegmentCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(polySegmentRequest(c, Drawable, Gc, Segments), cookie)
	return PolySegmentCookie{cookie}
}

func (cook PolySegmentCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for PolySegment
func polySegmentRequest(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Segments []Segment) []byte {
	size := xgb.Pad((12 + xgb.Pad((len(Segments) * 8))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 66 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	b += SegmentListBytes(buf[b:], Segments)

	return buf
}

// Request PolyRectangle
// size: xgb.Pad((12 + xgb.Pad((len(Rectangles) * 8))))
type PolyRectangleCookie struct {
	*xgb.Cookie
}

// Write request to wire for PolyRectangle
func PolyRectangle(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Rectangles []Rectangle) PolyRectangleCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(polyRectangleRequest(c, Drawable, Gc, Rectangles), cookie)
	return PolyRectangleCookie{cookie}
}

func PolyRectangleChecked(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Rectangles []Rectangle) PolyRectangleCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(polyRectangleRequest(c, Drawable, Gc, Rectangles), cookie)
	return PolyRectangleCookie{cookie}
}

func (cook PolyRectangleCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for PolyRectangle
func polyRectangleRequest(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Rectangles []Rectangle) []byte {
	size := xgb.Pad((12 + xgb.Pad((len(Rectangles) * 8))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 67 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	b += RectangleListBytes(buf[b:], Rectangles)

	return buf
}

// Request PolyArc
// size: xgb.Pad((12 + xgb.Pad((len(Arcs) * 12))))
type PolyArcCookie struct {
	*xgb.Cookie
}

// Write request to wire for PolyArc
func PolyArc(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Arcs []Arc) PolyArcCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(polyArcRequest(c, Drawable, Gc, Arcs), cookie)
	return PolyArcCookie{cookie}
}

func PolyArcChecked(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Arcs []Arc) PolyArcCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(polyArcRequest(c, Drawable, Gc, Arcs), cookie)
	return PolyArcCookie{cookie}
}

func (cook PolyArcCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for PolyArc
func polyArcRequest(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Arcs []Arc) []byte {
	size := xgb.Pad((12 + xgb.Pad((len(Arcs) * 12))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 68 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	b += ArcListBytes(buf[b:], Arcs)

	return buf
}

// Request FillPoly
// size: xgb.Pad((16 + xgb.Pad((len(Points) * 4))))
type FillPolyCookie struct {
	*xgb.Cookie
}

// Write request to wire for FillPoly
func FillPoly(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Shape byte, CoordinateMode byte, Points []Point) FillPolyCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(fillPolyRequest(c, Drawable, Gc, Shape, CoordinateMode, Points), cookie)
	return FillPolyCookie{cookie}
}

func FillPolyChecked(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Shape byte, CoordinateMode byte, Points []Point) FillPolyCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(fillPolyRequest(c, Drawable, Gc, Shape, CoordinateMode, Points), cookie)
	return FillPolyCookie{cookie}
}

func (cook FillPolyCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for FillPoly
func fillPolyRequest(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Shape byte, CoordinateMode byte, Points []Point) []byte {
	size := xgb.Pad((16 + xgb.Pad((len(Points) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 69 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	buf[b] = Shape
	b += 1

	buf[b] = CoordinateMode
	b += 1

	b += 2 // padding

	b += PointListBytes(buf[b:], Points)

	return buf
}

// Request PolyFillRectangle
// size: xgb.Pad((12 + xgb.Pad((len(Rectangles) * 8))))
type PolyFillRectangleCookie struct {
	*xgb.Cookie
}

// Write request to wire for PolyFillRectangle
func PolyFillRectangle(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Rectangles []Rectangle) PolyFillRectangleCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(polyFillRectangleRequest(c, Drawable, Gc, Rectangles), cookie)
	return PolyFillRectangleCookie{cookie}
}

func PolyFillRectangleChecked(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Rectangles []Rectangle) PolyFillRectangleCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(polyFillRectangleRequest(c, Drawable, Gc, Rectangles), cookie)
	return PolyFillRectangleCookie{cookie}
}

func (cook PolyFillRectangleCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for PolyFillRectangle
func polyFillRectangleRequest(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Rectangles []Rectangle) []byte {
	size := xgb.Pad((12 + xgb.Pad((len(Rectangles) * 8))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 70 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	b += RectangleListBytes(buf[b:], Rectangles)

	return buf
}

// Request PolyFillArc
// size: xgb.Pad((12 + xgb.Pad((len(Arcs) * 12))))
type PolyFillArcCookie struct {
	*xgb.Cookie
}

// Write request to wire for PolyFillArc
func PolyFillArc(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Arcs []Arc) PolyFillArcCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(polyFillArcRequest(c, Drawable, Gc, Arcs), cookie)
	return PolyFillArcCookie{cookie}
}

func PolyFillArcChecked(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Arcs []Arc) PolyFillArcCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(polyFillArcRequest(c, Drawable, Gc, Arcs), cookie)
	return PolyFillArcCookie{cookie}
}

func (cook PolyFillArcCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for PolyFillArc
func polyFillArcRequest(c *xgb.Conn, Drawable Drawable, Gc Gcontext, Arcs []Arc) []byte {
	size := xgb.Pad((12 + xgb.Pad((len(Arcs) * 12))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 71 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	b += ArcListBytes(buf[b:], Arcs)

	return buf
}

// Request PutImage
// size: xgb.Pad((24 + xgb.Pad((len(Data) * 1))))
type PutImageCookie struct {
	*xgb.Cookie
}

// Write request to wire for PutImage
func PutImage(c *xgb.Conn, Format byte, Drawable Drawable, Gc Gcontext, Width uint16, Height uint16, DstX int16, DstY int16, LeftPad byte, Depth byte, Data []byte) PutImageCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(putImageRequest(c, Format, Drawable, Gc, Width, Height, DstX, DstY, LeftPad, Depth, Data), cookie)
	return PutImageCookie{cookie}
}

func PutImageChecked(c *xgb.Conn, Format byte, Drawable Drawable, Gc Gcontext, Width uint16, Height uint16, DstX int16, DstY int16, LeftPad byte, Depth byte, Data []byte) PutImageCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(putImageRequest(c, Format, Drawable, Gc, Width, Height, DstX, DstY, LeftPad, Depth, Data), cookie)
	return PutImageCookie{cookie}
}

func (cook PutImageCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for PutImage
func putImageRequest(c *xgb.Conn, Format byte, Drawable Drawable, Gc Gcontext, Width uint16, Height uint16, DstX int16, DstY int16, LeftPad byte, Depth byte, Data []byte) []byte {
	size := xgb.Pad((24 + xgb.Pad((len(Data) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 72 // request opcode
	b += 1

	buf[b] = Format
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	xgb.Put16(buf[b:], uint16(DstX))
	b += 2

	xgb.Put16(buf[b:], uint16(DstY))
	b += 2

	buf[b] = LeftPad
	b += 1

	buf[b] = Depth
	b += 1

	b += 2 // padding

	copy(buf[b:], Data[:len(Data)])
	b += xgb.Pad(int(len(Data)))

	return buf
}

// Request GetImage
// size: 20
type GetImageCookie struct {
	*xgb.Cookie
}

func GetImage(c *xgb.Conn, Format byte, Drawable Drawable, X int16, Y int16, Width uint16, Height uint16, PlaneMask uint32) GetImageCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getImageRequest(c, Format, Drawable, X, Y, Width, Height, PlaneMask), cookie)
	return GetImageCookie{cookie}
}

func GetImageUnchecked(c *xgb.Conn, Format byte, Drawable Drawable, X int16, Y int16, Width uint16, Height uint16, PlaneMask uint32) GetImageCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getImageRequest(c, Format, Drawable, X, Y, Width, Height, PlaneMask), cookie)
	return GetImageCookie{cookie}
}

// Request reply for GetImage
// size: (32 + xgb.Pad(((int(Length) * 4) * 1)))
type GetImageReply struct {
	Sequence uint16
	Length   uint32
	Depth    byte
	Visual   Visualid
	// padding: 20 bytes
	Data []byte // size: xgb.Pad(((int(Length) * 4) * 1))
}

// Waits and reads reply data from request GetImage
func (cook GetImageCookie) Reply() (*GetImageReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getImageReply(buf), nil
}

// Read reply into structure from buffer for GetImage
func getImageReply(buf []byte) *GetImageReply {
	v := new(GetImageReply)
	b := 1 // skip reply determinant

	v.Depth = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Visual = Visualid(xgb.Get32(buf[b:]))
	b += 4

	b += 20 // padding

	v.Data = make([]byte, (int(v.Length) * 4))
	copy(v.Data[:(int(v.Length)*4)], buf[b:])
	b += xgb.Pad(int((int(v.Length) * 4)))

	return v
}

// Write request to wire for GetImage
func getImageRequest(c *xgb.Conn, Format byte, Drawable Drawable, X int16, Y int16, Width uint16, Height uint16, PlaneMask uint32) []byte {
	size := 20
	b := 0
	buf := make([]byte, size)

	buf[b] = 73 // request opcode
	b += 1

	buf[b] = Format
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put16(buf[b:], uint16(X))
	b += 2

	xgb.Put16(buf[b:], uint16(Y))
	b += 2

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	xgb.Put32(buf[b:], PlaneMask)
	b += 4

	return buf
}

// Request PolyText8
// size: xgb.Pad((16 + xgb.Pad((len(Items) * 1))))
type PolyText8Cookie struct {
	*xgb.Cookie
}

// Write request to wire for PolyText8
func PolyText8(c *xgb.Conn, Drawable Drawable, Gc Gcontext, X int16, Y int16, Items []byte) PolyText8Cookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(polyText8Request(c, Drawable, Gc, X, Y, Items), cookie)
	return PolyText8Cookie{cookie}
}

func PolyText8Checked(c *xgb.Conn, Drawable Drawable, Gc Gcontext, X int16, Y int16, Items []byte) PolyText8Cookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(polyText8Request(c, Drawable, Gc, X, Y, Items), cookie)
	return PolyText8Cookie{cookie}
}

func (cook PolyText8Cookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for PolyText8
func polyText8Request(c *xgb.Conn, Drawable Drawable, Gc Gcontext, X int16, Y int16, Items []byte) []byte {
	size := xgb.Pad((16 + xgb.Pad((len(Items) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 74 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put16(buf[b:], uint16(X))
	b += 2

	xgb.Put16(buf[b:], uint16(Y))
	b += 2

	copy(buf[b:], Items[:len(Items)])
	b += xgb.Pad(int(len(Items)))

	return buf
}

// Request PolyText16
// size: xgb.Pad((16 + xgb.Pad((len(Items) * 1))))
type PolyText16Cookie struct {
	*xgb.Cookie
}

// Write request to wire for PolyText16
func PolyText16(c *xgb.Conn, Drawable Drawable, Gc Gcontext, X int16, Y int16, Items []byte) PolyText16Cookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(polyText16Request(c, Drawable, Gc, X, Y, Items), cookie)
	return PolyText16Cookie{cookie}
}

func PolyText16Checked(c *xgb.Conn, Drawable Drawable, Gc Gcontext, X int16, Y int16, Items []byte) PolyText16Cookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(polyText16Request(c, Drawable, Gc, X, Y, Items), cookie)
	return PolyText16Cookie{cookie}
}

func (cook PolyText16Cookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for PolyText16
func polyText16Request(c *xgb.Conn, Drawable Drawable, Gc Gcontext, X int16, Y int16, Items []byte) []byte {
	size := xgb.Pad((16 + xgb.Pad((len(Items) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 75 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put16(buf[b:], uint16(X))
	b += 2

	xgb.Put16(buf[b:], uint16(Y))
	b += 2

	copy(buf[b:], Items[:len(Items)])
	b += xgb.Pad(int(len(Items)))

	return buf
}

// Request ImageText8
// size: xgb.Pad((16 + xgb.Pad((int(StringLen) * 1))))
type ImageText8Cookie struct {
	*xgb.Cookie
}

// Write request to wire for ImageText8
func ImageText8(c *xgb.Conn, StringLen byte, Drawable Drawable, Gc Gcontext, X int16, Y int16, String string) ImageText8Cookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(imageText8Request(c, StringLen, Drawable, Gc, X, Y, String), cookie)
	return ImageText8Cookie{cookie}
}

func ImageText8Checked(c *xgb.Conn, StringLen byte, Drawable Drawable, Gc Gcontext, X int16, Y int16, String string) ImageText8Cookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(imageText8Request(c, StringLen, Drawable, Gc, X, Y, String), cookie)
	return ImageText8Cookie{cookie}
}

func (cook ImageText8Cookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ImageText8
func imageText8Request(c *xgb.Conn, StringLen byte, Drawable Drawable, Gc Gcontext, X int16, Y int16, String string) []byte {
	size := xgb.Pad((16 + xgb.Pad((int(StringLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 76 // request opcode
	b += 1

	buf[b] = StringLen
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put16(buf[b:], uint16(X))
	b += 2

	xgb.Put16(buf[b:], uint16(Y))
	b += 2

	copy(buf[b:], String[:StringLen])
	b += xgb.Pad(int(StringLen))

	return buf
}

// Request ImageText16
// size: xgb.Pad((16 + xgb.Pad((int(StringLen) * 2))))
type ImageText16Cookie struct {
	*xgb.Cookie
}

// Write request to wire for ImageText16
func ImageText16(c *xgb.Conn, StringLen byte, Drawable Drawable, Gc Gcontext, X int16, Y int16, String []Char2b) ImageText16Cookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(imageText16Request(c, StringLen, Drawable, Gc, X, Y, String), cookie)
	return ImageText16Cookie{cookie}
}

func ImageText16Checked(c *xgb.Conn, StringLen byte, Drawable Drawable, Gc Gcontext, X int16, Y int16, String []Char2b) ImageText16Cookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(imageText16Request(c, StringLen, Drawable, Gc, X, Y, String), cookie)
	return ImageText16Cookie{cookie}
}

func (cook ImageText16Cookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ImageText16
func imageText16Request(c *xgb.Conn, StringLen byte, Drawable Drawable, Gc Gcontext, X int16, Y int16, String []Char2b) []byte {
	size := xgb.Pad((16 + xgb.Pad((int(StringLen) * 2))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 77 // request opcode
	b += 1

	buf[b] = StringLen
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Gc))
	b += 4

	xgb.Put16(buf[b:], uint16(X))
	b += 2

	xgb.Put16(buf[b:], uint16(Y))
	b += 2

	b += Char2bListBytes(buf[b:], String)

	return buf
}

// Request CreateColormap
// size: 16
type CreateColormapCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateColormap
func CreateColormap(c *xgb.Conn, Alloc byte, Mid Colormap, Window Window, Visual Visualid) CreateColormapCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createColormapRequest(c, Alloc, Mid, Window, Visual), cookie)
	return CreateColormapCookie{cookie}
}

func CreateColormapChecked(c *xgb.Conn, Alloc byte, Mid Colormap, Window Window, Visual Visualid) CreateColormapCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createColormapRequest(c, Alloc, Mid, Window, Visual), cookie)
	return CreateColormapCookie{cookie}
}

func (cook CreateColormapCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateColormap
func createColormapRequest(c *xgb.Conn, Alloc byte, Mid Colormap, Window Window, Visual Visualid) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = 78 // request opcode
	b += 1

	buf[b] = Alloc
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Mid))
	b += 4

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put32(buf[b:], uint32(Visual))
	b += 4

	return buf
}

// Request FreeColormap
// size: 8
type FreeColormapCookie struct {
	*xgb.Cookie
}

// Write request to wire for FreeColormap
func FreeColormap(c *xgb.Conn, Cmap Colormap) FreeColormapCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(freeColormapRequest(c, Cmap), cookie)
	return FreeColormapCookie{cookie}
}

func FreeColormapChecked(c *xgb.Conn, Cmap Colormap) FreeColormapCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(freeColormapRequest(c, Cmap), cookie)
	return FreeColormapCookie{cookie}
}

func (cook FreeColormapCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for FreeColormap
func freeColormapRequest(c *xgb.Conn, Cmap Colormap) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 79 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cmap))
	b += 4

	return buf
}

// Request CopyColormapAndFree
// size: 12
type CopyColormapAndFreeCookie struct {
	*xgb.Cookie
}

// Write request to wire for CopyColormapAndFree
func CopyColormapAndFree(c *xgb.Conn, Mid Colormap, SrcCmap Colormap) CopyColormapAndFreeCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(copyColormapAndFreeRequest(c, Mid, SrcCmap), cookie)
	return CopyColormapAndFreeCookie{cookie}
}

func CopyColormapAndFreeChecked(c *xgb.Conn, Mid Colormap, SrcCmap Colormap) CopyColormapAndFreeCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(copyColormapAndFreeRequest(c, Mid, SrcCmap), cookie)
	return CopyColormapAndFreeCookie{cookie}
}

func (cook CopyColormapAndFreeCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CopyColormapAndFree
func copyColormapAndFreeRequest(c *xgb.Conn, Mid Colormap, SrcCmap Colormap) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = 80 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Mid))
	b += 4

	xgb.Put32(buf[b:], uint32(SrcCmap))
	b += 4

	return buf
}

// Request InstallColormap
// size: 8
type InstallColormapCookie struct {
	*xgb.Cookie
}

// Write request to wire for InstallColormap
func InstallColormap(c *xgb.Conn, Cmap Colormap) InstallColormapCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(installColormapRequest(c, Cmap), cookie)
	return InstallColormapCookie{cookie}
}

func InstallColormapChecked(c *xgb.Conn, Cmap Colormap) InstallColormapCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(installColormapRequest(c, Cmap), cookie)
	return InstallColormapCookie{cookie}
}

func (cook InstallColormapCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for InstallColormap
func installColormapRequest(c *xgb.Conn, Cmap Colormap) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 81 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cmap))
	b += 4

	return buf
}

// Request UninstallColormap
// size: 8
type UninstallColormapCookie struct {
	*xgb.Cookie
}

// Write request to wire for UninstallColormap
func UninstallColormap(c *xgb.Conn, Cmap Colormap) UninstallColormapCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(uninstallColormapRequest(c, Cmap), cookie)
	return UninstallColormapCookie{cookie}
}

func UninstallColormapChecked(c *xgb.Conn, Cmap Colormap) UninstallColormapCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(uninstallColormapRequest(c, Cmap), cookie)
	return UninstallColormapCookie{cookie}
}

func (cook UninstallColormapCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for UninstallColormap
func uninstallColormapRequest(c *xgb.Conn, Cmap Colormap) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 82 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cmap))
	b += 4

	return buf
}

// Request ListInstalledColormaps
// size: 8
type ListInstalledColormapsCookie struct {
	*xgb.Cookie
}

func ListInstalledColormaps(c *xgb.Conn, Window Window) ListInstalledColormapsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(listInstalledColormapsRequest(c, Window), cookie)
	return ListInstalledColormapsCookie{cookie}
}

func ListInstalledColormapsUnchecked(c *xgb.Conn, Window Window) ListInstalledColormapsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(listInstalledColormapsRequest(c, Window), cookie)
	return ListInstalledColormapsCookie{cookie}
}

// Request reply for ListInstalledColormaps
// size: (32 + xgb.Pad((int(CmapsLen) * 4)))
type ListInstalledColormapsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	CmapsLen uint16
	// padding: 22 bytes
	Cmaps []Colormap // size: xgb.Pad((int(CmapsLen) * 4))
}

// Waits and reads reply data from request ListInstalledColormaps
func (cook ListInstalledColormapsCookie) Reply() (*ListInstalledColormapsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listInstalledColormapsReply(buf), nil
}

// Read reply into structure from buffer for ListInstalledColormaps
func listInstalledColormapsReply(buf []byte) *ListInstalledColormapsReply {
	v := new(ListInstalledColormapsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.CmapsLen = xgb.Get16(buf[b:])
	b += 2

	b += 22 // padding

	v.Cmaps = make([]Colormap, v.CmapsLen)
	for i := 0; i < int(v.CmapsLen); i++ {
		v.Cmaps[i] = Colormap(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for ListInstalledColormaps
func listInstalledColormapsRequest(c *xgb.Conn, Window Window) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 83 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	return buf
}

// Request AllocColor
// size: 16
type AllocColorCookie struct {
	*xgb.Cookie
}

func AllocColor(c *xgb.Conn, Cmap Colormap, Red uint16, Green uint16, Blue uint16) AllocColorCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(allocColorRequest(c, Cmap, Red, Green, Blue), cookie)
	return AllocColorCookie{cookie}
}

func AllocColorUnchecked(c *xgb.Conn, Cmap Colormap, Red uint16, Green uint16, Blue uint16) AllocColorCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(allocColorRequest(c, Cmap, Red, Green, Blue), cookie)
	return AllocColorCookie{cookie}
}

// Request reply for AllocColor
// size: 20
type AllocColorReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Red   uint16
	Green uint16
	Blue  uint16
	// padding: 2 bytes
	Pixel uint32
}

// Waits and reads reply data from request AllocColor
func (cook AllocColorCookie) Reply() (*AllocColorReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return allocColorReply(buf), nil
}

// Read reply into structure from buffer for AllocColor
func allocColorReply(buf []byte) *AllocColorReply {
	v := new(AllocColorReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Red = xgb.Get16(buf[b:])
	b += 2

	v.Green = xgb.Get16(buf[b:])
	b += 2

	v.Blue = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.Pixel = xgb.Get32(buf[b:])
	b += 4

	return v
}

// Write request to wire for AllocColor
func allocColorRequest(c *xgb.Conn, Cmap Colormap, Red uint16, Green uint16, Blue uint16) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = 84 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cmap))
	b += 4

	xgb.Put16(buf[b:], Red)
	b += 2

	xgb.Put16(buf[b:], Green)
	b += 2

	xgb.Put16(buf[b:], Blue)
	b += 2

	b += 2 // padding

	return buf
}

// Request AllocNamedColor
// size: xgb.Pad((12 + xgb.Pad((int(NameLen) * 1))))
type AllocNamedColorCookie struct {
	*xgb.Cookie
}

func AllocNamedColor(c *xgb.Conn, Cmap Colormap, NameLen uint16, Name string) AllocNamedColorCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(allocNamedColorRequest(c, Cmap, NameLen, Name), cookie)
	return AllocNamedColorCookie{cookie}
}

func AllocNamedColorUnchecked(c *xgb.Conn, Cmap Colormap, NameLen uint16, Name string) AllocNamedColorCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(allocNamedColorRequest(c, Cmap, NameLen, Name), cookie)
	return AllocNamedColorCookie{cookie}
}

// Request reply for AllocNamedColor
// size: 24
type AllocNamedColorReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Pixel       uint32
	ExactRed    uint16
	ExactGreen  uint16
	ExactBlue   uint16
	VisualRed   uint16
	VisualGreen uint16
	VisualBlue  uint16
}

// Waits and reads reply data from request AllocNamedColor
func (cook AllocNamedColorCookie) Reply() (*AllocNamedColorReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return allocNamedColorReply(buf), nil
}

// Read reply into structure from buffer for AllocNamedColor
func allocNamedColorReply(buf []byte) *AllocNamedColorReply {
	v := new(AllocNamedColorReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Pixel = xgb.Get32(buf[b:])
	b += 4

	v.ExactRed = xgb.Get16(buf[b:])
	b += 2

	v.ExactGreen = xgb.Get16(buf[b:])
	b += 2

	v.ExactBlue = xgb.Get16(buf[b:])
	b += 2

	v.VisualRed = xgb.Get16(buf[b:])
	b += 2

	v.VisualGreen = xgb.Get16(buf[b:])
	b += 2

	v.VisualBlue = xgb.Get16(buf[b:])
	b += 2

	return v
}

// Write request to wire for AllocNamedColor
func allocNamedColorRequest(c *xgb.Conn, Cmap Colormap, NameLen uint16, Name string) []byte {
	size := xgb.Pad((12 + xgb.Pad((int(NameLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 85 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cmap))
	b += 4

	xgb.Put16(buf[b:], NameLen)
	b += 2

	b += 2 // padding

	copy(buf[b:], Name[:NameLen])
	b += xgb.Pad(int(NameLen))

	return buf
}

// Request AllocColorCells
// size: 12
type AllocColorCellsCookie struct {
	*xgb.Cookie
}

func AllocColorCells(c *xgb.Conn, Contiguous bool, Cmap Colormap, Colors uint16, Planes uint16) AllocColorCellsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(allocColorCellsRequest(c, Contiguous, Cmap, Colors, Planes), cookie)
	return AllocColorCellsCookie{cookie}
}

func AllocColorCellsUnchecked(c *xgb.Conn, Contiguous bool, Cmap Colormap, Colors uint16, Planes uint16) AllocColorCellsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(allocColorCellsRequest(c, Contiguous, Cmap, Colors, Planes), cookie)
	return AllocColorCellsCookie{cookie}
}

// Request reply for AllocColorCells
// size: ((32 + xgb.Pad((int(PixelsLen) * 4))) + xgb.Pad((int(MasksLen) * 4)))
type AllocColorCellsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	PixelsLen uint16
	MasksLen  uint16
	// padding: 20 bytes
	Pixels []uint32 // size: xgb.Pad((int(PixelsLen) * 4))
	Masks  []uint32 // size: xgb.Pad((int(MasksLen) * 4))
}

// Waits and reads reply data from request AllocColorCells
func (cook AllocColorCellsCookie) Reply() (*AllocColorCellsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return allocColorCellsReply(buf), nil
}

// Read reply into structure from buffer for AllocColorCells
func allocColorCellsReply(buf []byte) *AllocColorCellsReply {
	v := new(AllocColorCellsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.PixelsLen = xgb.Get16(buf[b:])
	b += 2

	v.MasksLen = xgb.Get16(buf[b:])
	b += 2

	b += 20 // padding

	v.Pixels = make([]uint32, v.PixelsLen)
	for i := 0; i < int(v.PixelsLen); i++ {
		v.Pixels[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	v.Masks = make([]uint32, v.MasksLen)
	for i := 0; i < int(v.MasksLen); i++ {
		v.Masks[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for AllocColorCells
func allocColorCellsRequest(c *xgb.Conn, Contiguous bool, Cmap Colormap, Colors uint16, Planes uint16) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = 86 // request opcode
	b += 1

	if Contiguous {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cmap))
	b += 4

	xgb.Put16(buf[b:], Colors)
	b += 2

	xgb.Put16(buf[b:], Planes)
	b += 2

	return buf
}

// Request AllocColorPlanes
// size: 16
type AllocColorPlanesCookie struct {
	*xgb.Cookie
}

func AllocColorPlanes(c *xgb.Conn, Contiguous bool, Cmap Colormap, Colors uint16, Reds uint16, Greens uint16, Blues uint16) AllocColorPlanesCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(allocColorPlanesRequest(c, Contiguous, Cmap, Colors, Reds, Greens, Blues), cookie)
	return AllocColorPlanesCookie{cookie}
}

func AllocColorPlanesUnchecked(c *xgb.Conn, Contiguous bool, Cmap Colormap, Colors uint16, Reds uint16, Greens uint16, Blues uint16) AllocColorPlanesCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(allocColorPlanesRequest(c, Contiguous, Cmap, Colors, Reds, Greens, Blues), cookie)
	return AllocColorPlanesCookie{cookie}
}

// Request reply for AllocColorPlanes
// size: (32 + xgb.Pad((int(PixelsLen) * 4)))
type AllocColorPlanesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	PixelsLen uint16
	// padding: 2 bytes
	RedMask   uint32
	GreenMask uint32
	BlueMask  uint32
	// padding: 8 bytes
	Pixels []uint32 // size: xgb.Pad((int(PixelsLen) * 4))
}

// Waits and reads reply data from request AllocColorPlanes
func (cook AllocColorPlanesCookie) Reply() (*AllocColorPlanesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return allocColorPlanesReply(buf), nil
}

// Read reply into structure from buffer for AllocColorPlanes
func allocColorPlanesReply(buf []byte) *AllocColorPlanesReply {
	v := new(AllocColorPlanesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.PixelsLen = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.RedMask = xgb.Get32(buf[b:])
	b += 4

	v.GreenMask = xgb.Get32(buf[b:])
	b += 4

	v.BlueMask = xgb.Get32(buf[b:])
	b += 4

	b += 8 // padding

	v.Pixels = make([]uint32, v.PixelsLen)
	for i := 0; i < int(v.PixelsLen); i++ {
		v.Pixels[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for AllocColorPlanes
func allocColorPlanesRequest(c *xgb.Conn, Contiguous bool, Cmap Colormap, Colors uint16, Reds uint16, Greens uint16, Blues uint16) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = 87 // request opcode
	b += 1

	if Contiguous {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cmap))
	b += 4

	xgb.Put16(buf[b:], Colors)
	b += 2

	xgb.Put16(buf[b:], Reds)
	b += 2

	xgb.Put16(buf[b:], Greens)
	b += 2

	xgb.Put16(buf[b:], Blues)
	b += 2

	return buf
}

// Request FreeColors
// size: xgb.Pad((12 + xgb.Pad((len(Pixels) * 4))))
type FreeColorsCookie struct {
	*xgb.Cookie
}

// Write request to wire for FreeColors
func FreeColors(c *xgb.Conn, Cmap Colormap, PlaneMask uint32, Pixels []uint32) FreeColorsCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(freeColorsRequest(c, Cmap, PlaneMask, Pixels), cookie)
	return FreeColorsCookie{cookie}
}

func FreeColorsChecked(c *xgb.Conn, Cmap Colormap, PlaneMask uint32, Pixels []uint32) FreeColorsCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(freeColorsRequest(c, Cmap, PlaneMask, Pixels), cookie)
	return FreeColorsCookie{cookie}
}

func (cook FreeColorsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for FreeColors
func freeColorsRequest(c *xgb.Conn, Cmap Colormap, PlaneMask uint32, Pixels []uint32) []byte {
	size := xgb.Pad((12 + xgb.Pad((len(Pixels) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 88 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cmap))
	b += 4

	xgb.Put32(buf[b:], PlaneMask)
	b += 4

	for i := 0; i < int(len(Pixels)); i++ {
		xgb.Put32(buf[b:], Pixels[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request StoreColors
// size: xgb.Pad((8 + xgb.Pad((len(Items) * 12))))
type StoreColorsCookie struct {
	*xgb.Cookie
}

// Write request to wire for StoreColors
func StoreColors(c *xgb.Conn, Cmap Colormap, Items []Coloritem) StoreColorsCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(storeColorsRequest(c, Cmap, Items), cookie)
	return StoreColorsCookie{cookie}
}

func StoreColorsChecked(c *xgb.Conn, Cmap Colormap, Items []Coloritem) StoreColorsCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(storeColorsRequest(c, Cmap, Items), cookie)
	return StoreColorsCookie{cookie}
}

func (cook StoreColorsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for StoreColors
func storeColorsRequest(c *xgb.Conn, Cmap Colormap, Items []Coloritem) []byte {
	size := xgb.Pad((8 + xgb.Pad((len(Items) * 12))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 89 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cmap))
	b += 4

	b += ColoritemListBytes(buf[b:], Items)

	return buf
}

// Request StoreNamedColor
// size: xgb.Pad((16 + xgb.Pad((int(NameLen) * 1))))
type StoreNamedColorCookie struct {
	*xgb.Cookie
}

// Write request to wire for StoreNamedColor
func StoreNamedColor(c *xgb.Conn, Flags byte, Cmap Colormap, Pixel uint32, NameLen uint16, Name string) StoreNamedColorCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(storeNamedColorRequest(c, Flags, Cmap, Pixel, NameLen, Name), cookie)
	return StoreNamedColorCookie{cookie}
}

func StoreNamedColorChecked(c *xgb.Conn, Flags byte, Cmap Colormap, Pixel uint32, NameLen uint16, Name string) StoreNamedColorCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(storeNamedColorRequest(c, Flags, Cmap, Pixel, NameLen, Name), cookie)
	return StoreNamedColorCookie{cookie}
}

func (cook StoreNamedColorCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for StoreNamedColor
func storeNamedColorRequest(c *xgb.Conn, Flags byte, Cmap Colormap, Pixel uint32, NameLen uint16, Name string) []byte {
	size := xgb.Pad((16 + xgb.Pad((int(NameLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 90 // request opcode
	b += 1

	buf[b] = Flags
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cmap))
	b += 4

	xgb.Put32(buf[b:], Pixel)
	b += 4

	xgb.Put16(buf[b:], NameLen)
	b += 2

	b += 2 // padding

	copy(buf[b:], Name[:NameLen])
	b += xgb.Pad(int(NameLen))

	return buf
}

// Request QueryColors
// size: xgb.Pad((8 + xgb.Pad((len(Pixels) * 4))))
type QueryColorsCookie struct {
	*xgb.Cookie
}

func QueryColors(c *xgb.Conn, Cmap Colormap, Pixels []uint32) QueryColorsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryColorsRequest(c, Cmap, Pixels), cookie)
	return QueryColorsCookie{cookie}
}

func QueryColorsUnchecked(c *xgb.Conn, Cmap Colormap, Pixels []uint32) QueryColorsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryColorsRequest(c, Cmap, Pixels), cookie)
	return QueryColorsCookie{cookie}
}

// Request reply for QueryColors
// size: (32 + xgb.Pad((int(ColorsLen) * 8)))
type QueryColorsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ColorsLen uint16
	// padding: 22 bytes
	Colors []Rgb // size: xgb.Pad((int(ColorsLen) * 8))
}

// Waits and reads reply data from request QueryColors
func (cook QueryColorsCookie) Reply() (*QueryColorsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryColorsReply(buf), nil
}

// Read reply into structure from buffer for QueryColors
func queryColorsReply(buf []byte) *QueryColorsReply {
	v := new(QueryColorsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ColorsLen = xgb.Get16(buf[b:])
	b += 2

	b += 22 // padding

	v.Colors = make([]Rgb, v.ColorsLen)
	b += RgbReadList(buf[b:], v.Colors)

	return v
}

// Write request to wire for QueryColors
func queryColorsRequest(c *xgb.Conn, Cmap Colormap, Pixels []uint32) []byte {
	size := xgb.Pad((8 + xgb.Pad((len(Pixels) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 91 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cmap))
	b += 4

	for i := 0; i < int(len(Pixels)); i++ {
		xgb.Put32(buf[b:], Pixels[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request LookupColor
// size: xgb.Pad((12 + xgb.Pad((int(NameLen) * 1))))
type LookupColorCookie struct {
	*xgb.Cookie
}

func LookupColor(c *xgb.Conn, Cmap Colormap, NameLen uint16, Name string) LookupColorCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(lookupColorRequest(c, Cmap, NameLen, Name), cookie)
	return LookupColorCookie{cookie}
}

func LookupColorUnchecked(c *xgb.Conn, Cmap Colormap, NameLen uint16, Name string) LookupColorCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(lookupColorRequest(c, Cmap, NameLen, Name), cookie)
	return LookupColorCookie{cookie}
}

// Request reply for LookupColor
// size: 20
type LookupColorReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	ExactRed    uint16
	ExactGreen  uint16
	ExactBlue   uint16
	VisualRed   uint16
	VisualGreen uint16
	VisualBlue  uint16
}

// Waits and reads reply data from request LookupColor
func (cook LookupColorCookie) Reply() (*LookupColorReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return lookupColorReply(buf), nil
}

// Read reply into structure from buffer for LookupColor
func lookupColorReply(buf []byte) *LookupColorReply {
	v := new(LookupColorReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.ExactRed = xgb.Get16(buf[b:])
	b += 2

	v.ExactGreen = xgb.Get16(buf[b:])
	b += 2

	v.ExactBlue = xgb.Get16(buf[b:])
	b += 2

	v.VisualRed = xgb.Get16(buf[b:])
	b += 2

	v.VisualGreen = xgb.Get16(buf[b:])
	b += 2

	v.VisualBlue = xgb.Get16(buf[b:])
	b += 2

	return v
}

// Write request to wire for LookupColor
func lookupColorRequest(c *xgb.Conn, Cmap Colormap, NameLen uint16, Name string) []byte {
	size := xgb.Pad((12 + xgb.Pad((int(NameLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 92 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cmap))
	b += 4

	xgb.Put16(buf[b:], NameLen)
	b += 2

	b += 2 // padding

	copy(buf[b:], Name[:NameLen])
	b += xgb.Pad(int(NameLen))

	return buf
}

// Request CreateCursor
// size: 32
type CreateCursorCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateCursor
func CreateCursor(c *xgb.Conn, Cid Cursor, Source Pixmap, Mask Pixmap, ForeRed uint16, ForeGreen uint16, ForeBlue uint16, BackRed uint16, BackGreen uint16, BackBlue uint16, X uint16, Y uint16) CreateCursorCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createCursorRequest(c, Cid, Source, Mask, ForeRed, ForeGreen, ForeBlue, BackRed, BackGreen, BackBlue, X, Y), cookie)
	return CreateCursorCookie{cookie}
}

func CreateCursorChecked(c *xgb.Conn, Cid Cursor, Source Pixmap, Mask Pixmap, ForeRed uint16, ForeGreen uint16, ForeBlue uint16, BackRed uint16, BackGreen uint16, BackBlue uint16, X uint16, Y uint16) CreateCursorCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createCursorRequest(c, Cid, Source, Mask, ForeRed, ForeGreen, ForeBlue, BackRed, BackGreen, BackBlue, X, Y), cookie)
	return CreateCursorCookie{cookie}
}

func (cook CreateCursorCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateCursor
func createCursorRequest(c *xgb.Conn, Cid Cursor, Source Pixmap, Mask Pixmap, ForeRed uint16, ForeGreen uint16, ForeBlue uint16, BackRed uint16, BackGreen uint16, BackBlue uint16, X uint16, Y uint16) []byte {
	size := 32
	b := 0
	buf := make([]byte, size)

	buf[b] = 93 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cid))
	b += 4

	xgb.Put32(buf[b:], uint32(Source))
	b += 4

	xgb.Put32(buf[b:], uint32(Mask))
	b += 4

	xgb.Put16(buf[b:], ForeRed)
	b += 2

	xgb.Put16(buf[b:], ForeGreen)
	b += 2

	xgb.Put16(buf[b:], ForeBlue)
	b += 2

	xgb.Put16(buf[b:], BackRed)
	b += 2

	xgb.Put16(buf[b:], BackGreen)
	b += 2

	xgb.Put16(buf[b:], BackBlue)
	b += 2

	xgb.Put16(buf[b:], X)
	b += 2

	xgb.Put16(buf[b:], Y)
	b += 2

	return buf
}

// Request CreateGlyphCursor
// size: 32
type CreateGlyphCursorCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateGlyphCursor
func CreateGlyphCursor(c *xgb.Conn, Cid Cursor, SourceFont Font, MaskFont Font, SourceChar uint16, MaskChar uint16, ForeRed uint16, ForeGreen uint16, ForeBlue uint16, BackRed uint16, BackGreen uint16, BackBlue uint16) CreateGlyphCursorCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createGlyphCursorRequest(c, Cid, SourceFont, MaskFont, SourceChar, MaskChar, ForeRed, ForeGreen, ForeBlue, BackRed, BackGreen, BackBlue), cookie)
	return CreateGlyphCursorCookie{cookie}
}

func CreateGlyphCursorChecked(c *xgb.Conn, Cid Cursor, SourceFont Font, MaskFont Font, SourceChar uint16, MaskChar uint16, ForeRed uint16, ForeGreen uint16, ForeBlue uint16, BackRed uint16, BackGreen uint16, BackBlue uint16) CreateGlyphCursorCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createGlyphCursorRequest(c, Cid, SourceFont, MaskFont, SourceChar, MaskChar, ForeRed, ForeGreen, ForeBlue, BackRed, BackGreen, BackBlue), cookie)
	return CreateGlyphCursorCookie{cookie}
}

func (cook CreateGlyphCursorCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateGlyphCursor
func createGlyphCursorRequest(c *xgb.Conn, Cid Cursor, SourceFont Font, MaskFont Font, SourceChar uint16, MaskChar uint16, ForeRed uint16, ForeGreen uint16, ForeBlue uint16, BackRed uint16, BackGreen uint16, BackBlue uint16) []byte {
	size := 32
	b := 0
	buf := make([]byte, size)

	buf[b] = 94 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cid))
	b += 4

	xgb.Put32(buf[b:], uint32(SourceFont))
	b += 4

	xgb.Put32(buf[b:], uint32(MaskFont))
	b += 4

	xgb.Put16(buf[b:], SourceChar)
	b += 2

	xgb.Put16(buf[b:], MaskChar)
	b += 2

	xgb.Put16(buf[b:], ForeRed)
	b += 2

	xgb.Put16(buf[b:], ForeGreen)
	b += 2

	xgb.Put16(buf[b:], ForeBlue)
	b += 2

	xgb.Put16(buf[b:], BackRed)
	b += 2

	xgb.Put16(buf[b:], BackGreen)
	b += 2

	xgb.Put16(buf[b:], BackBlue)
	b += 2

	return buf
}

// Request FreeCursor
// size: 8
type FreeCursorCookie struct {
	*xgb.Cookie
}

// Write request to wire for FreeCursor
func FreeCursor(c *xgb.Conn, Cursor Cursor) FreeCursorCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(freeCursorRequest(c, Cursor), cookie)
	return FreeCursorCookie{cookie}
}

func FreeCursorChecked(c *xgb.Conn, Cursor Cursor) FreeCursorCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(freeCursorRequest(c, Cursor), cookie)
	return FreeCursorCookie{cookie}
}

func (cook FreeCursorCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for FreeCursor
func freeCursorRequest(c *xgb.Conn, Cursor Cursor) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 95 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cursor))
	b += 4

	return buf
}

// Request RecolorCursor
// size: 20
type RecolorCursorCookie struct {
	*xgb.Cookie
}

// Write request to wire for RecolorCursor
func RecolorCursor(c *xgb.Conn, Cursor Cursor, ForeRed uint16, ForeGreen uint16, ForeBlue uint16, BackRed uint16, BackGreen uint16, BackBlue uint16) RecolorCursorCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(recolorCursorRequest(c, Cursor, ForeRed, ForeGreen, ForeBlue, BackRed, BackGreen, BackBlue), cookie)
	return RecolorCursorCookie{cookie}
}

func RecolorCursorChecked(c *xgb.Conn, Cursor Cursor, ForeRed uint16, ForeGreen uint16, ForeBlue uint16, BackRed uint16, BackGreen uint16, BackBlue uint16) RecolorCursorCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(recolorCursorRequest(c, Cursor, ForeRed, ForeGreen, ForeBlue, BackRed, BackGreen, BackBlue), cookie)
	return RecolorCursorCookie{cookie}
}

func (cook RecolorCursorCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for RecolorCursor
func recolorCursorRequest(c *xgb.Conn, Cursor Cursor, ForeRed uint16, ForeGreen uint16, ForeBlue uint16, BackRed uint16, BackGreen uint16, BackBlue uint16) []byte {
	size := 20
	b := 0
	buf := make([]byte, size)

	buf[b] = 96 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cursor))
	b += 4

	xgb.Put16(buf[b:], ForeRed)
	b += 2

	xgb.Put16(buf[b:], ForeGreen)
	b += 2

	xgb.Put16(buf[b:], ForeBlue)
	b += 2

	xgb.Put16(buf[b:], BackRed)
	b += 2

	xgb.Put16(buf[b:], BackGreen)
	b += 2

	xgb.Put16(buf[b:], BackBlue)
	b += 2

	return buf
}

// Request QueryBestSize
// size: 12
type QueryBestSizeCookie struct {
	*xgb.Cookie
}

func QueryBestSize(c *xgb.Conn, Class byte, Drawable Drawable, Width uint16, Height uint16) QueryBestSizeCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryBestSizeRequest(c, Class, Drawable, Width, Height), cookie)
	return QueryBestSizeCookie{cookie}
}

func QueryBestSizeUnchecked(c *xgb.Conn, Class byte, Drawable Drawable, Width uint16, Height uint16) QueryBestSizeCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryBestSizeRequest(c, Class, Drawable, Width, Height), cookie)
	return QueryBestSizeCookie{cookie}
}

// Request reply for QueryBestSize
// size: 12
type QueryBestSizeReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Width  uint16
	Height uint16
}

// Waits and reads reply data from request QueryBestSize
func (cook QueryBestSizeCookie) Reply() (*QueryBestSizeReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryBestSizeReply(buf), nil
}

// Read reply into structure from buffer for QueryBestSize
func queryBestSizeReply(buf []byte) *QueryBestSizeReply {
	v := new(QueryBestSizeReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	return v
}

// Write request to wire for QueryBestSize
func queryBestSizeRequest(c *xgb.Conn, Class byte, Drawable Drawable, Width uint16, Height uint16) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = 97 // request opcode
	b += 1

	buf[b] = Class
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	return buf
}

// Request QueryExtension
// size: xgb.Pad((8 + xgb.Pad((int(NameLen) * 1))))
type QueryExtensionCookie struct {
	*xgb.Cookie
}

func QueryExtension(c *xgb.Conn, NameLen uint16, Name string) QueryExtensionCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryExtensionRequest(c, NameLen, Name), cookie)
	return QueryExtensionCookie{cookie}
}

func QueryExtensionUnchecked(c *xgb.Conn, NameLen uint16, Name string) QueryExtensionCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryExtensionRequest(c, NameLen, Name), cookie)
	return QueryExtensionCookie{cookie}
}

// Request reply for QueryExtension
// size: 12
type QueryExtensionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Present     bool
	MajorOpcode byte
	FirstEvent  byte
	FirstError  byte
}

// Waits and reads reply data from request QueryExtension
func (cook QueryExtensionCookie) Reply() (*QueryExtensionReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryExtensionReply(buf), nil
}

// Read reply into structure from buffer for QueryExtension
func queryExtensionReply(buf []byte) *QueryExtensionReply {
	v := new(QueryExtensionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	if buf[b] == 1 {
		v.Present = true
	} else {
		v.Present = false
	}
	b += 1

	v.MajorOpcode = buf[b]
	b += 1

	v.FirstEvent = buf[b]
	b += 1

	v.FirstError = buf[b]
	b += 1

	return v
}

// Write request to wire for QueryExtension
func queryExtensionRequest(c *xgb.Conn, NameLen uint16, Name string) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(NameLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 98 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], NameLen)
	b += 2

	b += 2 // padding

	copy(buf[b:], Name[:NameLen])
	b += xgb.Pad(int(NameLen))

	return buf
}

// Request ListExtensions
// size: 4
type ListExtensionsCookie struct {
	*xgb.Cookie
}

func ListExtensions(c *xgb.Conn) ListExtensionsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(listExtensionsRequest(c), cookie)
	return ListExtensionsCookie{cookie}
}

func ListExtensionsUnchecked(c *xgb.Conn) ListExtensionsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(listExtensionsRequest(c), cookie)
	return ListExtensionsCookie{cookie}
}

// Request reply for ListExtensions
// size: (32 + StrListSize(Names))
type ListExtensionsReply struct {
	Sequence uint16
	Length   uint32
	NamesLen byte
	// padding: 24 bytes
	Names []Str // size: StrListSize(Names)
}

// Waits and reads reply data from request ListExtensions
func (cook ListExtensionsCookie) Reply() (*ListExtensionsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listExtensionsReply(buf), nil
}

// Read reply into structure from buffer for ListExtensions
func listExtensionsReply(buf []byte) *ListExtensionsReply {
	v := new(ListExtensionsReply)
	b := 1 // skip reply determinant

	v.NamesLen = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.Names = make([]Str, v.NamesLen)
	b += StrReadList(buf[b:], v.Names)

	return v
}

// Write request to wire for ListExtensions
func listExtensionsRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 99 // request opcode
	b += 1

	b += 1                             // padding
	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request ChangeKeyboardMapping
// size: xgb.Pad((8 + xgb.Pad(((int(KeycodeCount) * int(KeysymsPerKeycode)) * 4))))
type ChangeKeyboardMappingCookie struct {
	*xgb.Cookie
}

// Write request to wire for ChangeKeyboardMapping
func ChangeKeyboardMapping(c *xgb.Conn, KeycodeCount byte, FirstKeycode Keycode, KeysymsPerKeycode byte, Keysyms []Keysym) ChangeKeyboardMappingCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeKeyboardMappingRequest(c, KeycodeCount, FirstKeycode, KeysymsPerKeycode, Keysyms), cookie)
	return ChangeKeyboardMappingCookie{cookie}
}

func ChangeKeyboardMappingChecked(c *xgb.Conn, KeycodeCount byte, FirstKeycode Keycode, KeysymsPerKeycode byte, Keysyms []Keysym) ChangeKeyboardMappingCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeKeyboardMappingRequest(c, KeycodeCount, FirstKeycode, KeysymsPerKeycode, Keysyms), cookie)
	return ChangeKeyboardMappingCookie{cookie}
}

func (cook ChangeKeyboardMappingCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeKeyboardMapping
func changeKeyboardMappingRequest(c *xgb.Conn, KeycodeCount byte, FirstKeycode Keycode, KeysymsPerKeycode byte, Keysyms []Keysym) []byte {
	size := xgb.Pad((8 + xgb.Pad(((int(KeycodeCount) * int(KeysymsPerKeycode)) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 100 // request opcode
	b += 1

	buf[b] = KeycodeCount
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = byte(FirstKeycode)
	b += 1

	buf[b] = KeysymsPerKeycode
	b += 1

	b += 2 // padding

	for i := 0; i < int((int(KeycodeCount) * int(KeysymsPerKeycode))); i++ {
		xgb.Put32(buf[b:], uint32(Keysyms[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request GetKeyboardMapping
// size: 8
type GetKeyboardMappingCookie struct {
	*xgb.Cookie
}

func GetKeyboardMapping(c *xgb.Conn, FirstKeycode Keycode, Count byte) GetKeyboardMappingCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getKeyboardMappingRequest(c, FirstKeycode, Count), cookie)
	return GetKeyboardMappingCookie{cookie}
}

func GetKeyboardMappingUnchecked(c *xgb.Conn, FirstKeycode Keycode, Count byte) GetKeyboardMappingCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getKeyboardMappingRequest(c, FirstKeycode, Count), cookie)
	return GetKeyboardMappingCookie{cookie}
}

// Request reply for GetKeyboardMapping
// size: (32 + xgb.Pad((int(Length) * 4)))
type GetKeyboardMappingReply struct {
	Sequence          uint16
	Length            uint32
	KeysymsPerKeycode byte
	// padding: 24 bytes
	Keysyms []Keysym // size: xgb.Pad((int(Length) * 4))
}

// Waits and reads reply data from request GetKeyboardMapping
func (cook GetKeyboardMappingCookie) Reply() (*GetKeyboardMappingReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getKeyboardMappingReply(buf), nil
}

// Read reply into structure from buffer for GetKeyboardMapping
func getKeyboardMappingReply(buf []byte) *GetKeyboardMappingReply {
	v := new(GetKeyboardMappingReply)
	b := 1 // skip reply determinant

	v.KeysymsPerKeycode = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.Keysyms = make([]Keysym, v.Length)
	for i := 0; i < int(v.Length); i++ {
		v.Keysyms[i] = Keysym(xgb.Get32(buf[b:]))
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetKeyboardMapping
func getKeyboardMappingRequest(c *xgb.Conn, FirstKeycode Keycode, Count byte) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 101 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = byte(FirstKeycode)
	b += 1

	buf[b] = Count
	b += 1

	return buf
}

// Request ChangeKeyboardControl
// size: xgb.Pad((4 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
type ChangeKeyboardControlCookie struct {
	*xgb.Cookie
}

// Write request to wire for ChangeKeyboardControl
func ChangeKeyboardControl(c *xgb.Conn, ValueMask uint32, ValueList []uint32) ChangeKeyboardControlCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeKeyboardControlRequest(c, ValueMask, ValueList), cookie)
	return ChangeKeyboardControlCookie{cookie}
}

func ChangeKeyboardControlChecked(c *xgb.Conn, ValueMask uint32, ValueList []uint32) ChangeKeyboardControlCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeKeyboardControlRequest(c, ValueMask, ValueList), cookie)
	return ChangeKeyboardControlCookie{cookie}
}

func (cook ChangeKeyboardControlCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeKeyboardControl
func changeKeyboardControlRequest(c *xgb.Conn, ValueMask uint32, ValueList []uint32) []byte {
	size := xgb.Pad((4 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 102 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], ValueMask)
	b += 4
	for i := 0; i < xgb.PopCount(int(ValueMask)); i++ {
		xgb.Put32(buf[b:], ValueList[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request GetKeyboardControl
// size: 4
type GetKeyboardControlCookie struct {
	*xgb.Cookie
}

func GetKeyboardControl(c *xgb.Conn) GetKeyboardControlCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getKeyboardControlRequest(c), cookie)
	return GetKeyboardControlCookie{cookie}
}

func GetKeyboardControlUnchecked(c *xgb.Conn) GetKeyboardControlCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getKeyboardControlRequest(c), cookie)
	return GetKeyboardControlCookie{cookie}
}

// Request reply for GetKeyboardControl
// size: 52
type GetKeyboardControlReply struct {
	Sequence         uint16
	Length           uint32
	GlobalAutoRepeat byte
	LedMask          uint32
	KeyClickPercent  byte
	BellPercent      byte
	BellPitch        uint16
	BellDuration     uint16
	// padding: 2 bytes
	AutoRepeats []byte // size: 32
}

// Waits and reads reply data from request GetKeyboardControl
func (cook GetKeyboardControlCookie) Reply() (*GetKeyboardControlReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getKeyboardControlReply(buf), nil
}

// Read reply into structure from buffer for GetKeyboardControl
func getKeyboardControlReply(buf []byte) *GetKeyboardControlReply {
	v := new(GetKeyboardControlReply)
	b := 1 // skip reply determinant

	v.GlobalAutoRepeat = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.LedMask = xgb.Get32(buf[b:])
	b += 4

	v.KeyClickPercent = buf[b]
	b += 1

	v.BellPercent = buf[b]
	b += 1

	v.BellPitch = xgb.Get16(buf[b:])
	b += 2

	v.BellDuration = xgb.Get16(buf[b:])
	b += 2

	b += 2 // padding

	v.AutoRepeats = make([]byte, 32)
	copy(v.AutoRepeats[:32], buf[b:])
	b += xgb.Pad(int(32))

	return v
}

// Write request to wire for GetKeyboardControl
func getKeyboardControlRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 103 // request opcode
	b += 1

	b += 1                             // padding
	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request Bell
// size: 4
type BellCookie struct {
	*xgb.Cookie
}

// Write request to wire for Bell
func Bell(c *xgb.Conn, Percent int8) BellCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(bellRequest(c, Percent), cookie)
	return BellCookie{cookie}
}

func BellChecked(c *xgb.Conn, Percent int8) BellCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(bellRequest(c, Percent), cookie)
	return BellCookie{cookie}
}

func (cook BellCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for Bell
func bellRequest(c *xgb.Conn, Percent int8) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 104 // request opcode
	b += 1

	buf[b] = byte(Percent)
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request ChangePointerControl
// size: 12
type ChangePointerControlCookie struct {
	*xgb.Cookie
}

// Write request to wire for ChangePointerControl
func ChangePointerControl(c *xgb.Conn, AccelerationNumerator int16, AccelerationDenominator int16, Threshold int16, DoAcceleration bool, DoThreshold bool) ChangePointerControlCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(changePointerControlRequest(c, AccelerationNumerator, AccelerationDenominator, Threshold, DoAcceleration, DoThreshold), cookie)
	return ChangePointerControlCookie{cookie}
}

func ChangePointerControlChecked(c *xgb.Conn, AccelerationNumerator int16, AccelerationDenominator int16, Threshold int16, DoAcceleration bool, DoThreshold bool) ChangePointerControlCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(changePointerControlRequest(c, AccelerationNumerator, AccelerationDenominator, Threshold, DoAcceleration, DoThreshold), cookie)
	return ChangePointerControlCookie{cookie}
}

func (cook ChangePointerControlCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangePointerControl
func changePointerControlRequest(c *xgb.Conn, AccelerationNumerator int16, AccelerationDenominator int16, Threshold int16, DoAcceleration bool, DoThreshold bool) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = 105 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(AccelerationNumerator))
	b += 2

	xgb.Put16(buf[b:], uint16(AccelerationDenominator))
	b += 2

	xgb.Put16(buf[b:], uint16(Threshold))
	b += 2

	if DoAcceleration {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	if DoThreshold {
		buf[b] = 1
	} else {
		buf[b] = 0
	}
	b += 1

	return buf
}

// Request GetPointerControl
// size: 4
type GetPointerControlCookie struct {
	*xgb.Cookie
}

func GetPointerControl(c *xgb.Conn) GetPointerControlCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getPointerControlRequest(c), cookie)
	return GetPointerControlCookie{cookie}
}

func GetPointerControlUnchecked(c *xgb.Conn) GetPointerControlCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getPointerControlRequest(c), cookie)
	return GetPointerControlCookie{cookie}
}

// Request reply for GetPointerControl
// size: 32
type GetPointerControlReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	AccelerationNumerator   uint16
	AccelerationDenominator uint16
	Threshold               uint16
	// padding: 18 bytes
}

// Waits and reads reply data from request GetPointerControl
func (cook GetPointerControlCookie) Reply() (*GetPointerControlReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getPointerControlReply(buf), nil
}

// Read reply into structure from buffer for GetPointerControl
func getPointerControlReply(buf []byte) *GetPointerControlReply {
	v := new(GetPointerControlReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.AccelerationNumerator = xgb.Get16(buf[b:])
	b += 2

	v.AccelerationDenominator = xgb.Get16(buf[b:])
	b += 2

	v.Threshold = xgb.Get16(buf[b:])
	b += 2

	b += 18 // padding

	return v
}

// Write request to wire for GetPointerControl
func getPointerControlRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 106 // request opcode
	b += 1

	b += 1                             // padding
	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request SetScreenSaver
// size: 12
type SetScreenSaverCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetScreenSaver
func SetScreenSaver(c *xgb.Conn, Timeout int16, Interval int16, PreferBlanking byte, AllowExposures byte) SetScreenSaverCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setScreenSaverRequest(c, Timeout, Interval, PreferBlanking, AllowExposures), cookie)
	return SetScreenSaverCookie{cookie}
}

func SetScreenSaverChecked(c *xgb.Conn, Timeout int16, Interval int16, PreferBlanking byte, AllowExposures byte) SetScreenSaverCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setScreenSaverRequest(c, Timeout, Interval, PreferBlanking, AllowExposures), cookie)
	return SetScreenSaverCookie{cookie}
}

func (cook SetScreenSaverCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetScreenSaver
func setScreenSaverRequest(c *xgb.Conn, Timeout int16, Interval int16, PreferBlanking byte, AllowExposures byte) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = 107 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put16(buf[b:], uint16(Timeout))
	b += 2

	xgb.Put16(buf[b:], uint16(Interval))
	b += 2

	buf[b] = PreferBlanking
	b += 1

	buf[b] = AllowExposures
	b += 1

	return buf
}

// Request GetScreenSaver
// size: 4
type GetScreenSaverCookie struct {
	*xgb.Cookie
}

func GetScreenSaver(c *xgb.Conn) GetScreenSaverCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getScreenSaverRequest(c), cookie)
	return GetScreenSaverCookie{cookie}
}

func GetScreenSaverUnchecked(c *xgb.Conn) GetScreenSaverCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getScreenSaverRequest(c), cookie)
	return GetScreenSaverCookie{cookie}
}

// Request reply for GetScreenSaver
// size: 32
type GetScreenSaverReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	Timeout        uint16
	Interval       uint16
	PreferBlanking byte
	AllowExposures byte
	// padding: 18 bytes
}

// Waits and reads reply data from request GetScreenSaver
func (cook GetScreenSaverCookie) Reply() (*GetScreenSaverReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getScreenSaverReply(buf), nil
}

// Read reply into structure from buffer for GetScreenSaver
func getScreenSaverReply(buf []byte) *GetScreenSaverReply {
	v := new(GetScreenSaverReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.Timeout = xgb.Get16(buf[b:])
	b += 2

	v.Interval = xgb.Get16(buf[b:])
	b += 2

	v.PreferBlanking = buf[b]
	b += 1

	v.AllowExposures = buf[b]
	b += 1

	b += 18 // padding

	return v
}

// Write request to wire for GetScreenSaver
func getScreenSaverRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 108 // request opcode
	b += 1

	b += 1                             // padding
	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request ChangeHosts
// size: xgb.Pad((8 + xgb.Pad((int(AddressLen) * 1))))
type ChangeHostsCookie struct {
	*xgb.Cookie
}

// Write request to wire for ChangeHosts
func ChangeHosts(c *xgb.Conn, Mode byte, Family byte, AddressLen uint16, Address []byte) ChangeHostsCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(changeHostsRequest(c, Mode, Family, AddressLen, Address), cookie)
	return ChangeHostsCookie{cookie}
}

func ChangeHostsChecked(c *xgb.Conn, Mode byte, Family byte, AddressLen uint16, Address []byte) ChangeHostsCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(changeHostsRequest(c, Mode, Family, AddressLen, Address), cookie)
	return ChangeHostsCookie{cookie}
}

func (cook ChangeHostsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangeHosts
func changeHostsRequest(c *xgb.Conn, Mode byte, Family byte, AddressLen uint16, Address []byte) []byte {
	size := xgb.Pad((8 + xgb.Pad((int(AddressLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 109 // request opcode
	b += 1

	buf[b] = Mode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = Family
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], AddressLen)
	b += 2

	copy(buf[b:], Address[:AddressLen])
	b += xgb.Pad(int(AddressLen))

	return buf
}

// Request ListHosts
// size: 4
type ListHostsCookie struct {
	*xgb.Cookie
}

func ListHosts(c *xgb.Conn) ListHostsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(listHostsRequest(c), cookie)
	return ListHostsCookie{cookie}
}

func ListHostsUnchecked(c *xgb.Conn) ListHostsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(listHostsRequest(c), cookie)
	return ListHostsCookie{cookie}
}

// Request reply for ListHosts
// size: (32 + HostListSize(Hosts))
type ListHostsReply struct {
	Sequence uint16
	Length   uint32
	Mode     byte
	HostsLen uint16
	// padding: 22 bytes
	Hosts []Host // size: HostListSize(Hosts)
}

// Waits and reads reply data from request ListHosts
func (cook ListHostsCookie) Reply() (*ListHostsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return listHostsReply(buf), nil
}

// Read reply into structure from buffer for ListHosts
func listHostsReply(buf []byte) *ListHostsReply {
	v := new(ListHostsReply)
	b := 1 // skip reply determinant

	v.Mode = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.HostsLen = xgb.Get16(buf[b:])
	b += 2

	b += 22 // padding

	v.Hosts = make([]Host, v.HostsLen)
	b += HostReadList(buf[b:], v.Hosts)

	return v
}

// Write request to wire for ListHosts
func listHostsRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 110 // request opcode
	b += 1

	b += 1                             // padding
	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request SetAccessControl
// size: 4
type SetAccessControlCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetAccessControl
func SetAccessControl(c *xgb.Conn, Mode byte) SetAccessControlCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setAccessControlRequest(c, Mode), cookie)
	return SetAccessControlCookie{cookie}
}

func SetAccessControlChecked(c *xgb.Conn, Mode byte) SetAccessControlCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setAccessControlRequest(c, Mode), cookie)
	return SetAccessControlCookie{cookie}
}

func (cook SetAccessControlCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetAccessControl
func setAccessControlRequest(c *xgb.Conn, Mode byte) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 111 // request opcode
	b += 1

	buf[b] = Mode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request SetCloseDownMode
// size: 4
type SetCloseDownModeCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetCloseDownMode
func SetCloseDownMode(c *xgb.Conn, Mode byte) SetCloseDownModeCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setCloseDownModeRequest(c, Mode), cookie)
	return SetCloseDownModeCookie{cookie}
}

func SetCloseDownModeChecked(c *xgb.Conn, Mode byte) SetCloseDownModeCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setCloseDownModeRequest(c, Mode), cookie)
	return SetCloseDownModeCookie{cookie}
}

func (cook SetCloseDownModeCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetCloseDownMode
func setCloseDownModeRequest(c *xgb.Conn, Mode byte) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 112 // request opcode
	b += 1

	buf[b] = Mode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request KillClient
// size: 8
type KillClientCookie struct {
	*xgb.Cookie
}

// Write request to wire for KillClient
func KillClient(c *xgb.Conn, Resource uint32) KillClientCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(killClientRequest(c, Resource), cookie)
	return KillClientCookie{cookie}
}

func KillClientChecked(c *xgb.Conn, Resource uint32) KillClientCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(killClientRequest(c, Resource), cookie)
	return KillClientCookie{cookie}
}

func (cook KillClientCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for KillClient
func killClientRequest(c *xgb.Conn, Resource uint32) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = 113 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], Resource)
	b += 4

	return buf
}

// Request RotateProperties
// size: xgb.Pad((12 + xgb.Pad((int(AtomsLen) * 4))))
type RotatePropertiesCookie struct {
	*xgb.Cookie
}

// Write request to wire for RotateProperties
func RotateProperties(c *xgb.Conn, Window Window, AtomsLen uint16, Delta int16, Atoms []Atom) RotatePropertiesCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(rotatePropertiesRequest(c, Window, AtomsLen, Delta, Atoms), cookie)
	return RotatePropertiesCookie{cookie}
}

func RotatePropertiesChecked(c *xgb.Conn, Window Window, AtomsLen uint16, Delta int16, Atoms []Atom) RotatePropertiesCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(rotatePropertiesRequest(c, Window, AtomsLen, Delta, Atoms), cookie)
	return RotatePropertiesCookie{cookie}
}

func (cook RotatePropertiesCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for RotateProperties
func rotatePropertiesRequest(c *xgb.Conn, Window Window, AtomsLen uint16, Delta int16, Atoms []Atom) []byte {
	size := xgb.Pad((12 + xgb.Pad((int(AtomsLen) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 114 // request opcode
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Window))
	b += 4

	xgb.Put16(buf[b:], AtomsLen)
	b += 2

	xgb.Put16(buf[b:], uint16(Delta))
	b += 2

	for i := 0; i < int(AtomsLen); i++ {
		xgb.Put32(buf[b:], uint32(Atoms[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request ForceScreenSaver
// size: 4
type ForceScreenSaverCookie struct {
	*xgb.Cookie
}

// Write request to wire for ForceScreenSaver
func ForceScreenSaver(c *xgb.Conn, Mode byte) ForceScreenSaverCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(forceScreenSaverRequest(c, Mode), cookie)
	return ForceScreenSaverCookie{cookie}
}

func ForceScreenSaverChecked(c *xgb.Conn, Mode byte) ForceScreenSaverCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(forceScreenSaverRequest(c, Mode), cookie)
	return ForceScreenSaverCookie{cookie}
}

func (cook ForceScreenSaverCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ForceScreenSaver
func forceScreenSaverRequest(c *xgb.Conn, Mode byte) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 115 // request opcode
	b += 1

	buf[b] = Mode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request SetPointerMapping
// size: xgb.Pad((4 + xgb.Pad((int(MapLen) * 1))))
type SetPointerMappingCookie struct {
	*xgb.Cookie
}

func SetPointerMapping(c *xgb.Conn, MapLen byte, Map []byte) SetPointerMappingCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(setPointerMappingRequest(c, MapLen, Map), cookie)
	return SetPointerMappingCookie{cookie}
}

func SetPointerMappingUnchecked(c *xgb.Conn, MapLen byte, Map []byte) SetPointerMappingCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(setPointerMappingRequest(c, MapLen, Map), cookie)
	return SetPointerMappingCookie{cookie}
}

// Request reply for SetPointerMapping
// size: 8
type SetPointerMappingReply struct {
	Sequence uint16
	Length   uint32
	Status   byte
}

// Waits and reads reply data from request SetPointerMapping
func (cook SetPointerMappingCookie) Reply() (*SetPointerMappingReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return setPointerMappingReply(buf), nil
}

// Read reply into structure from buffer for SetPointerMapping
func setPointerMappingReply(buf []byte) *SetPointerMappingReply {
	v := new(SetPointerMappingReply)
	b := 1 // skip reply determinant

	v.Status = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	return v
}

// Write request to wire for SetPointerMapping
func setPointerMappingRequest(c *xgb.Conn, MapLen byte, Map []byte) []byte {
	size := xgb.Pad((4 + xgb.Pad((int(MapLen) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 116 // request opcode
	b += 1

	buf[b] = MapLen
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	copy(buf[b:], Map[:MapLen])
	b += xgb.Pad(int(MapLen))

	return buf
}

// Request GetPointerMapping
// size: 4
type GetPointerMappingCookie struct {
	*xgb.Cookie
}

func GetPointerMapping(c *xgb.Conn) GetPointerMappingCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getPointerMappingRequest(c), cookie)
	return GetPointerMappingCookie{cookie}
}

func GetPointerMappingUnchecked(c *xgb.Conn) GetPointerMappingCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getPointerMappingRequest(c), cookie)
	return GetPointerMappingCookie{cookie}
}

// Request reply for GetPointerMapping
// size: (32 + xgb.Pad((int(MapLen) * 1)))
type GetPointerMappingReply struct {
	Sequence uint16
	Length   uint32
	MapLen   byte
	// padding: 24 bytes
	Map []byte // size: xgb.Pad((int(MapLen) * 1))
}

// Waits and reads reply data from request GetPointerMapping
func (cook GetPointerMappingCookie) Reply() (*GetPointerMappingReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getPointerMappingReply(buf), nil
}

// Read reply into structure from buffer for GetPointerMapping
func getPointerMappingReply(buf []byte) *GetPointerMappingReply {
	v := new(GetPointerMappingReply)
	b := 1 // skip reply determinant

	v.MapLen = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.Map = make([]byte, v.MapLen)
	copy(v.Map[:v.MapLen], buf[b:])
	b += xgb.Pad(int(v.MapLen))

	return v
}

// Write request to wire for GetPointerMapping
func getPointerMappingRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 117 // request opcode
	b += 1

	b += 1                             // padding
	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request SetModifierMapping
// size: xgb.Pad((4 + xgb.Pad(((int(KeycodesPerModifier) * 8) * 1))))
type SetModifierMappingCookie struct {
	*xgb.Cookie
}

func SetModifierMapping(c *xgb.Conn, KeycodesPerModifier byte, Keycodes []Keycode) SetModifierMappingCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(setModifierMappingRequest(c, KeycodesPerModifier, Keycodes), cookie)
	return SetModifierMappingCookie{cookie}
}

func SetModifierMappingUnchecked(c *xgb.Conn, KeycodesPerModifier byte, Keycodes []Keycode) SetModifierMappingCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(setModifierMappingRequest(c, KeycodesPerModifier, Keycodes), cookie)
	return SetModifierMappingCookie{cookie}
}

// Request reply for SetModifierMapping
// size: 8
type SetModifierMappingReply struct {
	Sequence uint16
	Length   uint32
	Status   byte
}

// Waits and reads reply data from request SetModifierMapping
func (cook SetModifierMappingCookie) Reply() (*SetModifierMappingReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return setModifierMappingReply(buf), nil
}

// Read reply into structure from buffer for SetModifierMapping
func setModifierMappingReply(buf []byte) *SetModifierMappingReply {
	v := new(SetModifierMappingReply)
	b := 1 // skip reply determinant

	v.Status = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	return v
}

// Write request to wire for SetModifierMapping
func setModifierMappingRequest(c *xgb.Conn, KeycodesPerModifier byte, Keycodes []Keycode) []byte {
	size := xgb.Pad((4 + xgb.Pad(((int(KeycodesPerModifier) * 8) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = 118 // request opcode
	b += 1

	buf[b] = KeycodesPerModifier
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	for i := 0; i < int((int(KeycodesPerModifier) * 8)); i++ {
		buf[b] = byte(Keycodes[i])
		b += 1
	}
	b = xgb.Pad(b)

	return buf
}

// Request GetModifierMapping
// size: 4
type GetModifierMappingCookie struct {
	*xgb.Cookie
}

func GetModifierMapping(c *xgb.Conn) GetModifierMappingCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(getModifierMappingRequest(c), cookie)
	return GetModifierMappingCookie{cookie}
}

func GetModifierMappingUnchecked(c *xgb.Conn) GetModifierMappingCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(getModifierMappingRequest(c), cookie)
	return GetModifierMappingCookie{cookie}
}

// Request reply for GetModifierMapping
// size: (32 + xgb.Pad(((int(KeycodesPerModifier) * 8) * 1)))
type GetModifierMappingReply struct {
	Sequence            uint16
	Length              uint32
	KeycodesPerModifier byte
	// padding: 24 bytes
	Keycodes []Keycode // size: xgb.Pad(((int(KeycodesPerModifier) * 8) * 1))
}

// Waits and reads reply data from request GetModifierMapping
func (cook GetModifierMappingCookie) Reply() (*GetModifierMappingReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return getModifierMappingReply(buf), nil
}

// Read reply into structure from buffer for GetModifierMapping
func getModifierMappingReply(buf []byte) *GetModifierMappingReply {
	v := new(GetModifierMappingReply)
	b := 1 // skip reply determinant

	v.KeycodesPerModifier = buf[b]
	b += 1

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	b += 24 // padding

	v.Keycodes = make([]Keycode, (int(v.KeycodesPerModifier) * 8))
	for i := 0; i < int((int(v.KeycodesPerModifier) * 8)); i++ {
		v.Keycodes[i] = Keycode(buf[b])
		b += 1
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for GetModifierMapping
func getModifierMappingRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 119 // request opcode
	b += 1

	b += 1                             // padding
	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request NoOperation
// size: 4
type NoOperationCookie struct {
	*xgb.Cookie
}

// Write request to wire for NoOperation
func NoOperation(c *xgb.Conn) NoOperationCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(noOperationRequest(c), cookie)
	return NoOperationCookie{cookie}
}

func NoOperationChecked(c *xgb.Conn) NoOperationCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(noOperationRequest(c), cookie)
	return NoOperationCookie{cookie}
}

func (cook NoOperationCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for NoOperation
func noOperationRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = 127 // request opcode
	b += 1

	b += 1                             // padding
	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}
