package render

/*
	This file was generated by render.xml on May 10 2012 4:20:28pm EDT.
	This file is automatically generated. Edit at your peril!
*/

import (
	"github.com/BurntSushi/xgb"

	"github.com/BurntSushi/xgb/xproto"
)

// Init must be called before using the RENDER extension.
func Init(c *xgb.Conn) error {
	reply, err := xproto.QueryExtension(c, 6, "RENDER").Reply()
	switch {
	case err != nil:
		return err
	case !reply.Present:
		return xgb.Errorf("No extension named RENDER could be found on on the server.")
	}

	xgb.ExtLock.Lock()
	c.Extensions["RENDER"] = reply.MajorOpcode
	for evNum, fun := range xgb.NewExtEventFuncs["RENDER"] {
		xgb.NewEventFuncs[int(reply.FirstEvent)+evNum] = fun
	}
	for errNum, fun := range xgb.NewExtErrorFuncs["RENDER"] {
		xgb.NewErrorFuncs[int(reply.FirstError)+errNum] = fun
	}
	xgb.ExtLock.Unlock()

	return nil
}

func init() {
	xgb.NewExtEventFuncs["RENDER"] = make(map[int]xgb.NewEventFun)
	xgb.NewExtErrorFuncs["RENDER"] = make(map[int]xgb.NewErrorFun)
}

// Skipping definition for base type 'Int32'

// Skipping definition for base type 'Void'

// Skipping definition for base type 'Byte'

// Skipping definition for base type 'Int8'

// Skipping definition for base type 'Card16'

// Skipping definition for base type 'Char'

// Skipping definition for base type 'Card32'

// Skipping definition for base type 'Double'

// Skipping definition for base type 'Bool'

// Skipping definition for base type 'Float'

// Skipping definition for base type 'Card8'

// Skipping definition for base type 'Int16'

const (
	PictTypeIndexed = 0
	PictTypeDirect  = 1
)

const (
	PictureNone = 0
)

const (
	PictOpClear               = 0
	PictOpSrc                 = 1
	PictOpDst                 = 2
	PictOpOver                = 3
	PictOpOverReverse         = 4
	PictOpIn                  = 5
	PictOpInReverse           = 6
	PictOpOut                 = 7
	PictOpOutReverse          = 8
	PictOpAtop                = 9
	PictOpAtopReverse         = 10
	PictOpXor                 = 11
	PictOpAdd                 = 12
	PictOpSaturate            = 13
	PictOpDisjointClear       = 16
	PictOpDisjointSrc         = 17
	PictOpDisjointDst         = 18
	PictOpDisjointOver        = 19
	PictOpDisjointOverReverse = 20
	PictOpDisjointIn          = 21
	PictOpDisjointInReverse   = 22
	PictOpDisjointOut         = 23
	PictOpDisjointOutReverse  = 24
	PictOpDisjointAtop        = 25
	PictOpDisjointAtopReverse = 26
	PictOpDisjointXor         = 27
	PictOpConjointClear       = 32
	PictOpConjointSrc         = 33
	PictOpConjointDst         = 34
	PictOpConjointOver        = 35
	PictOpConjointOverReverse = 36
	PictOpConjointIn          = 37
	PictOpConjointInReverse   = 38
	PictOpConjointOut         = 39
	PictOpConjointOutReverse  = 40
	PictOpConjointAtop        = 41
	PictOpConjointAtopReverse = 42
	PictOpConjointXor         = 43
	PictOpMultiply            = 48
	PictOpScreen              = 49
	PictOpOverlay             = 50
	PictOpDarken              = 51
	PictOpLighten             = 52
	PictOpColorDodge          = 53
	PictOpColorBurn           = 54
	PictOpHardLight           = 55
	PictOpSoftLight           = 56
	PictOpDifference          = 57
	PictOpExclusion           = 58
	PictOpHSLHue              = 59
	PictOpHSLSaturation       = 60
	PictOpHSLColor            = 61
	PictOpHSLLuminosity       = 62
)

const (
	PolyEdgeSharp  = 0
	PolyEdgeSmooth = 1
)

const (
	PolyModePrecise   = 0
	PolyModeImprecise = 1
)

const (
	CpRepeat           = 1
	CpAlphaMap         = 2
	CpAlphaXOrigin     = 4
	CpAlphaYOrigin     = 8
	CpClipXOrigin      = 16
	CpClipYOrigin      = 32
	CpClipMask         = 64
	CpGraphicsExposure = 128
	CpSubwindowMode    = 256
	CpPolyEdge         = 512
	CpPolyMode         = 1024
	CpDither           = 2048
	CpComponentAlpha   = 4096
)

const (
	SubPixelUnknown       = 0
	SubPixelHorizontalRGB = 1
	SubPixelHorizontalBGR = 2
	SubPixelVerticalRGB   = 3
	SubPixelVerticalBGR   = 4
	SubPixelNone          = 5
)

const (
	RepeatNone    = 0
	RepeatNormal  = 1
	RepeatPad     = 2
	RepeatReflect = 3
)

type Glyphset uint32

func NewGlyphsetId(c *xgb.Conn) (Glyphset, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Glyphset(id), nil
}

type Picture uint32

func NewPictureId(c *xgb.Conn) (Picture, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Picture(id), nil
}

type Pictformat uint32

func NewPictformatId(c *xgb.Conn) (Pictformat, error) {
	id, err := c.NewId()
	if err != nil {
		return 0, err
	}
	return Pictformat(id), nil
}

type Glyph uint32

type Fixed int32

// 'Directformat' struct definition
// Size: 16
type Directformat struct {
	RedShift   uint16
	RedMask    uint16
	GreenShift uint16
	GreenMask  uint16
	BlueShift  uint16
	BlueMask   uint16
	AlphaShift uint16
	AlphaMask  uint16
}

// Struct read Directformat
func DirectformatRead(buf []byte, v *Directformat) int {
	b := 0

	v.RedShift = xgb.Get16(buf[b:])
	b += 2

	v.RedMask = xgb.Get16(buf[b:])
	b += 2

	v.GreenShift = xgb.Get16(buf[b:])
	b += 2

	v.GreenMask = xgb.Get16(buf[b:])
	b += 2

	v.BlueShift = xgb.Get16(buf[b:])
	b += 2

	v.BlueMask = xgb.Get16(buf[b:])
	b += 2

	v.AlphaShift = xgb.Get16(buf[b:])
	b += 2

	v.AlphaMask = xgb.Get16(buf[b:])
	b += 2

	return b
}

// Struct list read Directformat
func DirectformatReadList(buf []byte, dest []Directformat) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Directformat{}
		b += DirectformatRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Directformat
func (v Directformat) Bytes() []byte {
	buf := make([]byte, 16)
	b := 0

	xgb.Put16(buf[b:], v.RedShift)
	b += 2

	xgb.Put16(buf[b:], v.RedMask)
	b += 2

	xgb.Put16(buf[b:], v.GreenShift)
	b += 2

	xgb.Put16(buf[b:], v.GreenMask)
	b += 2

	xgb.Put16(buf[b:], v.BlueShift)
	b += 2

	xgb.Put16(buf[b:], v.BlueMask)
	b += 2

	xgb.Put16(buf[b:], v.AlphaShift)
	b += 2

	xgb.Put16(buf[b:], v.AlphaMask)
	b += 2

	return buf
}

// Write struct list Directformat
func DirectformatListBytes(buf []byte, list []Directformat) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Pictforminfo' struct definition
// Size: 28
type Pictforminfo struct {
	Id    Pictformat
	Type  byte
	Depth byte
	// padding: 2 bytes
	Direct   Directformat
	Colormap xproto.Colormap
}

// Struct read Pictforminfo
func PictforminfoRead(buf []byte, v *Pictforminfo) int {
	b := 0

	v.Id = Pictformat(xgb.Get32(buf[b:]))
	b += 4

	v.Type = buf[b]
	b += 1

	v.Depth = buf[b]
	b += 1

	b += 2 // padding

	v.Direct = Directformat{}
	b += DirectformatRead(buf[b:], &v.Direct)

	v.Colormap = xproto.Colormap(xgb.Get32(buf[b:]))
	b += 4

	return b
}

// Struct list read Pictforminfo
func PictforminfoReadList(buf []byte, dest []Pictforminfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Pictforminfo{}
		b += PictforminfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Pictforminfo
func (v Pictforminfo) Bytes() []byte {
	buf := make([]byte, 28)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Id))
	b += 4

	buf[b] = v.Type
	b += 1

	buf[b] = v.Depth
	b += 1

	b += 2 // padding

	{
		structBytes := v.Direct.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	xgb.Put32(buf[b:], uint32(v.Colormap))
	b += 4

	return buf
}

// Write struct list Pictforminfo
func PictforminfoListBytes(buf []byte, list []Pictforminfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Pictvisual' struct definition
// Size: 8
type Pictvisual struct {
	Visual xproto.Visualid
	Format Pictformat
}

// Struct read Pictvisual
func PictvisualRead(buf []byte, v *Pictvisual) int {
	b := 0

	v.Visual = xproto.Visualid(xgb.Get32(buf[b:]))
	b += 4

	v.Format = Pictformat(xgb.Get32(buf[b:]))
	b += 4

	return b
}

// Struct list read Pictvisual
func PictvisualReadList(buf []byte, dest []Pictvisual) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Pictvisual{}
		b += PictvisualRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Pictvisual
func (v Pictvisual) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Visual))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Format))
	b += 4

	return buf
}

// Write struct list Pictvisual
func PictvisualListBytes(buf []byte, list []Pictvisual) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Pictdepth' struct definition
// Size: (8 + xgb.Pad((int(NumVisuals) * 8)))
type Pictdepth struct {
	Depth byte
	// padding: 1 bytes
	NumVisuals uint16
	// padding: 4 bytes
	Visuals []Pictvisual // size: xgb.Pad((int(NumVisuals) * 8))
}

// Struct read Pictdepth
func PictdepthRead(buf []byte, v *Pictdepth) int {
	b := 0

	v.Depth = buf[b]
	b += 1

	b += 1 // padding

	v.NumVisuals = xgb.Get16(buf[b:])
	b += 2

	b += 4 // padding

	v.Visuals = make([]Pictvisual, v.NumVisuals)
	b += PictvisualReadList(buf[b:], v.Visuals)

	return b
}

// Struct list read Pictdepth
func PictdepthReadList(buf []byte, dest []Pictdepth) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Pictdepth{}
		b += PictdepthRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Pictdepth
func (v Pictdepth) Bytes() []byte {
	buf := make([]byte, (8 + xgb.Pad((int(v.NumVisuals) * 8))))
	b := 0

	buf[b] = v.Depth
	b += 1

	b += 1 // padding

	xgb.Put16(buf[b:], v.NumVisuals)
	b += 2

	b += 4 // padding

	b += PictvisualListBytes(buf[b:], v.Visuals)

	return buf
}

// Write struct list Pictdepth
func PictdepthListBytes(buf []byte, list []Pictdepth) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size Pictdepth
func PictdepthListSize(list []Pictdepth) int {
	size := 0
	for _, item := range list {
		size += (8 + xgb.Pad((int(item.NumVisuals) * 8)))
	}
	return size
}

// 'Pictscreen' struct definition
// Size: (8 + PictdepthListSize(Depths))
type Pictscreen struct {
	NumDepths uint32
	Fallback  Pictformat
	Depths    []Pictdepth // size: PictdepthListSize(Depths)
}

// Struct read Pictscreen
func PictscreenRead(buf []byte, v *Pictscreen) int {
	b := 0

	v.NumDepths = xgb.Get32(buf[b:])
	b += 4

	v.Fallback = Pictformat(xgb.Get32(buf[b:]))
	b += 4

	v.Depths = make([]Pictdepth, v.NumDepths)
	b += PictdepthReadList(buf[b:], v.Depths)

	return b
}

// Struct list read Pictscreen
func PictscreenReadList(buf []byte, dest []Pictscreen) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Pictscreen{}
		b += PictscreenRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Pictscreen
func (v Pictscreen) Bytes() []byte {
	buf := make([]byte, (8 + PictdepthListSize(v.Depths)))
	b := 0

	xgb.Put32(buf[b:], v.NumDepths)
	b += 4

	xgb.Put32(buf[b:], uint32(v.Fallback))
	b += 4

	b += PictdepthListBytes(buf[b:], v.Depths)

	return buf
}

// Write struct list Pictscreen
func PictscreenListBytes(buf []byte, list []Pictscreen) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Struct list size Pictscreen
func PictscreenListSize(list []Pictscreen) int {
	size := 0
	for _, item := range list {
		size += (8 + PictdepthListSize(item.Depths))
	}
	return size
}

// 'Indexvalue' struct definition
// Size: 12
type Indexvalue struct {
	Pixel uint32
	Red   uint16
	Green uint16
	Blue  uint16
	Alpha uint16
}

// Struct read Indexvalue
func IndexvalueRead(buf []byte, v *Indexvalue) int {
	b := 0

	v.Pixel = xgb.Get32(buf[b:])
	b += 4

	v.Red = xgb.Get16(buf[b:])
	b += 2

	v.Green = xgb.Get16(buf[b:])
	b += 2

	v.Blue = xgb.Get16(buf[b:])
	b += 2

	v.Alpha = xgb.Get16(buf[b:])
	b += 2

	return b
}

// Struct list read Indexvalue
func IndexvalueReadList(buf []byte, dest []Indexvalue) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Indexvalue{}
		b += IndexvalueRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Indexvalue
func (v Indexvalue) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	xgb.Put32(buf[b:], v.Pixel)
	b += 4

	xgb.Put16(buf[b:], v.Red)
	b += 2

	xgb.Put16(buf[b:], v.Green)
	b += 2

	xgb.Put16(buf[b:], v.Blue)
	b += 2

	xgb.Put16(buf[b:], v.Alpha)
	b += 2

	return buf
}

// Write struct list Indexvalue
func IndexvalueListBytes(buf []byte, list []Indexvalue) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Color' struct definition
// Size: 8
type Color struct {
	Red   uint16
	Green uint16
	Blue  uint16
	Alpha uint16
}

// Struct read Color
func ColorRead(buf []byte, v *Color) int {
	b := 0

	v.Red = xgb.Get16(buf[b:])
	b += 2

	v.Green = xgb.Get16(buf[b:])
	b += 2

	v.Blue = xgb.Get16(buf[b:])
	b += 2

	v.Alpha = xgb.Get16(buf[b:])
	b += 2

	return b
}

// Struct list read Color
func ColorReadList(buf []byte, dest []Color) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Color{}
		b += ColorRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Color
func (v Color) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put16(buf[b:], v.Red)
	b += 2

	xgb.Put16(buf[b:], v.Green)
	b += 2

	xgb.Put16(buf[b:], v.Blue)
	b += 2

	xgb.Put16(buf[b:], v.Alpha)
	b += 2

	return buf
}

// Write struct list Color
func ColorListBytes(buf []byte, list []Color) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Pointfix' struct definition
// Size: 8
type Pointfix struct {
	X Fixed
	Y Fixed
}

// Struct read Pointfix
func PointfixRead(buf []byte, v *Pointfix) int {
	b := 0

	v.X = Fixed(xgb.Get32(buf[b:]))
	b += 4

	v.Y = Fixed(xgb.Get32(buf[b:]))
	b += 4

	return b
}

// Struct list read Pointfix
func PointfixReadList(buf []byte, dest []Pointfix) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Pointfix{}
		b += PointfixRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Pointfix
func (v Pointfix) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put32(buf[b:], uint32(v.X))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Y))
	b += 4

	return buf
}

// Write struct list Pointfix
func PointfixListBytes(buf []byte, list []Pointfix) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Linefix' struct definition
// Size: 16
type Linefix struct {
	P1 Pointfix
	P2 Pointfix
}

// Struct read Linefix
func LinefixRead(buf []byte, v *Linefix) int {
	b := 0

	v.P1 = Pointfix{}
	b += PointfixRead(buf[b:], &v.P1)

	v.P2 = Pointfix{}
	b += PointfixRead(buf[b:], &v.P2)

	return b
}

// Struct list read Linefix
func LinefixReadList(buf []byte, dest []Linefix) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Linefix{}
		b += LinefixRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Linefix
func (v Linefix) Bytes() []byte {
	buf := make([]byte, 16)
	b := 0

	{
		structBytes := v.P1.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.P2.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	return buf
}

// Write struct list Linefix
func LinefixListBytes(buf []byte, list []Linefix) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Triangle' struct definition
// Size: 24
type Triangle struct {
	P1 Pointfix
	P2 Pointfix
	P3 Pointfix
}

// Struct read Triangle
func TriangleRead(buf []byte, v *Triangle) int {
	b := 0

	v.P1 = Pointfix{}
	b += PointfixRead(buf[b:], &v.P1)

	v.P2 = Pointfix{}
	b += PointfixRead(buf[b:], &v.P2)

	v.P3 = Pointfix{}
	b += PointfixRead(buf[b:], &v.P3)

	return b
}

// Struct list read Triangle
func TriangleReadList(buf []byte, dest []Triangle) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Triangle{}
		b += TriangleRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Triangle
func (v Triangle) Bytes() []byte {
	buf := make([]byte, 24)
	b := 0

	{
		structBytes := v.P1.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.P2.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.P3.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	return buf
}

// Write struct list Triangle
func TriangleListBytes(buf []byte, list []Triangle) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Trapezoid' struct definition
// Size: 40
type Trapezoid struct {
	Top    Fixed
	Bottom Fixed
	Left   Linefix
	Right  Linefix
}

// Struct read Trapezoid
func TrapezoidRead(buf []byte, v *Trapezoid) int {
	b := 0

	v.Top = Fixed(xgb.Get32(buf[b:]))
	b += 4

	v.Bottom = Fixed(xgb.Get32(buf[b:]))
	b += 4

	v.Left = Linefix{}
	b += LinefixRead(buf[b:], &v.Left)

	v.Right = Linefix{}
	b += LinefixRead(buf[b:], &v.Right)

	return b
}

// Struct list read Trapezoid
func TrapezoidReadList(buf []byte, dest []Trapezoid) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Trapezoid{}
		b += TrapezoidRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Trapezoid
func (v Trapezoid) Bytes() []byte {
	buf := make([]byte, 40)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Top))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Bottom))
	b += 4

	{
		structBytes := v.Left.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.Right.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	return buf
}

// Write struct list Trapezoid
func TrapezoidListBytes(buf []byte, list []Trapezoid) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Glyphinfo' struct definition
// Size: 12
type Glyphinfo struct {
	Width  uint16
	Height uint16
	X      int16
	Y      int16
	XOff   int16
	YOff   int16
}

// Struct read Glyphinfo
func GlyphinfoRead(buf []byte, v *Glyphinfo) int {
	b := 0

	v.Width = xgb.Get16(buf[b:])
	b += 2

	v.Height = xgb.Get16(buf[b:])
	b += 2

	v.X = int16(xgb.Get16(buf[b:]))
	b += 2

	v.Y = int16(xgb.Get16(buf[b:]))
	b += 2

	v.XOff = int16(xgb.Get16(buf[b:]))
	b += 2

	v.YOff = int16(xgb.Get16(buf[b:]))
	b += 2

	return b
}

// Struct list read Glyphinfo
func GlyphinfoReadList(buf []byte, dest []Glyphinfo) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Glyphinfo{}
		b += GlyphinfoRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Glyphinfo
func (v Glyphinfo) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	xgb.Put16(buf[b:], v.Width)
	b += 2

	xgb.Put16(buf[b:], v.Height)
	b += 2

	xgb.Put16(buf[b:], uint16(v.X))
	b += 2

	xgb.Put16(buf[b:], uint16(v.Y))
	b += 2

	xgb.Put16(buf[b:], uint16(v.XOff))
	b += 2

	xgb.Put16(buf[b:], uint16(v.YOff))
	b += 2

	return buf
}

// Write struct list Glyphinfo
func GlyphinfoListBytes(buf []byte, list []Glyphinfo) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Transform' struct definition
// Size: 36
type Transform struct {
	Matrix11 Fixed
	Matrix12 Fixed
	Matrix13 Fixed
	Matrix21 Fixed
	Matrix22 Fixed
	Matrix23 Fixed
	Matrix31 Fixed
	Matrix32 Fixed
	Matrix33 Fixed
}

// Struct read Transform
func TransformRead(buf []byte, v *Transform) int {
	b := 0

	v.Matrix11 = Fixed(xgb.Get32(buf[b:]))
	b += 4

	v.Matrix12 = Fixed(xgb.Get32(buf[b:]))
	b += 4

	v.Matrix13 = Fixed(xgb.Get32(buf[b:]))
	b += 4

	v.Matrix21 = Fixed(xgb.Get32(buf[b:]))
	b += 4

	v.Matrix22 = Fixed(xgb.Get32(buf[b:]))
	b += 4

	v.Matrix23 = Fixed(xgb.Get32(buf[b:]))
	b += 4

	v.Matrix31 = Fixed(xgb.Get32(buf[b:]))
	b += 4

	v.Matrix32 = Fixed(xgb.Get32(buf[b:]))
	b += 4

	v.Matrix33 = Fixed(xgb.Get32(buf[b:]))
	b += 4

	return b
}

// Struct list read Transform
func TransformReadList(buf []byte, dest []Transform) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Transform{}
		b += TransformRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Transform
func (v Transform) Bytes() []byte {
	buf := make([]byte, 36)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Matrix11))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Matrix12))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Matrix13))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Matrix21))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Matrix22))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Matrix23))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Matrix31))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Matrix32))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Matrix33))
	b += 4

	return buf
}

// Write struct list Transform
func TransformListBytes(buf []byte, list []Transform) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Animcursorelt' struct definition
// Size: 8
type Animcursorelt struct {
	Cursor xproto.Cursor
	Delay  uint32
}

// Struct read Animcursorelt
func AnimcursoreltRead(buf []byte, v *Animcursorelt) int {
	b := 0

	v.Cursor = xproto.Cursor(xgb.Get32(buf[b:]))
	b += 4

	v.Delay = xgb.Get32(buf[b:])
	b += 4

	return b
}

// Struct list read Animcursorelt
func AnimcursoreltReadList(buf []byte, dest []Animcursorelt) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Animcursorelt{}
		b += AnimcursoreltRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Animcursorelt
func (v Animcursorelt) Bytes() []byte {
	buf := make([]byte, 8)
	b := 0

	xgb.Put32(buf[b:], uint32(v.Cursor))
	b += 4

	xgb.Put32(buf[b:], v.Delay)
	b += 4

	return buf
}

// Write struct list Animcursorelt
func AnimcursoreltListBytes(buf []byte, list []Animcursorelt) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Spanfix' struct definition
// Size: 12
type Spanfix struct {
	L Fixed
	R Fixed
	Y Fixed
}

// Struct read Spanfix
func SpanfixRead(buf []byte, v *Spanfix) int {
	b := 0

	v.L = Fixed(xgb.Get32(buf[b:]))
	b += 4

	v.R = Fixed(xgb.Get32(buf[b:]))
	b += 4

	v.Y = Fixed(xgb.Get32(buf[b:]))
	b += 4

	return b
}

// Struct list read Spanfix
func SpanfixReadList(buf []byte, dest []Spanfix) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Spanfix{}
		b += SpanfixRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Spanfix
func (v Spanfix) Bytes() []byte {
	buf := make([]byte, 12)
	b := 0

	xgb.Put32(buf[b:], uint32(v.L))
	b += 4

	xgb.Put32(buf[b:], uint32(v.R))
	b += 4

	xgb.Put32(buf[b:], uint32(v.Y))
	b += 4

	return buf
}

// Write struct list Spanfix
func SpanfixListBytes(buf []byte, list []Spanfix) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// 'Trap' struct definition
// Size: 24
type Trap struct {
	Top Spanfix
	Bot Spanfix
}

// Struct read Trap
func TrapRead(buf []byte, v *Trap) int {
	b := 0

	v.Top = Spanfix{}
	b += SpanfixRead(buf[b:], &v.Top)

	v.Bot = Spanfix{}
	b += SpanfixRead(buf[b:], &v.Bot)

	return b
}

// Struct list read Trap
func TrapReadList(buf []byte, dest []Trap) int {
	b := 0
	for i := 0; i < len(dest); i++ {
		dest[i] = Trap{}
		b += TrapRead(buf[b:], &dest[i])
	}
	return xgb.Pad(b)
}

// Struct write Trap
func (v Trap) Bytes() []byte {
	buf := make([]byte, 24)
	b := 0

	{
		structBytes := v.Top.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := v.Bot.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	return buf
}

// Write struct list Trap
func TrapListBytes(buf []byte, list []Trap) int {
	b := 0
	var structBytes []byte
	for _, item := range list {
		structBytes = item.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}
	return b
}

// Error definition PictFormat (0)
// Size: 32

const BadPictFormat = 0

type PictFormatError struct {
	Sequence uint16
	NiceName string
}

// Error read PictFormat
func PictFormatErrorNew(buf []byte) xgb.Error {
	v := PictFormatError{}
	v.NiceName = "PictFormat"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

func (err PictFormatError) ImplementsError() {}

func (err PictFormatError) SequenceId() uint16 {
	return err.Sequence
}

func (err PictFormatError) BadId() uint32 {
	return 0
}

func (err PictFormatError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadPictFormat {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["RENDER"][0] = PictFormatErrorNew
}

// Error definition Picture (1)
// Size: 32

const BadPicture = 1

type PictureError struct {
	Sequence uint16
	NiceName string
}

// Error read Picture
func PictureErrorNew(buf []byte) xgb.Error {
	v := PictureError{}
	v.NiceName = "Picture"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

func (err PictureError) ImplementsError() {}

func (err PictureError) SequenceId() uint16 {
	return err.Sequence
}

func (err PictureError) BadId() uint32 {
	return 0
}

func (err PictureError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadPicture {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["RENDER"][1] = PictureErrorNew
}

// Error definition PictOp (2)
// Size: 32

const BadPictOp = 2

type PictOpError struct {
	Sequence uint16
	NiceName string
}

// Error read PictOp
func PictOpErrorNew(buf []byte) xgb.Error {
	v := PictOpError{}
	v.NiceName = "PictOp"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

func (err PictOpError) ImplementsError() {}

func (err PictOpError) SequenceId() uint16 {
	return err.Sequence
}

func (err PictOpError) BadId() uint32 {
	return 0
}

func (err PictOpError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadPictOp {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["RENDER"][2] = PictOpErrorNew
}

// Error definition GlyphSet (3)
// Size: 32

const BadGlyphSet = 3

type GlyphSetError struct {
	Sequence uint16
	NiceName string
}

// Error read GlyphSet
func GlyphSetErrorNew(buf []byte) xgb.Error {
	v := GlyphSetError{}
	v.NiceName = "GlyphSet"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

func (err GlyphSetError) ImplementsError() {}

func (err GlyphSetError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlyphSetError) BadId() uint32 {
	return 0
}

func (err GlyphSetError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadGlyphSet {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["RENDER"][3] = GlyphSetErrorNew
}

// Error definition Glyph (4)
// Size: 32

const BadGlyph = 4

type GlyphError struct {
	Sequence uint16
	NiceName string
}

// Error read Glyph
func GlyphErrorNew(buf []byte) xgb.Error {
	v := GlyphError{}
	v.NiceName = "Glyph"

	b := 1 // skip error determinant
	b += 1 // don't read error number

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	return v
}

func (err GlyphError) ImplementsError() {}

func (err GlyphError) SequenceId() uint16 {
	return err.Sequence
}

func (err GlyphError) BadId() uint32 {
	return 0
}

func (err GlyphError) Error() string {
	fieldVals := make([]string, 0, 0)
	fieldVals = append(fieldVals, "NiceName: "+err.NiceName)
	fieldVals = append(fieldVals, xgb.Sprintf("Sequence: %d", err.Sequence))
	return "BadGlyph {" + xgb.StringsJoin(fieldVals, ", ") + "}"
}

func init() {
	xgb.NewExtErrorFuncs["RENDER"][4] = GlyphErrorNew
}

// Request QueryVersion
// size: 12
type QueryVersionCookie struct {
	*xgb.Cookie
}

func QueryVersion(c *xgb.Conn, ClientMajorVersion uint32, ClientMinorVersion uint32) QueryVersionCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryVersionRequest(c, ClientMajorVersion, ClientMinorVersion), cookie)
	return QueryVersionCookie{cookie}
}

func QueryVersionUnchecked(c *xgb.Conn, ClientMajorVersion uint32, ClientMinorVersion uint32) QueryVersionCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryVersionRequest(c, ClientMajorVersion, ClientMinorVersion), cookie)
	return QueryVersionCookie{cookie}
}

// Request reply for QueryVersion
// size: 32
type QueryVersionReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	MajorVersion uint32
	MinorVersion uint32
	// padding: 16 bytes
}

// Waits and reads reply data from request QueryVersion
func (cook QueryVersionCookie) Reply() (*QueryVersionReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryVersionReply(buf), nil
}

// Read reply into structure from buffer for QueryVersion
func queryVersionReply(buf []byte) *QueryVersionReply {
	v := new(QueryVersionReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.MajorVersion = xgb.Get32(buf[b:])
	b += 4

	v.MinorVersion = xgb.Get32(buf[b:])
	b += 4

	b += 16 // padding

	return v
}

// Write request to wire for QueryVersion
func queryVersionRequest(c *xgb.Conn, ClientMajorVersion uint32, ClientMinorVersion uint32) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 0 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], ClientMajorVersion)
	b += 4

	xgb.Put32(buf[b:], ClientMinorVersion)
	b += 4

	return buf
}

// Request QueryPictFormats
// size: 4
type QueryPictFormatsCookie struct {
	*xgb.Cookie
}

func QueryPictFormats(c *xgb.Conn) QueryPictFormatsCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryPictFormatsRequest(c), cookie)
	return QueryPictFormatsCookie{cookie}
}

func QueryPictFormatsUnchecked(c *xgb.Conn) QueryPictFormatsCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryPictFormatsRequest(c), cookie)
	return QueryPictFormatsCookie{cookie}
}

// Request reply for QueryPictFormats
// size: (((32 + xgb.Pad((int(NumFormats) * 28))) + PictscreenListSize(Screens)) + xgb.Pad((int(NumSubpixel) * 4)))
type QueryPictFormatsReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumFormats  uint32
	NumScreens  uint32
	NumDepths   uint32
	NumVisuals  uint32
	NumSubpixel uint32
	// padding: 4 bytes
	Formats   []Pictforminfo // size: xgb.Pad((int(NumFormats) * 28))
	Screens   []Pictscreen   // size: PictscreenListSize(Screens)
	Subpixels []uint32       // size: xgb.Pad((int(NumSubpixel) * 4))
}

// Waits and reads reply data from request QueryPictFormats
func (cook QueryPictFormatsCookie) Reply() (*QueryPictFormatsReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryPictFormatsReply(buf), nil
}

// Read reply into structure from buffer for QueryPictFormats
func queryPictFormatsReply(buf []byte) *QueryPictFormatsReply {
	v := new(QueryPictFormatsReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumFormats = xgb.Get32(buf[b:])
	b += 4

	v.NumScreens = xgb.Get32(buf[b:])
	b += 4

	v.NumDepths = xgb.Get32(buf[b:])
	b += 4

	v.NumVisuals = xgb.Get32(buf[b:])
	b += 4

	v.NumSubpixel = xgb.Get32(buf[b:])
	b += 4

	b += 4 // padding

	v.Formats = make([]Pictforminfo, v.NumFormats)
	b += PictforminfoReadList(buf[b:], v.Formats)

	v.Screens = make([]Pictscreen, v.NumScreens)
	b += PictscreenReadList(buf[b:], v.Screens)

	v.Subpixels = make([]uint32, v.NumSubpixel)
	for i := 0; i < int(v.NumSubpixel); i++ {
		v.Subpixels[i] = xgb.Get32(buf[b:])
		b += 4
	}
	b = xgb.Pad(b)

	return v
}

// Write request to wire for QueryPictFormats
func queryPictFormatsRequest(c *xgb.Conn) []byte {
	size := 4
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 1 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	return buf
}

// Request QueryPictIndexValues
// size: 8
type QueryPictIndexValuesCookie struct {
	*xgb.Cookie
}

func QueryPictIndexValues(c *xgb.Conn, Format Pictformat) QueryPictIndexValuesCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryPictIndexValuesRequest(c, Format), cookie)
	return QueryPictIndexValuesCookie{cookie}
}

func QueryPictIndexValuesUnchecked(c *xgb.Conn, Format Pictformat) QueryPictIndexValuesCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryPictIndexValuesRequest(c, Format), cookie)
	return QueryPictIndexValuesCookie{cookie}
}

// Request reply for QueryPictIndexValues
// size: (32 + xgb.Pad((int(NumValues) * 12)))
type QueryPictIndexValuesReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumValues uint32
	// padding: 20 bytes
	Values []Indexvalue // size: xgb.Pad((int(NumValues) * 12))
}

// Waits and reads reply data from request QueryPictIndexValues
func (cook QueryPictIndexValuesCookie) Reply() (*QueryPictIndexValuesReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryPictIndexValuesReply(buf), nil
}

// Read reply into structure from buffer for QueryPictIndexValues
func queryPictIndexValuesReply(buf []byte) *QueryPictIndexValuesReply {
	v := new(QueryPictIndexValuesReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumValues = xgb.Get32(buf[b:])
	b += 4

	b += 20 // padding

	v.Values = make([]Indexvalue, v.NumValues)
	b += IndexvalueReadList(buf[b:], v.Values)

	return v
}

// Write request to wire for QueryPictIndexValues
func queryPictIndexValuesRequest(c *xgb.Conn, Format Pictformat) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 2 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Format))
	b += 4

	return buf
}

// Request CreatePicture
// size: xgb.Pad((16 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
type CreatePictureCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreatePicture
func CreatePicture(c *xgb.Conn, Pid Picture, Drawable xproto.Drawable, Format Pictformat, ValueMask uint32, ValueList []uint32) CreatePictureCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createPictureRequest(c, Pid, Drawable, Format, ValueMask, ValueList), cookie)
	return CreatePictureCookie{cookie}
}

func CreatePictureChecked(c *xgb.Conn, Pid Picture, Drawable xproto.Drawable, Format Pictformat, ValueMask uint32, ValueList []uint32) CreatePictureCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createPictureRequest(c, Pid, Drawable, Format, ValueMask, ValueList), cookie)
	return CreatePictureCookie{cookie}
}

func (cook CreatePictureCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreatePicture
func createPictureRequest(c *xgb.Conn, Pid Picture, Drawable xproto.Drawable, Format Pictformat, ValueMask uint32, ValueList []uint32) []byte {
	size := xgb.Pad((16 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 4 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Pid))
	b += 4

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	xgb.Put32(buf[b:], uint32(Format))
	b += 4

	xgb.Put32(buf[b:], ValueMask)
	b += 4
	for i := 0; i < xgb.PopCount(int(ValueMask)); i++ {
		xgb.Put32(buf[b:], ValueList[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request ChangePicture
// size: xgb.Pad((8 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
type ChangePictureCookie struct {
	*xgb.Cookie
}

// Write request to wire for ChangePicture
func ChangePicture(c *xgb.Conn, Picture Picture, ValueMask uint32, ValueList []uint32) ChangePictureCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(changePictureRequest(c, Picture, ValueMask, ValueList), cookie)
	return ChangePictureCookie{cookie}
}

func ChangePictureChecked(c *xgb.Conn, Picture Picture, ValueMask uint32, ValueList []uint32) ChangePictureCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(changePictureRequest(c, Picture, ValueMask, ValueList), cookie)
	return ChangePictureCookie{cookie}
}

func (cook ChangePictureCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ChangePicture
func changePictureRequest(c *xgb.Conn, Picture Picture, ValueMask uint32, ValueList []uint32) []byte {
	size := xgb.Pad((8 + (4 + xgb.Pad((4 * xgb.PopCount(int(ValueMask)))))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 5 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Picture))
	b += 4

	xgb.Put32(buf[b:], ValueMask)
	b += 4
	for i := 0; i < xgb.PopCount(int(ValueMask)); i++ {
		xgb.Put32(buf[b:], ValueList[i])
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request SetPictureClipRectangles
// size: xgb.Pad((12 + xgb.Pad((len(Rectangles) * 8))))
type SetPictureClipRectanglesCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetPictureClipRectangles
func SetPictureClipRectangles(c *xgb.Conn, Picture Picture, ClipXOrigin int16, ClipYOrigin int16, Rectangles []xproto.Rectangle) SetPictureClipRectanglesCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setPictureClipRectanglesRequest(c, Picture, ClipXOrigin, ClipYOrigin, Rectangles), cookie)
	return SetPictureClipRectanglesCookie{cookie}
}

func SetPictureClipRectanglesChecked(c *xgb.Conn, Picture Picture, ClipXOrigin int16, ClipYOrigin int16, Rectangles []xproto.Rectangle) SetPictureClipRectanglesCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setPictureClipRectanglesRequest(c, Picture, ClipXOrigin, ClipYOrigin, Rectangles), cookie)
	return SetPictureClipRectanglesCookie{cookie}
}

func (cook SetPictureClipRectanglesCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetPictureClipRectangles
func setPictureClipRectanglesRequest(c *xgb.Conn, Picture Picture, ClipXOrigin int16, ClipYOrigin int16, Rectangles []xproto.Rectangle) []byte {
	size := xgb.Pad((12 + xgb.Pad((len(Rectangles) * 8))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 6 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Picture))
	b += 4

	xgb.Put16(buf[b:], uint16(ClipXOrigin))
	b += 2

	xgb.Put16(buf[b:], uint16(ClipYOrigin))
	b += 2

	b += xproto.RectangleListBytes(buf[b:], Rectangles)

	return buf
}

// Request FreePicture
// size: 8
type FreePictureCookie struct {
	*xgb.Cookie
}

// Write request to wire for FreePicture
func FreePicture(c *xgb.Conn, Picture Picture) FreePictureCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(freePictureRequest(c, Picture), cookie)
	return FreePictureCookie{cookie}
}

func FreePictureChecked(c *xgb.Conn, Picture Picture) FreePictureCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(freePictureRequest(c, Picture), cookie)
	return FreePictureCookie{cookie}
}

func (cook FreePictureCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for FreePicture
func freePictureRequest(c *xgb.Conn, Picture Picture) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 7 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Picture))
	b += 4

	return buf
}

// Request Composite
// size: 36
type CompositeCookie struct {
	*xgb.Cookie
}

// Write request to wire for Composite
func Composite(c *xgb.Conn, Op byte, Src Picture, Mask Picture, Dst Picture, SrcX int16, SrcY int16, MaskX int16, MaskY int16, DstX int16, DstY int16, Width uint16, Height uint16) CompositeCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(compositeRequest(c, Op, Src, Mask, Dst, SrcX, SrcY, MaskX, MaskY, DstX, DstY, Width, Height), cookie)
	return CompositeCookie{cookie}
}

func CompositeChecked(c *xgb.Conn, Op byte, Src Picture, Mask Picture, Dst Picture, SrcX int16, SrcY int16, MaskX int16, MaskY int16, DstX int16, DstY int16, Width uint16, Height uint16) CompositeCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(compositeRequest(c, Op, Src, Mask, Dst, SrcX, SrcY, MaskX, MaskY, DstX, DstY, Width, Height), cookie)
	return CompositeCookie{cookie}
}

func (cook CompositeCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for Composite
func compositeRequest(c *xgb.Conn, Op byte, Src Picture, Mask Picture, Dst Picture, SrcX int16, SrcY int16, MaskX int16, MaskY int16, DstX int16, DstY int16, Width uint16, Height uint16) []byte {
	size := 36
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 8 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = Op
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], uint32(Src))
	b += 4

	xgb.Put32(buf[b:], uint32(Mask))
	b += 4

	xgb.Put32(buf[b:], uint32(Dst))
	b += 4

	xgb.Put16(buf[b:], uint16(SrcX))
	b += 2

	xgb.Put16(buf[b:], uint16(SrcY))
	b += 2

	xgb.Put16(buf[b:], uint16(MaskX))
	b += 2

	xgb.Put16(buf[b:], uint16(MaskY))
	b += 2

	xgb.Put16(buf[b:], uint16(DstX))
	b += 2

	xgb.Put16(buf[b:], uint16(DstY))
	b += 2

	xgb.Put16(buf[b:], Width)
	b += 2

	xgb.Put16(buf[b:], Height)
	b += 2

	return buf
}

// Request Trapezoids
// size: xgb.Pad((24 + xgb.Pad((len(Traps) * 40))))
type TrapezoidsCookie struct {
	*xgb.Cookie
}

// Write request to wire for Trapezoids
func Trapezoids(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, SrcX int16, SrcY int16, Traps []Trapezoid) TrapezoidsCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(trapezoidsRequest(c, Op, Src, Dst, MaskFormat, SrcX, SrcY, Traps), cookie)
	return TrapezoidsCookie{cookie}
}

func TrapezoidsChecked(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, SrcX int16, SrcY int16, Traps []Trapezoid) TrapezoidsCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(trapezoidsRequest(c, Op, Src, Dst, MaskFormat, SrcX, SrcY, Traps), cookie)
	return TrapezoidsCookie{cookie}
}

func (cook TrapezoidsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for Trapezoids
func trapezoidsRequest(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, SrcX int16, SrcY int16, Traps []Trapezoid) []byte {
	size := xgb.Pad((24 + xgb.Pad((len(Traps) * 40))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 10 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = Op
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], uint32(Src))
	b += 4

	xgb.Put32(buf[b:], uint32(Dst))
	b += 4

	xgb.Put32(buf[b:], uint32(MaskFormat))
	b += 4

	xgb.Put16(buf[b:], uint16(SrcX))
	b += 2

	xgb.Put16(buf[b:], uint16(SrcY))
	b += 2

	b += TrapezoidListBytes(buf[b:], Traps)

	return buf
}

// Request Triangles
// size: xgb.Pad((24 + xgb.Pad((len(Triangles) * 24))))
type TrianglesCookie struct {
	*xgb.Cookie
}

// Write request to wire for Triangles
func Triangles(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, SrcX int16, SrcY int16, Triangles []Triangle) TrianglesCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(trianglesRequest(c, Op, Src, Dst, MaskFormat, SrcX, SrcY, Triangles), cookie)
	return TrianglesCookie{cookie}
}

func TrianglesChecked(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, SrcX int16, SrcY int16, Triangles []Triangle) TrianglesCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(trianglesRequest(c, Op, Src, Dst, MaskFormat, SrcX, SrcY, Triangles), cookie)
	return TrianglesCookie{cookie}
}

func (cook TrianglesCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for Triangles
func trianglesRequest(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, SrcX int16, SrcY int16, Triangles []Triangle) []byte {
	size := xgb.Pad((24 + xgb.Pad((len(Triangles) * 24))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 11 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = Op
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], uint32(Src))
	b += 4

	xgb.Put32(buf[b:], uint32(Dst))
	b += 4

	xgb.Put32(buf[b:], uint32(MaskFormat))
	b += 4

	xgb.Put16(buf[b:], uint16(SrcX))
	b += 2

	xgb.Put16(buf[b:], uint16(SrcY))
	b += 2

	b += TriangleListBytes(buf[b:], Triangles)

	return buf
}

// Request TriStrip
// size: xgb.Pad((24 + xgb.Pad((len(Points) * 8))))
type TriStripCookie struct {
	*xgb.Cookie
}

// Write request to wire for TriStrip
func TriStrip(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, SrcX int16, SrcY int16, Points []Pointfix) TriStripCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(triStripRequest(c, Op, Src, Dst, MaskFormat, SrcX, SrcY, Points), cookie)
	return TriStripCookie{cookie}
}

func TriStripChecked(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, SrcX int16, SrcY int16, Points []Pointfix) TriStripCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(triStripRequest(c, Op, Src, Dst, MaskFormat, SrcX, SrcY, Points), cookie)
	return TriStripCookie{cookie}
}

func (cook TriStripCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for TriStrip
func triStripRequest(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, SrcX int16, SrcY int16, Points []Pointfix) []byte {
	size := xgb.Pad((24 + xgb.Pad((len(Points) * 8))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 12 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = Op
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], uint32(Src))
	b += 4

	xgb.Put32(buf[b:], uint32(Dst))
	b += 4

	xgb.Put32(buf[b:], uint32(MaskFormat))
	b += 4

	xgb.Put16(buf[b:], uint16(SrcX))
	b += 2

	xgb.Put16(buf[b:], uint16(SrcY))
	b += 2

	b += PointfixListBytes(buf[b:], Points)

	return buf
}

// Request TriFan
// size: xgb.Pad((24 + xgb.Pad((len(Points) * 8))))
type TriFanCookie struct {
	*xgb.Cookie
}

// Write request to wire for TriFan
func TriFan(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, SrcX int16, SrcY int16, Points []Pointfix) TriFanCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(triFanRequest(c, Op, Src, Dst, MaskFormat, SrcX, SrcY, Points), cookie)
	return TriFanCookie{cookie}
}

func TriFanChecked(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, SrcX int16, SrcY int16, Points []Pointfix) TriFanCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(triFanRequest(c, Op, Src, Dst, MaskFormat, SrcX, SrcY, Points), cookie)
	return TriFanCookie{cookie}
}

func (cook TriFanCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for TriFan
func triFanRequest(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, SrcX int16, SrcY int16, Points []Pointfix) []byte {
	size := xgb.Pad((24 + xgb.Pad((len(Points) * 8))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 13 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = Op
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], uint32(Src))
	b += 4

	xgb.Put32(buf[b:], uint32(Dst))
	b += 4

	xgb.Put32(buf[b:], uint32(MaskFormat))
	b += 4

	xgb.Put16(buf[b:], uint16(SrcX))
	b += 2

	xgb.Put16(buf[b:], uint16(SrcY))
	b += 2

	b += PointfixListBytes(buf[b:], Points)

	return buf
}

// Request CreateGlyphSet
// size: 12
type CreateGlyphSetCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateGlyphSet
func CreateGlyphSet(c *xgb.Conn, Gsid Glyphset, Format Pictformat) CreateGlyphSetCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createGlyphSetRequest(c, Gsid, Format), cookie)
	return CreateGlyphSetCookie{cookie}
}

func CreateGlyphSetChecked(c *xgb.Conn, Gsid Glyphset, Format Pictformat) CreateGlyphSetCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createGlyphSetRequest(c, Gsid, Format), cookie)
	return CreateGlyphSetCookie{cookie}
}

func (cook CreateGlyphSetCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateGlyphSet
func createGlyphSetRequest(c *xgb.Conn, Gsid Glyphset, Format Pictformat) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 17 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Gsid))
	b += 4

	xgb.Put32(buf[b:], uint32(Format))
	b += 4

	return buf
}

// Request ReferenceGlyphSet
// size: 12
type ReferenceGlyphSetCookie struct {
	*xgb.Cookie
}

// Write request to wire for ReferenceGlyphSet
func ReferenceGlyphSet(c *xgb.Conn, Gsid Glyphset, Existing Glyphset) ReferenceGlyphSetCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(referenceGlyphSetRequest(c, Gsid, Existing), cookie)
	return ReferenceGlyphSetCookie{cookie}
}

func ReferenceGlyphSetChecked(c *xgb.Conn, Gsid Glyphset, Existing Glyphset) ReferenceGlyphSetCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(referenceGlyphSetRequest(c, Gsid, Existing), cookie)
	return ReferenceGlyphSetCookie{cookie}
}

func (cook ReferenceGlyphSetCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for ReferenceGlyphSet
func referenceGlyphSetRequest(c *xgb.Conn, Gsid Glyphset, Existing Glyphset) []byte {
	size := 12
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 18 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Gsid))
	b += 4

	xgb.Put32(buf[b:], uint32(Existing))
	b += 4

	return buf
}

// Request FreeGlyphSet
// size: 8
type FreeGlyphSetCookie struct {
	*xgb.Cookie
}

// Write request to wire for FreeGlyphSet
func FreeGlyphSet(c *xgb.Conn, Glyphset Glyphset) FreeGlyphSetCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(freeGlyphSetRequest(c, Glyphset), cookie)
	return FreeGlyphSetCookie{cookie}
}

func FreeGlyphSetChecked(c *xgb.Conn, Glyphset Glyphset) FreeGlyphSetCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(freeGlyphSetRequest(c, Glyphset), cookie)
	return FreeGlyphSetCookie{cookie}
}

func (cook FreeGlyphSetCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for FreeGlyphSet
func freeGlyphSetRequest(c *xgb.Conn, Glyphset Glyphset) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 19 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Glyphset))
	b += 4

	return buf
}

// Request AddGlyphs
// size: xgb.Pad((((12 + xgb.Pad((int(GlyphsLen) * 4))) + xgb.Pad((int(GlyphsLen) * 12))) + xgb.Pad((len(Data) * 1))))
type AddGlyphsCookie struct {
	*xgb.Cookie
}

// Write request to wire for AddGlyphs
func AddGlyphs(c *xgb.Conn, Glyphset Glyphset, GlyphsLen uint32, Glyphids []uint32, Glyphs []Glyphinfo, Data []byte) AddGlyphsCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(addGlyphsRequest(c, Glyphset, GlyphsLen, Glyphids, Glyphs, Data), cookie)
	return AddGlyphsCookie{cookie}
}

func AddGlyphsChecked(c *xgb.Conn, Glyphset Glyphset, GlyphsLen uint32, Glyphids []uint32, Glyphs []Glyphinfo, Data []byte) AddGlyphsCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(addGlyphsRequest(c, Glyphset, GlyphsLen, Glyphids, Glyphs, Data), cookie)
	return AddGlyphsCookie{cookie}
}

func (cook AddGlyphsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for AddGlyphs
func addGlyphsRequest(c *xgb.Conn, Glyphset Glyphset, GlyphsLen uint32, Glyphids []uint32, Glyphs []Glyphinfo, Data []byte) []byte {
	size := xgb.Pad((((12 + xgb.Pad((int(GlyphsLen) * 4))) + xgb.Pad((int(GlyphsLen) * 12))) + xgb.Pad((len(Data) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 20 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Glyphset))
	b += 4

	xgb.Put32(buf[b:], GlyphsLen)
	b += 4

	for i := 0; i < int(GlyphsLen); i++ {
		xgb.Put32(buf[b:], Glyphids[i])
		b += 4
	}
	b = xgb.Pad(b)

	b += GlyphinfoListBytes(buf[b:], Glyphs)

	copy(buf[b:], Data[:len(Data)])
	b += xgb.Pad(int(len(Data)))

	return buf
}

// Request FreeGlyphs
// size: xgb.Pad((8 + xgb.Pad((len(Glyphs) * 4))))
type FreeGlyphsCookie struct {
	*xgb.Cookie
}

// Write request to wire for FreeGlyphs
func FreeGlyphs(c *xgb.Conn, Glyphset Glyphset, Glyphs []Glyph) FreeGlyphsCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(freeGlyphsRequest(c, Glyphset, Glyphs), cookie)
	return FreeGlyphsCookie{cookie}
}

func FreeGlyphsChecked(c *xgb.Conn, Glyphset Glyphset, Glyphs []Glyph) FreeGlyphsCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(freeGlyphsRequest(c, Glyphset, Glyphs), cookie)
	return FreeGlyphsCookie{cookie}
}

func (cook FreeGlyphsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for FreeGlyphs
func freeGlyphsRequest(c *xgb.Conn, Glyphset Glyphset, Glyphs []Glyph) []byte {
	size := xgb.Pad((8 + xgb.Pad((len(Glyphs) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 22 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Glyphset))
	b += 4

	for i := 0; i < int(len(Glyphs)); i++ {
		xgb.Put32(buf[b:], uint32(Glyphs[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request CompositeGlyphs8
// size: xgb.Pad((28 + xgb.Pad((len(Glyphcmds) * 1))))
type CompositeGlyphs8Cookie struct {
	*xgb.Cookie
}

// Write request to wire for CompositeGlyphs8
func CompositeGlyphs8(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, Glyphset Glyphset, SrcX int16, SrcY int16, Glyphcmds []byte) CompositeGlyphs8Cookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(compositeGlyphs8Request(c, Op, Src, Dst, MaskFormat, Glyphset, SrcX, SrcY, Glyphcmds), cookie)
	return CompositeGlyphs8Cookie{cookie}
}

func CompositeGlyphs8Checked(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, Glyphset Glyphset, SrcX int16, SrcY int16, Glyphcmds []byte) CompositeGlyphs8Cookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(compositeGlyphs8Request(c, Op, Src, Dst, MaskFormat, Glyphset, SrcX, SrcY, Glyphcmds), cookie)
	return CompositeGlyphs8Cookie{cookie}
}

func (cook CompositeGlyphs8Cookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CompositeGlyphs8
func compositeGlyphs8Request(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, Glyphset Glyphset, SrcX int16, SrcY int16, Glyphcmds []byte) []byte {
	size := xgb.Pad((28 + xgb.Pad((len(Glyphcmds) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 23 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = Op
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], uint32(Src))
	b += 4

	xgb.Put32(buf[b:], uint32(Dst))
	b += 4

	xgb.Put32(buf[b:], uint32(MaskFormat))
	b += 4

	xgb.Put32(buf[b:], uint32(Glyphset))
	b += 4

	xgb.Put16(buf[b:], uint16(SrcX))
	b += 2

	xgb.Put16(buf[b:], uint16(SrcY))
	b += 2

	copy(buf[b:], Glyphcmds[:len(Glyphcmds)])
	b += xgb.Pad(int(len(Glyphcmds)))

	return buf
}

// Request CompositeGlyphs16
// size: xgb.Pad((28 + xgb.Pad((len(Glyphcmds) * 1))))
type CompositeGlyphs16Cookie struct {
	*xgb.Cookie
}

// Write request to wire for CompositeGlyphs16
func CompositeGlyphs16(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, Glyphset Glyphset, SrcX int16, SrcY int16, Glyphcmds []byte) CompositeGlyphs16Cookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(compositeGlyphs16Request(c, Op, Src, Dst, MaskFormat, Glyphset, SrcX, SrcY, Glyphcmds), cookie)
	return CompositeGlyphs16Cookie{cookie}
}

func CompositeGlyphs16Checked(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, Glyphset Glyphset, SrcX int16, SrcY int16, Glyphcmds []byte) CompositeGlyphs16Cookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(compositeGlyphs16Request(c, Op, Src, Dst, MaskFormat, Glyphset, SrcX, SrcY, Glyphcmds), cookie)
	return CompositeGlyphs16Cookie{cookie}
}

func (cook CompositeGlyphs16Cookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CompositeGlyphs16
func compositeGlyphs16Request(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, Glyphset Glyphset, SrcX int16, SrcY int16, Glyphcmds []byte) []byte {
	size := xgb.Pad((28 + xgb.Pad((len(Glyphcmds) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 24 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = Op
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], uint32(Src))
	b += 4

	xgb.Put32(buf[b:], uint32(Dst))
	b += 4

	xgb.Put32(buf[b:], uint32(MaskFormat))
	b += 4

	xgb.Put32(buf[b:], uint32(Glyphset))
	b += 4

	xgb.Put16(buf[b:], uint16(SrcX))
	b += 2

	xgb.Put16(buf[b:], uint16(SrcY))
	b += 2

	copy(buf[b:], Glyphcmds[:len(Glyphcmds)])
	b += xgb.Pad(int(len(Glyphcmds)))

	return buf
}

// Request CompositeGlyphs32
// size: xgb.Pad((28 + xgb.Pad((len(Glyphcmds) * 1))))
type CompositeGlyphs32Cookie struct {
	*xgb.Cookie
}

// Write request to wire for CompositeGlyphs32
func CompositeGlyphs32(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, Glyphset Glyphset, SrcX int16, SrcY int16, Glyphcmds []byte) CompositeGlyphs32Cookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(compositeGlyphs32Request(c, Op, Src, Dst, MaskFormat, Glyphset, SrcX, SrcY, Glyphcmds), cookie)
	return CompositeGlyphs32Cookie{cookie}
}

func CompositeGlyphs32Checked(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, Glyphset Glyphset, SrcX int16, SrcY int16, Glyphcmds []byte) CompositeGlyphs32Cookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(compositeGlyphs32Request(c, Op, Src, Dst, MaskFormat, Glyphset, SrcX, SrcY, Glyphcmds), cookie)
	return CompositeGlyphs32Cookie{cookie}
}

func (cook CompositeGlyphs32Cookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CompositeGlyphs32
func compositeGlyphs32Request(c *xgb.Conn, Op byte, Src Picture, Dst Picture, MaskFormat Pictformat, Glyphset Glyphset, SrcX int16, SrcY int16, Glyphcmds []byte) []byte {
	size := xgb.Pad((28 + xgb.Pad((len(Glyphcmds) * 1))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 25 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = Op
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], uint32(Src))
	b += 4

	xgb.Put32(buf[b:], uint32(Dst))
	b += 4

	xgb.Put32(buf[b:], uint32(MaskFormat))
	b += 4

	xgb.Put32(buf[b:], uint32(Glyphset))
	b += 4

	xgb.Put16(buf[b:], uint16(SrcX))
	b += 2

	xgb.Put16(buf[b:], uint16(SrcY))
	b += 2

	copy(buf[b:], Glyphcmds[:len(Glyphcmds)])
	b += xgb.Pad(int(len(Glyphcmds)))

	return buf
}

// Request FillRectangles
// size: xgb.Pad((20 + xgb.Pad((len(Rects) * 8))))
type FillRectanglesCookie struct {
	*xgb.Cookie
}

// Write request to wire for FillRectangles
func FillRectangles(c *xgb.Conn, Op byte, Dst Picture, Color Color, Rects []xproto.Rectangle) FillRectanglesCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(fillRectanglesRequest(c, Op, Dst, Color, Rects), cookie)
	return FillRectanglesCookie{cookie}
}

func FillRectanglesChecked(c *xgb.Conn, Op byte, Dst Picture, Color Color, Rects []xproto.Rectangle) FillRectanglesCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(fillRectanglesRequest(c, Op, Dst, Color, Rects), cookie)
	return FillRectanglesCookie{cookie}
}

func (cook FillRectanglesCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for FillRectangles
func fillRectanglesRequest(c *xgb.Conn, Op byte, Dst Picture, Color Color, Rects []xproto.Rectangle) []byte {
	size := xgb.Pad((20 + xgb.Pad((len(Rects) * 8))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 26 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	buf[b] = Op
	b += 1

	b += 3 // padding

	xgb.Put32(buf[b:], uint32(Dst))
	b += 4

	{
		structBytes := Color.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	b += xproto.RectangleListBytes(buf[b:], Rects)

	return buf
}

// Request CreateCursor
// size: 16
type CreateCursorCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateCursor
func CreateCursor(c *xgb.Conn, Cid xproto.Cursor, Source Picture, X uint16, Y uint16) CreateCursorCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createCursorRequest(c, Cid, Source, X, Y), cookie)
	return CreateCursorCookie{cookie}
}

func CreateCursorChecked(c *xgb.Conn, Cid xproto.Cursor, Source Picture, X uint16, Y uint16) CreateCursorCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createCursorRequest(c, Cid, Source, X, Y), cookie)
	return CreateCursorCookie{cookie}
}

func (cook CreateCursorCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateCursor
func createCursorRequest(c *xgb.Conn, Cid xproto.Cursor, Source Picture, X uint16, Y uint16) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 27 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cid))
	b += 4

	xgb.Put32(buf[b:], uint32(Source))
	b += 4

	xgb.Put16(buf[b:], X)
	b += 2

	xgb.Put16(buf[b:], Y)
	b += 2

	return buf
}

// Request SetPictureTransform
// size: 44
type SetPictureTransformCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetPictureTransform
func SetPictureTransform(c *xgb.Conn, Picture Picture, Transform Transform) SetPictureTransformCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setPictureTransformRequest(c, Picture, Transform), cookie)
	return SetPictureTransformCookie{cookie}
}

func SetPictureTransformChecked(c *xgb.Conn, Picture Picture, Transform Transform) SetPictureTransformCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setPictureTransformRequest(c, Picture, Transform), cookie)
	return SetPictureTransformCookie{cookie}
}

func (cook SetPictureTransformCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetPictureTransform
func setPictureTransformRequest(c *xgb.Conn, Picture Picture, Transform Transform) []byte {
	size := 44
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 28 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Picture))
	b += 4

	{
		structBytes := Transform.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	return buf
}

// Request QueryFilters
// size: 8
type QueryFiltersCookie struct {
	*xgb.Cookie
}

func QueryFilters(c *xgb.Conn, Drawable xproto.Drawable) QueryFiltersCookie {
	cookie := c.NewCookie(true, true)
	c.NewRequest(queryFiltersRequest(c, Drawable), cookie)
	return QueryFiltersCookie{cookie}
}

func QueryFiltersUnchecked(c *xgb.Conn, Drawable xproto.Drawable) QueryFiltersCookie {
	cookie := c.NewCookie(false, true)
	c.NewRequest(queryFiltersRequest(c, Drawable), cookie)
	return QueryFiltersCookie{cookie}
}

// Request reply for QueryFilters
// size: ((32 + xgb.Pad((int(NumAliases) * 2))) + xproto.StrListSize(Filters))
type QueryFiltersReply struct {
	Sequence uint16
	Length   uint32
	// padding: 1 bytes
	NumAliases uint32
	NumFilters uint32
	// padding: 16 bytes
	Aliases []uint16     // size: xgb.Pad((int(NumAliases) * 2))
	Filters []xproto.Str // size: xproto.StrListSize(Filters)
}

// Waits and reads reply data from request QueryFilters
func (cook QueryFiltersCookie) Reply() (*QueryFiltersReply, error) {
	buf, err := cook.Cookie.Reply()
	if err != nil {
		return nil, err
	}
	if buf == nil {
		return nil, nil
	}
	return queryFiltersReply(buf), nil
}

// Read reply into structure from buffer for QueryFilters
func queryFiltersReply(buf []byte) *QueryFiltersReply {
	v := new(QueryFiltersReply)
	b := 1 // skip reply determinant

	b += 1 // padding

	v.Sequence = xgb.Get16(buf[b:])
	b += 2

	v.Length = xgb.Get32(buf[b:]) // 4-byte units
	b += 4

	v.NumAliases = xgb.Get32(buf[b:])
	b += 4

	v.NumFilters = xgb.Get32(buf[b:])
	b += 4

	b += 16 // padding

	v.Aliases = make([]uint16, v.NumAliases)
	for i := 0; i < int(v.NumAliases); i++ {
		v.Aliases[i] = xgb.Get16(buf[b:])
		b += 2
	}
	b = xgb.Pad(b)

	v.Filters = make([]xproto.Str, v.NumFilters)
	b += xproto.StrReadList(buf[b:], v.Filters)

	return v
}

// Write request to wire for QueryFilters
func queryFiltersRequest(c *xgb.Conn, Drawable xproto.Drawable) []byte {
	size := 8
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 29 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Drawable))
	b += 4

	return buf
}

// Request SetPictureFilter
// size: xgb.Pad(((12 + xgb.Pad((int(FilterLen) * 1))) + xgb.Pad((len(Values) * 4))))
type SetPictureFilterCookie struct {
	*xgb.Cookie
}

// Write request to wire for SetPictureFilter
func SetPictureFilter(c *xgb.Conn, Picture Picture, FilterLen uint16, Filter string, Values []Fixed) SetPictureFilterCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(setPictureFilterRequest(c, Picture, FilterLen, Filter, Values), cookie)
	return SetPictureFilterCookie{cookie}
}

func SetPictureFilterChecked(c *xgb.Conn, Picture Picture, FilterLen uint16, Filter string, Values []Fixed) SetPictureFilterCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(setPictureFilterRequest(c, Picture, FilterLen, Filter, Values), cookie)
	return SetPictureFilterCookie{cookie}
}

func (cook SetPictureFilterCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for SetPictureFilter
func setPictureFilterRequest(c *xgb.Conn, Picture Picture, FilterLen uint16, Filter string, Values []Fixed) []byte {
	size := xgb.Pad(((12 + xgb.Pad((int(FilterLen) * 1))) + xgb.Pad((len(Values) * 4))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 30 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Picture))
	b += 4

	xgb.Put16(buf[b:], FilterLen)
	b += 2

	b += 2 // padding

	copy(buf[b:], Filter[:FilterLen])
	b += xgb.Pad(int(FilterLen))

	for i := 0; i < int(len(Values)); i++ {
		xgb.Put32(buf[b:], uint32(Values[i]))
		b += 4
	}
	b = xgb.Pad(b)

	return buf
}

// Request CreateAnimCursor
// size: xgb.Pad((8 + xgb.Pad((len(Cursors) * 8))))
type CreateAnimCursorCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateAnimCursor
func CreateAnimCursor(c *xgb.Conn, Cid xproto.Cursor, Cursors []Animcursorelt) CreateAnimCursorCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createAnimCursorRequest(c, Cid, Cursors), cookie)
	return CreateAnimCursorCookie{cookie}
}

func CreateAnimCursorChecked(c *xgb.Conn, Cid xproto.Cursor, Cursors []Animcursorelt) CreateAnimCursorCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createAnimCursorRequest(c, Cid, Cursors), cookie)
	return CreateAnimCursorCookie{cookie}
}

func (cook CreateAnimCursorCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateAnimCursor
func createAnimCursorRequest(c *xgb.Conn, Cid xproto.Cursor, Cursors []Animcursorelt) []byte {
	size := xgb.Pad((8 + xgb.Pad((len(Cursors) * 8))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 31 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Cid))
	b += 4

	b += AnimcursoreltListBytes(buf[b:], Cursors)

	return buf
}

// Request AddTraps
// size: xgb.Pad((12 + xgb.Pad((len(Traps) * 24))))
type AddTrapsCookie struct {
	*xgb.Cookie
}

// Write request to wire for AddTraps
func AddTraps(c *xgb.Conn, Picture Picture, XOff int16, YOff int16, Traps []Trap) AddTrapsCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(addTrapsRequest(c, Picture, XOff, YOff, Traps), cookie)
	return AddTrapsCookie{cookie}
}

func AddTrapsChecked(c *xgb.Conn, Picture Picture, XOff int16, YOff int16, Traps []Trap) AddTrapsCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(addTrapsRequest(c, Picture, XOff, YOff, Traps), cookie)
	return AddTrapsCookie{cookie}
}

func (cook AddTrapsCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for AddTraps
func addTrapsRequest(c *xgb.Conn, Picture Picture, XOff int16, YOff int16, Traps []Trap) []byte {
	size := xgb.Pad((12 + xgb.Pad((len(Traps) * 24))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 32 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Picture))
	b += 4

	xgb.Put16(buf[b:], uint16(XOff))
	b += 2

	xgb.Put16(buf[b:], uint16(YOff))
	b += 2

	b += TrapListBytes(buf[b:], Traps)

	return buf
}

// Request CreateSolidFill
// size: 16
type CreateSolidFillCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateSolidFill
func CreateSolidFill(c *xgb.Conn, Picture Picture, Color Color) CreateSolidFillCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createSolidFillRequest(c, Picture, Color), cookie)
	return CreateSolidFillCookie{cookie}
}

func CreateSolidFillChecked(c *xgb.Conn, Picture Picture, Color Color) CreateSolidFillCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createSolidFillRequest(c, Picture, Color), cookie)
	return CreateSolidFillCookie{cookie}
}

func (cook CreateSolidFillCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateSolidFill
func createSolidFillRequest(c *xgb.Conn, Picture Picture, Color Color) []byte {
	size := 16
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 33 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Picture))
	b += 4

	{
		structBytes := Color.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	return buf
}

// Request CreateLinearGradient
// size: xgb.Pad(((28 + xgb.Pad((int(NumStops) * 4))) + xgb.Pad((int(NumStops) * 8))))
type CreateLinearGradientCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateLinearGradient
func CreateLinearGradient(c *xgb.Conn, Picture Picture, P1 Pointfix, P2 Pointfix, NumStops uint32, Stops []Fixed, Colors []Color) CreateLinearGradientCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createLinearGradientRequest(c, Picture, P1, P2, NumStops, Stops, Colors), cookie)
	return CreateLinearGradientCookie{cookie}
}

func CreateLinearGradientChecked(c *xgb.Conn, Picture Picture, P1 Pointfix, P2 Pointfix, NumStops uint32, Stops []Fixed, Colors []Color) CreateLinearGradientCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createLinearGradientRequest(c, Picture, P1, P2, NumStops, Stops, Colors), cookie)
	return CreateLinearGradientCookie{cookie}
}

func (cook CreateLinearGradientCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateLinearGradient
func createLinearGradientRequest(c *xgb.Conn, Picture Picture, P1 Pointfix, P2 Pointfix, NumStops uint32, Stops []Fixed, Colors []Color) []byte {
	size := xgb.Pad(((28 + xgb.Pad((int(NumStops) * 4))) + xgb.Pad((int(NumStops) * 8))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 34 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Picture))
	b += 4

	{
		structBytes := P1.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := P2.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	xgb.Put32(buf[b:], NumStops)
	b += 4

	for i := 0; i < int(NumStops); i++ {
		xgb.Put32(buf[b:], uint32(Stops[i]))
		b += 4
	}
	b = xgb.Pad(b)

	b += ColorListBytes(buf[b:], Colors)

	return buf
}

// Request CreateRadialGradient
// size: xgb.Pad(((36 + xgb.Pad((int(NumStops) * 4))) + xgb.Pad((int(NumStops) * 8))))
type CreateRadialGradientCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateRadialGradient
func CreateRadialGradient(c *xgb.Conn, Picture Picture, Inner Pointfix, Outer Pointfix, InnerRadius Fixed, OuterRadius Fixed, NumStops uint32, Stops []Fixed, Colors []Color) CreateRadialGradientCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createRadialGradientRequest(c, Picture, Inner, Outer, InnerRadius, OuterRadius, NumStops, Stops, Colors), cookie)
	return CreateRadialGradientCookie{cookie}
}

func CreateRadialGradientChecked(c *xgb.Conn, Picture Picture, Inner Pointfix, Outer Pointfix, InnerRadius Fixed, OuterRadius Fixed, NumStops uint32, Stops []Fixed, Colors []Color) CreateRadialGradientCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createRadialGradientRequest(c, Picture, Inner, Outer, InnerRadius, OuterRadius, NumStops, Stops, Colors), cookie)
	return CreateRadialGradientCookie{cookie}
}

func (cook CreateRadialGradientCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateRadialGradient
func createRadialGradientRequest(c *xgb.Conn, Picture Picture, Inner Pointfix, Outer Pointfix, InnerRadius Fixed, OuterRadius Fixed, NumStops uint32, Stops []Fixed, Colors []Color) []byte {
	size := xgb.Pad(((36 + xgb.Pad((int(NumStops) * 4))) + xgb.Pad((int(NumStops) * 8))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 35 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Picture))
	b += 4

	{
		structBytes := Inner.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	{
		structBytes := Outer.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	xgb.Put32(buf[b:], uint32(InnerRadius))
	b += 4

	xgb.Put32(buf[b:], uint32(OuterRadius))
	b += 4

	xgb.Put32(buf[b:], NumStops)
	b += 4

	for i := 0; i < int(NumStops); i++ {
		xgb.Put32(buf[b:], uint32(Stops[i]))
		b += 4
	}
	b = xgb.Pad(b)

	b += ColorListBytes(buf[b:], Colors)

	return buf
}

// Request CreateConicalGradient
// size: xgb.Pad(((24 + xgb.Pad((int(NumStops) * 4))) + xgb.Pad((int(NumStops) * 8))))
type CreateConicalGradientCookie struct {
	*xgb.Cookie
}

// Write request to wire for CreateConicalGradient
func CreateConicalGradient(c *xgb.Conn, Picture Picture, Center Pointfix, Angle Fixed, NumStops uint32, Stops []Fixed, Colors []Color) CreateConicalGradientCookie {
	cookie := c.NewCookie(false, false)
	c.NewRequest(createConicalGradientRequest(c, Picture, Center, Angle, NumStops, Stops, Colors), cookie)
	return CreateConicalGradientCookie{cookie}
}

func CreateConicalGradientChecked(c *xgb.Conn, Picture Picture, Center Pointfix, Angle Fixed, NumStops uint32, Stops []Fixed, Colors []Color) CreateConicalGradientCookie {
	cookie := c.NewCookie(true, false)
	c.NewRequest(createConicalGradientRequest(c, Picture, Center, Angle, NumStops, Stops, Colors), cookie)
	return CreateConicalGradientCookie{cookie}
}

func (cook CreateConicalGradientCookie) Check() error {
	return cook.Cookie.Check()
}

// Write request to wire for CreateConicalGradient
func createConicalGradientRequest(c *xgb.Conn, Picture Picture, Center Pointfix, Angle Fixed, NumStops uint32, Stops []Fixed, Colors []Color) []byte {
	size := xgb.Pad(((24 + xgb.Pad((int(NumStops) * 4))) + xgb.Pad((int(NumStops) * 8))))
	b := 0
	buf := make([]byte, size)

	buf[b] = c.Extensions["RENDER"]
	b += 1

	buf[b] = 36 // request opcode
	b += 1

	xgb.Put16(buf[b:], uint16(size/4)) // write request size in 4-byte units
	b += 2

	xgb.Put32(buf[b:], uint32(Picture))
	b += 4

	{
		structBytes := Center.Bytes()
		copy(buf[b:], structBytes)
		b += xgb.Pad(len(structBytes))
	}

	xgb.Put32(buf[b:], uint32(Angle))
	b += 4

	xgb.Put32(buf[b:], NumStops)
	b += 4

	for i := 0; i < int(NumStops); i++ {
		xgb.Put32(buf[b:], uint32(Stops[i]))
		b += 4
	}
	b = xgb.Pad(b)

	b += ColorListBytes(buf[b:], Colors)

	return buf
}
